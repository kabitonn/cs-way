<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml" rel="self" type="application/rss+xml"/>
    <title>CS Way</title>
    <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/</link>
    <description>CS Way</description>
    <language>zh-CN</language>
    <pubDate>Tue, 17 May 2022 12:24:16 GMT</pubDate>
    <lastBuildDate>Tue, 17 May 2022 12:24:16 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>Java</category>
    <category>OOP</category>
    <category>计算机基础</category>
    <category>数据库</category>
    <category>框架</category>
    <category>网络</category>
    <category>计算机</category>
    <category>中间件</category>
    <item>
      <title>JavaEE</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/JavaEE.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/JavaEE.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">JavaEE</source>
      <category>Java</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>

<h1 id="servlet-介绍" tabindex="-1"> Servlet 介绍</h1>
<h2 id="servlet-简介" tabindex="-1"> Servlet 简介</h2>
<p>Servlet是sun公司提供的一门用于开发动态web资源的技术。</p>
<p>Sun公司在其API中提供了一个servlet接口，用户若想用发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤：</p>
<ol>
<li>编写一个Java类，实现servlet接口。</li>
<li>把开发好的Java类部署到web服务器中。</li>
</ol>
<p>按照一种约定俗成的称呼习惯，通常我们也把实现了servlet接口的java程序，称之为Servlet</p>
<p>狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet 接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下 Servlet 只用来扩展基于HTTP协议的Web服务器。</p>
<p>Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。</p>
<h3 id="servlet-对比-cgi" tabindex="-1"> Servlet 对比 CGI</h3>
<p><strong>CGI的不足之处</strong>:</p>
<ul>
<li>需要为每个请求启动一个操作CGI程序的系统进程。如果请求频繁，这将会带来很大的开销。、</li>
<li>需要为每个请求加载和运行一个CGI程序，这将带来很大的开销</li>
<li>需要重复编写处理网络协议的代码以及编码，这些工作都是非常耗时的。</li>
</ul>
<p><strong>Servlet的优点</strong>:</p>
<ul>
<li>只需要启动一个操作系统进程以及加载一个JVM，大大降低了系统的开销</li>
<li>如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销</li>
<li>所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量。</li>
<li>Servlet能直接和Web服务器交互，而普通的CGI程序不能。Servlet还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。</li>
</ul>
<p><strong>补充</strong>：Sun Microsystems公司在1996年发布Servlet技术就是为了和CGI进行竞争，Servlet是一个特殊的Java程序，一个基于Java的Web应用通常包含一个或多个Servlet类。Servlet不能够自行创建并执行，它是在Servlet容器中运行的，容器将用户的请求传递给Servlet程序，并将Servlet的响应回传给用户。通常一个Servlet会关联一个或多个JSP页面。以前CGI经常因为性能开销上的问题被诟病，然而Fast CGI早就已经解决了CGI效率上的问题，所以面试的时候大可不必信口开河的诟病CGI，事实上有很多你熟悉的网站都使用了CGI技术。</p>
<h2 id="servlet-的运行" tabindex="-1"> Servlet 的运行</h2>
<p>Servlet
–GenericServlet
–HttpServlet
–自己的servlet</p>
<p>ServletRequest
–HttpServletRequest</p>
<p>ServletResponse
–HttpServletResponse</p>
<h3 id="servlet-工作原理" tabindex="-1"> Servlet 工作原理</h3>
<p>Servlet接口定义了Servlet与servlet容器之间的契约。这个契约是：Servlet容器将Servlet类载入内存，并产生Servlet实例和调用它具体的方法。但是要注意的是，在一个应用程序中，每种Servlet类型只能有一个实例。</p>
<p>用户请求致使Servlet容器调用Servlet的Service（）方法，并传入一个ServletRequest对象和一个ServletResponse对象。ServletRequest对象和ServletResponse对象都是由Servlet容器（例如TomCat）封装好的，并不需要程序员去实现，程序员可以直接使用这两个对象。</p>
<p>ServletRequest中封装了当前的Http请求，因此，开发人员不必解析和操作原始的Http数据。ServletResponse表示当前用户的Http响应，程序员只需直接操作ServletResponse对象就能把响应轻松的发回给用户。</p>
<p>对于每一个应用程序，Servlet容器还会创建一个ServletContext对象。这个对象中封装了上下文（应用程序）的环境详情。每个应用程序只有一个ServletContext。每个Servlet对象也都有一个封装Servlet配置的ServletConfig对象。</p>
<h3 id="servlet-工作模式" tabindex="-1"> Servlet 工作模式</h3>
<p>Servlet程序是由WEB服务器调用，web服务器收到客户端的Servlet访问请求后：</p>
<ol>
<li>Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第4步，否则，执行第2步。</li>
<li>装载并创建该Servlet的一个实例对象。</li>
<li>调用Servlet实例对象的init()方法。</li>
<li>创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。</li>
<li>WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。</li>
</ol>
<h3 id="tomcat和servlet的关系" tabindex="-1"> Tomcat和Servlet的关系</h3>
<p>Tomcat 是Web应用服务器,是一个Servlet/JSP容器. Tomcat 作为Servlet容器,负责处理客户请求,把请求传送给Servlet,并将Servlet的响应传送回给客户.而Servlet是一种运行在支持Java语言的服务器上的组件. Servlet最常见的用途是扩展Java Web服务器功能,提供非常安全的,可移植的,易于使用的CGI替代品.</p>
<p><img src="@source/assets/cs-note/java-ee/Tomcat和Servlet的关系.png" alt="" loading="lazy"></p>
<ol>
<li>Tomcat将http请求文本接收并解析，然后封装成HttpServletRequest类型的request对象，所有的HTTP头数据读可以通过request对象调用对应的方法查询到。</li>
<li>Tomcat同时会要响应的信息封装为HttpServletResponse类型的response对象，通过设置response属性就可以控制要输出到浏览器的内容，然后将response交给tomcat，tomcat就会将其变成响应文本的格式发送给浏览器</li>
</ol>
<p>Java Servlet API 是Servlet容器(tomcat)和Servlet之间的接口，它定义了Serlvet的各种方法，还定义了Servlet容器传送给Servlet的对象类，其中最重要的就是ServletRequest和ServletResponse。所以说我们在编写servlet时，需要实现Servlet接口，按照其规范进行操作。</p>
<h4 id="servlet-容器" tabindex="-1"> Servlet 容器</h4>
<p>Servlet容器也叫做Servlet引擎，是Web服务器或应用程序服务器的一部分，用于在发送的请求和响应之上提供网络服务，解码基于 MIME的请求，格式化基于MIME的响应。Servlet没有main方法，不能独立运行，它必须被部署到Servlet容器中，由容器来实例化和调用 Servlet的方法，Servlet容器在Servlet的生命周期内包容和管理Servlet。在JSP技术 推出后，管理和运行Servlet/JSP的容器也称为Web容器。</p>
<p><strong>Servlet容器的作用</strong>：负责处理客户请求，当客户请求来到时，Servlet容器获取请求，然后调用某个Servlet，并把Servlet的执行结果返回给客户。</p>
<p><strong>使用Servlet容器的原因</strong>：</p>
<ul>
<li>通信支持：利用容器提供的方法，你能轻松的让servlet与web服务器对话，而不用自己建立serversocket、监听某个端口、创建流等 等。容器知道自己与web服务器之间的协议，所以你的servlet不用担心web服务器（如Apache）和你自己的web代码之间的API，只需要考虑如何在servlet中实现业务逻辑（如处理一个订单）。</li>
<li>生命周期管理：servlet容器控制着servlet的生与死，它负责加载类、实例化和初始化servlet，调用servlet方法，以及使servlet实例被垃圾回收，有了servlet容器，你不需要太多的考虑资源管理。</li>
<li>多线程支持：容器会自动为它所接收的每个servlet请求创建一个新的java线程。针对用户的请求，如果servlet已经运行完相应的http服务方法，这个线程就会结束。这并不是说你不需要考虑线程安全性，其实你还会遇到同步问题，不过这样能使你少做很多工作。</li>
<li>声明方式实现安全：利用servlet容器，可以使用xml部署描述文件来配置和修改安全性，而不必将其硬编码写到servlet类代码中。</li>
<li>JSP支持：servlet容器负责将jsp代码翻译为真正的java代码。</li>
</ul>
<h4 id="tomcat" tabindex="-1"> Tomcat</h4>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-servlet/" target="_blank" rel="noopener noreferrer">Tomcat工作原理</a></p>
<p>Servlet容器处理客户端的请求并填充response对象。Servlet容器实现了Container接口。</p>
<p>在Tomcat中有4种级别的容器：Engine，Host，Context和Wrapper。</p>
<ul>
<li>Engine：整个Catalina Servlet引擎；</li>
<li>Host:包含一个或多个Context容器的虚拟主机；</li>
<li>Context：表示一个Web应用程序，可以包含多个Wrapper；</li>
<li>Wrapper：表示一个独立的Servlet；</li>
</ul>
<h3 id="servlet-生命周期" tabindex="-1"> Servlet 生命周期</h3>
<p><img src="@source/assets/cs-note/java-ee/Servlet-生命周期.png" alt="" loading="lazy"></p>
<ol>
<li>加载和实例化
<ul>
<li>当Servlet容器启动或客户端发送一个请求时，Servlet容器会查找内存中是否存在该Servlet实例，若存在，则直接读取该实例响应请求；如果不存在，就创建一个Servlet实例。</li>
</ul>
</li>
<li>初始化
<ul>
<li>实例化后，Servlet容器将调用Servlet的init()方法进行初始化（一些准备工作或资源预加载工作）。</li>
</ul>
</li>
<li>服务
<ul>
<li>初始化后，Servlet处于能响应请求的就绪状态。当接收到客户端请求时，调用service()的方法处理客户端请求，HttpServlet的service()方法会根据不同的请求 转调不同的doXXX()方法。</li>
</ul>
</li>
<li>销毁
<ul>
<li>当Servlet容器关闭时，Servlet实例也随时销毁。其间，Servlet容器会调用Servlet 的destroy()方法去判断该Servlet是否应当被释放（或回收资源）。</li>
</ul>
</li>
</ol>
<p>由上面可以看见，servlet的init方法和destroy方法，一般容器调用这两个方法之间的过程，就叫做servlet的生命周期。</p>
<ul>
<li>从第一次调用到服务器关闭</li>
<li>如果Servlet在web.xml中配置了load-on-startup，生命周期为从服务器启动到服务器关闭</li>
</ul>
<h1 id="servlet-使用" tabindex="-1"> Servlet 使用</h1>
<h2 id="servlet-请求方法" tabindex="-1"> Servlet 请求方法</h2>
<ul>
<li>Service方法:不管是get方式还是post方式的请求，如果Servlet类中有service方法，则优先调用Service方法。</li>
<li>doGet方法: 在没有service方法的情况下如果是get方式的请求所调用的处理请求的方法</li>
<li>doPost方法: 在没有service方法的情况下如果是post方式的请求所调用的处理请求的方法</li>
<li>注意：如果在覆写的service方法中调用了父类的service方法(super.service(arg0, arg1)),则service方法处理完后，会再次根据请求方式响应的doGet和doPost方法执行。所以，一般情况下我们是不在覆写的service中调用父类的service方法的，避免出现405错误。doget/dopost与Http协议有关，是在 javax.servlet.http.HttpServlet 中实现的</li>
</ul>
<p><strong>Servlet的常见错误</strong>：</p>
<ul>
<li>404错误:资源未找到
<ul>
<li>原因一：在请求地址中的servlet的别名书写错误。</li>
<li>原因二：虚拟项目名称拼写错误</li>
</ul>
</li>
<li>500错误：内部服务器错误
<ul>
<li>错误一：java.lang.ClassNotFoundException</li>
<li>解决：在web.xml中校验servlet类的全限定路径是否拼写错误。</li>
<li>错误二：因为service方法体的代码执行错误导致</li>
<li>解决：根据错误提示对service方法体中的代码进行错误更改。</li>
</ul>
</li>
<li>405错误:请求方式不支持
<ul>
<li>原因：请求方式和servlet中的方法不匹配所造成的。</li>
<li>解决：尽量使用service方法进行请求处理，并且不要再service方法中调用父类的service。</li>
</ul>
</li>
</ul>
<h2 id="servlet-重点对象" tabindex="-1"> Servlet 重点对象</h2>
<h3 id="request" tabindex="-1"> Request</h3>
<p>服务器接收到浏览器的请求后，会创建一个Request对象，对象中存储了此次请求相关的请求数据。服务器在调用Servlet时会将创建的Request对象作为实参传递给Servlet的方法</p>
<p>使用：</p>
<ul>
<li>获取请求头数据</li>
<li>获取请求行数据</li>
<li>获取用户数据</li>
</ul>
<p>Request对象中获取请求信息的方法</p>
<ul>
<li>获取请求头数据</li>
</ul>
<div><pre><code>    req<span>.</span><span>getMethod</span><span>(</span><span>)</span><span>;</span>      <span>//获取请求方式</span>
    req<span>.</span><span>getRequestURL</span><span>(</span><span>)</span><span>;</span>  <span>//获取请求URL信息</span>
    req<span>.</span><span>getRequestURI</span><span>(</span><span>)</span><span>;</span>  <span>//获取请求URI信息</span>
    req<span>.</span><span>getScheme</span><span>(</span><span>)</span><span>;</span>      <span>//获取协议</span>
</code></pre></div><ul>
<li>获取请求行数据</li>
</ul>
<div><pre><code>    req<span>.</span><span>getHeader</span><span>(</span><span>"键名"</span><span>)</span><span>;</span>    <span>//返回指定的请求头信息</span>
    req<span>.</span><span>getHeaderNames</span><span>(</span><span>)</span><span>;</span>     <span>//返回请求头的键名的枚举集合</span>
</code></pre></div><ul>
<li>获取用户数据</li>
</ul>
<div><pre><code>    req<span>.</span><span>getParameter</span><span>(</span><span>"键名"</span><span>)</span><span>;</span>         <span>//返回指定的用户数据</span>
    req<span>.</span><span>getParameterValues</span><span>(</span><span>"键名"</span><span>)</span><span>;</span>   <span>//返回同键不同值的请求数据(多选)，返回的数组。</span>
    req<span>.</span><span>getParameterNames</span><span>(</span><span>)</span><span>;</span>          <span>//返回所有用户请求数据的枚举集合</span>
</code></pre></div><pre><code>- 注意：如果要获取的请求数据不存在，不会报错，返回null。
- 注意：request对象由tomcat服务器创建，并作为实参传递给处理请求的servlet的service方法。
</code></pre>
<h4 id="getattribute-和-getparameter" tabindex="-1"> getAttribute() 和 getParameter()</h4>
<p><strong>从获取方向来看：</strong></p>
<p><code>getParameter()</code>是获取 POST/GET 传递的参数值；</p>
<p><code>getAttribute()</code>是获取对象容器中的数据值；</p>
<p><strong>从用途来看：</strong></p>
<p><code>getParameter()</code>用于客户端重定向时，即点击了链接或提交按扭时传值用，即用于在用表单或url重定向传值时接收数据用。</p>
<p><code>getAttribute()</code> 用于服务器端重定向时，即在 sevlet 中使用了 forward 函数,或 struts 中使用了
mapping.findForward。 getAttribute 只能收到程序用 setAttribute 传过来的值。</p>
<p>另外，可以用 <code>setAttribute()</code>,<code>getAttribute()</code> 发送接收对象.而 <code>getParameter()</code> 显然只能传字符串。
<code>setAttribute()</code> 是应用服务器把这个对象放在该页面所对应的一块内存中去，当你的页面服务器重定向到另一个页面时，应用服务器会把这块内存拷贝另一个页面所对应的内存中。这样<code>getAttribute()</code>就能取得你所设下的值，当然这种方法可以传对象。session也一样，只是对象在内存中的生命周期不一样而已。<code>getParameter()</code>只是应用服务器在分析你送上来的 request页面的文本时，取得你设在表单或 url 重定向时的值。</p>
<p><strong>总结：</strong></p>
<p><code>getParameter()</code>返回的是String,用于读取提交的表单中的值;（获取之后会根据实际需要转换为自己需要的相应类型，比如整型，日期类型啊等等）</p>
<p><code>getAttribute()</code>返回的是Object，需进行转换,可用<code>setAttribute()</code>设置成任意对象，使用很灵活，可随时用</p>
<p><strong>请求中文乱码解决</strong>:</p>
<ul>
<li>使用String进行数据重新编码：uname=new String(uname.getBytes(&quot;iso8859-1&quot;),&quot;utf-8&quot;);</li>
<li>使用公共配置
<ul>
<li>get方式：
<ul>
<li>步骤一：req.setCharacterEncoding(&quot;utf-8&quot;);</li>
<li>步骤二：在tomcat的目录下的conf目录中修改server.xml文件：在Connector标签中增加属性 useBodyEncodingForURI=&quot;true&quot;(不建议)</li>
</ul>
</li>
<li>post方式：req.setCharacterEncoding(&quot;utf-8&quot;);</li>
</ul>
</li>
</ul>
<h4 id="请求转发" tabindex="-1"> 请求转发</h4>
<p>请求转发指一个web资源收到客户端请求后，通知服务器去调用另外一个web资源进行处理。</p>
<p>服务器在接收到浏览器的请求后，仅仅使用一个Servlet进行请求处理，会造成不同的Servlet逻辑代码 冗余，Servlet的职责不明确。</p>
<p><strong>使用请求转发</strong>。实现多个servlet联动操作处理请求，这样避免代码冗余，让servlet的职责更加明确。</p>
<p>实现请求转发的方式</p>
<ul>
<li>通过ServletContext的getRequestDispatcher(String path)方法，该方法返回一个RequestDispatcher对象，调用这个对象的forward方法可以实现请求转发。</li>
<li>通过request对象提供的getRequestDispatche(String path)方法，该方法返回一个RequestDispatcher对象，调用这个对象的forward方法可以实现请求转发。</li>
</ul>
<p><strong>特点</strong>:一次请求，浏览器地址栏信息不改变</p>
<p><strong>注意</strong>：请求转发后直接return结束即可</p>
<h3 id="response" tabindex="-1"> Response</h3>
<p>服务器在调用指定的Servlet进行请求处理的时候，会给Servlet的方法传递两个实参request和response。其中request中封存了请求相关的请求数据，而response则是用来进行响应的一个对象。</p>
<p>Response对象的使用：</p>
<ul>
<li>设置响应头</li>
</ul>
<div><pre><code>    <span>setHeader</span><span>(</span><span>String</span> name<span>,</span><span>String</span> value<span>)</span><span>;</span>  <span>//在响应头中添加响应信息，但是同键会覆盖</span>
    <span>addHeader</span><span>(</span><span>String</span> name<span>,</span><span>String</span> value<span>)</span><span>;</span>  <span>//在响应头中添加响应信息，但是不会覆盖。</span>
</code></pre></div><ul>
<li>设置响应状态
<ul>
<li><code>sendError(int num,String msg);</code>        //自定义响应状态码。</li>
</ul>
</li>
<li>设置响应实体
<ul>
<li><code>resp.getWrite().write(String str);</code>    //响应具体的数据给浏览器</li>
</ul>
</li>
<li>设置响应编码格式：
<ul>
<li><code>resp.setContentType(&quot;text/html;charset=utf-8&quot;);</code></li>
</ul>
</li>
</ul>
<h4 id="重定向" tabindex="-1"> 重定向</h4>
<p>如果当前的请求，Servlet 无法进行处理怎么办?如果使用请求转发，造成表单数据重复提交怎么办？<strong>使用重定向</strong></p>
<p>实现重定向的方式</p>
<ul>
<li>response.setStatus(302);  response.setHeader(&quot;location&quot;, uri);</li>
<li>response.sendRedirect(uri);</li>
</ul>
<p>重定向的地址</p>
<ul>
<li>本地路径为：uri(/项目部署文件目录/···)</li>
<li>网络路径为：定向资源的 URL 信息</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>两次请求，两个request对象</li>
<li>浏览器地址栏信息改变</li>
<li>避免表单重复提交</li>
</ul>
<p><strong>适用场景</strong></p>
<ul>
<li>如果请求中有表单数据，而数据又比较重要，不能重复提交，建议使用重定向。</li>
<li>如果请求被Servlet接收后，无法进行处理，建议使用重定向定位到可以处理的资源。</li>
</ul>
<h4 id="与请求转发的区别" tabindex="-1"> 与请求转发的区别</h4>
<p><strong>请求转发（Forward）</strong> 通过RequestDispatcher对象的forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher可以通过HttpServletRequest 的getRequestDispatcher()方法获得。例如下面的代码就是跳转到login_success.jsp页面。</p>
<div><pre><code>     request<span>.</span><span>getRequestDispatcher</span><span>(</span><span>"login_success.jsp"</span><span>)</span><span>.</span><span>forward</span><span>(</span>request<span>,</span> response<span>)</span><span>;</span>
</code></pre></div><p><strong>重定向（Redirect）</strong>  是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 <code>HttpServletResponse</code> 的 <code>setStatus(int status)</code> 方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。</p>
<ul>
<li><strong>定义</strong>
<ul>
<li>一个web资源收到客户端请求后，通知服务器去调用另外一个web资源进行处理，称之为请求转发  /307。</li>
<li>一个web资源收到客户端请求后，通知浏览器去访问另外一个web资源进行处理，称之为请求重定向/302。</li>
</ul>
</li>
<li><strong>行为</strong>：转发是服务器行为，重定向是客户端行为</li>
<li><strong>请求数目</strong>：重定向是两次请求(重定向的第二个请求一定是GET)，转发是一次请求（在内部转发的）</li>
<li><strong>地址栏</strong>
<ul>
<li>redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL</li>
<li>forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址</li>
</ul>
</li>
<li><strong>访问资源</strong>：重定向可以访问外部网站资源，转发只能访问内部资源</li>
<li><strong>数据共享</strong>：forward转发页面和转发到的页面可以共享request里面的数据；redirect:不能共享数据</li>
<li><strong>运用地方</strong>
<ul>
<li>forward一般用于用户登陆的时候,根据角色转发到相应的模块.</li>
<li>redirect一般用于用户注销登陆时返回主页面和跳转到其它的网站等</li>
</ul>
</li>
<li><strong>效率</strong>：转发的性能要优于重定向</li>
</ul>
<h3 id="servletconfig" tabindex="-1"> ServletConfig</h3>
<p>ServletConfig 对象是 Servlet 的专属配置对象，每个Servlet都单独拥有一个 ServletConfig 对象，用来获取web.xml中的配置信息。</p>
<p><strong>ServletConfig 对象的使用</strong>：
- 获取 ServletConfig 对象
- 获取 web.xml 中 servlet 的配置信息</p>
<p><strong>web.xml 文件的使用</strong></p>
<p>web.xml 文件作用：存储项目相关的配置信息，保护 Servlet。解耦一些数据对程序的依赖。</p>
<p>web.xml 文件不同位置的作用</p>
<ul>
<li>Web 项目下的 web.xml 文件为局部配置，针对本项目的位置。</li>
<li>Tomcat 下的 web.xml 文件为全局配置，配置公共信息。</li>
</ul>
<p>web.xml 文件内容(核心组件)</p>
<ul>
<li>全局上下文配置(全局配置参数)</li>
<li>Servlet 配置</li>
<li>过滤器配置</li>
<li>监听器配置</li>
</ul>
<p>web.xml 文件中<strong>加载顺序</strong>：Web 容器会按 ServletContext -&gt; context-param -&gt; listener -&gt; filter -&gt; servlet 这个顺序加载组件，这些元素可配置在 web.xml文件中的任意位置。<strong>加载时机</strong>是服务器启动时。</p>
<h3 id="servletcontext" tabindex="-1"> ServletContext</h3>
<p>ServletContext对象由服务器进行创建，一个项目只有一个对象。不管在项目的任意位置进行获取得到的都是同一个对象，那么不同用户发起的请求获取到的也就是同一个对象了，该对象由用户共同拥有。</p>
<p>ServletContext 特点：</p>
<ul>
<li>服务器进行创建</li>
<li>用户共享</li>
<li>一个项目只有一个</li>
</ul>
<p><strong>生命周期</strong>：</p>
<ul>
<li>服务器启动到服务器关闭</li>
</ul>
<p>作用域：整个项目内</p>
<p>ServletContext对象的使用：</p>
<ul>
<li>获取 ServletContext 对象</li>
</ul>
<div><pre><code>    <span>ServletContext</span> sc<span>=</span><span>this</span><span>.</span><span>getServletContext</span><span>(</span><span>)</span><span>;</span>
    <span>ServletContext</span> sc2<span>=</span><span>this</span><span>.</span><span>getServletConfig</span><span>(</span><span>)</span><span>.</span><span>getServletContext</span><span>(</span><span>)</span><span>;</span>
    <span>ServletContext</span> sc3<span>=</span>req<span>.</span><span>getSession</span><span>(</span><span>)</span><span>.</span><span>getServletContext</span><span>(</span><span>)</span><span>;</span>
</code></pre></div><ul>
<li>使用作用域进行共享数据流转</li>
</ul>
<div><pre><code>    sc<span>.</span><span>setAttribute</span><span>(</span><span>String</span> name<span>,</span> <span>Object</span> value<span>)</span><span>;</span>
    sc<span>.</span><span>getAttribute</span><span>(</span><span>"str"</span><span>)</span>      <span>//返回的是Object类型</span>
</code></pre></div><ul>
<li>注意：
<ul>
<li>不同的用户可以给ServletContext对象进行数据的存取。</li>
<li>获取的数据不存在返回null。</li>
</ul>
</li>
<li>获取 web.xml 中的全局配置</li>
</ul>
<div><pre><code>    sc<span>.</span><span>getInitParameter</span><span>(</span><span>String</span> name<span>)</span><span>;</span>   <span>//根据键的名字返回web.xml中配置的全局数据的值，返回String类型。如果数据不存在返回null。</span>
    sc<span>.</span><span>getInitParameterNames</span><span>(</span><span>)</span><span>;</span>         <span>//返回键名的枚举。</span>
</code></pre></div><ul>
<li>作用：将静态数据和代码进行解耦。</li>
<li>获取 webroot 下项目资源流对象
<ul>
<li><code>InputStream is = sc.getResourceAsStream(String path);</code>   //<strong>注意</strong>：此种方式只能获取项目根目录下的资源流对象，class文件的流对象需要使用类加载器获取。path参数为项目根目录中的路径</li>
</ul>
</li>
<li>获取 webroot 下资源绝对路径
<ul>
<li><code>String path=sc.getRealPath(String path);</code> 获取的路径为项目根目录，path参数为项目根目录中的路径</li>
</ul>
</li>
</ul>
<h3 id="cookie" tabindex="-1"> Cookie</h3>
<p>HTTP 协议是没有记忆功能的，一次请求结束后，相关数据会被销毁。如果第二次的请求需要使用相同的请求数据怎么办呢？<strong>使用 Cookie 技术</strong></p>
<p>Cookie 技术其实是浏览器端的数据存储技术，解决了不同请求需要使用相同的请求数据的问题。我们把请求需要共享的请求数据，存储在浏览器端，避免用户进行重复的书写请求数据。但是哪些数据需要使用Cookie技术存储起来是一个主观问题，需要在后台进行响应的时候来告诉浏览器，有些数据其他请求还会使用，需要存储起来。</p>
<p><strong>Cookie特点</strong></p>
<ul>
<li>浏览器端的数据存储技术。</li>
<li>适合少量数据，键值对，不安全</li>
<li>存储的数据声明在服务器端。</li>
<li>存储时限
<ul>
<li>临时存储:存储在浏览器的运行内存中，浏览器关闭即失效。</li>
<li>定时存储:设置了Cookie的有效期，存储在客户端的硬盘中，在有效期内符合路径要求的请求都会附带该信息。</li>
</ul>
</li>
<li>默认cookie信息存储好之后，每次请求都会附带，除非设置有效路径</li>
</ul>
<p><strong>作用</strong>:解决了发送的不同请求的数据共享问题</p>
<p><strong>Cookie的使用</strong></p>
<ul>
<li>Cookie 的创建和存储以及可选设置</li>
<li>Cookie 数据存储
<ul>
<li>临时存储：不设置 cookie 信息的存储时间，周期为一次会话，存储在浏览器内存中</li>
<li>定时存储：设置存储时间，周期为时间设置，存储在用户电脑中。</li>
</ul>
</li>
<li>Cookie 获取</li>
<li><strong>注意</strong>:一个Cookie对象存储一条数据。多条数据，可以多创建几个Cookie对象进行存储。</li>
</ul>
<p><strong>Cookie 常用方法</strong></p>
<div><pre><code>    <span>Cookie</span> c<span>=</span><span>new</span> <span>Cookie</span><span>(</span><span>String</span> name<span>,</span> <span>String</span> value<span>)</span><span>;</span>     <span>//创建Cookie对象</span>
    resp<span>.</span><span>addCookie</span><span>(</span>c<span>)</span><span>;</span>                  <span>//响应Cookie信息给客户端</span>
    <span>Cookie</span><span>[</span><span>]</span> cks<span>=</span>req<span>.</span><span>getCookies</span><span>(</span><span>)</span><span>;</span>      <span>//获取Cookie信息数组,遍历即可</span>
    <span>String</span>  <span>getName</span><span>(</span><span>)</span> 
    <span>void</span>  <span>setValue</span><span>(</span><span>String</span> value<span>)</span>    <span>//Cookie的name不能被修改，所以没有setName()方法</span>
    <span>String</span>  <span>getValue</span><span>(</span><span>)</span>
    <span>void</span>  <span>setMaxAge</span><span>(</span><span>int</span> expiry<span>)</span>   <span>//设置此Cookie的有效期，从当前时间起，在浏览器上多少秒内有效。</span>
    <span>String</span>  <span>getMaxAge</span><span>(</span><span>)</span>
    <span>void</span>  <span>setPath</span><span>(</span><span>String</span> url<span>)</span>   <span>//设置此Cookie的作用页面。缺省时默认只对当前页面所在目录有效。</span>
    <span>String</span> <span>getPath</span><span>(</span><span>)</span>
    <span>void</span>  <span>setDomain</span><span>(</span><span>String</span> domain<span>)</span>   <span>//设置此Cookie作用的网站（隶属于哪个网站），缺省时默认为当前网站。</span>
    <span>String</span>  <span>getDomain</span><span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="session" tabindex="-1"> Session</h3>
<p>Request 对象解决了一次请求内的不同Servlet的数据共享问题，那么一个用户的不同请求的处理需要使用相同的数据怎么办呢?<strong>使用 session 技术</strong></p>
<p>用户使用浏览器第一次向服务器发送请求，服务器在接受到请求后，调用对应的Servlet进行处理。在处理过程中会给用户创建一个session对象，用来存储用户请求处理相关的公共数据，并将此session对象的JSESSIONID以Cookie的形式存储在浏览器中(临时存储，浏览器关闭即失效)。用户在发起第二次请求及后续请求时，请求信息中会附带JSESSIONID，服务器在接收到请求后，调用对应的Servlet进行请求处理，同时根据JSESSIONID返回其对应的session对象。</p>
<p><strong>Session 特点</strong></p>
<ul>
<li>存储在服务器端</li>
<li>服务器进行创建</li>
<li>依赖Cookie技术</li>
<li>一次会话</li>
<li>每个用户独立拥有一个 session 默认存储时间为 30 分钟</li>
</ul>
<p><strong>作用</strong>：解决了一个用户的不同请求的数据共享问题。</p>
<p><strong>Session的使用</strong></p>
<ul>
<li>创建 Session对象</li>
<li>存储数据到session对象</li>
<li>获取session对象</li>
<li>获取数据从session对象，如果获取session中不存在的数据返回null。</li>
<li><strong>注意</strong>：只要不关闭浏览器，并且session不失效的情况下，同一个用户的任意请求在项目的任意Servlet中获取到的都是同一个session对象。JSESSIONID存储在了Cookie的临时存储空间中，浏览器关闭即失效。</li>
</ul>
<p><strong>适用场景</strong>：一般用户在登陆web项目时会将用户的个人信息存储到Sesion中，供该用户的其他请求使用。</p>
<p><strong>作用域</strong>：一次会话；在JSESSIONID和SESSION对象不失效的情况下为整个项目内。</p>
<p><strong>session失效处理</strong>：将用户请求中的JSESSIONID和后台获取到的SESSION对象的JSESSIONID进行比对，如果一致，则session没有失效，如果不一致则证明session失效了。重定向到登录页面，让用户重新登录。</p>
<p><strong>Session常用方法</strong></p>
<div><pre><code>    <span>HttpSession</span>  request<span>.</span><span>getSession</span><span>(</span><span>true</span><span>)</span>    <span>//从request中获取HttpSession对象。参数是一个boolean，表示request没有获取到HTTPSession对象怎么处理，true:自动创建并返回一个HttpSession对象，false:不自动创建，直接返回null。</span>
    <span>HttpSession</span>  request<span>.</span><span>getSession</span><span>(</span><span>)</span>    <span>//从request中获取HttpSession对象，如果不存在，则自动创建并返回。一般用这个。</span>
    <span>//从遍历request中的Cookie，找到JSESSIONID这个Cookie，获取值（SessionId），根据值获取服务器内存中相应的Session对象，并返回这个Session对象。</span>
    <span>//如果没有获取到Session对象（首次访问或Session超时已被清除），则自动创建一个新的Session对象并返回，创建新的Session对象时，会产生一个新的SessionId，服务器会自动把这个SessionId作为Cookie添加到响应头中。</span>
    <span>String</span>  session<span>.</span><span>getId</span><span>(</span><span>)</span>   <span>//获取创建新Session时产生的SessionId。</span>
    session<span>.</span><span>setAttribute</span><span>(</span><span>String</span> name<span>,</span> <span>Object</span>  value<span>)</span>    <span>//往指定Session中存储数据</span>
    <span>Object</span>   session<span>.</span><span>getAttribute</span><span>(</span><span>String</span> name<span>)</span>    
    <span>void</span>  session<span>.</span><span>removeAttribute</span><span>(</span><span>String</span> name<span>)</span>    
    <span>void</span> <span>setMaxInactiveInterval</span><span>(</span><span>int</span> seconds<span>)</span><span>;</span>       <span>//设置session存储时间,在指定的时间内session对象没有被使用则销毁，如果使用了则重新计时。</span>
    <span>void</span>  session<span>.</span><span>invalidate</span><span>(</span><span>)</span>   <span>//强制使此Session对象失效，会删除此Session对象。除了等超时管理的时间到使Session失效，还可以用此方法使Session立刻失效。</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id="cookie-和-session-对比" tabindex="-1"> Cookie 和 Session 对比</h4>
<p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>
<p><strong>Cookie 一般用来保存用户信息</strong> 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<p>HttpServletResponse 接口提供了重写 URL 的方法：public java.lang.String encodeURL(java.lang.String url)<br>
该方法的实现机制为：</p>
<ul>
<li>先判断当前的 Web 组件是否启用 Session，如果没有启用 Session，直接返回参数 url。</li>
<li>再判断客户端浏览器是否支持 Cookie，如果支持 Cookie，直接返回参数 url；如果不支持 Cookie，就在参数 url 中加入 Session ID 信息，然后返回修改后的 url。</li>
</ul>
<h2 id="servlet-三大作用域" tabindex="-1"> Servlet 三大作用域</h2>
<h3 id="request-请求对象" tabindex="-1"> Request 请求对象</h3>
<p>共享的数据：请求共享</p>
<p>特点：同一次请求中，共享数据可以获取（请求一旦结束，请求共享清除站）（请求转发能共享参数，重定向不行）</p>
<h3 id="session-会话对象" tabindex="-1"> Session 会话对象</h3>
<p>共享的数据：session共享/会话共享</p>
<p>特点：同一次会话，共享参数可以获取（会话：从共享数据开始，到浏览器关闭/主动清除。不受请求转发和重定向的影响，只要存到session中，浏览器不主动清除都可以获取。）</p>
<h3 id="servletcontext-上下文对象" tabindex="-1"> ServletContext 上下文对象</h3>
<p>共享数据：上下文共享</p>
<p>特点：从存储开始到tomcat关闭都有</p>
<h2 id="servlet-filter" tabindex="-1"> Servlet Filter</h2>
<p>Servlet 的作用是针对浏览器发起的请求，进行请求的 处理。通过 Servlet 技术我们可以灵活的进行请求的处理，但是我们不但要对请求记性处理，我们还需对服务器的资源进行统一的管理，比如请求编码格式的统一设置，资源的统一分配等等，这个时候该怎么办呢？<strong>使用过滤器</strong></p>
<p><strong>Filter作用</strong>：</p>
<ul>
<li>对服务器接受的请求资源和响应给浏览器的资源进行管理</li>
<li>保护 servlet</li>
</ul>
<p><strong>Filter接口</strong></p>
<ul>
<li>init方法:服务器启动即执行。资源初始化</li>
<li>doFilter方法:拦截请求的方法，在此方法中可以对资源实现管理。<strong>注意</strong>：需要手动对请求进行放行。chain.doFilter(request, response);</li>
<li>destory方法：服务器关闭执行。</li>
</ul>
<p><strong>Filter的xml配置</strong></p>
<ul>
<li>url-pattern:'/*' :表示拦截所有的请求</li>
<li>url-pattern: '*.do' ：表示所有以.do结尾的请求。一般是用来进行模块拦截处理</li>
<li>url-pattern:/ts.do：表示拦截指定url的请求。针对某个servlet的请求进行拦截，保护servlet。</li>
</ul>
<p><strong>过滤器的执行</strong>:浏览器发起请求到服务器，服务器接收到请求后，根据URI信息在web.xml中找到对应的过滤器执行doFilter方法，该方法对此次请求进行处理后如果符合要求则放行，放行后如果还有符合要求的过滤则继续进行过滤，找到执行对应的servlet进行请求处理。servlet对请求处理完毕后，也就service方法结束了。还需继续返回相应的doFilter方法继续执行。</p>
<p><strong>过滤器的生命周期</strong>：服务器启动到服务器关闭。</p>
<p><strong>应用</strong></p>
<ul>
<li>统一编码格式设置。</li>
<li>session管理</li>
<li>权限管理</li>
<li>资源管理（统一水印，和谐词汇等等）</li>
</ul>
<h2 id="servlet-listener" tabindex="-1"> Servlet Listener</h2>
<p>Servlet 监听器是 Servlet 规范中定义的一种特殊类，用于监听 ServletContext、HttpSession 和 ServletRequest 等域对象的创建与销毁事件，以及监听这些域对象中属性发生修改的事件。</p>
<p><strong>监听对象</strong>：Request Session Application</p>
<p><strong>监听内容</strong>：创建、销毁、属性改变事件</p>
<p><strong>监听作用</strong>：在事件发生之前，之后进行一些处理</p>
<p><strong>监听器的使用</strong>：创建一个实现了指定接口的java类</p>
<ul>
<li>监听request---&gt;ServletRequestListener  监听request对象的创建和销毁</li>
<li>监听request---&gt;ServletRequestAttributeListener  监听request作用域数据的变更。</li>
<li>监听session---&gt;HttpSessionListener 监听session的创建和销毁</li>
<li>监听session---&gt;HttpSessionAttributeListener 监听session数据的变更</li>
<li>监听application---&gt;ServletContextListener 监听application对象的初始化和销毁</li>
<li>监听application---&gt;ServletContextAttributeListener 监听数据的变更</li>
</ul>
<p><strong>应用</strong></p>
<ul>
<li>统计当前在线人数。</li>
<li>统计网页浏览器次数。</li>
</ul>
<h2 id="servlet-线程安全问题" tabindex="-1"> Servlet 线程安全问题</h2>
<p>当多个请求同时请求servlet时，容器会起多个线程同时访问一个servlet的service（）方法。</p>
<p><img src="@source/assets/cs-note/java-ee/Servlet-线程安全问题.png" alt="" loading="lazy"></p>
<p>由此可以看出，多个客户访问同一 service（）方法，会涉及线程安全的问题。</p>
<ul>
<li>如果service()方法没有访问Servlet的成员变量也没有访问全局的资源比如静态变量、文件、数据库连接等，而是只使用了当前线程自己的资源，比如非指向全局资源的临时变量、request和response对象等。该方法本身就是线程安全的，不必进行任何的同步控制。</li>
<li>如果service()方法访问了Servlet的成员变量，但是对该变量的操作是只读操作，该方法本身就是线程安全的，不必进行任何的同步控制。</li>
<li>如果service()方法访问了Servlet的成员变量，并且对该变量的操作既有读又有写，通常需要加上同步控制语句。</li>
<li>如果service()方法访问了全局的静态变量，如果同一时刻系统中也可能有其它线程访问该静态变量，如果既有读也有写的操作，通常需要加上同步控制语句。</li>
<li>如果service()方法访问了全局的资源，比如文件、数据库连接等，通常需要加上同步控制语句。</li>
</ul>
<h3 id="servlet-同时处理多请求访问" tabindex="-1"> Servlet 同时处理多请求访问</h3>
<p>单实例多线程: 主要是请求来时，会由线程调度者从线程池李取出来一个线程，来作为响应线程。这个线程可能是已经实例化的，也可能是新创建的。</p>
<p>Servlet容器默认是采用单实例多线程的方式处理多个请求的：</p>
<ul>
<li>当web服务器启动的时候（或客户端发送请求到服务器时），Servlet就被加载并实例化(只存在一个Servlet实例)；</li>
<li>容器初始化化Servlet主要就是读取配置文件（例如tomcat,可以通过servlet.xml的设置线程池中线程数目，初始化线程池通过web.xml,初始化每个参数值等等。</li>
<li>当请求到达时，Servlet容器通过调度线程(Dispatchaer Thread) 调度它管理下线程池中等待执行的线程（Worker Thread）给请求者；</li>
<li>线程执行Servlet的service方法；</li>
<li>请求结束，放回线程池，等待被调用；</li>
<li><strong>注意</strong>：避免使用实例变量（成员变量），因为如果存在成员变量，可能发生多线程同时访问该资源时，都来操作它，照成数据的不一致，因此产生线程安全问题）</li>
</ul>
<p>从上面可以看出：</p>
<ul>
<li>Servlet单实例，减少了产生servlet的开销；</li>
<li>过线程池来响应多个请求，提高了请求的响应时间；</li>
<li>Servlet容器并不关心到达的Servlet请求访问的是否是同一个Servlet还是另一个Servlet，直接分配给它一个新的线程；如果是同一个Servlet的多个请求，那么Servlet的service方法将在多线程中并发的执行；</li>
<li>每一个请求由ServletRequest对象来接受请求，由ServletResponse对象来响应该请求；</li>
</ul>
<h3 id="servlet-单线程模式" tabindex="-1"> Servlet 单线程模式</h3>
<p>对于JSP页面，可以通过page指令进行设置。 <code>&lt;%@page isThreadSafe=&quot;false&quot;%&gt;</code></p>
<p>对于Servlet，可以让自定义的Servlet实现SingleThreadModel标识接口。</p>
<p>说明：如果将JSP或Servlet设置成单线程工作模式，会导致每个请求创建一个Servlet实例，这种实践将导致严重的性能问题（服务器的内存压力很大，还会导致频繁的垃圾回收），所以通常情况下并不会这么做。</p>
<h2 id="servlet-应用细节" tabindex="-1"> Servlet 应用细节</h2>
<h3 id="servlet-url-映射" tabindex="-1"> Servlet URL 映射</h3>
<h3 id="servlet与普通java类的区别" tabindex="-1"> Servlet与普通Java类的区别</h3>
<p>Servlet是一个供其他Java程序（Servlet引擎）调用的Java类，它不能独立运行，它的运行完全由Servlet引擎来控制和调度。</p>
<p>针对客户端的多次Servlet请求，通常情况下，服务器只会创建一个Servlet实例对象，也就是说Servlet实例对象一旦创建，它就会驻留在内存中，为后续的其它请求服务，直至web容器退出，servlet实例对象才会销毁。</p>
<p>在Servlet的整个生命周期内，Servlet的init方法只被调用一次。而对一个Servlet的每次访问请求都导致Servlet引擎调用一次servlet的service方法。对于每次访问请求，Servlet引擎都会创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象，然后将这两个对象作为参数传递给它调用的Servlet的service()方法，service方法再根据请求方式分别调用doXXX方法。</p>
<p>如果在<code>&lt;servlet&gt;</code>元素中配置了一个<code>&lt;load-on-startup&gt;</code>元素，那么WEB应用程序在启动时，就会装载并创建Servlet的实例对象、以及调用Servlet实例对象的init()方法。</p>
<h1 id="jsp-介绍" tabindex="-1"> JSP 介绍</h1>
<h2 id="jsp-简介" tabindex="-1"> JSP 简介</h2>
<p>JSP(Java Server Pages)是Sun 公司指定的一种服务器端动态页面技术的组件规范，Jsp是以“.jsp”为后缀的文件，在该文件中主要是html 和少量的java 代码。jsp 文件在容器中会转换成Servlet中执行。</p>
<ul>
<li>在HTML中嵌入Java脚本代码</li>
<li>由应用服务器中的JSP引擎来编译和执行嵌入的Java脚本代码</li>
<li>然后将生成的整个页面信息返回给客户端</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li>本质上还是 Servlet</li>
<li>跨平台，一次编写处处运行</li>
<li>组件跨平台</li>
<li>健壮性和安全性</li>
</ul>
<h2 id="jsp-运行" tabindex="-1"> JSP 运行</h2>
<h3 id="jsp-工作原理" tabindex="-1"> JSP 工作原理</h3>
<ol>
<li>当一个JSP文件第一次被请求的时候，JSP引擎(本身也是一个Servlet)首先会把这个JSP文件转换成一个Java源文件。在转换过程中如果发现JSP文件有语法错误，转换过程将中断，并向服务端和客户端输出出错信息；如果转换成功，JSP引擎用javac把该Java源文件编译成相应的.class文件并将该.class文件加载到内存中。</li>
<li>其次创建一个该Servlet的实例，并执行该实例的jspInit()方法(jspInit()方法在Servlet的生命周期中只被执行一次)。</li>
<li>然后创建并启动一个新的线程，新线程调用实例的jspService()方法。(对于每一个请求，JSP引擎会创建一个新的线程来处理该请求。如果有多个客户端同时请求该JSP文件，则JSP引擎会创建多个线程，每个客户端请求对应一个线程)。</li>
<li>浏览器在调用JSP文件时，Servlet容器会把浏览器的请求和对浏览器的回应封装成HttpServletRequest和HttpServletResponse对象，同时调用对应的Servlet实例中的jspService()方法，把这两个对象作为参数传递到jspService()方法中。</li>
<li>jspService()方法执行后会将HTML内容返回给客户端。</li>
<li>如果JSP文件被修改了，服务器将根据设置决定是否对该文件进行重新编译。如果需要重新编译，则将编译结果取代内存中的Servlet，并继续上述处理过程。 如果在任何时候由于系统资源不足，JSP引擎将以某种不确定的方式将Servlet从内存中移去。当这种情况发生时，jspDestroy()方法首先被调用, 然后Servlet实例便被标记加入“垃圾收集”处理。</li>
</ol>
<p>以多线程方式执行可大大降低对系统的资源需求,提高系统的并发量及响应时间，但应该注意多线程的编程限制，由于该Servlet始终驻于内存，所以响应是非常快的。</p>
<p>虽然JSP效率很高，但在第一次调用时由于需要转换和编译而有一些轻微的延迟。</p>
<p>在jspInit()中可以进行一些初始化工作,如建立与数据库的连接、建立网络连接、从配置文件中获取一些参数等，而在jspDestory()中释放相应的资源。</p>
<h3 id="jsp-执行过程" tabindex="-1"> JSP 执行过程</h3>
<p><img src="@source/assets/cs-note/java-ee/JSP-执行过程.png" alt="" loading="lazy"></p>
<ul>
<li>客户端发出请求。</li>
<li>Web容器将JSP转译成Servlet源代码。</li>
<li>Web容器将产生的源代码进行编译。</li>
<li>Web容器加载编译后的代码并执行。</li>
<li>把执行结果响应至客户端。</li>
</ul>
<p><img src="@source/assets/cs-note/java-ee/JSP-执行流程.png" alt="" loading="lazy"></p>
<ol>
<li>客户端发出请求，请求为JSP，web容器就会找出相应的servlet进行处理</li>
<li>将servlet转成字节码文件</li>
<li>将字节码文件加载到web容器里</li>
<li>这时会在web容器里建立实例</li>
<li>进行初始化</li>
<li>通过service接受请求</li>
<li>然后web容器会自动产生两个对象servlet和service最后进行销毁</li>
</ol>
<h3 id="jsp-生命周期" tabindex="-1"> JSP 生命周期</h3>
<ul>
<li>一个JSP的生命周期方法分别是通过 jspInit() 、  jspDestroy()  、 _jspService() 来实现的。如果某个JSP要做初始化和清理工作，则可以重写jspInit() 和 jspDestroy()方法实现。</li>
<li>JSP转译后的Servlet必须实现_jspService方法，作为处理响应的逻辑方法。JSP转译后自动根据JSP代码实现。</li>
<li>因为HttpJspBase重写了 HttpServlet中的service方法，覆盖了根据请求发生选择不同处理方法doXXX的派发逻辑，对一个JSP使用任何HTTP请求方法都会调用_jspService方法处理。</li>
</ul>
<p><img src="@source/assets/cs-note/java-ee/JSP-生命周期方法.png" alt="" loading="lazy"></p>
<p>JSP的生命周期相比于Servlet只多了最开始的一步：转译工作。且这个工作只做一次（在JSP文件不改变的情况下）。</p>
<p>在JSP被请求时，容器会先检查这个JSP是否被修改过，如果修改过，则重新转译，然后编译，其后的过程和Servlet生命周期一致。 如果没有，则直接调用内存中驻留的实例的方法。</p>
<ol>
<li>如果JSP文件是新的，则转译为Servlet java文件，然后编译为class文件。加载类到内存，创建一个(仅仅一个)Servlet对象。并执行jspInit，表示这个servlet被启用。
<ul>
<li>如果不是，则直接调用驻留在内存上的实例的_jspService 方法。</li>
</ul>
</li>
<li>通过_jspService方法处理请求。多个请求同时请求同一个JSP的servlet实例，则这些请求会使用独立的线程去调用_jspService 方法。</li>
<li>当此Servlet实例不再被使用、或者服务器关机时，调用jspDestroy，GC</li>
</ol>
<h2 id="和-servlet-的关系" tabindex="-1"> 和 Servlet 的关系</h2>
<p>Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。</p>
<p>JSP负责页面展现，Servlet 负责业务逻辑处理。</p>
<h1 id="jsp-使用" tabindex="-1"> JSP 使用</h1>
<h2 id="jsp-语法" tabindex="-1"> JSP 语法</h2>
<h3 id="jsp-注释" tabindex="-1"> JSP 注释</h3>
<div><pre><code>HTML的注释：会被转译，也会被发送，但是不会被浏览器执行
    <span>&lt;!-- 这是注释,但客户端可以查看到 --></span>

JSP注释：不会被转译   
    &lt;%-- 这是注释,但客户端不能查看到 --%>

在JSP脚本中注释(java语言注释)：会被转译，但是不会被servlet执行
    &lt;% //单行注释 %>
    &lt;% /*多行注释 */ %>
</code></pre></div><h3 id="jsp-指令" tabindex="-1"> JSP 指令</h3>
<p>语法：&lt;%@ 　　　　%&gt;</p>
<h4 id="include" tabindex="-1"> include</h4>
<p>把另外一个文件完全包含入当前文件中</p>
<div><pre><code>&lt;%@ include file = &quot; Filename&quot; %&gt;
</code></pre></div><p><strong>JSP的静态引入和动态引入</strong>：</p>
<ul>
<li>静态引入:<code>&lt;%@include file=&quot;要引入的jsp文件的相对路径&quot; %&gt;</code>
<ul>
<li>特点：会将引入的jsp文件和当前jsp文件转译成一个java(Servlet)文件使用。在网页中也就显示了合并后的显示效果。</li>
<li>注意：静态引入的jsp文化不会单独转译成java(Servlet)文件。当前文件和静态引入的jsp文件中不能够使用java代码块声明同名变量。</li>
</ul>
</li>
<li>动态引入：<code>&lt;jsp:include page=&quot;要引入的jsp文件的相对路径&quot;&gt;&lt;/jsp:include&gt;</code>
<ul>
<li>特点：会将引入的jsp文件单独转译，在当前文件转译好的java文件中调用引入的jsp文件的转译文件。在网页中显示合并后的显示效果。</li>
<li>注意：动态引入允许文件中声明同名变量。</li>
</ul>
</li>
<li>优点：降低jsp代码的冗余，便于维护升级。</li>
</ul>
<h4 id="page" tabindex="-1"> page</h4>
<div><pre><code>&lt;%@ page 属性1=&quot;属性值&quot; 属性2=&quot;属性值1,属性值2&quot;… 属性n=&quot;属性值n&quot;%&gt;
</code></pre></div><p>常用属性：</p>
<ul>
<li>language：指定JSP页面使用的脚本语言，默认为Java。</li>
<li>import：通过该属性来引用脚本语言中使用得到的类文件。</li>
<li>contentType：用来指定JSP页面所采用的编码方式，默认为text/html。</li>
</ul>
<h3 id="jsp-脚本元素" tabindex="-1"> JSP 脚本元素</h3>
<p>用来嵌入Java代码的，主要用来实现页面的动态请求</p>
<h4 id="jsp-局部代码块" tabindex="-1"> JSP 局部代码块</h4>
<p><code>&lt;% java代码 %&gt;</code></p>
<p><strong>特点</strong>：局部代码块中声明的java代码会被原样转译到jsp对应的servlet文件的_JspService方法中代码块中声明的变量都是局部变量。</p>
<p><strong>缺点</strong>：使用局部代码块在jsp中进行逻辑判断，书写麻烦，阅读困难。</p>
<h4 id="jsp-全局代码块" tabindex="-1"> JSP 全局代码块</h4>
<p><code>&lt;%! 全局代码 %&gt;</code></p>
<p><strong>特点</strong>：声明的java代码作为全局代码转译到对应的servlet类中</p>
<p><strong>注意</strong>：全局代码块声明的代码，需要使用局部代码块调用。</p>
<h4 id="jsp-脚本段语句-表达式" tabindex="-1"> JSP 脚本段语句(表达式)</h4>
<p><code>&lt;%=变量名或者方法%&gt;</code></p>
<p><strong>特点</strong>：帮助我们快速的获取变量或者方法的返回值作为数据响应给浏览器。</p>
<p><strong>注意</strong>：不要在变量名或者方法后使用分号。</p>
<p><strong>位置</strong>：除jsp语法要求以外的任意位置。</p>
<h3 id="jsp-动作" tabindex="-1"> JSP 动作</h3>
<h4 id="转发标签forward" tabindex="-1"> 转发标签forward</h4>
<p><code>&lt;jsp:forward page=&quot;要转发的jsp文件的相对路径&quot;&gt;···&lt;/jsp:forward&gt;</code></p>
<p><strong>特点</strong>：</p>
<ul>
<li>一次请求</li>
<li>地址栏信息不改变。</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>在转发标签的两个标签中间除了写&lt;jsp:param name=&quot;str&quot; value=&quot;aaa&quot; /&gt;子标签不会报错，其他任意字符都会报错。</li>
<li>&lt;jsp:param name=&quot;str&quot; value=&quot;aaa&quot; /&gt;
<ul>
<li>name属性为附带的数据的键名；value为附带的数据内容</li>
<li>注意：会将数据以？的形式拼接在转发路径的后面。</li>
</ul>
</li>
</ul>
<h2 id="jsp-路径" tabindex="-1"> JSP 路径</h2>
<ul>
<li>在jsp中资源路径可以使用相对路径完成跳转
<ul>
<li>问题一：资源的位置不可随意更改。</li>
<li>问题二：需要使用../进行文件夹的跳出。使用比较麻烦。</li>
</ul>
</li>
<li>使用绝对路径：/虚拟项目名/项目资源路径
<ul>
<li>注意：在jsp中资源的第一个/表示的是服务器根目录，相当于:localhost:8080</li>
</ul>
</li>
</ul>
<div><pre><code>&lt;a href=&quot;/jsp/jspPro.jsp&quot;&gt;jspPro.jsp&lt;/a&gt;
&lt;a href=&quot;/jsp/a/a.jsp&quot;&gt;a.jsp&lt;/a&gt;&lt;br /&gt;
</code></pre></div><div><pre><code>&lt;%
    String path = request.getContextPath();
    String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;
%&gt;
&lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;
&lt;!-- 作用：给资源前面添加项目路径：        http://127.0.0.1:8080/虚拟项目名/上  --&gt;
</code></pre></div><h2 id="jsp-内置对象" tabindex="-1"> JSP 内置对象</h2>
<p>JSP内置对象：可以不用声明和创建，就可以直接在JSP页面脚本（Java程序片和Java表达式）中使用的成员变量。内置对象必须由支持JSP的容器去创建。</p>
<p>JSP共有以下9大内置对象</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>真实类型</th>
<th>对象</th>
<th>作用域</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>request</td>
<td>HttpServletRequest</td>
<td>请求对象</td>
<td>request</td>
<td>向客户端请求数据</td>
</tr>
<tr>
<td>response</td>
<td>HTTPServletResponse</td>
<td>响应对象</td>
<td>page</td>
<td>封装了jsp产生的响应,然后被发送到客户端以响应客户的请求</td>
</tr>
<tr>
<td>session</td>
<td>HttpSession</td>
<td>会话对象</td>
<td>session</td>
<td>用来保存每个用户的信息,以便跟踪每个用户的操作状态</td>
</tr>
<tr>
<td>application</td>
<td>ServletContext</td>
<td>应用程序对象</td>
<td>application</td>
<td>所有用户间共享数据</td>
</tr>
<tr>
<td>pageContext</td>
<td>PageContext</td>
<td>页面上下文对象</td>
<td>page</td>
<td>为JSP页面包装页面的上下文。管理对属于JSP中特殊可见部分中己经命名对象的该问</td>
</tr>
<tr>
<td>page</td>
<td>Object</td>
<td>页面对象</td>
<td>page</td>
<td>Jsp实现类的实例,它是jsp本身,通过这个可以对它进行访问</td>
</tr>
<tr>
<td>out</td>
<td>JspWriter</td>
<td>输出对象</td>
<td>page</td>
<td>向客户端输出数据</td>
</tr>
<tr>
<td>config</td>
<td>ServletConfig</td>
<td>配置对象</td>
<td>page</td>
<td>表示Servlet的配置,当一个Servlet初始化时,容器把某些信息通过此对象传递给这个Servlet</td>
</tr>
<tr>
<td>exception</td>
<td>Throwable</td>
<td>异常对象</td>
<td>page</td>
<td>反映运行的异常</td>
</tr>
</tbody>
</table>
<p>JSP九大内置对象分为四类：</p>
<ul>
<li>输入输出对象：out对象、response对象、request对象</li>
<li>通信控制对象：pageContext对象、session对象、application对象</li>
<li>Servlet对象:page对象、config对象</li>
<li>错误处理对象：exception对象</li>
</ul>
<p><strong>request 对象</strong></p>
<p>request 对象是 javax.servlet.httpServletRequest类型的对象。 该对象代表了客户端的请求信息，主要用于接受通过HTTP协议传送到服务器的数据。（包括头信息、系统信息、请求方式以及请求参数等）。request对象的作用域为一次请求。</p>
<p><strong>response 对象</strong></p>
<p>response 代表的是对客户端的响应，主要是将JSP容器处理过的对象传回到客户端。response对象也具有作用域，它只在JSP页面内有效。</p>
<p><strong>session 对象</strong></p>
<p>session 对象是由服务器自动创建的与用户请求相关的对象。服务器为每个用户都生成一个session对象，用于保存该用户的信息，跟踪用户的操作状态。session对象内部使用Map类来保存数据，因此保存数据的格式为 “Key/value”。 session对象的value可以使复杂的对象类型，而不仅仅局限于字符串类型。</p>
<p><strong>application 对象</strong></p>
<p>application 对象可将信息保存在服务器中，直到服务器关闭，否则application对象中保存的信息会在整个应用中都有效。与session对象相比，application对象生命周期更长，类似于系统的“全局变量”。</p>
<p><strong>out 对象</strong></p>
<p>out 对象用于在Web浏览器内输出信息，并且管理应用服务器上的输出缓冲区。在使用 out 对象输出数据时，可以对数据缓冲区进行操作，及时清除缓冲区中的残余数据，为其他的输出让出缓冲空间。待数据输出完毕后，要及时关闭输出流。</p>
<p><strong>pageContext 对象</strong></p>
<p>pageContext 对象的作用是取得任何范围的参数，通过它可以获取 JSP页面的out、request、reponse、session、application 等对象。pageContext对象的创建和初始化都是由容器来完成的，在JSP页面中可以直接使用 pageContext对象</p>
<p><strong>config 对象</strong></p>
<p>config 对象的主要作用是取得服务器的配置信息。通过 pageConext对象的 getServletConfig() 方法可以获取一个config对象。当一个Servlet 初始化时，容器把某些信息通过 config对象传递给这个 Servlet。 开发者可以在web.xml 文件中为应用程序环境中的Servlet程序和JSP页面提供初始化参数。</p>
<p><strong>page 对象</strong></p>
<p>page 对象代表JSP本身，只有在JSP页面内才是合法的。 page隐含对象本质上包含当前 Servlet接口引用的变量，类似于Java编程中的 this 指针。</p>
<p><strong>exception 对象</strong></p>
<p>exception 对象的作用是显示异常信息，只有在包含 isErrorPage=&quot;true&quot; 的页面中才可以被使用，在一般的JSP页面中使用该对象将无法编译JSP文件。excepation对象和Java的所有对象一样，都具有系统提供的继承结构。exception 对象几乎定义了所有异常情况。在Java程序中，可以使用try/catch关键字来处理异常情况； 如果在JSP页面中出现没有捕获到的异常，就会生成 exception 对象，并把 exception 对象传送到在page指令中设定的错误页面中，然后在错误页面中处理相应的 exception 对象。</p>
<h2 id="jsp-作用域对象" tabindex="-1"> JSP 作用域对象</h2>
<table>
<thead>
<tr>
<th>变量名</th>
<th>作用范围</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>pageContext</td>
<td>当前页面</td>
<td>解决了在当前页面内的数据共享问题。获取其他内置对象。</td>
</tr>
<tr>
<td>request</td>
<td>一次请求</td>
<td>一次请求的servlet的数据共享。通过请求转发，将数据流转给下一个servlet。</td>
</tr>
<tr>
<td>session</td>
<td>一次会话</td>
<td>一个用户的不同请求的数据共享。将数据从一次请求流转给其他请求。</td>
</tr>
<tr>
<td>application</td>
<td>项目内</td>
<td>不同用户的数据共享。将数据从一个用户流转给其他用户。</td>
</tr>
</tbody>
</table>
<p>作用：数据流转</p>
<p>作用域的大小依次是application &gt; session &gt; request &gt; page</p>
]]></content:encoded>
    </item>
    <item>
      <title>JavaIO</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/JavaIO.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/JavaIO.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">JavaIO</source>
      <category>Java</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>

<h1 id="一、概览" tabindex="-1"> 一、概览</h1>
<p>Java 的 I/O 大概可以分成以下几类：</p>
<ul>
<li>磁盘操作：File</li>
<li>字节操作：InputStream 和 OutputStream</li>
<li>字符操作：Reader 和 Writer</li>
<li>对象操作：Serializable</li>
<li>网络操作：Socket</li>
<li>新的输入/输出：NIO</li>
</ul>
<h2 id="分类说明" tabindex="-1"> 分类说明</h2>
<p>IO流的分类：</p>
<ul>
<li>按照流的流向分
<ul>
<li>输出流：从内存读出到文件。只能进行写操作。</li>
<li>输入流：从文件读入到内存。只能进行读操作。</li>
</ul>
</li>
<li>按照操作单元划分
<ul>
<li>字节流：以字节为单位，每次次读入或读出是8位数据。可以读任何类型数据。</li>
<li>字符流：以字符为单位，每次次读入或读出是16位数据。其只能读取字符类型数据。</li>
</ul>
</li>
<li>按照流的角色划分
<ul>
<li>节点流：直接与数据源相连，读入或读出。</li>
<li>处理流：与节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。</li>
</ul>
</li>
</ul>
<p>流的原理浅析:</p>
<ul>
<li>java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java Io流的40多个类都是从如下4个抽象类基类中派生出来的。</li>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247484945&amp;idx=1&amp;sn=229be49807e3c2a9621f42c0a6c0aeb6&amp;source=41#wechat_redirect" target="_blank" rel="noopener noreferrer">Java IO 面试题</a></p>
<h3 id="操作方式分类结构" tabindex="-1"> 操作方式分类结构</h3>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-io/IO-操作方式分类.png" alt="" title=":size=800" loading="lazy"></p>
</div>
<p><strong>输入字节流InputStream</strong>：</p>
<ul>
<li>ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从Byte 数组、StringBuffer、和本地文件中读取数据。</li>
<li>PipedInputStream 是从与其它线程共用的管道中读取数据。PipedInputStream的一个实例要和PipedOutputStream的一个实例共同使用，共同完成管道的读取写入操作。主要用于线程操作。</li>
<li>DataInputStream： 将基础数据类型读取出来</li>
<li>ObjectInputStream 和所有 FilterInputStream 的子类都是装饰流(装饰器模式的主角）。</li>
</ul>
<p><strong>输出字节流OutputStream</strong>：</p>
<ul>
<li>ByteArrayOutputStream、FileOutputStream： 是两种基本的介质流，它们分别向- Byte 数组、和本地文件中写入数据。</li>
<li>PipedOutputStream 是向与其它线程共用的管道中写入数据。</li>
<li>DataOutputStream 将基础数据类型写入到文件中</li>
<li>ObjectOutputStream 和所有 FilterOutputStream 的子类都是装饰流。</li>
</ul>
<p><strong>字符输入流Reader</strong>：</p>
<ul>
<li>FileReader、CharReader、StringReader 是三种基本的介质流，它们分在本地文件、Char 数组、String中读取数据。</li>
<li>PipedReader：是从与其它线程共用的管道中读取数据</li>
<li>BufferedReader ：加缓冲功能，避免频繁读写硬盘</li>
<li>InputStreamReader： 是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。</li>
</ul>
<p><strong>字符输出流Writer</strong>：</p>
<ul>
<li>StringWriter:向String 中写入数据。</li>
<li>CharArrayWriter：实现一个可用作字符输入流的字符缓冲区</li>
<li>PipedWriter:是向与其它线程共用的管道中写入数据</li>
<li>BufferedWriter ： 增加缓冲功能，避免频繁读写硬盘。</li>
<li>PrintWriter 和 PrintStream 将对象的格式表示打印到文本输出流。 极其类似，功能和使用也非常相似</li>
<li>OutputStreamWriter： 是 OutputStream 到 Writer 转换的桥梁，它的子类FileWriter 其实就是一个实现此功能的具体类</li>
</ul>
<h3 id="操作对象分类结构" tabindex="-1"> 操作对象分类结构</h3>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-io/IO-操作对象分类.png" alt="" title=":size=800" loading="lazy"></p>
</div>
<p>对<strong>文件</strong>进行操作(节点流）：</p>
<ul>
<li>FileInputStream(字节输入流）</li>
<li>FileOutputStream(字节输出流）</li>
<li>FileReader(字符输入流）</li>
<li>FileWriter(字符输出流）</li>
</ul>
<p>对<strong>管道</strong>进行操作(节点流）：</p>
<ul>
<li>PipedInputStream(字节输入流）</li>
<li>PipedOutStream(字节输出流）</li>
<li>PipedReader(字符输入流）</li>
<li>PipedWriter(字符输出流）</li>
</ul>
<p>PipedInputStream的一个实例要和PipedOutputStream的一个实例共同使用，共同完成管道的读取写入操作。主要用于线程操作。</p>
<p><strong>字节/字符数组</strong>流(节点流）：</p>
<ul>
<li>ByteArrayInputStream</li>
<li>ByteArrayOutputStream</li>
<li>CharArrayReader</li>
<li>CharArrayWriter</li>
</ul>
<p>除了上述三种是节点流，其他都是处理流，需要跟节点流配合使用。</p>
<p>Buffered缓冲流(处理流）：带缓冲区的处理流，缓冲区的作用的主要目的是：避免每次和硬盘打交道，提高数据访问的效率</p>
<ul>
<li>BufferedInputStream</li>
<li>BufferedOutputStream</li>
<li>BufferedReader</li>
<li>BufferedWriter</li>
</ul>
<p>转化流(处理流）：</p>
<ul>
<li>InputStreamReader：把字节转化成字符</li>
<li>OutputStreamWriter：把字节转化成字符。</li>
</ul>
<p>基本类型数据流(处理流）：用于操作基本数据类型值</p>
<ul>
<li>DataInputStream</li>
<li>DataOutputStream</li>
</ul>
<p>打印流(处理流）：一般是打印到控制台，可以进行控制打印的地方</p>
<ul>
<li>PrintStream</li>
<li>PrintWriter</li>
</ul>
<p>对象流(处理流）：把封装的对象直接输出，而不是一个个在转换成字符串再输出</p>
<ul>
<li>ObjectInputStream：对象反序列化</li>
<li>ObjectOutputStream：对象序列化</li>
</ul>
<p>合并流(处理流）：</p>
<ul>
<li>SequenceInputStream：可以认为是一个工具类，将两个或者多个输入流当成一个输入流依次读取。</li>
</ul>
<h3 id="其他类" tabindex="-1"> 其他类</h3>
<p><strong>File类</strong>是对文件系统中文件以及文件夹进行封装的对象，可以通过对象的思想来操作文件和文件夹。 File类保存文件或目录的各种元数据信息，包括文件名、文件长度、最后修改时间、是否可读、获取当前文件的路径名，判断指定文件是否存在、获得当前目录中的文件列表，创建、删除文件和目录等方法。</p>
<p><strong>RandomAccessFile</strong>，该对象并不是流体系中的一员，其封装了字节流，同时还封装了一个缓冲区(字符数组），通过内部的指针来操作字符数组中的数据。 该对象特点：</p>
<ul>
<li>该对象只能操作文件，所以构造函数接收两种类型的参数：a.字符串文件路径；b.File对象</li>
<li>该对象既可以对文件进行读操作，也能进行写操作，在进行对象实例化时可指定操作模式(r,rw)</li>
</ul>
<h1 id="二、磁盘操作" tabindex="-1"> 二、磁盘操作</h1>
<p>Java7中文件IO发生了很大的变化，专门引入了很多新的类来取代原来的基于java.io.File的文件IO操作方式</p>
<h2 id="file" tabindex="-1"> File</h2>
<p>File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。</p>
<p>递归地列出一个目录下所有文件：</p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>listAllFiles</span><span>(</span><span>File</span> dir<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>dir <span>==</span> <span>null</span> <span>||</span> <span>!</span>dir<span>.</span><span>exists</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>return</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>dir<span>.</span><span>isFile</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dir<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>return</span><span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>File</span> file <span>:</span> dir<span>.</span><span>listFiles</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>listAllFiles</span><span>(</span>file<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>从 Java7 开始，可以使用 Paths 和 Files 代替 File。</p>
<h2 id="path" tabindex="-1"> Path</h2>
<ol>
<li>创建一个Path
<ul>
<li>创建Path实例可以通过 Paths工具类 的 get(）方法：</li>
</ul>
</li>
<li>File和Path之间的转换，File和URI之间的转换</li>
<li>获取Path的相关信息</li>
<li>移除冗余项：把.和..去除
<ul>
<li>normalize() : 返回一个路径，该路径是冗余名称元素的消除</li>
<li>toRealPath() : 融合了toAbsolutePath()方法和normalize()方法</li>
</ul>
</li>
</ol>
<h2 id="files" tabindex="-1"> Files</h2>
<p>Java NIO中的Files类(java.nio.file.Files）提供了多种操作文件系统中文件的方法。</p>
<p>java.nio.file.Files类是和java.nio.file.Path相结合使用的</p>
<ol>
<li>检查给定的Path在文件系统中是否存在：Files.exists()</li>
<li>创建文件/文件夹
<ul>
<li>Files.createFile()：创建文件</li>
<li>Files.createDirectories()：首先创建所有不存在的父目录来创建目录</li>
<li>Files.createDirectory()：只是创建目录</li>
</ul>
</li>
<li>删除文件或目录：Files.delete()</li>
<li>把一个文件从一个地址复制到另一个位置:Files.copy()</li>
<li>获取文件属性</li>
<li>遍历一个文件夹：Files.newDirectoryStream()</li>
<li>遍历整个文件目录：Files.walkFileTree()</li>
</ol>
<h1 id="三、字节操作" tabindex="-1"> 三、字节操作</h1>
<h2 id="实现文件复制" tabindex="-1"> 实现文件复制</h2>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>copyFile</span><span>(</span><span>String</span> src<span>,</span> <span>String</span> dist<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>
    <span>FileInputStream</span> in <span>=</span> <span>new</span> <span>FileInputStream</span><span>(</span>src<span>)</span><span>;</span>
    <span>FileOutputStream</span> out <span>=</span> <span>new</span> <span>FileOutputStream</span><span>(</span>dist<span>)</span><span>;</span>

    <span>byte</span><span>[</span><span>]</span> buffer <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>20</span> <span>*</span> <span>1024</span><span>]</span><span>;</span>
    <span>int</span> cnt<span>;</span>

    <span>// read() 最多读取 buffer.length 个字节</span>
    <span>// 返回的是实际读取的个数</span>
    <span>// 返回 -1 的时候表示读到 eof，即文件尾</span>
    <span>while</span> <span>(</span><span>(</span>cnt <span>=</span> in<span>.</span><span>read</span><span>(</span>buffer<span>,</span> <span>0</span><span>,</span> buffer<span>.</span>length<span>)</span><span>)</span> <span>!=</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
        out<span>.</span><span>write</span><span>(</span>buffer<span>,</span> <span>0</span><span>,</span> cnt<span>)</span><span>;</span>
    <span>}</span>

    in<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
    out<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="装饰者模式" tabindex="-1"> 装饰者模式</h2>
<p>Java I/O 使用了装饰者模式来实现。以 InputStream 为例，</p>
<ul>
<li>InputStream 是抽象组件；</li>
<li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；</li>
<li>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9709694b-db05-4cce-8d2f-1c8b09f4d921.png" width="650px"> </div><br>
<p>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。</p>
<div><pre><code><span>FileInputStream</span> fileInputStream <span>=</span> <span>new</span> <span>FileInputStream</span><span>(</span>filePath<span>)</span><span>;</span>
<span>BufferedInputStream</span> bufferedInputStream <span>=</span> <span>new</span> <span>BufferedInputStream</span><span>(</span>fileInputStream<span>)</span><span>;</span>
</code></pre></div><p>DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。</p>
<h1 id="四、字符操作" tabindex="-1"> 四、字符操作</h1>
<h2 id="编码与解码" tabindex="-1"> 编码与解码</h2>
<p>编码就是把字符转换为字节，而解码是把字节重新组合成字符。</p>
<p>如果编码和解码过程使用不同的编码方式那么就出现了乱码。</p>
<ul>
<li>GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；</li>
<li>UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；</li>
<li>UTF-16be 编码中，中文字符和英文字符都占 2 个字节。</li>
</ul>
<p>UTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。</p>
<p>Java 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。</p>
<h2 id="string-的编码方式" tabindex="-1"> String 的编码方式</h2>
<p>String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。</p>
<div><pre><code><span>String</span> str1 <span>=</span> <span>"中文"</span><span>;</span>
<span>byte</span><span>[</span><span>]</span> bytes <span>=</span> str1<span>.</span><span>getBytes</span><span>(</span><span>"UTF-8"</span><span>)</span><span>;</span>
<span>String</span> str2 <span>=</span> <span>new</span> <span>String</span><span>(</span>bytes<span>,</span> <span>"UTF-8"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str2<span>)</span><span>;</span>
</code></pre></div><p>在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与平台有关，一般为 UTF-8。</p>
<div><pre><code><span>byte</span><span>[</span><span>]</span> bytes <span>=</span> str1<span>.</span><span>getBytes</span><span>(</span><span>)</span><span>;</span>
</code></pre></div><h2 id="reader-与-writer" tabindex="-1"> Reader 与 Writer</h2>
<p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。</p>
<ul>
<li>InputStreamReader 实现从字节流解码成字符流；</li>
<li>OutputStreamWriter 实现字符流编码成为字节流。</li>
</ul>
<h2 id="实现逐行输出文本文件的内容" tabindex="-1"> 实现逐行输出文本文件的内容</h2>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>readFileContent</span><span>(</span><span>String</span> filePath<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>

    <span>FileReader</span> fileReader <span>=</span> <span>new</span> <span>FileReader</span><span>(</span>filePath<span>)</span><span>;</span>
    <span>BufferedReader</span> bufferedReader <span>=</span> <span>new</span> <span>BufferedReader</span><span>(</span>fileReader<span>)</span><span>;</span>

    <span>String</span> line<span>;</span>
    <span>while</span> <span>(</span><span>(</span>line <span>=</span> bufferedReader<span>.</span><span>readLine</span><span>(</span><span>)</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>line<span>)</span><span>;</span>
    <span>}</span>

    <span>// 装饰者模式使得 BufferedReader 组合了一个 Reader 对象</span>
    <span>// 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法</span>
    <span>// 因此只要一个 close() 调用即可</span>
    bufferedReader<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h1 id="五、对象操作" tabindex="-1"> 五、对象操作</h1>
<h2 id="序列化" tabindex="-1"> 序列化</h2>
<p>序列化就是将一个对象转换成字节序列，方便存储和传输。</p>
<ul>
<li>序列化：ObjectOutputStream.writeObject()</li>
<li>反序列化：ObjectInputStream.readObject()</li>
</ul>
<p>不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。</p>
<h2 id="serializable" tabindex="-1"> Serializable</h2>
<p>序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。</p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>IOException</span><span>,</span> <span>ClassNotFoundException</span> <span>{</span>

    <span>A</span> a1 <span>=</span> <span>new</span> <span>A</span><span>(</span><span>123</span><span>,</span> <span>"abc"</span><span>)</span><span>;</span>
    <span>String</span> objectFile <span>=</span> <span>"file/a1"</span><span>;</span>

    <span>ObjectOutputStream</span> objectOutputStream <span>=</span> <span>new</span> <span>ObjectOutputStream</span><span>(</span><span>new</span> <span>FileOutputStream</span><span>(</span>objectFile<span>)</span><span>)</span><span>;</span>
    objectOutputStream<span>.</span><span>writeObject</span><span>(</span>a1<span>)</span><span>;</span>
    objectOutputStream<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>

    <span>ObjectInputStream</span> objectInputStream <span>=</span> <span>new</span> <span>ObjectInputStream</span><span>(</span><span>new</span> <span>FileInputStream</span><span>(</span>objectFile<span>)</span><span>)</span><span>;</span>
    <span>A</span> a2 <span>=</span> <span>(</span><span>A</span><span>)</span> objectInputStream<span>.</span><span>readObject</span><span>(</span><span>)</span><span>;</span>
    objectInputStream<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a2<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>static</span> <span>class</span> <span>A</span> <span>implements</span> <span>Serializable</span> <span>{</span>

    <span>private</span> <span>int</span> x<span>;</span>
    <span>private</span> <span>String</span> y<span>;</span>

    <span>A</span><span>(</span><span>int</span> x<span>,</span> <span>String</span> y<span>)</span> <span>{</span>
        <span>this</span><span>.</span>x <span>=</span> x<span>;</span>
        <span>this</span><span>.</span>y <span>=</span> y<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>"x = "</span> <span>+</span> x <span>+</span> <span>"  "</span> <span>+</span> <span>"y = "</span> <span>+</span> y<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h2 id="transient" tabindex="-1"> transient</h2>
<p>transient 关键字可以使一些属性不会被序列化。</p>
<p>ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。</p>
<div><pre><code><span>private</span> <span>transient</span> <span>Object</span><span>[</span><span>]</span> elementData<span>;</span>
</code></pre></div><h1 id="六、网络操作" tabindex="-1"> 六、网络操作</h1>
<p>Java 中的网络支持：</p>
<ul>
<li>InetAddress：用于表示网络上的硬件资源，即 IP 地址；</li>
<li>URL：统一资源定位符；</li>
<li>Sockets：使用 TCP 协议实现网络通信；</li>
<li>Datagram：使用 UDP 协议实现网络通信。</li>
</ul>
<h2 id="inetaddress" tabindex="-1"> InetAddress</h2>
<p>没有公有的构造函数，只能通过静态方法来创建实例。</p>
<div><pre><code><span>InetAddress</span><span>.</span><span>getByName</span><span>(</span><span>String</span> host<span>)</span><span>;</span>
<span>InetAddress</span><span>.</span><span>getByAddress</span><span>(</span><span>byte</span><span>[</span><span>]</span> address<span>)</span><span>;</span>
</code></pre></div><h2 id="url" tabindex="-1"> URL</h2>
<p>可以直接从 URL 中读取字节流数据。</p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>

    <span>URL</span> url <span>=</span> <span>new</span> <span>URL</span><span>(</span><span>"http://www.baidu.com"</span><span>)</span><span>;</span>

    <span>/* 字节流 */</span>
    <span>InputStream</span> is <span>=</span> url<span>.</span><span>openStream</span><span>(</span><span>)</span><span>;</span>

    <span>/* 字符流 */</span>
    <span>InputStreamReader</span> isr <span>=</span> <span>new</span> <span>InputStreamReader</span><span>(</span>is<span>,</span> <span>"utf-8"</span><span>)</span><span>;</span>

    <span>/* 提供缓存功能 */</span>
    <span>BufferedReader</span> br <span>=</span> <span>new</span> <span>BufferedReader</span><span>(</span>isr<span>)</span><span>;</span>

    <span>String</span> line<span>;</span>
    <span>while</span> <span>(</span><span>(</span>line <span>=</span> br<span>.</span><span>readLine</span><span>(</span><span>)</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>line<span>)</span><span>;</span>
    <span>}</span>

    br<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id="sockets" tabindex="-1"> Sockets</h2>
<ul>
<li>ServerSocket：服务器端类</li>
<li>Socket：客户端类</li>
<li>服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1e6affc4-18e5-4596-96ef-fb84c63bf88a.png" width="550px"> </div><br>
<h2 id="datagram" tabindex="-1"> Datagram</h2>
<ul>
<li>DatagramSocket：通信类</li>
<li>DatagramPacket：数据包类</li>
</ul>
<h1 id="七、nio" tabindex="-1"> 七、NIO</h1>
<p>新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。NIO中的N可以理解为Non-blocking，不单纯是New</p>
<p>NIO的特性/NIO与IO区别:</p>
<ul>
<li>IO是面向流的，NIO是面向缓冲区的；</li>
<li>IO流是阻塞的，NIO流是不阻塞的;</li>
<li>NIO有选择器，而IO没有。</li>
</ul>
<p>读数据和写数据方式:</p>
<ul>
<li>从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。</li>
<li>从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。</li>
</ul>
<p>NIO核心组件简单介绍</p>
<ul>
<li>Channels</li>
<li>Buffers</li>
<li>Selectors</li>
</ul>
<h2 id="流与块" tabindex="-1"> 流与块</h2>
<p>I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p>
<p>面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。</p>
<p>面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p>
<p>I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。</p>
<h2 id="通道" tabindex="-1"> 通道</h2>
<p>通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。</p>
<p>通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。</p>
<p>通道包括以下类型：</p>
<ul>
<li>FileChannel：从文件中读写数据；</li>
<li>DatagramChannel：通过 UDP 读写网络中数据；</li>
<li>SocketChannel：通过 TCP 读写网络中数据；一般是客户端实现</li>
<li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。一般是服务器实现</li>
</ul>
<p>特殊操作</p>
<ul>
<li>Scatter / Gather
<ul>
<li>Scatter: 从一个Channel读取的信息分散到N个缓冲区中(Buufer)</li>
<li>Gather: 将N个Buffer里面内容按照顺序发送到一个Channel</li>
</ul>
</li>
</ul>
<p>通道之间的数据传输：在Java NIO中如果一个channel是FileChannel类型的，那么他可以直接把数据传输到另一个channel。</p>
<ul>
<li>transferFrom() :transferFrom方法把数据从通道源传输到FileChannel</li>
<li>transferTo() :transferTo方法把FileChannel数据传输到另一个channel</li>
</ul>
<h2 id="缓冲区" tabindex="-1"> 缓冲区</h2>
<p>Java NIO Buffers用于和NIO Channel交互。发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。</p>
<p>缓冲区实质上是一个数组(一块内存区)，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-io/channels-buffers.png" alt="" title=":size=300" loading="lazy"></p>
</div>
<p>缓冲区包括以下类型：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ul>
<p>Buffer的常见方法</p>
<ul>
<li>Buffer clear()</li>
<li>Buffer flip()</li>
<li>Buffer rewind()</li>
<li>Buffer position(int newPosition)</li>
</ul>
<h3 id="缓冲区状态变量" tabindex="-1"> 缓冲区状态变量</h3>
<ul>
<li>capacity：最大容量；</li>
<li>position：当前已经读写的字节数；</li>
<li>limit：还可以读写的字节数。</li>
</ul>
<p>状态变量的改变过程举例：</p>
<p>① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1bea398f-17a7-4f67-a90b-9e2d243eaa9a.png"/> </div><br>
<p>② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/80804f52-8815-4096-b506-48eef3eed5c6.png"/> </div><br>
<p>③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/952e06bd-5a65-4cab-82e4-dd1536462f38.png"/> </div><br>
<p>④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b5bdcbe2-b958-4aef-9151-6ad963cb28b4.png"/> </div><br>
<p>⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/67bf5487-c45d-49b6-b9c0-a058d8c68902.png"/> </div><br>
<h2 id="选择器" tabindex="-1"> 选择器</h2>
<p>NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。</p>
<p>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</p>
<p>通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。</p>
<p>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。</p>
<p>应该注意的是，只有套接字(Socket) Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/093f9e57-429c-413a-83ee-c689ba596cef.png" width="350px"> </div><br>
<p>要使用Selector的话，我们必须把Channel注册到Selector上，然后就可以调用Selector的select()方法。这个方法会进入阻塞，直到有一个channel的状态符合条件。当方法返回后，线程可以处理这些事件。</p>
<h3 id="_1-创建选择器" tabindex="-1"> 1. 创建选择器</h3>
<div><pre><code><span>Selector</span> selector <span>=</span> <span>Selector</span><span>.</span><span>open</span><span>(</span><span>)</span><span>;</span>
</code></pre></div><h3 id="_2-将通道注册到选择器上" tabindex="-1"> 2. 将通道注册到选择器上</h3>
<div><pre><code><span>ServerSocketChannel</span> ssChannel <span>=</span> <span>ServerSocketChannel</span><span>.</span><span>open</span><span>(</span><span>)</span><span>;</span>
ssChannel<span>.</span><span>configureBlocking</span><span>(</span><span>false</span><span>)</span><span>;</span><span>//Channel必须是非阻塞的</span>
ssChannel<span>.</span><span>register</span><span>(</span>selector<span>,</span> <span>SelectionKey</span><span>.</span>OP_ACCEPT<span>)</span><span>;</span>
</code></pre></div><p>通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。</p>
<p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：</p>
<ul>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ul>
<p>它们在 SelectionKey 的定义如下：</p>
<div><pre><code><span>public</span> <span>static</span> <span>final</span> <span>int</span> OP_READ <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>0</span><span>;</span>
<span>public</span> <span>static</span> <span>final</span> <span>int</span> OP_WRITE <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>2</span><span>;</span>
<span>public</span> <span>static</span> <span>final</span> <span>int</span> OP_CONNECT <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>3</span><span>;</span>
<span>public</span> <span>static</span> <span>final</span> <span>int</span> OP_ACCEPT <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>4</span><span>;</span>
</code></pre></div><p>可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：</p>
<div><pre><code><span>int</span> interestSet <span>=</span> <span>SelectionKey</span><span>.</span>OP_READ <span>|</span> <span>SelectionKey</span><span>.</span>OP_WRITE<span>;</span>
</code></pre></div><h3 id="_3-监听事件" tabindex="-1"> 3. 监听事件</h3>
<div><pre><code><span>int</span> num <span>=</span> selector<span>.</span><span>select</span><span>(</span><span>)</span><span>;</span>
</code></pre></div><p>使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。</p>
<h3 id="_4-获取到达的事件" tabindex="-1"> 4. 获取到达的事件</h3>
<div><pre><code><span>Set</span><span><span>&lt;</span><span>SelectionKey</span><span>></span></span> keys <span>=</span> selector<span>.</span><span>selectedKeys</span><span>(</span><span>)</span><span>;</span>
<span>Iterator</span><span><span>&lt;</span><span>SelectionKey</span><span>></span></span> keyIterator <span>=</span> keys<span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>
<span>while</span> <span>(</span>keyIterator<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>
    <span>SelectionKey</span> key <span>=</span> keyIterator<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>key<span>.</span><span>isAcceptable</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>// ...</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>key<span>.</span><span>isReadable</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>// ...</span>
    <span>}</span>
    keyIterator<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="_5-事件循环" tabindex="-1"> 5. 事件循环</h3>
<p>因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p>
<div><pre><code><span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
    <span>int</span> num <span>=</span> selector<span>.</span><span>select</span><span>(</span><span>)</span><span>;</span>
    <span>Set</span><span><span>&lt;</span><span>SelectionKey</span><span>></span></span> keys <span>=</span> selector<span>.</span><span>selectedKeys</span><span>(</span><span>)</span><span>;</span>
    <span>Iterator</span><span><span>&lt;</span><span>SelectionKey</span><span>></span></span> keyIterator <span>=</span> keys<span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>
    <span>while</span> <span>(</span>keyIterator<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>SelectionKey</span> key <span>=</span> keyIterator<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>key<span>.</span><span>isAcceptable</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>// ...</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>key<span>.</span><span>isReadable</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>// ...</span>
        <span>}</span>
        keyIterator<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="文件-nio-实例" tabindex="-1"> 文件 NIO 实例</h2>
<p>FileChannel的一般使用规则</p>
<ol>
<li>开启FileChannel：需要通过 InputStream ， OutputStream 或 RandomAccessFile 获取FileChannel</li>
<li>从FileChannel读取数据/写入数据：FileChannel中读取数据/写入数据之前首先要创建一个Buffer(缓冲区）对象，</li>
<li>关闭FileChannel</li>
</ol>
<p>以下展示了使用 NIO 快速复制文件的实例：</p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>fastCopy</span><span>(</span><span>String</span> src<span>,</span> <span>String</span> dist<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>
    <span>/* 获得源文件的输入字节流 */</span>
    <span>FileInputStream</span> fin <span>=</span> <span>new</span> <span>FileInputStream</span><span>(</span>src<span>)</span><span>;</span>
    <span>/* 获取输入字节流的文件通道 */</span>
    <span>FileChannel</span> fcin <span>=</span> fin<span>.</span><span>getChannel</span><span>(</span><span>)</span><span>;</span>
    <span>/* 获取目标文件的输出字节流 */</span>
    <span>FileOutputStream</span> fout <span>=</span> <span>new</span> <span>FileOutputStream</span><span>(</span>dist<span>)</span><span>;</span>
    <span>/* 获取输出字节流的文件通道 */</span>
    <span>FileChannel</span> fcout <span>=</span> fout<span>.</span><span>getChannel</span><span>(</span><span>)</span><span>;</span>
    <span>/* 为缓冲区分配 1024 个字节 */</span>
    <span>ByteBuffer</span> buffer <span>=</span> <span>ByteBuffer</span><span>.</span><span>allocateDirect</span><span>(</span><span>1024</span><span>)</span><span>;</span>
    <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
        <span>/* 从输入通道中读取数据到缓冲区中 */</span>
        <span>int</span> r <span>=</span> fcin<span>.</span><span>read</span><span>(</span>buffer<span>)</span><span>;</span>
        <span>/* read() 返回 -1 表示 EOF */</span>
        <span>if</span> <span>(</span>r <span>==</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
            <span>break</span><span>;</span>
        <span>}</span>
        <span>/* 切换读写 */</span>
        buffer<span>.</span><span>flip</span><span>(</span><span>)</span><span>;</span>
        <span>/* 把缓冲区的内容写入输出文件中 */</span>
        fcout<span>.</span><span>write</span><span>(</span>buffer<span>)</span><span>;</span>
        <span>/* 清空缓冲区 */</span>
        buffer<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h2 id="套接字-nio-实例" tabindex="-1"> 套接字 NIO 实例</h2>
<p>客户端</p>
<ol>
<li>通过SocketChannel连接到远程服务器</li>
<li>创建读数据/写数据缓冲区对象来读取服务端数据或向服务端发送数据</li>
<li>关闭SocketChannel</li>
</ol>
<p>服务端</p>
<ol>
<li>通过ServerSocketChannel 绑定ip地址和端口号</li>
<li>通过ServerSocketChannelImpl的accept()方法创建一个SocketChannel对象用户从客户端读/写数据</li>
<li>创建读数据/写数据缓冲区对象来读取客户端数据或向客户端发送数据</li>
<li>关闭SocketChannel和ServerSocketChannel</li>
</ol>
<div><pre><code><span>public</span> <span>class</span> <span>NIOServer</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>

        <span>Selector</span> selector <span>=</span> <span>Selector</span><span>.</span><span>open</span><span>(</span><span>)</span><span>;</span>

        <span>ServerSocketChannel</span> ssChannel <span>=</span> <span>ServerSocketChannel</span><span>.</span><span>open</span><span>(</span><span>)</span><span>;</span>
        ssChannel<span>.</span><span>configureBlocking</span><span>(</span><span>false</span><span>)</span><span>;</span>
        ssChannel<span>.</span><span>register</span><span>(</span>selector<span>,</span> <span>SelectionKey</span><span>.</span>OP_ACCEPT<span>)</span><span>;</span>

        <span>ServerSocket</span> serverSocket <span>=</span> ssChannel<span>.</span><span>socket</span><span>(</span><span>)</span><span>;</span>
        <span>InetSocketAddress</span> address <span>=</span> <span>new</span> <span>InetSocketAddress</span><span>(</span><span>"127.0.0.1"</span><span>,</span> <span>8888</span><span>)</span><span>;</span>
        serverSocket<span>.</span><span>bind</span><span>(</span>address<span>)</span><span>;</span>

        <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>

            selector<span>.</span><span>select</span><span>(</span><span>)</span><span>;</span>
            <span>Set</span><span><span>&lt;</span><span>SelectionKey</span><span>></span></span> keys <span>=</span> selector<span>.</span><span>selectedKeys</span><span>(</span><span>)</span><span>;</span>
            <span>Iterator</span><span><span>&lt;</span><span>SelectionKey</span><span>></span></span> keyIterator <span>=</span> keys<span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>

            <span>while</span> <span>(</span>keyIterator<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>

                <span>SelectionKey</span> key <span>=</span> keyIterator<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>

                <span>if</span> <span>(</span>key<span>.</span><span>isAcceptable</span><span>(</span><span>)</span><span>)</span> <span>{</span>

                    <span>ServerSocketChannel</span> ssChannel1 <span>=</span> <span>(</span><span>ServerSocketChannel</span><span>)</span> key<span>.</span><span>channel</span><span>(</span><span>)</span><span>;</span>

                    <span>// 服务器会为每个新连接创建一个 SocketChannel</span>
                    <span>SocketChannel</span> sChannel <span>=</span> ssChannel1<span>.</span><span>accept</span><span>(</span><span>)</span><span>;</span>
                    sChannel<span>.</span><span>configureBlocking</span><span>(</span><span>false</span><span>)</span><span>;</span>

                    <span>// 这个新连接主要用于从客户端读取数据</span>
                    sChannel<span>.</span><span>register</span><span>(</span>selector<span>,</span> <span>SelectionKey</span><span>.</span>OP_READ<span>)</span><span>;</span>

                <span>}</span> <span>else</span> <span>if</span> <span>(</span>key<span>.</span><span>isReadable</span><span>(</span><span>)</span><span>)</span> <span>{</span>

                    <span>SocketChannel</span> sChannel <span>=</span> <span>(</span><span>SocketChannel</span><span>)</span> key<span>.</span><span>channel</span><span>(</span><span>)</span><span>;</span>
                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>readDataFromSocketChannel</span><span>(</span>sChannel<span>)</span><span>)</span><span>;</span>
                    sChannel<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>

                keyIterator<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>private</span> <span>static</span> <span>String</span> <span>readDataFromSocketChannel</span><span>(</span><span>SocketChannel</span> sChannel<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>

        <span>ByteBuffer</span> buffer <span>=</span> <span>ByteBuffer</span><span>.</span><span>allocate</span><span>(</span><span>1024</span><span>)</span><span>;</span>
        <span>StringBuilder</span> data <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>

        <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>

            buffer<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>
            <span>int</span> n <span>=</span> sChannel<span>.</span><span>read</span><span>(</span>buffer<span>)</span><span>;</span>
            <span>if</span> <span>(</span>n <span>==</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
                <span>break</span><span>;</span>
            <span>}</span>
            buffer<span>.</span><span>flip</span><span>(</span><span>)</span><span>;</span>
            <span>int</span> limit <span>=</span> buffer<span>.</span><span>limit</span><span>(</span><span>)</span><span>;</span>
            <span>char</span><span>[</span><span>]</span> dst <span>=</span> <span>new</span> <span>char</span><span>[</span>limit<span>]</span><span>;</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> limit<span>;</span> i<span>++</span><span>)</span> <span>{</span>
                dst<span>[</span>i<span>]</span> <span>=</span> <span>(</span><span>char</span><span>)</span> buffer<span>.</span><span>get</span><span>(</span>i<span>)</span><span>;</span>
            <span>}</span>
            data<span>.</span><span>append</span><span>(</span>dst<span>)</span><span>;</span>
            buffer<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> data<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>NIOClient</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>
        <span>Socket</span> socket <span>=</span> <span>new</span> <span>Socket</span><span>(</span><span>"127.0.0.1"</span><span>,</span> <span>8888</span><span>)</span><span>;</span>
        <span>OutputStream</span> out <span>=</span> socket<span>.</span><span>getOutputStream</span><span>(</span><span>)</span><span>;</span>
        <span>String</span> s <span>=</span> <span>"hello world"</span><span>;</span>
        out<span>.</span><span>write</span><span>(</span>s<span>.</span><span>getBytes</span><span>(</span><span>)</span><span>)</span><span>;</span>
        out<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="其他实例" tabindex="-1"> 其他实例</h2>
<ul>
<li><a href="http://wiki.jikexueyuan.com/project/java-nio-zh/java-nio-datagramchannel.html" target="_blank" rel="noopener noreferrer">Java NIO DatagramChannel数据报通道</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/java-nio-zh/java-nio-pipe.html" target="_blank" rel="noopener noreferrer">Java NIO Pipe管道</a></li>
</ul>
<h2 id="scatter-gather" tabindex="-1"> Scatter / Gather</h2>
<p>Channel 提供了一种被称为 Scatter/Gather 的新功能，也称为本地矢量 I/O。Scatter/Gather 是指在多个缓冲区上实现一个简单的 I/O 操作。正确使用 Scatter / Gather可以明显提高性能。</p>
<p>Scatter/Gather应该使用直接的ByteBuffers以从本地I/O获取最大性能优势。</p>
<p>Scatter/Gather功能是通道(Channel)提供的 并不是Buffer。</p>
<ul>
<li>Scatter: 从一个Channel读取的信息分散到N个缓冲区中(Buufer)</li>
<li>Gather: 将N个Buffer里面内容按照顺序发送到一个Channel</li>
</ul>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-io/scatter.png" alt="" title=":size=300" loading="lazy"></p>
</div>
<p>&quot;<strong>scattering read</strong>&quot;是把数据从单个Channel写入到多个buffer：read()方法内部会负责把数据按顺序写进传入的buffer数组内。一个buffer写满后，接着写到下一个buffer中</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-io/gather.png" alt="" title=":size=300" loading="lazy"></p>
</div>
<p>&quot;<strong>gathering write</strong>&quot;把多个buffer的数据写入到同一个channel中：write()方法内部会负责把数据按顺序写入到channel中</p>
<p><strong>注意</strong>：并不是所有数据都写入到通道，写入的数据要根据position和limit的值来判断，只有position和limit之间的数据才会被写入</p>
<p><strong>注意</strong>：无论是scatter还是gather操作，都是按照buffer在数组中的顺序来依次读取或写入的</p>
<h2 id="内存映射文件" tabindex="-1"> 内存映射文件</h2>
<p>这个功能主要是为了提高大文件的读写速度而设计的。内存映射文件(memory-mappedfile)能让你创建和修改那些大到无法读入内存的文件。</p>
<p>有了内存映射文件，你就可以认为文件已经全部读进了内存，然后把它当成一个非常大的数组来访问了。将文件的一段区域映射到内存中，比传统的文件处理速度要快很多。内存映射文件它虽然最终也是要从磁盘读取数据，但是它并不需要将数据读取到OS内核缓冲区，而是直接将进程的用户私有地址空间中的一部分区域与文件对象建立起映射关系，就好像直接从内存中读、写文件一样，速度当然快了。</p>
<p>内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。</p>
<p>向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。</p>
<p>NIO中内存映射主要用到以下两个类：</p>
<ul>
<li>java.nio.MappedByteBuffer</li>
<li>java.nio.channels.FileChannel</li>
</ul>
<p>下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。</p>
<div><pre><code><span>MappedByteBuffer</span> mbb <span>=</span> fc<span>.</span><span>map</span><span>(</span><span>FileChannel<span>.</span>MapMode</span><span>.</span>READ_WRITE<span>,</span> <span>0</span><span>,</span> <span>1024</span><span>)</span><span>;</span>
</code></pre></div><p>内存映射文件的优点：</p>
<ul>
<li>用户进程将文件数据视为内存，因此不需要发出read()或write()系统调用</li>
<li>当用户进程触摸映射的内存空间时，将自动生成页面错误，以从磁盘引入文件数据。 如果用户修改映射的内存空间，受影响的页面将自动标记为脏，并随后刷新到磁盘以更新文件</li>
<li>操作系统的虚拟内存子系统将执行页面的智能缓存，根据系统负载自动管理内存</li>
<li>数据始终是页面对齐的，不需要缓冲区复制</li>
<li>可以映射非常大的文件，而不消耗大量内存来复制数据。</li>
</ul>
<h1 id="bio-nio-aio" tabindex="-1"> BIO,NIO,AIO</h1>
<p>Java 中的 BIO、NIO和 AIO 理解为是 Java 语言对操作系统的各种 IO 模型的封装。</p>
<p>同步与异步</p>
<ul>
<li>同步： 同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。</li>
<li>异步： 异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。</li>
</ul>
<p>阻塞和非阻塞</p>
<ul>
<li>阻塞： 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</li>
<li>非阻塞： 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。</li>
</ul>
<p>BIO:同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。
NIO:同步非阻塞的I/O模型
AIO:异步非阻塞的I/O模型</p>
<h2 id="bio-blocking-i-o" tabindex="-1"> BIO(Blocking I/O)</h2>
<p>同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。</p>
<p><strong>传统BIO</strong></p>
<p>BIO通信(一请求一应答）模型图如下</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-io/BIO通信模型.png" alt="" loading="lazy"></p>
</div>
<p>采用 BIO 通信模型 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。我们一般通过在while(true) 循环中服务端会调用 accept() 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成， 不过可以通过多线程来支持多个客户端的连接，如上图所示。</p>
<p>如果要让 BIO 通信模型 能够同时处理多个客户端请求，就必须使用多线程(主要原因是socket.accept()、socket.read()、socket.write() 涉及的三个主要函数都是同步阻塞的），也就是说它在接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。这就是典型的 <strong>一请求一应答通信模型</strong> 。</p>
<p><strong>伪异步 IO</strong></p>
<p>为了解决同步阻塞I/O面临的一个链路需要一个线程处理的问题，后来有人对它的线程模型进行了优化一一一后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M：线程池最大线程数N的比例关系，其中M可以远远大于N.通过线程池可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程耗尽。</p>
<p>伪异步IO模型图</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-io/伪异步IO模型.png" alt="" loading="lazy"></p>
</div>
<p>采用线程池和任务队列可以实现一种叫做伪异步的 I/O 通信框架，它的模型图如上图所示。当有新的客户端接入时，将客户端的 Socket 封装成一个Task(该任务实现java.lang.Runnable接口）投递到后端的线程池中进行处理，JDK 的线程池维护一个消息队列和 N 个活跃线程，对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。</p>
<p>伪异步I/O通信框架采用了线程池实现，因此避免了为每个请求都创建一个独立线程造成的线程资源耗尽问题。不过因为它的底层仍然是同步阻塞的BIO模型，因此无法从根本上解决问题。</p>
<p>在活动连接数不是特别高(小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p>
<h2 id="nio-non-blocking-i-o" tabindex="-1"> NIO(Non-blocking I/O)</h2>
<p>NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的(网络）应用，应使用 NIO 的非阻塞模式来开发。</p>
<ul>
<li>JDK 的 NIO 底层由 epoll 实现，该实现饱受诟病的空轮询 bug 会导致 cpu 飙升 100%</li>
<li>项目庞大之后，自行实现的 NIO 很容易出现各类 bug，维护成本较高</li>
</ul>
<h2 id="aio-asynchronous-i-o" tabindex="-1"> AIO(Asynchronous I/O)</h2>
<p>AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>
<p>AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。</p>
<p>AIO 的 I/O 操作，有两种方式的 API 可以进行：</p>
<ul>
<li>Future 方式:即提交一个 I/O 操作请求，返回一个 Future。然后您可以对 Future 进行检查，确定它是否完成，或者阻塞 IO 操作直到操作正常完成或者超时异常。
<ul>
<li>Future.get()是同步的，所以如果不仔细考虑使用场合，使用 Future 方式可能很容易进入完全同步的编程模式，从而使得异步操作成为一个摆设</li>
</ul>
</li>
<li>Callback 方式:即提交一个 I/O 操作请求，并且指定一个 CompletionHandler。当异步 I/O 操作完成时，便发送一个通知，此时这个 CompletionHandler 对象的 completed 或者 failed 方法将会被调用</li>
</ul>
<div><pre><code><span>public</span> <span>interface</span> <span>CompletionHandler</span><span><span>&lt;</span><span>V</span><span>,</span><span>A</span><span>></span></span> <span>{</span>
    <span>// 当操作完成后被调用，result 参数表示操作结果，</span>
    <span>// attachment 参数表示提交操作请求时的参数。</span>
    <span>void</span> <span>completed</span><span>(</span><span>V</span> result<span>,</span> <span>A</span> attachment<span>)</span><span>;</span>

    <span>// 当操作失败是调用，exc 参数表示失败原因。attachment 参数同上。</span>
    <span>void</span> <span>failed</span><span>(</span><span>Throwable</span> exc<span>,</span> <span>A</span> attachment<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><ul>
<li>V表示结果值的类型。对于异步网络通道的读写操作而言，这个结果值 V 都是整数类型，表示已经操作的卦数，如果是 -1，NIO.2 内核实现保证传递的 ByteBuffer参数不会有变化。</li>
<li>A表示关联到 I/O 操作的对象的类型。用于传递操作环境。通常会封装一个连接环境。</li>
<li>如果成功则 completed 方法被调用。如果失败则 failed 方法被调用。</li>
</ul>
<p>准备好 CompletionHandler 之后，如何使用 CompletionHandler 呢？AIO 提供四种类型的异步通道以及不同的 I/O 操作接受一个 CompletionHandler 对象，它们分别是：</p>
<ul>
<li>AsynchronousSocketChannel：connect，read，write</li>
<li>AsynchronousFileChannel：lock，read，write</li>
<li>AsynchronousServerSocketChannel：accept</li>
<li>AsynchronousDatagramChannel：read，write，send，receive</li>
</ul>
<p><a href="http://wiki.jikexueyuan.com/project/java-nio-zh/java-nio-asynchronousfilechannel.html" target="_blank" rel="noopener noreferrer">Java NIO AsynchronousFileChannel异步文件通道</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-nio2/index.html" target="_blank" rel="noopener noreferrer">Java NIO 异步 I/O 网络客户端程序实例</a></p>
<h1 id="八、参考资料" tabindex="-1"> 八、参考资料</h1>
<ul>
<li>Eckel B, 埃克尔, 昊鹏, 等. Java 编程思想 [M]. 机械工业出版社, 2002.</li>
<li><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener noreferrer">IBM: NIO 入门</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/index.html" target="_blank" rel="noopener noreferrer">Java NIO Tutorial</a></li>
<li><a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener noreferrer">Java NIO 浅析</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html" target="_blank" rel="noopener noreferrer">IBM: 深入分析 Java I/O 的工作机制</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/index.html" target="_blank" rel="noopener noreferrer">IBM: 深入分析 Java 中的中文编码问题</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html" target="_blank" rel="noopener noreferrer">IBM: Java 序列化的高级认识</a></li>
<li><a href="http://blog.csdn.net/shimiso/article/details/24990499" target="_blank" rel="noopener noreferrer">NIO 与传统 IO 的区别</a></li>
<li><a href="http://stg-tud.github.io/sedc/Lecture/ws13-14/5.3-Decorator.html#mode=document" target="_blank" rel="noopener noreferrer">Decorator Design Pattern</a></li>
<li><a href="http://labojava.blogspot.com/2012/12/socket-multicast.html" target="_blank" rel="noopener noreferrer">Socket Multicast</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java基础</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/Java%E5%9F%BA%E7%A1%80.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/Java%E5%9F%BA%E7%A1%80.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">Java基础</source>
      <category>Java</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
</ul>
</li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>

<h1 id="一、数据类型" tabindex="-1"> 一、数据类型</h1>
<h2 id="基本类型" tabindex="-1"> 基本类型</h2>
<ul>
<li>byte/8</li>
<li>char/16</li>
<li>short/16</li>
<li>int/32</li>
<li>float/32</li>
<li>long/64</li>
<li>double/64</li>
<li>boolean/~</li>
</ul>
<p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</p>
<p>byte = char = short &lt; int &lt; long &lt; float &lt; double</p>
<p>两个数值进行二元操作时，会有如下的转换操作：</p>
<ul>
<li>如果两个操作数其中有一个是double类型，另一个操作就会转换为double类型。</li>
<li>否则，如果其中一个操作数是float类型，另一个将会转换为float类型。</li>
<li>否则，如果其中一个操作数是long类型，另一个会转换为long类型。</li>
<li>否则，两个操作数都转换为int类型。</li>
</ul>
<p>Java允许对boolean类型的值进行按位“与”、“或”和“异或”操作，但不能进行按位“非”。对于boolean值，按位操作与逻辑操作有相同的结果，但是不会发生“短路”。</p>
<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html" target="_blank" rel="noopener noreferrer">Primitive Data Types</a></li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf" target="_blank" rel="noopener noreferrer">The Java® Virtual Machine Specification</a></li>
</ul>
<h2 id="包装类型" tabindex="-1"> 包装类型</h2>
<p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p>
<div><pre><code><span>Integer</span> x <span>=</span> <span>2</span><span>;</span>     <span>// 装箱 调用了 Integer.valueOf(2)</span>
<span>int</span> y <span>=</span> x<span>;</span>         <span>// 拆箱 调用了 X.intValue()</span>
</code></pre></div><ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html" target="_blank" rel="noopener noreferrer">Autoboxing and Unboxing</a></li>
</ul>
<h2 id="缓存池" tabindex="-1"> 缓存池</h2>
<p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象；</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li>
</ul>
<div><pre><code><span>Integer</span> x <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>123</span><span>)</span><span>;</span>
<span>Integer</span> y <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>123</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>x <span>==</span> y<span>)</span><span>;</span>    <span>// false</span>
<span>Integer</span> z <span>=</span> <span>Integer</span><span>.</span><span>valueOf</span><span>(</span><span>123</span><span>)</span><span>;</span>
<span>Integer</span> k <span>=</span> <span>Integer</span><span>.</span><span>valueOf</span><span>(</span><span>123</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>z <span>==</span> k<span>)</span><span>;</span>   <span>// true</span>
</code></pre></div><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p>
<div><pre><code><span>public</span> <span>static</span> <span>Integer</span> <span>valueOf</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>i <span>>=</span> <span>IntegerCache</span><span>.</span>low <span>&amp;&amp;</span> i <span>&lt;=</span> <span>IntegerCache</span><span>.</span>high<span>)</span>
        <span>return</span> <span>IntegerCache</span><span>.</span>cache<span>[</span>i <span>+</span> <span>(</span><span>-</span><span>IntegerCache</span><span>.</span>low<span>)</span><span>]</span><span>;</span>
    <span>return</span> <span>new</span> <span>Integer</span><span>(</span>i<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p>
<div><pre><code><span>static</span> <span>final</span> <span>int</span> low <span>=</span> <span>-</span><span>128</span><span>;</span>
<span>static</span> <span>final</span> <span>int</span> high<span>;</span>
<span>static</span> <span>final</span> <span>Integer</span> cache<span>[</span><span>]</span><span>;</span>

<span>static</span> <span>{</span>
    <span>// high value may be configured by property</span>
    <span>int</span> h <span>=</span> <span>127</span><span>;</span>
    <span>String</span> integerCacheHighPropValue <span>=</span>
        sun<span>.</span>misc<span>.</span>VM<span>.</span><span>getSavedProperty</span><span>(</span><span>"java.lang.Integer.IntegerCache.high"</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>integerCacheHighPropValue <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
            <span>int</span> i <span>=</span> <span>parseInt</span><span>(</span>integerCacheHighPropValue<span>)</span><span>;</span>
            i <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>i<span>,</span> <span>127</span><span>)</span><span>;</span>
            <span>// Maximum array size is Integer.MAX_VALUE</span>
            h <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>i<span>,</span> <span>Integer</span><span>.</span>MAX_VALUE <span>-</span> <span>(</span><span>-</span>low<span>)</span> <span>-</span><span>1</span><span>)</span><span>;</span>
        <span>}</span> <span>catch</span><span>(</span> <span>NumberFormatException</span> nfe<span>)</span> <span>{</span>
            <span>// If the property cannot be parsed into an int, ignore it.</span>
        <span>}</span>
    <span>}</span>
    high <span>=</span> h<span>;</span>

    cache <span>=</span> <span>new</span> <span>Integer</span><span>[</span><span>(</span>high <span>-</span> low<span>)</span> <span>+</span> <span>1</span><span>]</span><span>;</span>
    <span>int</span> j <span>=</span> low<span>;</span>
    <span>for</span><span>(</span><span>int</span> k <span>=</span> <span>0</span><span>;</span> k <span>&lt;</span> cache<span>.</span>length<span>;</span> k<span>++</span><span>)</span>
        cache<span>[</span>k<span>]</span> <span>=</span> <span>new</span> <span>Integer</span><span>(</span>j<span>++</span><span>)</span><span>;</span>

    <span>// range [-128, 127] must be interned (JLS7 5.1.7)</span>
    <span>assert</span> <span>IntegerCache</span><span>.</span>high <span>>=</span> <span>127</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p>
<div><pre><code><span>Integer</span> m <span>=</span> <span>123</span><span>;</span>
<span>Integer</span> n <span>=</span> <span>123</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>m <span>==</span> n<span>)</span><span>;</span> <span>// true</span>
</code></pre></div><p>基本类型对应的缓冲池如下：</p>
<ul>
<li>boolean values true and false</li>
<li>all byte values</li>
<li>short values between -128 and 127</li>
<li>int values between -128 and 127</li>
<li>char in the range \u0000 to \u007F</li>
</ul>
<p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</p>
<p>在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=&lt;size&gt; 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。</p>
<p><a href="https://stackoverflow.com/questions/9030817/differences-between-new-integer123-integer-valueof123-and-just-123" target="_blank" rel="noopener noreferrer">StackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123
</a></p>
<h1 id="二、string" tabindex="-1"> 二、String</h1>
<h2 id="概览" tabindex="-1"> 概览</h2>
<p>String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承)</p>
<p>在 Java 8 中，String 内部使用 char 数组存储数据。</p>
<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>String</span>
    <span>implements</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span><span>,</span> <span>Comparable</span><span><span>&lt;</span><span>String</span><span>></span></span><span>,</span> <span>CharSequence</span> <span>{</span>
    <span>/** The value is used for character storage. */</span>
    <span>private</span> <span>final</span> <span>char</span> value<span>[</span><span>]</span><span>;</span>
<span>}</span>
</code></pre></div><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p>
<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>String</span>
    <span>implements</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span><span>,</span> <span>Comparable</span><span><span>&lt;</span><span>String</span><span>></span></span><span>,</span> <span>CharSequence</span> <span>{</span>
    <span>/** The value is used for character storage. */</span>
    <span>private</span> <span>final</span> <span>byte</span><span>[</span><span>]</span> value<span>;</span>

    <span>/** The identifier of the encoding used to encode the bytes in <span>{</span><span>@code</span> <span><span>value</span></span><span>}</span>. */</span>
    <span>private</span> <span>final</span> <span>byte</span> coder<span>;</span>
<span>}</span>
</code></pre></div><p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p>
<h2 id="不可变的好处" tabindex="-1"> 不可变的好处</h2>
<p><strong>1. 可以缓存 hash 值</strong></p>
<p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p>
<p><strong>2. String Pool 的需要</strong></p>
<p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9112288f-23f5-4e53-b222-a46fdbca1603.png" width="300px"> </div><br>
<p><strong>3. 安全性</strong></p>
<p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p>
<p><strong>4. 线程安全</strong></p>
<p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p>
<p><a href="https://www.programcreek.com/2013/04/why-string-is-immutable-in-java/" target="_blank" rel="noopener noreferrer">Program Creek : Why String is immutable in Java?</a></p>
<h2 id="string-stringbuffer-and-stringbuilder" tabindex="-1"> String, StringBuffer and StringBuilder</h2>
<p><strong>1. 可变性</strong></p>
<ul>
<li>String 不可变</li>
<li>StringBuffer 和 StringBuilder 可变</li>
</ul>
<p><strong>2. 线程安全</strong></p>
<ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder 不是线程安全的</li>
<li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
<p><a href="https://stackoverflow.com/questions/2971315/string-stringbuffer-and-stringbuilder" target="_blank" rel="noopener noreferrer">StackOverflow : String, StringBuffer, and StringBuilder</a></p>
<h2 id="string-pool" tabindex="-1"> String Pool</h2>
<p>字符串常量池(String Pool)保存着所有字符串字面量(literal strings)，这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。</p>
<p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等(使用 equals() 方法进行确定)，那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p>
<p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p>
<div><pre><code><span>String</span> s1 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"aaa"</span><span>)</span><span>;</span>
<span>String</span> s2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"aaa"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1 <span>==</span> s2<span>)</span><span>;</span>           <span>// false</span>
<span>String</span> s3 <span>=</span> s1<span>.</span><span>intern</span><span>(</span><span>)</span><span>;</span>
<span>String</span> s4 <span>=</span> s1<span>.</span><span>intern</span><span>(</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s3 <span>==</span> s4<span>)</span><span>;</span>           <span>// true</span>
</code></pre></div><p>如果是采用 &quot;bbb&quot; 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p>
<div><pre><code><span>String</span> s5 <span>=</span> <span>"bbb"</span><span>;</span>
<span>String</span> s6 <span>=</span> <span>"bbb"</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s5 <span>==</span> s6<span>)</span><span>;</span>  <span>// true</span>
</code></pre></div><p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p>
<ul>
<li><a href="https://stackoverflow.com/questions/10578984/what-is-string-interning" target="_blank" rel="noopener noreferrer">StackOverflow : What is String interning?</a></li>
<li><a href="https://tech.meituan.com/in_depth_understanding_string_intern.html" target="_blank" rel="noopener noreferrer">深入解析 String#intern</a></li>
</ul>
<h2 id="new-string-abc" tabindex="-1"> new String(&quot;abc&quot;)</h2>
<p>使用这种方式一共会创建两个字符串对象(前提是 String Pool 中还没有 &quot;abc&quot; 字符串对象)。</p>
<ul>
<li>&quot;abc&quot; 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 &quot;abc&quot; 字符串字面量；</li>
<li>而使用 new 的方式会在堆中创建一个字符串对象。</li>
</ul>
<p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p>
<div><pre><code><span>public</span> <span>class</span> <span>NewStringTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>String</span> s <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"abc"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><p>使用 javap -verbose 进行反编译，得到以下内容：</p>
<div><pre><code><span>// ...</span>
<span>Constant</span> pool<span>:</span>
<span>// ...</span>
   #<span>2</span> <span>=</span> <span>Class</span>              #<span>18</span>            <span>// java/lang/String</span>
   #<span>3</span> <span>=</span> <span>String</span>             #<span>19</span>            <span>// abc</span>
<span>// ...</span>
  #<span>18</span> <span>=</span> <span>Utf8</span>               java<span>/</span>lang<span>/</span><span>String</span>
  #<span>19</span> <span>=</span> <span>Utf8</span>               abc
<span>// ...</span>

  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span><span>java<span>.</span>lang<span>.</span></span>String</span><span>[</span><span>]</span><span>)</span><span>;</span>
    descriptor<span>:</span> <span>(</span><span>[</span><span>Ljava</span><span>/</span>lang<span>/</span><span>String</span><span>;</span><span>)</span><span>V</span>
    flags<span>:</span> ACC_PUBLIC<span>,</span> ACC_STATIC
    <span>Code</span><span>:</span>
      stack<span>=</span><span>3</span><span>,</span> locals<span>=</span><span>2</span><span>,</span> args_size<span>=</span><span>1</span>
         <span>0</span><span>:</span> <span>new</span>           #<span>2</span>                  <span>// class java/lang/String</span>
         <span>3</span><span>:</span> dup
         <span>4</span><span>:</span> ldc           #<span>3</span>                  <span>// String abc</span>
         <span>6</span><span>:</span> invokespecial #<span>4</span>                  <span>// Method java/lang/String."&lt;init>":(Ljava/lang/String;)V</span>
         <span>9</span><span>:</span> astore_1
<span>// ...</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>在 Constant Pool 中，#19 存储这字符串字面量 &quot;abc&quot;，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p>
<p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p>
<div><pre><code><span>public</span> <span>String</span><span>(</span><span>String</span> original<span>)</span> <span>{</span>
    <span>this</span><span>.</span>value <span>=</span> original<span>.</span>value<span>;</span>
    <span>this</span><span>.</span>hash <span>=</span> original<span>.</span>hash<span>;</span>
<span>}</span>
</code></pre></div><h1 id="三、运算" tabindex="-1"> 三、运算</h1>
<h2 id="参数传递" tabindex="-1"> 参数传递</h2>
<p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。</p>
<p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中使指针引用其它对象，那么这两个指针此时指向的是完全不同的对象，在一方改变其所指向对象的内容时对另一方没有影响。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Dog</span> <span>{</span>

    <span>String</span> name<span>;</span>

    <span>Dog</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>this</span><span>.</span>name<span>;</span>
    <span>}</span>

    <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>String</span> <span>getObjectAddress</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>super</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>PassByValueExample</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Dog</span> dog <span>=</span> <span>new</span> <span>Dog</span><span>(</span><span>"A"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dog<span>.</span><span>getObjectAddress</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// Dog@4554617c</span>
        <span>func</span><span>(</span>dog<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dog<span>.</span><span>getObjectAddress</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// Dog@4554617c</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dog<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>          <span>// A</span>
    <span>}</span>

    <span>private</span> <span>static</span> <span>void</span> <span>func</span><span>(</span><span>Dog</span> dog<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dog<span>.</span><span>getObjectAddress</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// Dog@4554617c</span>
        dog <span>=</span> <span>new</span> <span>Dog</span><span>(</span><span>"B"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dog<span>.</span><span>getObjectAddress</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// Dog@74a14482</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dog<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>          <span>// B</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。</p>
<div><pre><code><span>class</span> <span>PassByValueExample</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Dog</span> dog <span>=</span> <span>new</span> <span>Dog</span><span>(</span><span>"A"</span><span>)</span><span>;</span>
        <span>func</span><span>(</span>dog<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dog<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>          <span>// B</span>
    <span>}</span>

    <span>private</span> <span>static</span> <span>void</span> <span>func</span><span>(</span><span>Dog</span> dog<span>)</span> <span>{</span>
        dog<span>.</span><span>setName</span><span>(</span><span>"B"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><a href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value" target="_blank" rel="noopener noreferrer">StackOverflow: Is Java “pass-by-reference” or “pass-by-value”?</a></p>
<h2 id="float-与-double" tabindex="-1"> float 与 double</h2>
<p>Java 不能隐式执行向下转型，因为这会使得精度降低。</p>
<p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。</p>
<div><pre><code><span>// float f = 1.1;</span>
</code></pre></div><p>1.1f 字面量才是 float 类型。</p>
<div><pre><code><span>float</span> f <span>=</span> <span>1.1f</span><span>;</span>
</code></pre></div><h2 id="隐式类型转换" tabindex="-1"> 隐式类型转换</h2>
<p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。</p>
<div><pre><code><span>short</span> s1 <span>=</span> <span>1</span><span>;</span>
<span>// s1 = s1 + 1;</span>
</code></pre></div><p>但是使用 += 或者 ++ 运算符可以执行隐式类型转换。</p>
<div><pre><code>s1 <span>+=</span> <span>1</span><span>;</span>
<span>// s1++;</span>
</code></pre></div><p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p>
<div><pre><code>s1 <span>=</span> <span>(</span><span>short</span><span>)</span> <span>(</span>s1 <span>+</span> <span>1</span><span>)</span><span>;</span>
</code></pre></div><p><a href="https://stackoverflow.com/questions/8710619/why-dont-javas-compound-assignment-operators-require-casting" target="_blank" rel="noopener noreferrer">StackOverflow : Why don't Java's +=, -=, *=, /= compound assignment operators require casting?</a></p>
<h2 id="switch" tabindex="-1"> switch</h2>
<p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p>
<div><pre><code><span>String</span> s <span>=</span> <span>"a"</span><span>;</span>
<span>switch</span> <span>(</span>s<span>)</span> <span>{</span>
    <span>case</span> <span>"a"</span><span>:</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"aaa"</span><span>)</span><span>;</span>
        <span>break</span><span>;</span>
    <span>case</span> <span>"b"</span><span>:</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"bbb"</span><span>)</span><span>;</span>
        <span>break</span><span>;</span>
<span>}</span>
</code></pre></div><p>switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p>
<div><pre><code><span>// long x = 111;</span>
<span>// switch (x) { // Incompatible types. Found: 'long', required: 'char, byte, short, int, Character, Byte, Short, Integer, String, or an enum'</span>
<span>//     case 111:</span>
<span>//         System.out.println(111);</span>
<span>//         break;</span>
<span>//     case 222:</span>
<span>//         System.out.println(222);</span>
<span>//         break;</span>
<span>// }</span>
</code></pre></div><p><a href="https://stackoverflow.com/questions/2676210/why-cant-your-switch-statement-data-type-be-long-java" target="_blank" rel="noopener noreferrer">StackOverflow : Why can't your switch statement data type be long, Java?</a></p>
<h2 id="三元运算" tabindex="-1"> 三元运算</h2>
<p>三元操作符类型的转换规则：</p>
<ol>
<li>若两个操作数不可转换，则不做转换，返回值为Object类型</li>
<li>若两个操作数是明确类型的表达式（比如变量），则按照正常的二进制数字来转换，int类型转换为long类型，long类型转换为float类型等。</li>
<li>若两个操作数中有一个是数字S,另外一个是表达式，且其类型标示为T，那么，若数字S在T的范围内，则转换为T类型；若S超出了T类型的范围，则T转换为S类型。</li>
<li>若两个操作数都是直接量数字，则返回值类型为范围较大者</li>
</ol>
<h1 id="四、继承" tabindex="-1"> 四、继承</h1>
<h2 id="访问权限" tabindex="-1"> 访问权限</h2>
<p>Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p>
<p>public&gt;protected&gt;默认(包访问权限)&gt;private</p>
<table>
<thead>
<tr>
<th></th>
<th>private</th>
<th>defalt</th>
<th>protect</th>
<th>public</th>
</tr>
</thead>
<tbody>
<tr>
<td>同一个类</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>同一个包</td>
<td></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>子类</td>
<td></td>
<td></td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>全局</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
</tr>
</tbody>
</table>
<p>可以对类或类中的成员(字段以及方法)加上访问修饰符。</p>
<ul>
<li>类可见表示其它类可以用这个类创建实例对象。</li>
<li>成员可见表示其它类可以用这个类的实例对象访问到该成员；</li>
</ul>
<p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p>
<p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。</p>
<p>子类能继承父类的所有域，只是private修饰的无法访问</p>
<p>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。</p>
<p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。</p>
<div><pre><code><span>public</span> <span>class</span> <span>AccessExample</span> <span>{</span>
    <span>public</span> <span>String</span> id<span>;</span>
<span>}</span>
</code></pre></div><p>可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。</p>
<div><pre><code><span>public</span> <span>class</span> <span>AccessExample</span> <span>{</span>

    <span>private</span> <span>int</span> id<span>;</span>

    <span>public</span> <span>String</span> <span>getId</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> id <span>+</span> <span>""</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setId</span><span>(</span><span>String</span> id<span>)</span> <span>{</span>
        <span>this</span><span>.</span>id <span>=</span> <span>Integer</span><span>.</span><span>valueOf</span><span>(</span>id<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。</p>
<div><pre><code><span>public</span> <span>class</span> <span>AccessWithInnerClassExample</span> <span>{</span>

    <span>private</span> <span>class</span> <span>InnerClass</span> <span>{</span>
        <span>int</span> x<span>;</span>
    <span>}</span>

    <span>private</span> <span>InnerClass</span> innerClass<span>;</span>

    <span>public</span> <span>AccessWithInnerClassExample</span><span>(</span><span>)</span> <span>{</span>
        innerClass <span>=</span> <span>new</span> <span>InnerClass</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getValue</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> innerClass<span>.</span>x<span>;</span>  <span>// 直接访问</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="内部类" tabindex="-1"> 内部类</h2>
<p>把类定义在另一个类的内部，该类就被称为内部类。</p>
<p>内部类是可以用private修饰的！不让类以外的其他类访问！</p>
<p>内部类的访问规则</p>
<ul>
<li>可以直接访问外部类的成员，包括私有</li>
<li>外部类要想访问内部类成员，必须创建对象</li>
</ul>
<h3 id="内部类的分类" tabindex="-1"> 内部类的分类</h3>
<ul>
<li>成员内部类</li>
<li>局部内部类</li>
<li>匿名内部类</li>
</ul>
<h4 id="成员内部类" tabindex="-1"> 成员内部类</h4>
<p>成员内部类</p>
<ul>
<li>访问规则：外部类名.内部类名 对象名 = new 外部类名().new 内部类名();</li>
<li>可以访问外部所有资源，但本身内部不可有静态属性(自己需要依靠外部类的实例化)</li>
<li>访问外部类同名成员时：外部类.this.成员变量/成员方法</li>
</ul>
<p>静态内部类</p>
<ul>
<li>访问规则：外部类名.内部类名 对象名 = new 外部类名.内部类名();</li>
<li>不可访问外部非静态资源</li>
</ul>
<h4 id="局部内部类" tabindex="-1"> 局部内部类</h4>
<p>像方法里的局部变量一样</p>
<ul>
<li>
<p>无法被访问修饰符和static修饰</p>
</li>
<li>
<p>只能访问外部的final变量和形参</p>
</li>
<li>
<p>因为局部变量使用完毕就消失，而堆内存的数据并不会立即消失。所以，堆内存还是用该变量，而该变量已经没有了。为了让该值还存在，就加final修饰。</p>
</li>
<li>
<p>通过反编译工具我们看到了，加入final后，堆内存直接存储的是值，而不是变量名。</p>
</li>
<li>
<p>在JDK8版本之中,方法内部类中调用方法中的局部变量,可以不需要修饰为 final,匿名内部类也是一样的，主要是JDK8之后增加了 Effectively final 功能</p>
</li>
</ul>
<p>局部内部类：外部类的一般方法中</p>
<p>局部静态内部类：外部类的静态方法中</p>
<h4 id="匿名内部类" tabindex="-1"> 匿名内部类</h4>
<p>局部内部类的简化形式</p>
<ul>
<li>没有构造器，没有静态资源，无法被访问修饰符和static修饰</li>
<li>对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用;</li>
<li>使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口;</li>
<li>匿名内部类中是不能定义构造函数的</li>
<li>匿名内部类中不能存在任何的静态成员变量和静态方法,匿名内部类不能是抽象的,它必须要实现继承的类或者实现的接口的所有抽象方法</li>
<li>匿名内部类初始化:使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果</li>
</ul>
<p>本质：其实是继承该类或者实现接口的子类匿名对象</p>
<h2 id="抽象类与接口" tabindex="-1"> 抽象类与接口</h2>
<p><strong>1. 抽象类</strong></p>
<p>抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。</p>
<p>抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。</p>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>AbstractClassExample</span> <span>{</span>

    <span>protected</span> <span>int</span> x<span>;</span>
    <span>private</span> <span>int</span> y<span>;</span>

    <span>public</span> <span>abstract</span> <span>void</span> <span>func1</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>void</span> <span>func2</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"func2"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>AbstractExtendClassExample</span> <span>extends</span> <span>AbstractClassExample</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>func1</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"func1"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>// AbstractClassExample ac1 = new AbstractClassExample(); // 'AbstractClassExample' is abstract; cannot be instantiated</span>
<span>AbstractClassExample</span> ac2 <span>=</span> <span>new</span> <span>AbstractExtendClassExample</span><span>(</span><span>)</span><span>;</span>
ac2<span>.</span><span>func1</span><span>(</span><span>)</span><span>;</span>
</code></pre></div><p><strong>2. 接口</strong></p>
<p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p>
<p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。</p>
<p>接口的成员(字段 + 方法)默认都是 public 的，并且不允许定义为 private 或者 protected。</p>
<p>接口的字段默认都是 static 和 final 的。</p>
<div><pre><code><span>public</span> <span>interface</span> <span>InterfaceExample</span> <span>{</span>

    <span>void</span> <span>func1</span><span>(</span><span>)</span><span>;</span>

    <span>default</span> <span>void</span> <span>func2</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"func2"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>int</span> x <span>=</span> <span>123</span><span>;</span>
    <span>// int y;               // Variable 'y' might not have been initialized</span>
    <span>public</span> <span>int</span> z <span>=</span> <span>0</span><span>;</span>       <span>// Modifier 'public' is redundant for interface fields</span>
    <span>// private int k = 0;   // Modifier 'private' not allowed here</span>
    <span>// protected int l = 0; // Modifier 'protected' not allowed here</span>
    <span>// private void fun3(); // Modifier 'private' not allowed here</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>InterfaceImplementExample</span> <span>implements</span> <span>InterfaceExample</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>func1</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"func1"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>// InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; cannot be instantiated</span>
<span>InterfaceExample</span> ie2 <span>=</span> <span>new</span> <span>InterfaceImplementExample</span><span>(</span><span>)</span><span>;</span>
ie2<span>.</span><span>func1</span><span>(</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>InterfaceExample</span><span>.</span>x<span>)</span><span>;</span>
</code></pre></div><p><strong>3. 比较</strong></p>
<ul>
<li>从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li>
<li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li>
<li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li>
<li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li>
<li>接口不能有构造方法，抽象类可以有</li>
</ul>
<p><strong>4. 使用选择</strong></p>
<p>使用接口：</p>
<ul>
<li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；</li>
<li>需要使用多重继承。</li>
</ul>
<p>使用抽象类：</p>
<ul>
<li>需要在几个相关的类中共享代码。</li>
<li>需要能控制继承来的成员的访问权限，而不是都为 public。</li>
<li>需要继承非静态和非常量字段。</li>
</ul>
<p>在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p>
<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html" target="_blank" rel="noopener noreferrer">Abstract Methods and Classes</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/l-javainterface-abstract/" target="_blank" rel="noopener noreferrer">深入理解 abstract class 和 interface</a></li>
<li><a href="https://dzone.com/articles/when-to-use-abstract-class-and-intreface" target="_blank" rel="noopener noreferrer">When to Use Abstract Class and Interface</a></li>
</ul>
<h2 id="super" tabindex="-1"> super</h2>
<ul>
<li>
<p>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super 函数。</p>
</li>
<li>
<p>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</p>
</li>
<li>
<p>this()和super()不可以同时出现在一个构造函数中，这是因为会造成初始化两次</p>
</li>
<li>
<p>super()和this()一定要放在构造方法内第一行</p>
</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>SuperExample</span> <span>{</span>

    <span>protected</span> <span>int</span> x<span>;</span>
    <span>protected</span> <span>int</span> y<span>;</span>

    <span>public</span> <span>SuperExample</span><span>(</span><span>int</span> x<span>,</span> <span>int</span> y<span>)</span> <span>{</span>
        <span>this</span><span>.</span>x <span>=</span> x<span>;</span>
        <span>this</span><span>.</span>y <span>=</span> y<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>func</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"SuperExample.func()"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>SuperExtendExample</span> <span>extends</span> <span>SuperExample</span> <span>{</span>

    <span>private</span> <span>int</span> z<span>;</span>

    <span>public</span> <span>SuperExtendExample</span><span>(</span><span>int</span> x<span>,</span> <span>int</span> y<span>,</span> <span>int</span> z<span>)</span> <span>{</span>
        <span>super</span><span>(</span>x<span>,</span> y<span>)</span><span>;</span>
        <span>this</span><span>.</span>z <span>=</span> z<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>func</span><span>(</span><span>)</span> <span>{</span>
        <span>super</span><span>.</span><span>func</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"SuperExtendExample.func()"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><pre><code><span>SuperExample</span> e <span>=</span> <span>new</span> <span>SuperExtendExample</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>
e<span>.</span><span>func</span><span>(</span><span>)</span><span>;</span>
</code></pre></div><div><pre><code>SuperExample.func()
SuperExtendExample.func()
</code></pre></div><p><a href="https://docs.oracle.com/javase/tutorial/java/IandI/super.html" target="_blank" rel="noopener noreferrer">Using the Keyword super</a></p>
<h2 id="重写与重载" tabindex="-1"> 重写与重载</h2>
<p><strong>1. 重写(Override)</strong></p>
<p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p>
<ul>
<li>参数列表必须完全与被重写方法的相同</li>
<li>声明为final的方法不能被重写。、</li>
<li>声明为static的方法不能被重写，但是能够被再次声明。</li>
<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li>
<li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。</li>
<li>构造方法不能被重写。</li>
<li>如果不能继承一个方法，则不能重写这个方法。</li>
</ul>
<p>为了满足里式替换原则，重写有以下三个限制：</p>
<ul>
<li>子类方法的访问权限必须大于等于父类方法；</li>
<li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li>
<li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li>
</ul>
<p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。</p>
<p>下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：</p>
<ul>
<li>子类方法访问权限为 public，大于父类的 protected。</li>
<li>子类的返回类型为 <code>ArrayList&lt;Integer&gt;</code>，是父类返回类型 <code>List&lt;Integer&gt;</code> 的子类。</li>
<li>子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。</li>
<li>子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。</li>
</ul>
<div><pre><code><span>class</span> <span>SuperClass</span> <span>{</span>
    <span>protected</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>func</span><span>(</span><span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>class</span> <span>SubClass</span> <span>extends</span> <span>SuperClass</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>func</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有查找到再到父类中查看，看是否有继承来的方法。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：</p>
<ul>
<li>this.func(this)</li>
<li>super.func(this)</li>
<li>this.func(super)</li>
<li>super.func(super)</li>
</ul>
<div><pre><code><span>/*
    A
    |
    B
    |
    C
    |
    D
 */</span>


<span>class</span> <span>A</span> <span>{</span>

    <span>public</span> <span>void</span> <span>show</span><span>(</span><span>A</span> obj<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"A.show(A)"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>show</span><span>(</span><span>C</span> obj<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"A.show(C)"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>class</span> <span>B</span> <span>extends</span> <span>A</span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>show</span><span>(</span><span>A</span> obj<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"B.show(A)"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>class</span> <span>C</span> <span>extends</span> <span>B</span> <span>{</span>
<span>}</span>

<span>class</span> <span>D</span> <span>extends</span> <span>C</span> <span>{</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>

    <span>A</span> a <span>=</span> <span>new</span> <span>A</span><span>(</span><span>)</span><span>;</span>
    <span>B</span> b <span>=</span> <span>new</span> <span>B</span><span>(</span><span>)</span><span>;</span>
    <span>C</span> c <span>=</span> <span>new</span> <span>C</span><span>(</span><span>)</span><span>;</span>
    <span>D</span> d <span>=</span> <span>new</span> <span>D</span><span>(</span><span>)</span><span>;</span>

    <span>// 在 A 中存在 show(A obj)，直接调用</span>
    a<span>.</span><span>show</span><span>(</span>a<span>)</span><span>;</span> <span>// A.show(A)</span>
    <span>// 在 A 中不存在 show(B obj)，将 B 转型成其父类 A</span>
    a<span>.</span><span>show</span><span>(</span>b<span>)</span><span>;</span> <span>// A.show(A)</span>
    <span>// 在 B 中存在从 A 继承来的 show(C obj)，直接调用</span>
    b<span>.</span><span>show</span><span>(</span>c<span>)</span><span>;</span> <span>// A.show(C)</span>
    <span>// 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C</span>
    b<span>.</span><span>show</span><span>(</span>d<span>)</span><span>;</span> <span>// A.show(C)</span>

    <span>// 引用的还是 B 对象，所以 ba 和 b 的调用结果一样</span>
    <span>A</span> ba <span>=</span> <span>new</span> <span>B</span><span>(</span><span>)</span><span>;</span>
    ba<span>.</span><span>show</span><span>(</span>c<span>)</span><span>;</span> <span>// A.show(C)</span>
    ba<span>.</span><span>show</span><span>(</span>d<span>)</span><span>;</span> <span>// A.show(C)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p><strong>2. 重载(Overload)</strong></p>
<p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p>
<p>应该注意的是，返回值不同，其它都相同不算是重载。</p>
<ul>
<li>被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；</li>
<li>被重载的方法可以改变返回类型；</li>
<li>被重载的方法可以改变访问修饰符；</li>
<li>被重载的方法可以声明新的或更广的检查异常；</li>
<li>方法能够在同一个类中或者在一个子类中被重载。</li>
<li>无法以返回值类型作为重载函数的区分标准。</li>
</ul>
<h1 id="五、object-通用方法" tabindex="-1"> 五、Object 通用方法</h1>
<h2 id="概览-1" tabindex="-1"> 概览</h2>
<div><pre><code>
<span>public</span> <span>native</span> <span>int</span> <span>hashCode</span><span>(</span><span>)</span>

<span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> obj<span>)</span>

<span>protected</span> <span>native</span> <span>Object</span> <span>clone</span><span>(</span><span>)</span> <span>throws</span> <span>CloneNotSupportedException</span>

<span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span>

<span>public</span> <span>final</span> <span>native</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>getClass</span><span>(</span><span>)</span>

<span>protected</span> <span>void</span> <span>finalize</span><span>(</span><span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span><span>}</span>

<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>notify</span><span>(</span><span>)</span>

<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>notifyAll</span><span>(</span><span>)</span>

<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>wait</span><span>(</span><span>long</span> timeout<span>)</span> <span>throws</span> <span>InterruptedException</span>

<span>public</span> <span>final</span> <span>void</span> <span>wait</span><span>(</span><span>long</span> timeout<span>,</span> <span>int</span> nanos<span>)</span> <span>throws</span> <span>InterruptedException</span>

<span>public</span> <span>final</span> <span>void</span> <span>wait</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id="equals" tabindex="-1"> equals()</h2>
<p><strong>1. 等价关系</strong></p>
<p>Ⅰ 自反性</p>
<div><pre><code>x<span>.</span><span>equals</span><span>(</span>x<span>)</span><span>;</span> <span>// true</span>
</code></pre></div><p>Ⅱ 对称性</p>
<div><pre><code>x<span>.</span><span>equals</span><span>(</span>y<span>)</span> <span>==</span> y<span>.</span><span>equals</span><span>(</span>x<span>)</span><span>;</span> <span>// true</span>
</code></pre></div><p>Ⅲ 传递性</p>
<div><pre><code><span>if</span> <span>(</span>x<span>.</span><span>equals</span><span>(</span>y<span>)</span> <span>&amp;&amp;</span> y<span>.</span><span>equals</span><span>(</span>z<span>)</span><span>)</span>
    x<span>.</span><span>equals</span><span>(</span>z<span>)</span><span>;</span> <span>// true;</span>
</code></pre></div><p>Ⅳ 一致性</p>
<p>多次调用 equals() 方法结果不变</p>
<div><pre><code>x<span>.</span><span>equals</span><span>(</span>y<span>)</span> <span>==</span> x<span>.</span><span>equals</span><span>(</span>y<span>)</span><span>;</span> <span>// true</span>
</code></pre></div><p>Ⅴ 与 null 的比较</p>
<p>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</p>
<div><pre><code>x<span>.</span><span>equals</span><span>(</span><span>null</span><span>)</span><span>;</span> <span>// false;</span>
</code></pre></div><p><strong>2. 等价与相等</strong></p>
<ul>
<li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li>
<li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li>
</ul>
<div><pre><code><span>Integer</span> x <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>1</span><span>)</span><span>;</span>
<span>Integer</span> y <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>1</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>x<span>.</span><span>equals</span><span>(</span>y<span>)</span><span>)</span><span>;</span> <span>// true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>x <span>==</span> y<span>)</span><span>;</span>      <span>// false</span>
</code></pre></div><p><strong>3. 实现</strong></p>
<ul>
<li>检查是否为同一个对象的引用，如果是直接返回 true；</li>
<li>检查是否是同一个类型，如果不是，直接返回 false；</li>
<li>将 Object 对象进行转型；</li>
<li>判断每个关键域是否相等。</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>EqualExample</span> <span>{</span>

    <span>private</span> <span>int</span> x<span>;</span>
    <span>private</span> <span>int</span> y<span>;</span>
    <span>private</span> <span>int</span> z<span>;</span>

    <span>public</span> <span>EqualExample</span><span>(</span><span>int</span> x<span>,</span> <span>int</span> y<span>,</span> <span>int</span> z<span>)</span> <span>{</span>
        <span>this</span><span>.</span>x <span>=</span> x<span>;</span>
        <span>this</span><span>.</span>y <span>=</span> y<span>;</span>
        <span>this</span><span>.</span>z <span>=</span> z<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>this</span> <span>==</span> o<span>)</span> <span>return</span> <span>true</span><span>;</span>
        <span>if</span> <span>(</span>o <span>==</span> <span>null</span> <span>||</span> <span>getClass</span><span>(</span><span>)</span> <span>!=</span> o<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span> <span>return</span> <span>false</span><span>;</span>

        <span>EqualExample</span> that <span>=</span> <span>(</span><span>EqualExample</span><span>)</span> o<span>;</span>

        <span>if</span> <span>(</span>x <span>!=</span> that<span>.</span>x<span>)</span> <span>return</span> <span>false</span><span>;</span>
        <span>if</span> <span>(</span>y <span>!=</span> that<span>.</span>y<span>)</span> <span>return</span> <span>false</span><span>;</span>
        <span>return</span> z <span>==</span> that<span>.</span>z<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h2 id="hashcode" tabindex="-1"> hashCode()</h2>
<p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p>
<p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</p>
<p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hashCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。</p>
<div><pre><code><span>EqualExample</span> e1 <span>=</span> <span>new</span> <span>EqualExample</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>)</span><span>;</span>
<span>EqualExample</span> e2 <span>=</span> <span>new</span> <span>EqualExample</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>e1<span>.</span><span>equals</span><span>(</span>e2<span>)</span><span>)</span><span>;</span> <span>// true</span>
<span>HashSet</span><span><span>&lt;</span><span>EqualExample</span><span>></span></span> set <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
set<span>.</span><span>add</span><span>(</span>e1<span>)</span><span>;</span>
set<span>.</span><span>add</span><span>(</span>e2<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>set<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>   <span>// 2</span>
</code></pre></div><p>理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。</p>
<p>一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p>
<div><pre><code><span>@Override</span>
<span>public</span> <span>int</span> <span>hashCode</span><span>(</span><span>)</span> <span>{</span>
    <span>int</span> result <span>=</span> <span>17</span><span>;</span>
    result <span>=</span> <span>31</span> <span>*</span> result <span>+</span> x<span>;</span>
    result <span>=</span> <span>31</span> <span>*</span> result <span>+</span> y<span>;</span>
    result <span>=</span> <span>31</span> <span>*</span> result <span>+</span> z<span>;</span>
    <span>return</span> result<span>;</span>
<span>}</span>
</code></pre></div><h2 id="tostring" tabindex="-1"> toString()</h2>
<p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p>
<div><pre><code><span>public</span> <span>class</span> <span>ToStringExample</span> <span>{</span>

    <span>private</span> <span>int</span> number<span>;</span>

    <span>public</span> <span>ToStringExample</span><span>(</span><span>int</span> number<span>)</span> <span>{</span>
        <span>this</span><span>.</span>number <span>=</span> number<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>ToStringExample</span> example <span>=</span> <span>new</span> <span>ToStringExample</span><span>(</span><span>123</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>example<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre></div><div><pre><code>ToStringExample@4554617c
</code></pre></div><h2 id="clone" tabindex="-1"> clone()</h2>
<p>clone 和 readObject 对象的初始化并不是通过构造函数完成的，而是读取别的内存区域中的对象的各个域来完成。</p>
<p><strong>1. cloneable</strong></p>
<p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p>
<div><pre><code><span>public</span> <span>class</span> <span>CloneExample</span> <span>{</span>
    <span>private</span> <span>int</span> a<span>;</span>
    <span>private</span> <span>int</span> b<span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>CloneExample</span> e1 <span>=</span> <span>new</span> <span>CloneExample</span><span>(</span><span>)</span><span>;</span>
<span>// CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object'</span>
</code></pre></div><p>重写 clone() 得到以下实现：</p>
<div><pre><code><span>public</span> <span>class</span> <span>CloneExample</span> <span>{</span>
    <span>private</span> <span>int</span> a<span>;</span>
    <span>private</span> <span>int</span> b<span>;</span>

    <span>@Override</span>
    <span>public</span> <span>CloneExample</span> <span>clone</span><span>(</span><span>)</span> <span>throws</span> <span>CloneNotSupportedException</span> <span>{</span>
        <span>return</span> <span>(</span><span>CloneExample</span><span>)</span><span>super</span><span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>CloneExample</span> e1 <span>=</span> <span>new</span> <span>CloneExample</span><span>(</span><span>)</span><span>;</span>
<span>try</span> <span>{</span>
    <span>CloneExample</span> e2 <span>=</span> e1<span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>
<span>}</span> <span>catch</span> <span>(</span><span>CloneNotSupportedException</span> e<span>)</span> <span>{</span>
    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code>java.lang.CloneNotSupportedException: CloneExample
</code></pre></div><p>以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。</p>
<p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p>
<div><pre><code><span>public</span> <span>class</span> <span>CloneExample</span> <span>implements</span> <span>Cloneable</span> <span>{</span>
    <span>private</span> <span>int</span> a<span>;</span>
    <span>private</span> <span>int</span> b<span>;</span>

    <span>@Override</span>
    <span>public</span> <span>Object</span> <span>clone</span><span>(</span><span>)</span> <span>throws</span> <span>CloneNotSupportedException</span> <span>{</span>
        <span>return</span> <span>super</span><span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><p><strong>2. 浅拷贝</strong></p>
<p>拷贝对象和原始对象的引用类型引用同一个对象。</p>
<div><pre><code><span>public</span> <span>class</span> <span>ShallowCloneExample</span> <span>implements</span> <span>Cloneable</span> <span>{</span>

    <span>private</span> <span>int</span><span>[</span><span>]</span> arr<span>;</span>

    <span>public</span> <span>ShallowCloneExample</span><span>(</span><span>)</span> <span>{</span>
        arr <span>=</span> <span>new</span> <span>int</span><span>[</span><span>10</span><span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            arr<span>[</span>i<span>]</span> <span>=</span> i<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>set</span><span>(</span><span>int</span> index<span>,</span> <span>int</span> value<span>)</span> <span>{</span>
        arr<span>[</span>index<span>]</span> <span>=</span> value<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>get</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>return</span> arr<span>[</span>index<span>]</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>protected</span> <span>ShallowCloneExample</span> <span>clone</span><span>(</span><span>)</span> <span>throws</span> <span>CloneNotSupportedException</span> <span>{</span>
        <span>return</span> <span>(</span><span>ShallowCloneExample</span><span>)</span> <span>super</span><span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><div><pre><code><span>ShallowCloneExample</span> e1 <span>=</span> <span>new</span> <span>ShallowCloneExample</span><span>(</span><span>)</span><span>;</span>
<span>ShallowCloneExample</span> e2 <span>=</span> <span>null</span><span>;</span>
<span>try</span> <span>{</span>
    e2 <span>=</span> e1<span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>
<span>}</span> <span>catch</span> <span>(</span><span>CloneNotSupportedException</span> e<span>)</span> <span>{</span>
    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
e1<span>.</span><span>set</span><span>(</span><span>2</span><span>,</span> <span>222</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>e2<span>.</span><span>get</span><span>(</span><span>2</span><span>)</span><span>)</span><span>;</span> <span>// 222</span>
</code></pre></div><p><strong>3. 深拷贝</strong></p>
<p>拷贝对象和原始对象的引用类型引用不同对象。</p>
<div><pre><code><span>public</span> <span>class</span> <span>DeepCloneExample</span> <span>implements</span> <span>Cloneable</span> <span>{</span>

    <span>private</span> <span>int</span><span>[</span><span>]</span> arr<span>;</span>

    <span>public</span> <span>DeepCloneExample</span><span>(</span><span>)</span> <span>{</span>
        arr <span>=</span> <span>new</span> <span>int</span><span>[</span><span>10</span><span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            arr<span>[</span>i<span>]</span> <span>=</span> i<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>set</span><span>(</span><span>int</span> index<span>,</span> <span>int</span> value<span>)</span> <span>{</span>
        arr<span>[</span>index<span>]</span> <span>=</span> value<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>get</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>return</span> arr<span>[</span>index<span>]</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>protected</span> <span>DeepCloneExample</span> <span>clone</span><span>(</span><span>)</span> <span>throws</span> <span>CloneNotSupportedException</span> <span>{</span>
        <span>DeepCloneExample</span> result <span>=</span> <span>(</span><span>DeepCloneExample</span><span>)</span> <span>super</span><span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>
        result<span>.</span>arr <span>=</span> <span>new</span> <span>int</span><span>[</span>arr<span>.</span>length<span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            result<span>.</span>arr<span>[</span>i<span>]</span> <span>=</span> arr<span>[</span>i<span>]</span><span>;</span>
        <span>}</span>
        <span>return</span> result<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><div><pre><code><span>DeepCloneExample</span> e1 <span>=</span> <span>new</span> <span>DeepCloneExample</span><span>(</span><span>)</span><span>;</span>
<span>DeepCloneExample</span> e2 <span>=</span> <span>null</span><span>;</span>
<span>try</span> <span>{</span>
    e2 <span>=</span> e1<span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>
<span>}</span> <span>catch</span> <span>(</span><span>CloneNotSupportedException</span> e<span>)</span> <span>{</span>
    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
e1<span>.</span><span>set</span><span>(</span><span>2</span><span>,</span> <span>222</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>e2<span>.</span><span>get</span><span>(</span><span>2</span><span>)</span><span>)</span><span>;</span> <span>// 2</span>
</code></pre></div><p><strong>4. clone() 的替代方案</strong></p>
<p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p>
<div><pre><code><span>public</span> <span>class</span> <span>CloneConstructorExample</span> <span>{</span>

    <span>private</span> <span>int</span><span>[</span><span>]</span> arr<span>;</span>

    <span>public</span> <span>CloneConstructorExample</span><span>(</span><span>)</span> <span>{</span>
        arr <span>=</span> <span>new</span> <span>int</span><span>[</span><span>10</span><span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            arr<span>[</span>i<span>]</span> <span>=</span> i<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>CloneConstructorExample</span><span>(</span><span>CloneConstructorExample</span> original<span>)</span> <span>{</span>
        arr <span>=</span> <span>new</span> <span>int</span><span>[</span>original<span>.</span>arr<span>.</span>length<span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> original<span>.</span>arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            arr<span>[</span>i<span>]</span> <span>=</span> original<span>.</span>arr<span>[</span>i<span>]</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>set</span><span>(</span><span>int</span> index<span>,</span> <span>int</span> value<span>)</span> <span>{</span>
        arr<span>[</span>index<span>]</span> <span>=</span> value<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>get</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>return</span> arr<span>[</span>index<span>]</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><div><pre><code><span>CloneConstructorExample</span> e1 <span>=</span> <span>new</span> <span>CloneConstructorExample</span><span>(</span><span>)</span><span>;</span>
<span>CloneConstructorExample</span> e2 <span>=</span> <span>new</span> <span>CloneConstructorExample</span><span>(</span>e1<span>)</span><span>;</span>
e1<span>.</span><span>set</span><span>(</span><span>2</span><span>,</span> <span>222</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>e2<span>.</span><span>get</span><span>(</span><span>2</span><span>)</span><span>)</span><span>;</span> <span>// 2</span>
</code></pre></div><h1 id="六、关键字" tabindex="-1"> 六、关键字</h1>
<p>true、false、null都不是关键字</p>
<p>goto、const、是保留的关键字</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>abstract</td>
<td>continue</td>
<td>for</td>
<td>new</td>
</tr>
<tr>
<td>switch</td>
<td>default</td>
<td>if</td>
<td>package</td>
</tr>
<tr>
<td>synchronized</td>
<td>do</td>
<td>goto</td>
<td>private</td>
</tr>
<tr>
<td>this</td>
<td>break</td>
<td>double</td>
<td>implements</td>
</tr>
<tr>
<td>protected</td>
<td>throw</td>
<td>byte</td>
<td>else</td>
</tr>
<tr>
<td>import</td>
<td>public</td>
<td>throws</td>
<td>case</td>
</tr>
<tr>
<td>enum</td>
<td>instanceof</td>
<td>return</td>
<td>transient</td>
</tr>
<tr>
<td>catch</td>
<td>extends</td>
<td>int</td>
<td>short</td>
</tr>
<tr>
<td>try</td>
<td>char</td>
<td>final</td>
<td>interface</td>
</tr>
<tr>
<td>static</td>
<td>void</td>
<td>class</td>
<td>finally</td>
</tr>
<tr>
<td>long</td>
<td>strictfp</td>
<td>volatile</td>
<td>const</td>
</tr>
<tr>
<td>float</td>
<td>native</td>
<td>super</td>
<td>while</td>
</tr>
<tr>
<td>boolean</td>
<td>assert</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="final" tabindex="-1"> final</h2>
<p><strong>1. 数据</strong></p>
<p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p>
<ul>
<li>对于基本类型，final 使数值不变；</li>
<li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li>
</ul>
<p>final变量的初始化(可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量)</p>
<ul>
<li>final所修饰的成员变量只能赋值一次
<ul>
<li>在声明的时候直接赋值</li>
<li>静态初始化块中赋值</li>
<li>构造块中赋值，构造器中赋值</li>
<li>在类方法中赋值</li>
</ul>
</li>
<li>final修饰的局部变量
<ul>
<li>在声明的时候初始化</li>
<li>在第一次使用的通过方法或者表达式给它赋值。</li>
</ul>
</li>
</ul>
<div><pre><code><span>final</span> <span>int</span> x <span>=</span> <span>1</span><span>;</span>
<span>// x = 2;  // cannot assign value to final variable 'x'</span>
<span>final</span> <span>A</span> y <span>=</span> <span>new</span> <span>A</span><span>(</span><span>)</span><span>;</span>
y<span>.</span>a <span>=</span> <span>1</span><span>;</span>
</code></pre></div><p><strong>2. 方法</strong></p>
<p>声明方法不能被子类重写。</p>
<p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p>
<p><strong>3. 类</strong></p>
<p>声明类不允许被继承。</p>
<h2 id="static" tabindex="-1"> static</h2>
<p><strong>1. 静态变量</strong></p>
<ul>
<li>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</li>
<li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li>
</ul>
<p>Java在序列化时不会实例化static变量和transient修饰的变量，因为static代表类的成员，transient代表对象的临时数据，被声明这两种类型的数据成员不能被序列化</p>
<div><pre><code><span>public</span> <span>class</span> <span>A</span> <span>{</span>

    <span>private</span> <span>int</span> x<span>;</span>         <span>// 实例变量</span>
    <span>private</span> <span>static</span> <span>int</span> y<span>;</span>  <span>// 静态变量</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// int x = A.x;  // Non-static field 'x' cannot be referenced from a static context</span>
        <span>A</span> a <span>=</span> <span>new</span> <span>A</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> x <span>=</span> a<span>.</span>x<span>;</span>
        <span>int</span> y <span>=</span> <span>A</span><span>.</span>y<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>2. 静态方法</strong></p>
<p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>A</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>func1</span><span>(</span><span>)</span><span>{</span>
    <span>}</span>
    <span>// public abstract static void func2();  // Illegal combination of modifiers: 'abstract' and 'static'</span>
<span>}</span>
</code></pre></div><p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。</p>
<div><pre><code><span>public</span> <span>class</span> <span>A</span> <span>{</span>

    <span>private</span> <span>static</span> <span>int</span> x<span>;</span>
    <span>private</span> <span>int</span> y<span>;</span>

    <span>public</span> <span>static</span> <span>void</span> <span>func1</span><span>(</span><span>)</span><span>{</span>
        <span>int</span> a <span>=</span> x<span>;</span>
        <span>// int b = y;  // Non-static field 'y' cannot be referenced from a static context</span>
        <span>// int b = this.y;     // 'A.this' cannot be referenced from a static context</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>3. 静态语句块</strong></p>
<p>静态语句块在类初始化时运行一次。</p>
<div><pre><code><span>public</span> <span>class</span> <span>A</span> <span>{</span>
    <span>static</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"123"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>A</span> a1 <span>=</span> <span>new</span> <span>A</span><span>(</span><span>)</span><span>;</span>
        <span>A</span> a2 <span>=</span> <span>new</span> <span>A</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code>123
</code></pre></div><p><strong>4. 静态内部类</strong></p>
<p>非静态内部类依赖于外部类的实例，而静态内部类不需要。</p>
<div><pre><code><span>public</span> <span>class</span> <span>OuterClass</span> <span>{</span>

    <span>class</span> <span>InnerClass</span> <span>{</span>
    <span>}</span>

    <span>static</span> <span>class</span> <span>StaticInnerClass</span> <span>{</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context</span>
        <span>OuterClass</span> outerClass <span>=</span> <span>new</span> <span>OuterClass</span><span>(</span><span>)</span><span>;</span>
        <span>InnerClass</span> innerClass <span>=</span> outerClass<span>.</span><span>new</span> <span>InnerClass</span><span>(</span><span>)</span><span>;</span>
        <span>StaticInnerClass</span> staticInnerClass <span>=</span> <span>new</span> <span>StaticInnerClass</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>静态内部类不能访问外部类的非静态的变量和方法。</p>
<p><strong>5. 静态导包</strong></p>
<p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p>
<div><pre><code><span>import</span> <span>static</span> <span>com<span>.</span>xxx<span>.</span></span><span>ClassName</span><span>.</span>*
</code></pre></div><p><strong>6. 初始化顺序</strong></p>
<p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p>
<div><pre><code><span>public</span> <span>static</span> <span>String</span> staticField <span>=</span> <span>"静态变量"</span><span>;</span>
</code></pre></div><div><pre><code><span>static</span> <span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"静态语句块"</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>String</span> field <span>=</span> <span>"实例变量"</span><span>;</span>
</code></pre></div><div><pre><code><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"普通语句块"</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><p>最后才是构造函数的初始化。</p>
<div><pre><code><span>public</span> <span>InitialOrderTest</span><span>(</span><span>)</span> <span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"构造函数"</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><p>存在继承的情况下，初始化顺序为：</p>
<ul>
<li>父类(静态变量、静态语句块)</li>
<li>子类(静态变量、静态语句块)</li>
<li>父类(实例变量、普通语句块)</li>
<li>父类(构造函数)</li>
<li>子类(实例变量、普通语句块)</li>
<li>子类(构造函数)</li>
</ul>
<h1 id="七、反射" tabindex="-1"> 七、反射</h1>
<p>每个类都有一个  <strong>Class</strong>  对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p>
<p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p>
<p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p>
<p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p>
<ul>
<li><strong>Field</strong> ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li>
<li><strong>Method</strong> ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li>
<li><strong>Constructor</strong> ：可以用 Constructor 的 newInstance() 创建新的对象。</li>
</ul>
<p><strong>反射的优点：</strong></p>
<ul>
<li><strong>可扩展性</strong>  ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</li>
<li><strong>类浏览器和可视化开发环境</strong>  ：一个类浏览器需要可以枚举类的成员。可视化开发环境(如 IDE)可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</li>
<li><strong>调试器和测试工具</strong>  ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</li>
</ul>
<p><strong>反射的缺点：</strong></p>
<p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p>
<ul>
<li>
<p><strong>性能开销</strong>  ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</p>
</li>
<li>
<p><strong>安全限制</strong>  ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</p>
</li>
<li>
<p><strong>内部暴露</strong>  ：由于反射允许代码执行一些在正常情况下不被允许的操作(比如访问私有的属性和方法)，所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</p>
</li>
</ul>
<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener noreferrer">Trail: The Reflection API</a></li>
<li><a href="http://www.sczyh30.com/posts/Java/java-reflection-1/" target="_blank" rel="noopener noreferrer">深入解析 Java 反射(1)- 基础</a></li>
</ul>
<h1 id="八、异常" tabindex="-1"> 八、异常</h1>
<p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： <strong>Error</strong>  和 <strong>Exception</strong>。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：</p>
<ul>
<li><strong>受检异常</strong> ：需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；</li>
<li><strong>非受检异常</strong> ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/PPjwP.png" width="600"/> </div><br>
<p>Throwable类常用方法</p>
<ul>
<li>public string getMessage():返回异常发生时的简要描述</li>
<li>public string toString():返回异常发生时的详细信息</li>
<li>public string getLocalizedMessage():返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同</li>
<li>public void printStackTrace():在控制台上打印Throwable对象封装的异常信息</li>
</ul>
<p>异常处理</p>
<ul>
<li>try 块： 用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。</li>
<li>catch 块： 用于处理try捕获到的异常。
<ul>
<li>一个 try 块可能有多个 catch 块。若如此，则执行第一个匹配块。即Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个catch代码块，不会再执行其他的 catch代码块</li>
</ul>
</li>
<li>finally 块： 无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return 语句时，finally语句块将在方法返回之前(已暂存返回值)被执行。</li>
</ul>
<p>在以下4种特殊情况下，finally块不会被执行：</p>
<ul>
<li>
<p>在finally语句块第一行发生了异常。 因为在其他行，finally块还是会得到执行</p>
</li>
<li>
<p>在前面的代码中用了System.exit(int)已退出程序。 exit是带参函数 ；若该语句在异常语句之后，finally会执行</p>
</li>
<li>
<p>程序所在的线程死亡。</p>
</li>
<li>
<p>关闭CPU。</p>
</li>
<li>
<p><a href="https://www.tianmaying.com/tutorial/Java-Exception" target="_blank" rel="noopener noreferrer">Java 入门之异常处理</a></p>
</li>
<li>
<p><a href="http://www.importnew.com/7383.html" target="_blank" rel="noopener noreferrer">Java 异常的面试问题及答案 -Part 1</a></p>
</li>
</ul>
<h1 id="九、泛型" tabindex="-1"> 九、泛型</h1>
<p>泛型只是在 编译期 保证对象类型相同的技术。真正在代码的运行期，jvm会擦出泛型的存在。</p>
<p>所以我们可以利用反射技术为一个已指定泛型的集合添加一个不符合泛型要求的元素，因为反射的生效期在运行期，泛型无法进行拦截。</p>
<p>因此，泛型指定的元素不具有继承的特性。不能将泛型中的派生类类型复制给基类类型。从而出现了通配符的技术，为了解决在泛型中不能像正常JAVA类中的继承关系。个人的理解是通配符的继承就是为了弥补泛型在继承关系上面的缺陷而诞生的。因此集合可以使用通配符来描述继承关系，但不能直接使用指定泛型来描述。通配符的方式可以正确的描述带泛型集合的继承关系。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Box</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>
    <span>// T stands for "Type"</span>
    <span>private</span> <span>T</span> t<span>;</span>
    <span>public</span> <span>void</span> <span>set</span><span>(</span><span>T</span> t<span>)</span> <span>{</span> <span>this</span><span>.</span>t <span>=</span> t<span>;</span> <span>}</span>
    <span>public</span> <span>T</span> <span>get</span><span>(</span><span>)</span> <span>{</span> <span>return</span> t<span>;</span> <span>}</span>
<span>}</span>
</code></pre></div><ul>
<li><a href="http://www.importnew.com/24029.html" target="_blank" rel="noopener noreferrer">Java 泛型详解</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1033693" target="_blank" rel="noopener noreferrer">10 道 Java 泛型面试题</a></li>
</ul>
<h1 id="十、注解" tabindex="-1"> 十、注解</h1>
<p>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</p>
<p><a href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html" target="_blank" rel="noopener noreferrer">注解 Annotation 实现原理与自定义注解例子</a></p>
<h1 id="十一、特性" tabindex="-1"> 十一、特性</h1>
<h2 id="java-各版本的新特性" tabindex="-1"> Java 各版本的新特性</h2>
<p><strong>New highlights in Java SE 8</strong></p>
<ol>
<li>Lambda Expressions</li>
<li>Pipelines and Streams</li>
<li>Date and Time API</li>
<li>Default Methods</li>
<li>Type Annotations</li>
<li>Nashhorn JavaScript Engine</li>
<li>Concurrent Accumulators</li>
<li>Parallel operations</li>
<li>PermGen Error Removed</li>
</ol>
<p><strong>New highlights in Java SE 7</strong></p>
<ol>
<li>Strings in Switch Statement</li>
<li>Type Inference for Generic Instance Creation</li>
<li>Multiple Exception Handling</li>
<li>Support for Dynamic Languages</li>
<li>Try with Resources</li>
<li>Java nio Package</li>
<li>Binary Literals, Underscore in literals</li>
<li>Diamond Syntax</li>
</ol>
<ul>
<li><a href="http://www.selfgrowth.com/articles/difference-between-java-18-and-java-17" target="_blank" rel="noopener noreferrer">Difference between Java 1.8 and Java 1.7?</a></li>
</ul>
<h2 id="java-与-c-的区别" tabindex="-1"> Java 与 C++ 的区别</h2>
<ul>
<li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li>
<li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li>
<li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li>
<li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li>
<li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li>
<li>Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li>
<li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li>
<li>Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。</li>
</ul>
<p><a href="http://cs-fundamentals.com/tech-interview/java/differences-between-java-and-cpp.php" target="_blank" rel="noopener noreferrer">What are the main differences between Java and C++?</a></p>
<h2 id="jre-or-jdk" tabindex="-1"> JRE or JDK</h2>
<ul>
<li>JRE is the JVM program, Java application need to run on JRE.</li>
<li>JDK is a superset of JRE, JRE + tools for developing java programs. e.g, it provides the compiler &quot;javac&quot;</li>
</ul>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li>Eckel B. Java 编程思想[M]. 机械工业出版社, 2002.</li>
<li>Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java容器</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/Java%E5%AE%B9%E5%99%A8.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/Java%E5%AE%B9%E5%99%A8.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">Java容器</source>
      <category>Java</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>

<h1 id="一、概览" tabindex="-1"> 一、概览</h1>
<p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表。</p>
<p><img src="@source/assets/cs-note/java-collection/java-collection-framwork.png" alt="" loading="lazy"></p>
<h2 id="collection" tabindex="-1"> Collection</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/73403d84-d921-49f1-93a9-d8fe050f3497.png" width="800px"> </div><br>
<h3 id="_1-set" tabindex="-1"> 1. Set</h3>
<ul>
<li>
<p>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</p>
</li>
<li>
<p>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</p>
</li>
<li>
<p>LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</p>
</li>
</ul>
<h3 id="_2-list" tabindex="-1"> 2. List</h3>
<ul>
<li>
<p>ArrayList：基于动态数组实现，支持随机访问。</p>
</li>
<li>
<p>Vector：和 ArrayList 类似，但它是线程安全的。</p>
</li>
<li>
<p>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</p>
</li>
</ul>
<h3 id="_3-queue" tabindex="-1"> 3. Queue</h3>
<ul>
<li>
<p>LinkedList：可以用它来实现双向队列。</p>
</li>
<li>
<p>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</p>
</li>
</ul>
<h2 id="map" tabindex="-1"> Map</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/774d756b-902a-41a3-a3fd-81ca3ef688dc.png" width="500px"> </div><br>
<ul>
<li>
<p>TreeMap：基于红黑树实现。</p>
</li>
<li>
<p>HashMap：基于哈希表实现。</p>
</li>
<li>
<p>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</p>
</li>
<li>
<p>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。</p>
</li>
</ul>
<h1 id="二、容器中的设计模式" tabindex="-1"> 二、容器中的设计模式</h1>
<h2 id="迭代器模式" tabindex="-1"> 迭代器模式</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/93fb1d38-83f9-464a-a733-67b2e6bfddda.png" width="600px"> </div><br>
<p>Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p>
<p>从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
list<span>.</span><span>add</span><span>(</span><span>"a"</span><span>)</span><span>;</span>
list<span>.</span><span>add</span><span>(</span><span>"b"</span><span>)</span><span>;</span>
<span>for</span> <span>(</span><span>String</span> item <span>:</span> list<span>)</span> <span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>item<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h2 id="适配器模式" tabindex="-1"> 适配器模式</h2>
<p>java.util.Arrays.asList() 可以把数组类型转换为 List 类型。</p>
<div><pre><code><span>@SafeVarargs</span>
<span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>List</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>asList</span><span>(</span><span>T</span><span>.</span><span>.</span><span>.</span> a<span>)</span>
</code></pre></div><p>应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p>
<div><pre><code><span>Integer</span><span>[</span><span>]</span> arr <span>=</span> <span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>}</span><span>;</span>
<span>List</span> list <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span>arr<span>)</span><span>;</span>
</code></pre></div><p>也可以使用以下方式调用 asList()：</p>
<div><pre><code><span>List</span> list <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>
</code></pre></div><h1 id="三、源码分析" tabindex="-1"> 三、源码分析</h1>
<p>如果没有特别说明，以下源码分析基于 JDK 1.8。</p>
<h2 id="arraylist" tabindex="-1"> ArrayList</h2>
<h3 id="_1-概览" tabindex="-1"> 1. 概览</h3>
<p>因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。</p>
<div><pre><code><span>public</span> <span>class</span> <span>ArrayList</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>AbstractList</span><span><span>&lt;</span><span>E</span><span>></span></span>
        <span>implements</span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span><span>,</span> <span>RandomAccess</span><span>,</span> <span>Cloneable</span><span>,</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span>
</code></pre></div><p>数组的默认大小为 10。</p>
<div><pre><code><span>private</span> <span>static</span> <span>final</span> <span>int</span> DEFAULT_CAPACITY <span>=</span> <span>10</span><span>;</span>
</code></pre></div><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/52a7744f-5bce-4ff3-a6f0-8449334d9f3d.png" width="400px"> </div><br>
<h3 id="_2-初始化" tabindex="-1"> 2. 初始化</h3>
<p>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。</p>
<div><pre><code>    <span>private</span> <span>static</span> <span>final</span> <span>int</span> DEFAULT_CAPACITY <span>=</span> <span>10</span><span>;</span>
    <span>private</span> <span>static</span> <span>final</span> <span>Object</span><span>[</span><span>]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span>=</span> <span>{</span><span>}</span><span>;</span>

    <span>public</span> <span>ArrayList</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>initialCapacity <span>></span> <span>0</span><span>)</span> <span>{</span>
            <span>this</span><span>.</span>elementData <span>=</span> <span>new</span> <span>Object</span><span>[</span>initialCapacity<span>]</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>initialCapacity <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>this</span><span>.</span>elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>"Illegal Capacity: "</span><span>+</span>
                                               initialCapacity<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>ArrayList</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>elementData <span>=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>;</span>
    <span>}</span>

    <span>public</span> <span>ArrayList</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>
        elementData <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span><span>(</span>size <span>=</span> elementData<span>.</span>length<span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
            <span>// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>
            <span>if</span> <span>(</span>elementData<span>.</span><span>getClass</span><span>(</span><span>)</span> <span>!=</span> <span>Object</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span>
                elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>,</span> <span>Object</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>// replace with empty array.</span>
            <span>this</span><span>.</span>elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>
        <span>}</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id="_3-扩容" tabindex="-1"> 3. 扩容</h3>
<p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。</p>
<p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p>
<div><pre><code>    <span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>
        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  <span>// Increments modCount!!</span>
        elementData<span>[</span>size<span>++</span><span>]</span> <span>=</span> e<span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>//得到最小扩容量</span>
    <span>private</span> <span>void</span> <span>ensureCapacityInternal</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>elementData <span>==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>)</span> <span>{</span>
            <span>// 获取默认初始容量大小和传入参数的较大值</span>
            minCapacity <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>DEFAULT_CAPACITY<span>,</span> minCapacity<span>)</span><span>;</span>
        <span>}</span>
        <span>ensureExplicitCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>
    <span>}</span>
    <span>//判断是否需要扩容</span>
    <span>private</span> <span>void</span> <span>ensureExplicitCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
        modCount<span>++</span><span>;</span>
        <span>// overflow-conscious code</span>
        <span>if</span> <span>(</span>minCapacity <span>-</span> elementData<span>.</span>length <span>></span> <span>0</span><span>)</span>
            <span>grow</span><span>(</span>minCapacity<span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>static</span> <span>final</span> <span>int</span> MAX_ARRAY_SIZE <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE <span>-</span> <span>8</span><span>;</span>

    <span>//ArrayList扩容的核心方法</span>
    <span>private</span> <span>void</span> <span>grow</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
        <span>// overflow-conscious code</span>
        <span>int</span> oldCapacity <span>=</span> elementData<span>.</span>length<span>;</span>
        <span>int</span> newCapacity <span>=</span> oldCapacity <span>+</span> <span>(</span>oldCapacity <span>>></span> <span>1</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>newCapacity <span>-</span> minCapacity <span>&lt;</span> <span>0</span><span>)</span>
            newCapacity <span>=</span> minCapacity<span>;</span>
        <span>if</span> <span>(</span>newCapacity <span>-</span> MAX_ARRAY_SIZE <span>></span> <span>0</span><span>)</span>
            newCapacity <span>=</span> <span>hugeCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>
        <span>// minCapacity is usually close to size, so this is a win:</span>
        elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> newCapacity<span>)</span><span>;</span>
    <span>}</span>
    <span>private</span> <span>static</span> <span>int</span> <span>hugeCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>minCapacity <span>&lt;</span> <span>0</span><span>)</span> <span>// overflow</span>
            <span>throw</span> <span>new</span> <span>OutOfMemoryError</span><span>(</span><span>)</span><span>;</span>
        <span>//对minCapacity和MAX_ARRAY_SIZE进行比较</span>
        <span>//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span>
        <span>//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span>
        <span>//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span>
        <span>return</span> <span>(</span>minCapacity <span>></span> MAX_ARRAY_SIZE<span>)</span> <span>?</span>
            <span>Integer</span><span>.</span>MAX_VALUE <span>:</span>
            MAX_ARRAY_SIZE<span>;</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>最好在 add 大量元素之前用 ensureCapacity 方法，以减少增量重新分配的次数</p>
<p>如果新容量大于 MAX_ARRAY_SIZE,进入(执行) hugeCapacity() 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果minCapacity大于最大容量，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 Integer.MAX_VALUE - 8。</p>
<p><strong>System.arraycopy()和Arrays.copyOf()方法</strong></p>
<p>这两个实现数组复制的方法被广泛使用而且很多地方都特别巧妙</p>
<p>联系： 从两者源代码可以发现copyOf()内部调用了System.arraycopy()方法</p>
<p>区别：</p>
<ol>
<li>arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置</li>
<li>copyOf()是系统自动在内部新建一个数组，并返回该数组。</li>
</ol>
<h3 id="_4-删除元素" tabindex="-1"> 4. 删除元素</h3>
<p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看出 ArrayList 删除元素的代价是非常高的。</p>
<div><pre><code><span>public</span> <span>E</span> <span>remove</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
    <span>rangeCheck</span><span>(</span>index<span>)</span><span>;</span>
    modCount<span>++</span><span>;</span>
    <span>E</span> oldValue <span>=</span> <span>elementData</span><span>(</span>index<span>)</span><span>;</span>
    <span>int</span> numMoved <span>=</span> size <span>-</span> index <span>-</span> <span>1</span><span>;</span>
    <span>if</span> <span>(</span>numMoved <span>></span> <span>0</span><span>)</span>
        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>+</span><span>1</span><span>,</span> elementData<span>,</span> index<span>,</span> numMoved<span>)</span><span>;</span>
    elementData<span>[</span><span>--</span>size<span>]</span> <span>=</span> <span>null</span><span>;</span> <span>// clear to let GC do its work</span>
    <span>return</span> oldValue<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="_5-fail-fast" tabindex="-1"> 5. Fail-Fast</h3>
<p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p>
<p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。</p>
<div><pre><code><span>private</span> <span>void</span> <span>writeObject</span><span>(</span><span><span>java<span>.</span>io<span>.</span></span>ObjectOutputStream</span> s<span>)</span>
    <span>throws</span> <span><span>java<span>.</span>io<span>.</span></span>IOException</span><span>{</span>
    <span>// Write out element count, and any hidden stuff</span>
    <span>int</span> expectedModCount <span>=</span> modCount<span>;</span>
    s<span>.</span><span>defaultWriteObject</span><span>(</span><span>)</span><span>;</span>

    <span>// Write out size as capacity for behavioural compatibility with clone()</span>
    s<span>.</span><span>writeInt</span><span>(</span>size<span>)</span><span>;</span>

    <span>// Write out all elements in the proper order.</span>
    <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span> i<span>&lt;</span>size<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        s<span>.</span><span>writeObject</span><span>(</span>elementData<span>[</span>i<span>]</span><span>)</span><span>;</span>
    <span>}</span>

    <span>if</span> <span>(</span>modCount <span>!=</span> expectedModCount<span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>ConcurrentModificationException</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="_6-序列化" tabindex="-1"> 6. 序列化</h3>
<p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。</p>
<p>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。</p>
<div><pre><code><span>transient</span> <span>Object</span><span>[</span><span>]</span> elementData<span>;</span> <span>// non-private to simplify nested class access</span>
</code></pre></div><p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。</p>
<div><pre><code><span>private</span> <span>void</span> <span>readObject</span><span>(</span><span><span>java<span>.</span>io<span>.</span></span>ObjectInputStream</span> s<span>)</span>
    <span>throws</span> <span><span>java<span>.</span>io<span>.</span></span>IOException</span><span>,</span> <span>ClassNotFoundException</span> <span>{</span>
    elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>

    <span>// Read in size, and any hidden stuff</span>
    s<span>.</span><span>defaultReadObject</span><span>(</span><span>)</span><span>;</span>

    <span>// Read in capacity</span>
    s<span>.</span><span>readInt</span><span>(</span><span>)</span><span>;</span> <span>// ignored</span>

    <span>if</span> <span>(</span>size <span>></span> <span>0</span><span>)</span> <span>{</span>
        <span>// be like clone(), allocate array based upon size not capacity</span>
        <span>ensureCapacityInternal</span><span>(</span>size<span>)</span><span>;</span>

        <span>Object</span><span>[</span><span>]</span> a <span>=</span> elementData<span>;</span>
        <span>// Read in all elements in the proper order.</span>
        <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span> i<span>&lt;</span>size<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            a<span>[</span>i<span>]</span> <span>=</span> s<span>.</span><span>readObject</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><div><pre><code><span>private</span> <span>void</span> <span>writeObject</span><span>(</span><span><span>java<span>.</span>io<span>.</span></span>ObjectOutputStream</span> s<span>)</span>
    <span>throws</span> <span><span>java<span>.</span>io<span>.</span></span>IOException</span><span>{</span>
    <span>// Write out element count, and any hidden stuff</span>
    <span>int</span> expectedModCount <span>=</span> modCount<span>;</span>
    s<span>.</span><span>defaultWriteObject</span><span>(</span><span>)</span><span>;</span>

    <span>// Write out size as capacity for behavioural compatibility with clone()</span>
    s<span>.</span><span>writeInt</span><span>(</span>size<span>)</span><span>;</span>

    <span>// Write out all elements in the proper order.</span>
    <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span> i<span>&lt;</span>size<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        s<span>.</span><span>writeObject</span><span>(</span>elementData<span>[</span>i<span>]</span><span>)</span><span>;</span>
    <span>}</span>

    <span>if</span> <span>(</span>modCount <span>!=</span> expectedModCount<span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>ConcurrentModificationException</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。</p>
<div><pre><code><span>ArrayList</span> list <span>=</span> <span>new</span> <span>ArrayList</span><span>(</span><span>)</span><span>;</span>
<span>ObjectOutputStream</span> oos <span>=</span> <span>new</span> <span>ObjectOutputStream</span><span>(</span><span>new</span> <span>FileOutputStream</span><span>(</span>file<span>)</span><span>)</span><span>;</span>
oos<span>.</span><span>writeObject</span><span>(</span>list<span>)</span><span>;</span>
</code></pre></div><h2 id="vector" tabindex="-1"> Vector</h2>
<h3 id="_1-同步" tabindex="-1"> 1. 同步</h3>
<p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行方法同步。</p>
<div><pre><code><span>public</span> <span>synchronized</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>
    modCount<span>++</span><span>;</span>
    <span>ensureCapacityHelper</span><span>(</span>elementCount <span>+</span> <span>1</span><span>)</span><span>;</span>
    elementData<span>[</span>elementCount<span>++</span><span>]</span> <span>=</span> e<span>;</span>
    <span>return</span> <span>true</span><span>;</span>
<span>}</span>

<span>public</span> <span>synchronized</span> <span>E</span> <span>get</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>index <span>>=</span> elementCount<span>)</span>
        <span>throw</span> <span>new</span> <span>ArrayIndexOutOfBoundsException</span><span>(</span>index<span>)</span><span>;</span>

    <span>return</span> <span>elementData</span><span>(</span>index<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="_2-扩容" tabindex="-1"> 2. 扩容</h3>
<p>Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。</p>
<div><pre><code><span>public</span> <span>Vector</span><span>(</span><span>int</span> initialCapacity<span>,</span> <span>int</span> capacityIncrement<span>)</span> <span>{</span>
    <span>super</span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>initialCapacity <span>&lt;</span> <span>0</span><span>)</span>
        <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>"Illegal Capacity: "</span><span>+</span>
                                           initialCapacity<span>)</span><span>;</span>
    <span>this</span><span>.</span>elementData <span>=</span> <span>new</span> <span>Object</span><span>[</span>initialCapacity<span>]</span><span>;</span>
    <span>this</span><span>.</span>capacityIncrement <span>=</span> capacityIncrement<span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>private</span> <span>void</span> <span>grow</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
    <span>// overflow-conscious code</span>
    <span>int</span> oldCapacity <span>=</span> elementData<span>.</span>length<span>;</span>
    <span>int</span> newCapacity <span>=</span> oldCapacity <span>+</span> <span>(</span><span>(</span>capacityIncrement <span>></span> <span>0</span><span>)</span> <span>?</span>
                                     capacityIncrement <span>:</span> oldCapacity<span>)</span><span>;</span>
    <span>if</span> <span>(</span>newCapacity <span>-</span> minCapacity <span>&lt;</span> <span>0</span><span>)</span>
        newCapacity <span>=</span> minCapacity<span>;</span>
    <span>if</span> <span>(</span>newCapacity <span>-</span> MAX_ARRAY_SIZE <span>></span> <span>0</span><span>)</span>
        newCapacity <span>=</span> <span>hugeCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>
    elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> newCapacity<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0，也就是说默认情况下 Vector 每次扩容时容量都会翻倍。</p>
<div><pre><code><span>public</span> <span>Vector</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>
    <span>this</span><span>(</span>initialCapacity<span>,</span> <span>0</span><span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>Vector</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span><span>(</span><span>10</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h3 id="_3-与-arraylist-的比较" tabindex="-1"> 3. 与 ArrayList 的比较</h3>
<ul>
<li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li>
<li>Vector 每次扩容请求其大小的 2 倍(也可以通过构造函数设置增长的容量)，而 ArrayList 是 1.5 倍。</li>
</ul>
<h3 id="_4-替代方案" tabindex="-1"> 4. 替代方案</h3>
<p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> synList <span>=</span> <span>Collections</span><span>.</span><span>synchronizedList</span><span>(</span>list<span>)</span><span>;</span>
</code></pre></div><p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>CopyOnWriteArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
</code></pre></div><h2 id="copyonwritearraylist" tabindex="-1"> CopyOnWriteArrayList</h2>
<h3 id="读写分离" tabindex="-1"> 读写分离</h3>
<p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p>
<p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p>
<p>写操作结束之后需要把原始数组指向新的复制数组。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>
    <span>final</span> <span>ReentrantLock</span> lock <span>=</span> <span>this</span><span>.</span>lock<span>;</span>
    lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>
    <span>try</span> <span>{</span>
        <span>Object</span><span>[</span><span>]</span> elements <span>=</span> <span>getArray</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> len <span>=</span> elements<span>.</span>length<span>;</span>
        <span>Object</span><span>[</span><span>]</span> newElements <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elements<span>,</span> len <span>+</span> <span>1</span><span>)</span><span>;</span>
        newElements<span>[</span>len<span>]</span> <span>=</span> e<span>;</span>
        <span>setArray</span><span>(</span>newElements<span>)</span><span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span> <span>finally</span> <span>{</span>
        lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>final</span> <span>void</span> <span>setArray</span><span>(</span><span>Object</span><span>[</span><span>]</span> a<span>)</span> <span>{</span>
    array <span>=</span> a<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><div><pre><code><span>@SuppressWarnings</span><span>(</span><span>"unchecked"</span><span>)</span>
<span>private</span> <span>E</span> <span>get</span><span>(</span><span>Object</span><span>[</span><span>]</span> a<span>,</span> <span>int</span> index<span>)</span> <span>{</span>
    <span>return</span> <span>(</span><span>E</span><span>)</span> a<span>[</span>index<span>]</span><span>;</span>
<span>}</span>
</code></pre></div><h3 id="适用场景" tabindex="-1"> 适用场景</h3>
<p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p>
<p>但是 CopyOnWriteArrayList 有其缺陷：</p>
<ul>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li>
</ul>
<p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p>
<h2 id="linkedlist" tabindex="-1"> LinkedList</h2>
<p>LinkedList是一个实现了List接口和Deque接口的<strong>双端链表</strong>。 LinkedList底层的链表结构使它<strong>支持高效的插入和删除操作</strong>，另外它实现了Deque接口，使得LinkedList类也具有队列的特性; LinkedList不是线程安全的，如果想使LinkedList变成线程安全的，可以调用静态类Collections类中的synchronizedList方法：</p>
<div><pre><code>    <span>List</span> list<span>=</span><span>Collections</span><span>.</span><span>synchronizedList</span><span>(</span><span>new</span> <span>LinkedList</span><span>(</span><span>.</span><span>.</span><span>.</span><span>)</span><span>)</span><span>;</span>
</code></pre></div><h3 id="_1-概览-1" tabindex="-1"> 1. 概览</h3>
<p>基于双向链表实现，使用 Node 存储链表节点信息。</p>
<div><pre><code><span>private</span> <span>static</span> <span>class</span> <span>Node</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>{</span>
    <span>E</span> item<span>;</span>
    <span>Node</span><span><span>&lt;</span><span>E</span><span>></span></span> next<span>;</span>
    <span>Node</span><span><span>&lt;</span><span>E</span><span>></span></span> prev<span>;</span>
<span>}</span>
</code></pre></div><p>每个链表存储了 first 和 last 指针：</p>
<div><pre><code><span>transient</span> <span>Node</span><span><span>&lt;</span><span>E</span><span>></span></span> first<span>;</span>
<span>transient</span> <span>Node</span><span><span>&lt;</span><span>E</span><span>></span></span> last<span>;</span>
</code></pre></div><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c8563120-cb00-4dd6-9213-9d9b337a7f7c.png" width="500px"> </div><br>
<h3 id="_2-与-arraylist-的比较" tabindex="-1"> 2. 与 ArrayList 的比较</h3>
<ul>
<li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全</li>
<li>底层数据结构：Arraylist 底层使用的是动态数组(Object 数组)；LinkedList 底层使用的是双向链表数据结构(JDK1.6之前为循环链表，JDK1.7取消了循环)</li>
<li>随机访问：LinkedList 不支持高效的随机元素访问，而 ArrayList 支持</li>
<li>内存空间占用： ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间(因为要存放直接后继和直接前驱以及数据)。</li>
<li>插入和删除是否受元素位置的影响：
<ul>
<li>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)；但是如果要在指定位置 i 插入和删除元素的话(add(int index, E element))时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li>
<li>LinkedList 采用链表存储，所以对于add(E e)方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置i插入和删除元素的话(add(int index, E element) 时间复杂度近似为o(n))因为需要先移动到指定位置再插入</li>
</ul>
</li>
</ul>
<h2 id="hashmap" tabindex="-1"> HashMap</h2>
<h3 id="_1-存储结构" tabindex="-1"> 1. 存储结构</h3>
<h4 id="jdk1-8之前" tabindex="-1"> JDK1.8之前</h4>
<p>JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置(这里的 n 指的是数组的长度)，如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-collection/jdk7的HashMap结构.png" alt="" loading="lazy"></p>
</div>
<h4 id="jdk1-8之后" tabindex="-1"> JDK1.8之后</h4>
<p>jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值(默认为8)时，将链表转化为红黑树，以减少搜索时间。</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-collection/jdk8的HashMap结构.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<h3 id="_2-拉链法的工作原理" tabindex="-1"> 2. 拉链法的工作原理</h3>
<div><pre><code><span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
map<span>.</span><span>put</span><span>(</span><span>"K1"</span><span>,</span> <span>"V1"</span><span>)</span><span>;</span>
map<span>.</span><span>put</span><span>(</span><span>"K2"</span><span>,</span> <span>"V2"</span><span>)</span><span>;</span>
map<span>.</span><span>put</span><span>(</span><span>"K3"</span><span>,</span> <span>"V3"</span><span>)</span><span>;</span>
</code></pre></div><ul>
<li>新建一个 HashMap，默认大小为 16；</li>
<li>插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。</li>
<li>插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。</li>
<li>插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &lt;K2,V2&gt; 前面。</li>
</ul>
<p>应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部。</p>
<p>查找需要分成两步进行：</p>
<ul>
<li>计算键值对所在的桶；</li>
<li>在链表上顺序查找，时间复杂度显然和链表的长度成正比。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e0870f80-b79e-4542-ae39-7420d4b0d8fe.png" width="550px"> </div><br>
<h3 id="_3-put-操作" tabindex="-1"> 3. put 操作</h3>
<h4 id="jdk1-8之前-1" tabindex="-1"> JDK1.8之前</h4>
<div><pre><code><span>public</span> <span>V</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>table <span>==</span> EMPTY_TABLE<span>)</span> <span>{</span>
        <span>inflateTable</span><span>(</span>threshold<span>)</span><span>;</span>
    <span>}</span>
    <span>// 键为 null 单独处理</span>
    <span>if</span> <span>(</span>key <span>==</span> <span>null</span><span>)</span>
        <span>return</span> <span>putForNullKey</span><span>(</span>value<span>)</span><span>;</span>
    <span>int</span> hash <span>=</span> <span>hash</span><span>(</span>key<span>)</span><span>;</span>
    <span>// 确定桶下标</span>
    <span>int</span> i <span>=</span> <span>indexFor</span><span>(</span>hash<span>,</span> table<span>.</span>length<span>)</span><span>;</span>
    <span>// 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value</span>
    <span>for</span> <span>(</span><span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e <span>=</span> table<span>[</span>i<span>]</span><span>;</span> e <span>!=</span> <span>null</span><span>;</span> e <span>=</span> e<span>.</span>next<span>)</span> <span>{</span>
        <span>Object</span> k<span>;</span>
        <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span> <span>(</span><span>(</span>k <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span> <span>{</span>
            <span>V</span> oldValue <span>=</span> e<span>.</span>value<span>;</span>
            e<span>.</span>value <span>=</span> value<span>;</span>
            e<span>.</span><span>recordAccess</span><span>(</span><span>this</span><span>)</span><span>;</span>
            <span>return</span> oldValue<span>;</span>
        <span>}</span>
    <span>}</span>

    modCount<span>++</span><span>;</span>
    <span>// 插入新键值对</span>
    <span>addEntry</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> i<span>)</span><span>;</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p>
<div><pre><code><span>private</span> <span>V</span> <span>putForNullKey</span><span>(</span><span>V</span> value<span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e <span>=</span> table<span>[</span><span>0</span><span>]</span><span>;</span> e <span>!=</span> <span>null</span><span>;</span> e <span>=</span> e<span>.</span>next<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>e<span>.</span>key <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>V</span> oldValue <span>=</span> e<span>.</span>value<span>;</span>
            e<span>.</span>value <span>=</span> value<span>;</span>
            e<span>.</span><span>recordAccess</span><span>(</span><span>this</span><span>)</span><span>;</span>
            <span>return</span> oldValue<span>;</span>
        <span>}</span>
    <span>}</span>
    modCount<span>++</span><span>;</span>
    <span>addEntry</span><span>(</span><span>0</span><span>,</span> <span>null</span><span>,</span> value<span>,</span> <span>0</span><span>)</span><span>;</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p>
<div><pre><code><span>void</span> <span>addEntry</span><span>(</span><span>int</span> hash<span>,</span> <span>K</span> key<span>,</span> <span>V</span> value<span>,</span> <span>int</span> bucketIndex<span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>(</span>size <span>>=</span> threshold<span>)</span> <span>&amp;&amp;</span> <span>(</span><span>null</span> <span>!=</span> table<span>[</span>bucketIndex<span>]</span><span>)</span><span>)</span> <span>{</span>
        <span>resize</span><span>(</span><span>2</span> <span>*</span> table<span>.</span>length<span>)</span><span>;</span>
        hash <span>=</span> <span>(</span><span>null</span> <span>!=</span> key<span>)</span> <span>?</span> <span>hash</span><span>(</span>key<span>)</span> <span>:</span> <span>0</span><span>;</span>
        bucketIndex <span>=</span> <span>indexFor</span><span>(</span>hash<span>,</span> table<span>.</span>length<span>)</span><span>;</span>
    <span>}</span>

    <span>createEntry</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> bucketIndex<span>)</span><span>;</span>
<span>}</span>

<span>void</span> <span>createEntry</span><span>(</span><span>int</span> hash<span>,</span> <span>K</span> key<span>,</span> <span>V</span> value<span>,</span> <span>int</span> bucketIndex<span>)</span> <span>{</span>
    <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e <span>=</span> table<span>[</span>bucketIndex<span>]</span><span>;</span>
    <span>// 头插法，链表头部指向新的键值对</span>
    table<span>[</span>bucketIndex<span>]</span> <span>=</span> <span>new</span> <span>Entry</span><span><span>&lt;</span><span>></span></span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> e<span>)</span><span>;</span>
    size<span>++</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><div><pre><code><span>Entry</span><span>(</span><span>int</span> h<span>,</span> <span>K</span> k<span>,</span> <span>V</span> v<span>,</span> <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> n<span>)</span> <span>{</span>
    value <span>=</span> v<span>;</span>
    next <span>=</span> n<span>;</span>
    key <span>=</span> k<span>;</span>
    hash <span>=</span> h<span>;</span>
<span>}</span>
</code></pre></div><h4 id="jdk1-8之后-1" tabindex="-1"> JDK1.8之后</h4>
<p>HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。</p>
<p>对putVal方法添加元素的分析如下：</p>
<ol>
<li>如果定位到的数组位置没有元素 就直接插入。</li>
<li>如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</li>
</ol>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-collection/HashMap的put方法.png" alt="" title=":size=800" loading="lazy"></p>
</div>
<div><pre><code>    <span>public</span> <span>V</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span> <span>{</span>
        <span>return</span> <span>putVal</span><span>(</span><span>hash</span><span>(</span>key<span>)</span><span>,</span> key<span>,</span> value<span>,</span> <span>false</span><span>,</span> <span>true</span><span>)</span><span>;</span>
    <span>}</span>

    <span>final</span> <span>V</span> <span>putVal</span><span>(</span><span>int</span> hash<span>,</span> <span>K</span> key<span>,</span> <span>V</span> value<span>,</span> <span>boolean</span> onlyIfAbsent<span>,</span>
                   <span>boolean</span> evict<span>)</span> <span>{</span>
        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab<span>;</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> p<span>;</span> <span>int</span> n<span>,</span> i<span>;</span>
        <span>if</span> <span>(</span><span>(</span>tab <span>=</span> table<span>)</span> <span>==</span> <span>null</span> <span>||</span> <span>(</span>n <span>=</span> tab<span>.</span>length<span>)</span> <span>==</span> <span>0</span><span>)</span>
            n <span>=</span> <span>(</span>tab <span>=</span> <span>resize</span><span>(</span><span>)</span><span>)</span><span>.</span>length<span>;</span>
        <span>if</span> <span>(</span><span>(</span>p <span>=</span> tab<span>[</span>i <span>=</span> <span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> hash<span>]</span><span>)</span> <span>==</span> <span>null</span><span>)</span>
            tab<span>[</span>i<span>]</span> <span>=</span> <span>newNode</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>
        <span>else</span> <span>{</span>
            <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>;</span> <span>K</span> k<span>;</span>
            <span>if</span> <span>(</span>p<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>
                <span>(</span><span>(</span>k <span>=</span> p<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>
                e <span>=</span> p<span>;</span>
            <span>else</span> <span>if</span> <span>(</span>p <span>instanceof</span> <span>TreeNode</span><span>)</span>
                e <span>=</span> <span>(</span><span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>p<span>)</span><span>.</span><span>putTreeVal</span><span>(</span><span>this</span><span>,</span> tab<span>,</span> hash<span>,</span> key<span>,</span> value<span>)</span><span>;</span>
            <span>else</span> <span>{</span>
                <span>for</span> <span>(</span><span>int</span> binCount <span>=</span> <span>0</span><span>;</span> <span>;</span> <span>++</span>binCount<span>)</span> <span>{</span>
                    <span>if</span> <span>(</span><span>(</span>e <span>=</span> p<span>.</span>next<span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
                        p<span>.</span>next <span>=</span> <span>newNode</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>
                        <span>if</span> <span>(</span>binCount <span>>=</span> TREEIFY_THRESHOLD <span>-</span> <span>1</span><span>)</span> <span>// -1 for 1st</span>
                            <span>treeifyBin</span><span>(</span>tab<span>,</span> hash<span>)</span><span>;</span>
                        <span>break</span><span>;</span>
                    <span>}</span>
                    <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>
                        <span>(</span><span>(</span>k <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>
                        <span>break</span><span>;</span>
                    p <span>=</span> e<span>;</span>
                <span>}</span>
            <span>}</span>
            <span>if</span> <span>(</span>e <span>!=</span> <span>null</span><span>)</span> <span>{</span> <span>// existing mapping for key</span>
                <span>V</span> oldValue <span>=</span> e<span>.</span>value<span>;</span>
                <span>if</span> <span>(</span><span>!</span>onlyIfAbsent <span>||</span> oldValue <span>==</span> <span>null</span><span>)</span>
                    e<span>.</span>value <span>=</span> value<span>;</span>
                <span>afterNodeAccess</span><span>(</span>e<span>)</span><span>;</span>
                <span>return</span> oldValue<span>;</span>
            <span>}</span>
        <span>}</span>
        <span>++</span>modCount<span>;</span>
        <span>if</span> <span>(</span><span>++</span>size <span>></span> threshold<span>)</span>
            <span>resize</span><span>(</span><span>)</span><span>;</span>
        <span>afterNodeInsertion</span><span>(</span>evict<span>)</span><span>;</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h3 id="_4-确定桶下标" tabindex="-1"> 4. 确定桶下标</h3>
<p>很多操作都需要先确定一个键值对所在的桶下标。</p>
<div><pre><code><span>int</span> hash <span>=</span> <span>hash</span><span>(</span>key<span>)</span><span>;</span>
<span>int</span> i <span>=</span> <span>indexFor</span><span>(</span>hash<span>,</span> table<span>.</span>length<span>)</span><span>;</span>
</code></pre></div><p><strong>4.1 计算 hash 值</strong></p>
<h4 id="jdk1-8之前-2" tabindex="-1"> JDK1.8之前</h4>
<p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p>
<p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次</p>
<div><pre><code><span>final</span> <span>int</span> <span>hash</span><span>(</span><span>Object</span> k<span>)</span> <span>{</span>
    <span>int</span> h <span>=</span> hashSeed<span>;</span>
    <span>if</span> <span>(</span><span>0</span> <span>!=</span> h <span>&amp;&amp;</span> k <span>instanceof</span> <span>String</span><span>)</span> <span>{</span>
        <span>return</span> <span><span>sun<span>.</span>misc<span>.</span></span>Hashing</span><span>.</span><span>stringHash32</span><span>(</span><span>(</span><span>String</span><span>)</span> k<span>)</span><span>;</span>
    <span>}</span>
    h <span>^=</span> k<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>;</span>
    <span>// This function ensures that hashCodes that differ only by</span>
    <span>// constant multiples at each bit position have a bounded</span>
    <span>// number of collisions (approximately 8 at default load factor).</span>
    h <span>^=</span> <span>(</span>h <span>>>></span> <span>20</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>12</span><span>)</span><span>;</span>
    <span>return</span> h <span>^</span> <span>(</span>h <span>>>></span> <span>7</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>4</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>public</span> <span>final</span> <span>int</span> <span>hashCode</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>Objects</span><span>.</span><span>hashCode</span><span>(</span>key<span>)</span> <span>^</span> <span>Objects</span><span>.</span><span>hashCode</span><span>(</span>value<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h4 id="jdk1-8之后-2" tabindex="-1"> JDK1.8之后</h4>
<div><pre><code>    <span>static</span> <span>final</span> <span>int</span> <span>hash</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>
        <span>int</span> h<span>;</span>
        <span>return</span> <span>(</span>key <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>(</span>h <span>=</span> key<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>16</span><span>)</span><span>;</span>
    <span>}</span>
</code></pre></div><p><strong>4.2 取模</strong></p>
<p>令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：</p>
<div><pre><code>x   : 00010000
x-1 : 00001111
</code></pre></div><p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p>
<div><pre><code>y       : 10110010
x-1     : 00001111
y&amp;(x-1) : 00000010
</code></pre></div><p>这个性质和 y 对 x 取模效果是一样的：</p>
<div><pre><code>y   : 10110010
x   : 00010000
y%x : 00000010
</code></pre></div><p>我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。</p>
<p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。</p>
<div><pre><code><span>static</span> <span>int</span> <span>indexFor</span><span>(</span><span>int</span> h<span>,</span> <span>int</span> length<span>)</span> <span>{</span>
    <span>return</span> h <span>&amp;</span> <span>(</span>length<span>-</span><span>1</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h3 id="_5-扩容-基本原理" tabindex="-1"> 5. 扩容-基本原理</h3>
<p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此平均查找次数的复杂度为 O(N/M)。</p>
<p>为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p>
<p>和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">capacity</td>
<td style="text-align:left">table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</td>
</tr>
<tr>
<td style="text-align:center">size</td>
<td style="text-align:left">键值对数量。</td>
</tr>
<tr>
<td style="text-align:center">threshold</td>
<td style="text-align:left">size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。</td>
</tr>
<tr>
<td style="text-align:center">loadFactor</td>
<td style="text-align:left">装载因子，table 能够使用的比例，threshold = (int)(newCapacity * loadFactor)。</td>
</tr>
<tr>
<td style="text-align:center">MAXIMUM_CAPACITY</td>
<td style="text-align:left">最大容量2^30, 最终容量Integer.MAX_VALUE</td>
</tr>
</tbody>
</table>
<div><pre><code>    <span>static</span> <span>final</span> <span>int</span> DEFAULT_INITIAL_CAPACITY <span>=</span> <span>16</span><span>;</span>

    <span>static</span> <span>final</span> <span>int</span> MAXIMUM_CAPACITY <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>30</span><span>;</span>

    <span>static</span> <span>final</span> <span>float</span> DEFAULT_LOAD_FACTOR <span>=</span> <span>0.75f</span><span>;</span>

    <span>transient</span> <span>Entry</span><span>[</span><span>]</span> table<span>;</span>

    <span>transient</span> <span>int</span> size<span>;</span>

    <span>int</span> threshold<span>;</span>

    <span>final</span> <span>float</span> loadFactor<span>;</span>

    <span>transient</span> <span>int</span> modCount<span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。</p>
<div><pre><code><span>void</span> <span>addEntry</span><span>(</span><span>int</span> hash<span>,</span> <span>K</span> key<span>,</span> <span>V</span> value<span>,</span> <span>int</span> bucketIndex<span>)</span> <span>{</span>
    <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e <span>=</span> table<span>[</span>bucketIndex<span>]</span><span>;</span>
    table<span>[</span>bucketIndex<span>]</span> <span>=</span> <span>new</span> <span>Entry</span><span><span>&lt;</span><span>></span></span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> e<span>)</span><span>;</span>
    <span>if</span> <span>(</span>size<span>++</span> <span>>=</span> threshold<span>)</span>
        <span>resize</span><span>(</span><span>2</span> <span>*</span> table<span>.</span>length<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><p>扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。</p>
<p>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。</p>
<div><pre><code><span>void</span> <span>resize</span><span>(</span><span>int</span> newCapacity<span>)</span> <span>{</span>
    <span>Entry</span><span>[</span><span>]</span> oldTable <span>=</span> table<span>;</span>
    <span>int</span> oldCapacity <span>=</span> oldTable<span>.</span>length<span>;</span>
    <span>if</span> <span>(</span>oldCapacity <span>==</span> MAXIMUM_CAPACITY<span>)</span> <span>{</span>
        threshold <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>;</span>
        <span>return</span><span>;</span>
    <span>}</span>
    <span>Entry</span><span>[</span><span>]</span> newTable <span>=</span> <span>new</span> <span>Entry</span><span>[</span>newCapacity<span>]</span><span>;</span>
    <span>transfer</span><span>(</span>newTable<span>)</span><span>;</span>
    table <span>=</span> newTable<span>;</span>
    threshold <span>=</span> <span>(</span><span>int</span><span>)</span><span>(</span>newCapacity <span>*</span> loadFactor<span>)</span><span>;</span>
<span>}</span>

<span>void</span> <span>transfer</span><span>(</span><span>Entry</span><span>[</span><span>]</span> newTable<span>)</span> <span>{</span>
    <span>Entry</span><span>[</span><span>]</span> src <span>=</span> table<span>;</span>
    <span>int</span> newCapacity <span>=</span> newTable<span>.</span>length<span>;</span>
    <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> src<span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
        <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e <span>=</span> src<span>[</span>j<span>]</span><span>;</span>
        <span>if</span> <span>(</span>e <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            src<span>[</span>j<span>]</span> <span>=</span> <span>null</span><span>;</span>
            <span>do</span> <span>{</span>
                <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next <span>=</span> e<span>.</span>next<span>;</span>
                <span>int</span> i <span>=</span> <span>indexFor</span><span>(</span>e<span>.</span>hash<span>,</span> newCapacity<span>)</span><span>;</span>
                e<span>.</span>next <span>=</span> newTable<span>[</span>i<span>]</span><span>;</span>
                newTable<span>[</span>i<span>]</span> <span>=</span> e<span>;</span>
                e <span>=</span> next<span>;</span>
            <span>}</span> <span>while</span> <span>(</span>e <span>!=</span> <span>null</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h3 id="_6-扩容-重新计算桶下标" tabindex="-1"> 6. 扩容-重新计算桶下标</h3>
<p>在进行扩容时，需要把键值对重新放到对应的桶上。HashMap 使用了一个特殊的机制，可以降低重新计算桶下标的操作。</p>
<p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p>
<div><pre><code>capacity     : 00010000
new capacity : 00100000
</code></pre></div><p>对于一个 Key，</p>
<ul>
<li>它的哈希值如果在第 5 位上为 0，那么取模得到的结果和之前一样；</li>
<li>如果为 1，那么得到的结果为原来的结果 +16。</li>
</ul>
<h3 id="_7-计算数组容量" tabindex="-1"> 7. 计算数组容量</h3>
<p>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。</p>
<p>先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：</p>
<div><pre><code>mask |= mask >> 1    11011000
mask |= mask >> 2    11111110
mask |= mask >> 4    11111111
</code></pre></div><p>mask+1 是大于原始数字的最小的 2 的 n 次方。</p>
<div><pre><code>num     10010000
mask+1 100000000
</code></pre></div><p>以下是 HashMap 中计算数组容量的代码：</p>
<div><pre><code><span>static</span> <span>final</span> <span>int</span> <span>tableSizeFor</span><span>(</span><span>int</span> cap<span>)</span> <span>{</span>
    <span>int</span> n <span>=</span> cap <span>-</span> <span>1</span><span>;</span>
    n <span>|=</span> n <span>>>></span> <span>1</span><span>;</span>
    n <span>|=</span> n <span>>>></span> <span>2</span><span>;</span>
    n <span>|=</span> n <span>>>></span> <span>4</span><span>;</span>
    n <span>|=</span> n <span>>>></span> <span>8</span><span>;</span>
    n <span>|=</span> n <span>>>></span> <span>16</span><span>;</span>
    <span>return</span> <span>(</span>n <span>&lt;</span> <span>0</span><span>)</span> <span>?</span> <span>1</span> <span>:</span> <span>(</span>n <span>>=</span> MAXIMUM_CAPACITY<span>)</span> <span>?</span> MAXIMUM_CAPACITY <span>:</span> n <span>+</span> <span>1</span><span>;</span>
<span>}</span>
</code></pre></div><h3 id="_8-hashmap-多线程操作导致死循环问题" tabindex="-1"> 8. HashMap 多线程操作导致死循环问题</h3>
<p>主要原因在于 并发下的Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p>
<p>详情请查看：https://coolshell.cn/articles/9606.html</p>
<h3 id="_9-与-hashtable-的比较" tabindex="-1"> 9. 与 HashTable 的比较</h3>
<ul>
<li>线程是否安全： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过synchronized 修饰</li>
<li>效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰</li>
<li>对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li>
<li>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值(默认为8)时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
<li>接口继承：HashMap继承AbstractMap，Hashtable继承Dictionary实现Map</li>
<li>初始容量大小和每次扩充容量大小的不同 ：
<ul>
<li>创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。</li>
<li>创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小(HashMap 中的tableSizeFor()方法保证)。</li>
</ul>
</li>
<li>HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的</li>
<li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li>
</ul>
<h3 id="_10-与hashset-的比较" tabindex="-1"> 10. 与HashSet 的比较</h3>
<p><code>HashSet</code> 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。(HashSet 的源码非常非常少，因为除了 <code>clone() </code>、<code>writeObject()</code>、<code>readObject()</code>是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p>
<table>
<thead>
<tr>
<th style="text-align:center">HashMap</th>
<th style="text-align:center">HashSet</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">实现了Map接口</td>
<td style="text-align:center">实现Set接口</td>
</tr>
<tr>
<td style="text-align:center">存储键值对</td>
<td style="text-align:center">仅存储对象</td>
</tr>
<tr>
<td style="text-align:center">调用 <code>put()</code>向map中添加元素</td>
<td style="text-align:center">调用 <code>add()</code>方法向Set中添加元素</td>
</tr>
<tr>
<td style="text-align:center">HashMap使用键(Key)计算Hashcode</td>
<td style="text-align:center">HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，</td>
</tr>
</tbody>
</table>
<p><strong>HashSet如何检查重复</strong></p>
<p>当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals()方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。(摘自我的Java启蒙书《Head fist java》第二版)</p>
<p><strong>hashCode()与equals()的相关规定：</strong></p>
<ol>
<li>如果两个对象相等，则hashcode一定也是相同的</li>
<li>两个对象相等,对两个equals方法返回true</li>
<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>
<li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li>
<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等(即使这两个对象指向相同的数据)。</li>
</ol>
<p><strong>==与equals的区别</strong></p>
<ol>
<li>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</li>
<li>==是指对内存地址进行比较 equals()是对字符串的内容进行比较</li>
<li>==指引用是否相同 equals()指的是值是否相同</li>
</ol>
<h2 id="concurrenthashmap" tabindex="-1"> ConcurrentHashMap</h2>
<h3 id="_1-存储结构-1" tabindex="-1"> 1. 存储结构</h3>
<h4 id="jdk1-7" tabindex="-1"> JDK1.7</h4>
<div><pre><code><span>static</span> <span>final</span> <span>class</span> <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>{</span>
    <span>final</span> <span>int</span> hash<span>;</span>
    <span>final</span> <span>K</span> key<span>;</span>
    <span>volatile</span> <span>V</span> value<span>;</span>
    <span>volatile</span> <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next<span>;</span>
<span>}</span>
</code></pre></div><p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁(Segment)，每个分段锁维护着几个桶(HashEntry)，多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高(并发度就是 Segment 的个数)。</p>
<p>Segment 继承自 ReentrantLock。所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-collection/jdk7的ConcurrentHashMap结构.png" alt="" loading="lazy"></p>
</div>
<div><pre><code><span>static</span> <span>final</span> <span>class</span> <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>extends</span> <span>ReentrantLock</span> <span>implements</span> <span>Serializable</span> <span>{</span>

    <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID <span>=</span> <span>2249069246763182397L</span><span>;</span>

    <span>static</span> <span>final</span> <span>int</span> MAX_SCAN_RETRIES <span>=</span>
        <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>availableProcessors</span><span>(</span><span>)</span> <span>></span> <span>1</span> <span>?</span> <span>64</span> <span>:</span> <span>1</span><span>;</span>

    <span>transient</span> <span>volatile</span> <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> table<span>;</span>

    <span>transient</span> <span>int</span> count<span>;</span>

    <span>transient</span> <span>int</span> modCount<span>;</span>

    <span>transient</span> <span>int</span> threshold<span>;</span>

    <span>final</span> <span>float</span> loadFactor<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><pre><code><span>final</span> <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> segments<span>;</span>
</code></pre></div><p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p>
<p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p>
<div><pre><code><span>static</span> <span>final</span> <span>int</span> DEFAULT_CONCURRENCY_LEVEL <span>=</span> <span>16</span><span>;</span>
</code></pre></div><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/db808eff-31d7-4229-a4ad-b8ae71870a3a.png" width="550px"> </div><br>
<h4 id="jdk1-8" tabindex="-1"> JDK1.8</h4>
<p>ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。Java 8在链表长度超过一定阈值(8)时将链表(寻址时间复杂度为O(N))转换为红黑树(寻址时间复杂度为O(log(N)))</p>
<p>synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-collection/jdk8的ConcurrentHashMap结构.png" alt="" loading="lazy"></p>
</div>
<h3 id="_2-put-操作" tabindex="-1"> 2. put 操作</h3>
<h4 id="jdk1-7-1" tabindex="-1"> JDK1.7</h4>
<p>当执行put方法插入数据时，根据key的hash值，在Segment数组中找到相应的位置，如果相应位置的Segment还未初始化，则通过CAS进行赋值，接着执行Segment对象的put方法通过加锁机制插入数据，实现如下：</p>
<h4 id="jdk1-8-1" tabindex="-1"> JDK1.8</h4>
<p>当执行put方法插入数据时，根据key的hash值，在Node数组中找到相应的位置，实现如下：</p>
<ol>
<li>如果相应位置的Node还未初始化，则通过CAS插入相应的数据；</li>
<li>如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</li>
<li>如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；</li>
<li>如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</li>
<li>如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</li>
</ol>
<h3 id="_3-size-操作" tabindex="-1"> 3. size 操作</h3>
<h4 id="jdk1-7-2" tabindex="-1"> JDK1.7</h4>
<p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p>
<div><pre><code><span>/**
 * The number of elements. Accessed only either within locks
 * or among other volatile reads that maintain visibility.
 */</span>
<span>transient</span> <span>int</span> count<span>;</span>
</code></pre></div><p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p>
<p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p>
<p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p>
<p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p>
<div><pre><code>
    <span>static</span> <span>final</span> <span>int</span> RETRIES_BEFORE_LOCK <span>=</span> <span>2</span><span>;</span>

    <span>public</span> <span>int</span> <span>size</span><span>(</span><span>)</span> <span>{</span>
        <span>// Try a few times to get accurate count. On failure due to</span>
        <span>// continuous async changes in table, resort to locking.</span>
        <span>final</span> <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> segments <span>=</span> <span>this</span><span>.</span>segments<span>;</span>
        <span>int</span> size<span>;</span>
        <span>boolean</span> overflow<span>;</span> <span>// true if size overflows 32 bits</span>
        <span>long</span> sum<span>;</span>         <span>// sum of modCounts</span>
        <span>long</span> last <span>=</span> <span>0L</span><span>;</span>   <span>// previous sum</span>
        <span>int</span> retries <span>=</span> <span>-</span><span>1</span><span>;</span> <span>// first iteration isn't retry</span>
        <span>try</span> <span>{</span>
            <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>
                <span>// 超过尝试次数，则对每个 Segment 加锁</span>
                <span>if</span> <span>(</span>retries<span>++</span> <span>==</span> RETRIES_BEFORE_LOCK<span>)</span> <span>{</span>
                    <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> segments<span>.</span>length<span>;</span> <span>++</span>j<span>)</span>
                        <span>ensureSegment</span><span>(</span>j<span>)</span><span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span> <span>// force creation</span>
                <span>}</span>
                sum <span>=</span> <span>0L</span><span>;</span>
                size <span>=</span> <span>0</span><span>;</span>
                overflow <span>=</span> <span>false</span><span>;</span>
                <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> segments<span>.</span>length<span>;</span> <span>++</span>j<span>)</span> <span>{</span>
                    <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> seg <span>=</span> <span>segmentAt</span><span>(</span>segments<span>,</span> j<span>)</span><span>;</span>
                    <span>if</span> <span>(</span>seg <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                        sum <span>+=</span> seg<span>.</span>modCount<span>;</span>
                        <span>int</span> c <span>=</span> seg<span>.</span>count<span>;</span>
                        <span>if</span> <span>(</span>c <span>&lt;</span> <span>0</span> <span>||</span> <span>(</span>size <span>+=</span> c<span>)</span> <span>&lt;</span> <span>0</span><span>)</span>
                            overflow <span>=</span> <span>true</span><span>;</span>
                    <span>}</span>
                <span>}</span>
                <span>// 连续两次得到的结果一致，则认为这个结果是正确的</span>
                <span>if</span> <span>(</span>sum <span>==</span> last<span>)</span>
                    <span>break</span><span>;</span>
                last <span>=</span> sum<span>;</span>
            <span>}</span>
        <span>}</span> <span>finally</span> <span>{</span>
            <span>if</span> <span>(</span>retries <span>></span> RETRIES_BEFORE_LOCK<span>)</span> <span>{</span>
                <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> segments<span>.</span>length<span>;</span> <span>++</span>j<span>)</span>
                    <span>segmentAt</span><span>(</span>segments<span>,</span> j<span>)</span><span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> overflow <span>?</span> <span>Integer</span><span>.</span>MAX_VALUE <span>:</span> size<span>;</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h4 id="jdk1-8-2" tabindex="-1"> JDK1.8</h4>
<ul>
<li>使用一个volatile类型的变量baseCount记录元素的个数，当插入新数据或则删除数据时，会通过addCount()方法更新baseCount
<ol>
<li>初始化时counterCells为空，在并发量很高时，如果存在两个线程同时执行CAS修改baseCount值，则失败的线程会继续执行方法体中的逻辑，使用CounterCell记录元素个数的变化；</li>
<li>如果CounterCell数组counterCells为空，调用fullAddCount()方法进行初始化，并插入对应的记录数，通过CAS设置cellsBusy字段，只有设置成功的线程才能初始化CounterCell数组</li>
<li>如果通过CAS设置cellsBusy字段失败的话，则继续尝试通过CAS修改baseCount字段，如果修改baseCount字段成功的话，就退出循环，否则继续循环插入CounterCell对象</li>
</ol>
</li>
<li>size实现比1.7简单多，因为元素个数保存baseCount中，部分元素的变化个数保存在CounterCell数组中，通过累加baseCount和CounterCell数组中的数量，即可得到元素的总个数</li>
</ul>
<h3 id="_4-和-hashtable-的对比" tabindex="-1"> 4. 和 Hashtable 的对比</h3>
<ul>
<li>底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li>实现线程安全的方式(重要)：
<ul>
<li>在JDK1.7的时候，ConcurrentHashMap(分段锁) 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。(JDK1.6以后 对 synchronized锁做了很多优化) 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li>
<li>Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
</li>
</ul>
<h2 id="linkedhashmap" tabindex="-1"> LinkedHashMap</h2>
<h3 id="存储结构" tabindex="-1"> 存储结构</h3>
<p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。</p>
<div><pre><code><span>public</span> <span>class</span> <span>LinkedHashMap</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>extends</span> <span>HashMap</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>implements</span> <span>Map</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span>
</code></pre></div><p>内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。</p>
<div><pre><code><span>/**
 * The head (eldest) of the doubly linked list.
 */</span>
<span>transient</span> <span>LinkedHashMap<span>.</span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> head<span>;</span>

<span>/**
 * The tail (youngest) of the doubly linked list.
 */</span>
<span>transient</span> <span>LinkedHashMap<span>.</span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> tail<span>;</span>
</code></pre></div><p>accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。</p>
<div><pre><code><span>final</span> <span>boolean</span> accessOrder<span>;</span>
</code></pre></div><p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p>
<div><pre><code><span>void</span> <span>afterNodeAccess</span><span>(</span><span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> p<span>)</span> <span>{</span> <span>}</span>
<span>void</span> <span>afterNodeInsertion</span><span>(</span><span>boolean</span> evict<span>)</span> <span>{</span> <span>}</span>
</code></pre></div><h3 id="afternodeaccess" tabindex="-1"> afterNodeAccess()</h3>
<p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p>
<div><pre><code><span>void</span> <span>afterNodeAccess</span><span>(</span><span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>)</span> <span>{</span> <span>// move node to last</span>
    <span>LinkedHashMap<span>.</span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> last<span>;</span>
    <span>if</span> <span>(</span>accessOrder <span>&amp;&amp;</span> <span>(</span>last <span>=</span> tail<span>)</span> <span>!=</span> e<span>)</span> <span>{</span>
        <span>LinkedHashMap<span>.</span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> p <span>=</span>
            <span>(</span><span>LinkedHashMap<span>.</span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>e<span>,</span> b <span>=</span> p<span>.</span>before<span>,</span> a <span>=</span> p<span>.</span>after<span>;</span>
        p<span>.</span>after <span>=</span> <span>null</span><span>;</span>
        <span>if</span> <span>(</span>b <span>==</span> <span>null</span><span>)</span>
            head <span>=</span> a<span>;</span>
        <span>else</span>
            b<span>.</span>after <span>=</span> a<span>;</span>
        <span>if</span> <span>(</span>a <span>!=</span> <span>null</span><span>)</span>
            a<span>.</span>before <span>=</span> b<span>;</span>
        <span>else</span>
            last <span>=</span> b<span>;</span>
        <span>if</span> <span>(</span>last <span>==</span> <span>null</span><span>)</span>
            head <span>=</span> p<span>;</span>
        <span>else</span> <span>{</span>
            p<span>.</span>before <span>=</span> last<span>;</span>
            last<span>.</span>after <span>=</span> p<span>;</span>
        <span>}</span>
        tail <span>=</span> p<span>;</span>
        <span>++</span>modCount<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id="afternodeinsertion" tabindex="-1"> afterNodeInsertion()</h3>
<p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。</p>
<p>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p>
<div><pre><code><span>void</span> <span>afterNodeInsertion</span><span>(</span><span>boolean</span> evict<span>)</span> <span>{</span> <span>// possibly remove eldest</span>
    <span>LinkedHashMap<span>.</span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> first<span>;</span>
    <span>if</span> <span>(</span>evict <span>&amp;&amp;</span> <span>(</span>first <span>=</span> head<span>)</span> <span>!=</span> <span>null</span> <span>&amp;&amp;</span> <span>removeEldestEntry</span><span>(</span>first<span>)</span><span>)</span> <span>{</span>
        <span>K</span> key <span>=</span> first<span>.</span>key<span>;</span>
        <span>removeNode</span><span>(</span><span>hash</span><span>(</span>key<span>)</span><span>,</span> key<span>,</span> <span>null</span><span>,</span> <span>false</span><span>,</span> <span>true</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p>
<div><pre><code><span>protected</span> <span>boolean</span> <span>removeEldestEntry</span><span>(</span><span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> eldest<span>)</span> <span>{</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre></div><h3 id="lru-缓存" tabindex="-1"> LRU 缓存</h3>
<p>以下是使用 LinkedHashMap 实现的一个 LRU 缓存：</p>
<ul>
<li>设定最大缓存空间 MAX_ENTRIES  为 3；</li>
<li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；</li>
<li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。</li>
</ul>
<div><pre><code><span>class</span> <span>LRUCache</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span> <span>extends</span> <span>LinkedHashMap</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span> <span>{</span>
    <span>private</span> <span>static</span> <span>final</span> <span>int</span> MAX_ENTRIES <span>=</span> <span>3</span><span>;</span>

    <span>protected</span> <span>boolean</span> <span>removeEldestEntry</span><span>(</span><span>Map<span>.</span>Entry</span> eldest<span>)</span> <span>{</span>
        <span>return</span> <span>size</span><span>(</span><span>)</span> <span>></span> MAX_ENTRIES<span>;</span>
    <span>}</span>

    <span>LRUCache</span><span>(</span><span>)</span> <span>{</span>
        <span>super</span><span>(</span>MAX_ENTRIES<span>,</span> <span>0.75f</span><span>,</span> <span>true</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>LRUCache</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>></span></span> cache <span>=</span> <span>new</span> <span>LRUCache</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    cache<span>.</span><span>put</span><span>(</span><span>1</span><span>,</span> <span>"a"</span><span>)</span><span>;</span>
    cache<span>.</span><span>put</span><span>(</span><span>2</span><span>,</span> <span>"b"</span><span>)</span><span>;</span>
    cache<span>.</span><span>put</span><span>(</span><span>3</span><span>,</span> <span>"c"</span><span>)</span><span>;</span>
    cache<span>.</span><span>get</span><span>(</span><span>1</span><span>)</span><span>;</span>
    cache<span>.</span><span>put</span><span>(</span><span>4</span><span>,</span> <span>"d"</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>cache<span>.</span><span>keySet</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code>[3, 1, 4]
</code></pre></div><h2 id="weakhashmap" tabindex="-1"> WeakHashMap</h2>
<h3 id="存储结构-1" tabindex="-1"> 存储结构</h3>
<p>WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。</p>
<p>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。</p>
<div><pre><code><span>private</span> <span>static</span> <span>class</span> <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>extends</span> <span>WeakReference</span><span><span>&lt;</span><span>Object</span><span>></span></span> <span>implements</span> <span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span>
</code></pre></div><h3 id="concurrentcache" tabindex="-1"> ConcurrentCache</h3>
<p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。</p>
<p>ConcurrentCache 采取的是分代缓存：</p>
<ul>
<li>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收(伊甸园)；</li>
<li>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。</li>
<li>当调用  get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。</li>
<li>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。</li>
</ul>
<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>ConcurrentCache</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span> <span>{</span>

    <span>private</span> <span>final</span> <span>int</span> size<span>;</span>

    <span>private</span> <span>final</span> <span>Map</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span> eden<span>;</span>

    <span>private</span> <span>final</span> <span>Map</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span> longterm<span>;</span>

    <span>public</span> <span>ConcurrentCache</span><span>(</span><span>int</span> size<span>)</span> <span>{</span>
        <span>this</span><span>.</span>size <span>=</span> size<span>;</span>
        <span>this</span><span>.</span>eden <span>=</span> <span>new</span> <span>ConcurrentHashMap</span><span><span>&lt;</span><span>></span></span><span>(</span>size<span>)</span><span>;</span>
        <span>this</span><span>.</span>longterm <span>=</span> <span>new</span> <span>WeakHashMap</span><span><span>&lt;</span><span>></span></span><span>(</span>size<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>V</span> <span>get</span><span>(</span><span>K</span> k<span>)</span> <span>{</span>
        <span>V</span> v <span>=</span> <span>this</span><span>.</span>eden<span>.</span><span>get</span><span>(</span>k<span>)</span><span>;</span>
        <span>if</span> <span>(</span>v <span>==</span> <span>null</span><span>)</span> <span>{</span>
            v <span>=</span> <span>this</span><span>.</span>longterm<span>.</span><span>get</span><span>(</span>k<span>)</span><span>;</span>
            <span>if</span> <span>(</span>v <span>!=</span> <span>null</span><span>)</span>
                <span>this</span><span>.</span>eden<span>.</span><span>put</span><span>(</span>k<span>,</span> v<span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> v<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>put</span><span>(</span><span>K</span> k<span>,</span> <span>V</span> v<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>this</span><span>.</span>eden<span>.</span><span>size</span><span>(</span><span>)</span> <span>>=</span> size<span>)</span> <span>{</span>
            <span>this</span><span>.</span>longterm<span>.</span><span>putAll</span><span>(</span><span>this</span><span>.</span>eden<span>)</span><span>;</span>
            <span>this</span><span>.</span>eden<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>this</span><span>.</span>eden<span>.</span><span>put</span><span>(</span>k<span>,</span> v<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li>Eckel B. Java 编程思想 [M]. 机械工业出版社, 2002.</li>
<li><a href="https://www.w3resource.com/java-tutorial/java-collections.php" target="_blank" rel="noopener noreferrer">Java Collection Framework</a></li>
<li><a href="https://openhome.cc/Gossip/DesignPattern/IteratorPattern.htm" target="_blank" rel="noopener noreferrer">Iterator 模式</a></li>
<li><a href="https://tech.meituan.com/java_hashmap.html" target="_blank" rel="noopener noreferrer">Java 8 系列之重新认识 HashMap</a></li>
<li><a href="http://javarevisited.blogspot.hk/2010/10/difference-between-hashmap-and.html" target="_blank" rel="noopener noreferrer">What is difference between HashMap and Hashtable in Java?</a></li>
<li><a href="http://www.zhangchangle.com/2018/02/07/Java%E9%9B%86%E5%90%88%E4%B9%8BHashMap/" target="_blank" rel="noopener noreferrer">Java 集合之 HashMap</a></li>
<li><a href="http://www.programering.com/a/MDO3QDNwATM.html" target="_blank" rel="noopener noreferrer">The principle of ConcurrentHashMap analysis</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/" target="_blank" rel="noopener noreferrer">探索 ConcurrentHashMap 高并发性的实现机制</a></li>
<li><a href="https://www.jianshu.com/p/75adf47958a7" target="_blank" rel="noopener noreferrer">HashMap 相关面试题及其解答</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/java-enhancement/java-thirtysix.html" target="_blank" rel="noopener noreferrer">Java 集合细节(二)：asList 的缺陷</a></li>
<li><a href="http://javaconceptoftheday.com/java-collection-framework-linkedlist-class/" target="_blank" rel="noopener noreferrer">Java Collection Framework – The LinkedList Class</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java并发基础</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">Java并发基础</source>
      <category>Java</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[ 
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
 
<h1 id="一、线程" tabindex="-1"> 一、线程</h1>
<h2 id="线程简介" tabindex="-1"> 线程简介</h2>
<h3 id="_1-什么是线程" tabindex="-1"> 1. 什么是线程</h3>
<p>现代操作系统调度的最小单元是线程，也叫轻量级进程(Light Weight Process)，在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。</p>
<h3 id="_2-上下文切换" tabindex="-1"> 2. 上下文切换</h3>
<p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p>
<p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换会这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>Linux 相比与其他操作系统(包括其他类 Unix 系统)有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
<h3 id="_3-使用多线程原因" tabindex="-1"> 3. 使用多线程原因</h3>
<ol>
<li>更多处理器核心：一个线程在同一时刻只能运行在一个处理器上，将逻辑分配到多个核心处理器上更加有效率。</li>
<li>更快的响应时间：将数据一致性不强的操作分派给其他线程，使响应用户请求的线程尽快完成，缩短响应时间。</li>
<li>更好的编程模型：考虑问题时，仅需将业务建立起合适的模型，而无须考虑复杂的底层实现。</li>
</ol>
<p>先从总体上来说：</p>
<ul>
<li>**从计算机底层来说：**线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li>**从当代互联网发展趋势来说：**现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>再深入到计算机底层来探讨：</p>
<ul>
<li><strong>单核时代：</strong> 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。</li>
<li><strong>多核时代:</strong> 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</li>
</ul>
<h3 id="_4-守护线程" tabindex="-1"> 4. 守护线程</h3>
<p><strong>守护线程和用户线程简介:</strong></p>
<ul>
<li>**用户 (User) 线程：**运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程</li>
<li>**守护 (Daemon) 线程：**运行在后台，为其他前台线程服务.也可以说守护线程是 JVM 中非守护线程的 <strong>“佣人”</strong>。一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作.</li>
</ul>
<p>main 函数所在的线程就是一个用户线程啊，main 函数启动的同时在 JVM 内部同时还启动了好多守护线程，比如垃圾回收线程。</p>
<p><strong>那么守护线程和用户线程有什么区别呢？</strong></p>
<p>比较明显的区别之一是用户线程结束，JVM 退出，不管这个时候有没有守护线程运行。而守护线程不会影响 JVM 的退出。</p>
<p><strong>注意事项：</strong></p>
<ol>
<li><code>setDaemon(true)</code>必须在<code>start()</code>方法前执行，否则会抛出 <code>IllegalThreadStateException</code> 异常</li>
<li>在守护线程中产生的新线程也是守护线程</li>
<li>不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑</li>
<li>守护 (Daemon) 线程中不能依靠 finally 块的内容来确保执行关闭或清理资源的逻辑。因为我们上面也说过了一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作，所以守护 (Daemon) 线程中的 finally 语句块可能无法被执行。</li>
</ol>
<h2 id="线程状态" tabindex="-1"> 线程状态</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/adfb427d-3b21-40d7-a142-757f4ed73079.png" width="600px"> </div><br>
<table>
<thead>
<tr>
<th>状态名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>New</td>
<td>初始状态，线程被构建，但还未启动</td>
</tr>
<tr>
<td>Runnable</td>
<td>运行状态，Java线程将操作系统中就绪和运行两种状态称作&quot;运行中&quot;</td>
</tr>
<tr>
<td>Blocked</td>
<td>阻塞状态，表示线程阻塞于锁</td>
</tr>
<tr>
<td>Waiting</td>
<td>等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断)</td>
</tr>
<tr>
<td>Time_Waiting</td>
<td>限时等待，不同于Waiting，可以在指定时间内自行返回</td>
</tr>
<tr>
<td>Terminated</td>
<td>终止状态，表示当前线程已执行完毕</td>
</tr>
</tbody>
</table>
<p><strong>无限期等待(Waiting)</strong></p>
<p>等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>没有设置 Timeout 参数的 Object.wait() 方法</td>
<td>Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>没有设置 Timeout 参数的 Thread.join() 方法</td>
<td>被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.park() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody>
</table>
<p><strong>限期等待(Timed Waiting)</strong></p>
<p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p>
<p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。</p>
<p>调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</p>
<p>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p>
<p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Thread.sleep() 方法</td>
<td>时间结束</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Object.wait() 方法</td>
<td>时间结束 / Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Thread.join() 方法</td>
<td>时间结束 / 被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.parkNanos() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
<tr>
<td>LockSupport.parkUntil() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody>
</table>
<h2 id="线程生命周期" tabindex="-1"> 线程生命周期</h2>
<p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态(图源《Java 并发编程艺术》4.1.4 节)。</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/Java-线程状态变迁.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示(图源《Java 并发编程艺术》4.1.4 节)：</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/RUNNABLE-VS-RUNNING.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<p>由上图可以看出：线程创建之后它将处于 <strong>NEW(新建)</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY(可运行)</strong> 状态。可运行状态的线程获得了 CPU 时间片(timeslice)后就处于 <strong>RUNNING(运行)</strong> 状态。</p>
<blockquote>
<p>操作系统隐藏 Java 虚拟机(JVM)中的 RUNNABLE 和 RUNNING 状态，它只能看到 RUNNABLE 状态(图源：<a href="https://howtodoinjava.com/" target="_blank" rel="noopener noreferrer">HowToDoInJava</a>：<a href="https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/" target="_blank" rel="noopener noreferrer">Java Thread Life Cycle and Thread States</a>)，所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE(运行中)</strong> 状态 。</p>
</blockquote>
<p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p>
<h2 id="线程的使用" tabindex="-1"> 线程的使用</h2>
<p>有三种使用线程的方法：</p>
<ul>
<li>实现 Runnable 接口；</li>
<li>实现 Callable 接口；</li>
<li>继承 Thread 类。</li>
</ul>
<p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</p>
<h3 id="实现-runnable-接口" tabindex="-1"> 实现 Runnable 接口</h3>
<p>需要实现 run() 方法。</p>
<p>通过 Thread 调用 start() 方法来启动线程。</p>
<div><pre><code><span>public</span> <span>class</span> <span>MyRunnable</span> <span>implements</span> <span>Runnable</span> <span>{</span>
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
        <span>// ...</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>MyRunnable</span> instance <span>=</span> <span>new</span> <span>MyRunnable</span><span>(</span><span>)</span><span>;</span>
    <span>Thread</span> thread <span>=</span> <span>new</span> <span>Thread</span><span>(</span>instance<span>)</span><span>;</span>
    thread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h3 id="实现-callable-接口" tabindex="-1"> 实现 Callable 接口</h3>
<p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p>
<div><pre><code><span>public</span> <span>class</span> <span>MyCallable</span> <span>implements</span> <span>Callable</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>{</span>
    <span>public</span> <span>Integer</span> <span>call</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>123</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>ExecutionException</span><span>,</span> <span>InterruptedException</span> <span>{</span>
    <span>MyCallable</span> mc <span>=</span> <span>new</span> <span>MyCallable</span><span>(</span><span>)</span><span>;</span>
    <span>FutureTask</span><span><span>&lt;</span><span>Integer</span><span>></span></span> ft <span>=</span> <span>new</span> <span>FutureTask</span><span><span>&lt;</span><span>></span></span><span>(</span>mc<span>)</span><span>;</span>
    <span>Thread</span> thread <span>=</span> <span>new</span> <span>Thread</span><span>(</span>ft<span>)</span><span>;</span>
    thread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>ft<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h3 id="继承-thread-类" tabindex="-1"> 继承 Thread 类</h3>
<p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</p>
<p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p>
<div><pre><code><span>public</span> <span>class</span> <span>MyThread</span> <span>extends</span> <span>Thread</span> <span>{</span>
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
        <span>// ...</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>MyThread</span> mt <span>=</span> <span>new</span> <span>MyThread</span><span>(</span><span>)</span><span>;</span>
    mt<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h3 id="实现接口-vs-继承-thread" tabindex="-1"> 实现接口 VS 继承 Thread</h3>
<p>实现接口会更好一些，因为：</p>
<ul>
<li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li>
<li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li>
</ul>
<h2 id="线程间通信" tabindex="-1"> 线程间通信</h2>
<h3 id="synchronized" tabindex="-1"> synchronized</h3>
<p>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p>
<p>对于同步块的实现使用了monitorenter和monitorexit指令，而同步方法则是依靠方法修饰符上的ACC_SYNCHRONIZED来完成的。无论采用哪种方式，其本质是对一个对象的监视器(monitor)进行获取，而这个获取过程是排他的，也就是同一时刻只能有一个线程获取到由synchronized所保护对象的监视器</p>
<p>任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而没有获取到监视器(执行该方法)的线程将会被阻塞在同步块和同步方法的入口处，进入BLOCKED状态。</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/对象、监视器、同步队列和执行线程之间的关系.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<p>从图中可以看到，任意线程对Object(Object由synchronized保护)的访问，首先要获得Object的监视器。如果获取失败，线程进入同步队列，线程状态变为BLOCKED。当访问Object的前驱(获得了锁的线程)释放了锁，则该释放操作唤醒阻塞在同步队列中的线程，使其重新尝试对监视器的获取。</p>
<h3 id="条件队列-wait-notify" tabindex="-1"> 条件队列(wait/notify)</h3>
<p>等待/通知的相关方法是任意Java对象都具备的，因为这些方法被定义在所有对象的超类java.lang.Object上，方法和描述如下表</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>wait()</td>
<td></td>
</tr>
<tr>
<td>wait(long)</td>
<td></td>
</tr>
<tr>
<td>wait(long,int)</td>
<td></td>
</tr>
<tr>
<td>notify()</td>
<td></td>
</tr>
<tr>
<td>notifyAll()</td>
<td></td>
</tr>
</tbody>
</table>
<p>是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。</p>
<p>调用wait()、notify()以及notifyAll()时需要注意的细节，如下:</p>
<ol>
<li>使用wait()、notify()和notifyAll()时需要先对调用对象加锁。</li>
<li>调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列。</li>
<li>notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或notifAll()的线程释放锁之后，等待线程才有机会从wait()返回。</li>
<li>notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为BLOCKED。</li>
<li>从wait()方法返回的前提是获得了调用对象的锁。</li>
</ol>
<ul>
<li>wait() 方法要以 try/catch 包覆，或是掷出 InterruptedException</li>
<li>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。</li>
</ul>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/等待通知运行过程.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<p>WaitThread首先获取了对象的锁，然后调用对象的wait()方法，从而放弃了锁并进入了对象的等待队列WaitQueue中，进入等待状态。由于WaitThread释放了对象的锁，NotifyThread随后获取了对象的锁，并调用对象的notify()方法，将WaitThread从WaitQueue移到SynchronizedQueue中，此时WaitThread的状态变为阻塞状态。NotifyThread释放了锁之后，WaitThread再次获取到锁并从wait()方法返回继续执行</p>
<p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p>
<p><strong>等待/通知</strong>的经典范式分为两部分，分别针对等待方(消费者)和通知方(生产者)</p>
<p>等待方遵循如下原则:</p>
<ol>
<li>获取对象的锁。</li>
<li>如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。</li>
<li>条件满足则执行对应的逻辑。</li>
</ol>
<p>通知方遵循如下原则:</p>
<ol>
<li>获得对象的锁。</li>
<li>改变条件。</li>
<li>通知所有等待在对象上的线程</li>
</ol>
<p><strong>wait() 和 sleep() 的区别</strong></p>
<ul>
<li>两者都可以暂停线程的执行。</li>
<li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li>
<li>两者最主要的区别在于：<strong>sleep 方法没有释放锁，而 wait 方法释放了锁</strong> 。</li>
<li>Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。</li>
<li>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。或者可以使用wait(long timeout)超时后线程会自动苏醒。sleep() 方法执行完成后，线程会自动苏醒。</li>
<li>wait()方法可以抛出异常也可以捕获异常，sleep方法必须通过try~catch块捕获异常</li>
</ul>
<h3 id="显式condition对象-await-signal" tabindex="-1"> 显式Condition对象(await/signal)</h3>
<p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</p>
<p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p>
<p>使用 Lock 来获取一个 Condition 对象。</p>
<p>synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例(即对象监视器)，<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</p>
<h3 id="join" tabindex="-1"> join()</h3>
<p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p>
<p>线程Thread除了提供join()方法之外，还提供了join(long millis)和join(longmillis,int nanos)两个具备超时特性的方法。这两个超时方法表示，如果线程thread在给定的超时时间里没有终止，那么将会从该超时方法中返回</p>
<p>join()底层就是调用wait()方法的，wait()释放锁资源，故join也释放锁资源</p>
<h3 id="threadlocal" tabindex="-1"> ThreadLocal</h3>
<p>ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。</p>
<p>可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。</p>
<p>从Thread类源代码可以看出Thread 类中有一个 threadLocals 和 一个 inheritableThreadLocals 变量，它们都是 ThreadLocalMap 类型的变量,我们可以把 ThreadLocalMap 理解为 ThreadLocal 类实现的定制化的 HashMap。默认情况下这两个变量都是null，只有当前线程调用 ThreadLocal 类的 set 或 get 方法时才创建它们，实际上调用这两个方法的时候，我们调用的是ThreadLocalMap类对应的 get()、set()方法。</p>
<p>最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。 ThrealLocal 类中可以通过Thread.currentThread()获取到当前线程对象后，直接通过getMap(Thread t)可以访问到该线程的ThreadLocalMap对象。</p>
<p>ThreadLocalMap是ThreadLocal的静态内部类。</p>
<p>ThreadLocalMap中使用开放地址法来处理散列冲突，而HashMap中使用的是分离链表法。</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/ThreadLocal内部类.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<p><strong>ThreadLocal 内存泄露问题</strong></p>
<p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用remove()方法</p>
<h1 id="二、并发机制底层原理" tabindex="-1"> 二、并发机制底层原理</h1>
<p>在多线程并发编程中synchronized和volatile都扮演着重要的角色，volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</p>
<h2 id="volatile" tabindex="-1"> volatile</h2>
<div><pre><code>    instance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span> <span>// instance是volatile变量</span>
</code></pre></div><div><pre><code>    0x01a3de1d: movb $0×0,0×1104800(%esi);
    0x01a3de24: lock addl $0×0,(%esp);
</code></pre></div><p>有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，通过查IA-32架构软件开发者手册可知，Lock前缀的指令在多核处理器下会引发了两件事情</p>
<ul>
<li>将当前处理器缓存行的数据写回到系统内存。</li>
<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li>
</ul>
<p><strong>volatile的两条实现原则</strong>。</p>
<ol>
<li>Lock前缀指令会引起处理器缓存回写到内存</li>
<li>一个处理器的缓存回写到内存会导致其他处理器的缓存无效</li>
</ol>
<h2 id="synchronized-1" tabindex="-1"> synchronized</h2>
<p>synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式。</p>
<ul>
<li>对于普通同步方法，锁是当前实例对象。</li>
<li>对于静态同步方法，锁是当前类的Class对象。</li>
<li>对于同步方法块，锁是synchonized括号里配置的对象。</li>
</ul>
<p>从JVM规范中可以看到Synchonized在JVM里的实现原理，JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。</p>
<p>代码块同步是使用monitorenter和monitorexit指令实现的，而同步方法则依靠方法修饰符上的ACC_SYNCHRONIZED来完成的。</p>
<p>无论采用哪种方式，其本质是对一个对象的监视器(monitor,monitor对象存在于每个Java对象的对象头中)进行获取，而这个获取过程是排他的，也就是同一时刻只能有一个线程获取到由synchronized所保护对象的监视器。</p>
<p>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。</p>
<h3 id="_1-java对象头" tabindex="-1"> 1. Java对象头</h3>
<p>锁存在Java对象头里。如果对象是数组类型，则虚拟机用3个Word(字宽)存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，一字宽等于四字节，即32bit。</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>32/64bit</td>
<td>Mark Word</td>
<td>存储对象的hashCode或锁信息等。</td>
</tr>
<tr>
<td>32/64bit</td>
<td>Class Metadata Address</td>
<td>存储到对象类型数据的指针</td>
</tr>
<tr>
<td>32/64bit</td>
<td>Array length</td>
<td>数组的长度(如果当前对象是数组)</td>
</tr>
</tbody>
</table>
<p>Java对象头里的Mark Word里默认存储对象的HashCode，分代年龄和锁标记位。32位JVM的Mark Word的默认存储结构如下：</p>
<p></p>
<table>
<thead>
<tr>
<th>25 bit</th>
<th>4bit</th>
<th>1bit：是否是偏向锁</th>
<th>2bit：锁标志位</th>
</tr>
</thead>
<tbody>
<tr>
<td>对象的hashCode</td>
<td>对象分代年龄</td>
<td>0</td>
<td>01</td>
</tr>
</tbody>
</table>
<p>在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据：</p>
<table>
  	<tr>
		<td rowspan="2">锁状态</td>
		<td colspan="2">25 bit</td>
		<td rowspan="2">4 bit </td>
		<td>1 bit</td>
		<td>2 bit</td>
	</tr>
    <tr>
		<td>23 bit</td>
		<td>2 bit</td>
		<td>是否是偏向锁</td>
		<td>锁标志位</td>
	</tr>
    <tr>
        <td>无锁状态</td>
		<td colspan="2">对象的hashCode</td>
		<td>对象分代年龄</td>
		<td>0</td>
		<td>01</td>
    </tr>
	<tr>
        <td>轻量级锁</td>
		<td colspan="4">指向栈中锁记录的指针</td>
		<td>00</td>
    </tr>
    <tr>
        <td>重量级锁</td>
		<td colspan="4">指向互斥量(重量级锁)(monitor)的指针</td>
		<td>10</td>
    </tr>
    <tr>
        <td>偏向锁</td>
        <td>线程ID</td>
		<td>Epoch</td>
		<td>对象分代年龄</td>
		<td>1</td>
		<td>01</td>
    </tr>
    <tr>
        <td>GC标记</td>
		<td colspan="4">空</td>
		<td>11</td>
    </tr>
</table>
<h4 id="hashcode-分代年龄等信息" tabindex="-1"> hashcode，分代年龄等信息</h4>
<p>偏向锁</p>
<ul>
<li>当一个对象已经计算过identity hash code，它就无法进入偏向锁状态</li>
<li>当一个对象当前正处于偏向锁状态，并且需要计算其identity hash code的话，则它的偏向锁会被撤销，并且锁会膨胀为重量锁</li>
<li>在偏向锁中，哈希码和线程ID复用同一块空间，HotSpot VM是以实际上只有很少对象会计算identity hash code为前提来进行了优化，所以对象没有计算哈希码的时候可以使用偏向锁，一但计算之后，空间被占用则不能再使用偏向锁了。</li>
</ul>
<p>轻量级锁</p>
<ul>
<li>虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方为这份拷贝加了一个Displaced前缀，即Displaced Mark Word）。然后，虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针</li>
</ul>
<p>重量级锁</p>
<ul>
<li>重量锁的实现中，ObjectMonitor类里有字段可以记录非加锁状态下的Mark Word，其中可以存储identity hash code的值。或者简单说就是重量锁可以存下identity hash code。ObjectMonitor是虚拟机中的一个C++类。</li>
</ul>
<h3 id="_2-锁的升级" tabindex="-1"> 2. 锁的升级</h3>
<p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在 Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p>

<h3 id="_3-偏向锁" tabindex="-1"> 3. 偏向锁</h3>
<p>大多数情况下，锁不仅不存在多线程竞争，而且总是由同 一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出 同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1(表示当前是偏向锁)：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
<h4 id="偏向锁的撤销" tabindex="-1"> 偏向锁的撤销</h4>
<p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点(在这个时间点上没有字节码正在执行)，它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。下图中的线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程。</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/偏向锁初始化的流程.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-29-11-29-13.png" alt="" loading="lazy"></p>
<h4 id="偏向锁的关闭" tabindex="-1"> 偏向锁的关闭</h4>
<p>偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟-XX：BiasedLockingStartupDelay = 0。如果你确定自己应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁-XX:-UseBiasedLocking=false，那么默认会进入轻量级锁状态。</p>
<h3 id="_4-轻量级锁" tabindex="-1"> 4. 轻量级锁</h3>
<p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p>
<p>轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p>
<h4 id="轻量级锁加锁" tabindex="-1"> 轻量级锁加锁</h4>
<p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>
<h4 id="轻量级锁解锁" tabindex="-1"> 轻量级锁解锁</h4>
<p>轻量级解锁时，会使用原子的CAS操作来将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/争夺锁导致的锁膨胀流程图.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<p>因为自旋会消耗CPU，为了避免无用的自旋(比如获得锁的线程被阻塞住了)，一旦锁升级 成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时， 都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮 的夺锁之争</p>
<h3 id="_5-锁的对比" tabindex="-1"> 5. 锁的对比</h3>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td>
<td>适用于只有一个线程访问同步块场景。</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度。</td>
<td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td>
<td>追求响应时间。同步块执行速度非常快。</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU。</td>
<td>线程阻塞，响应时间缓慢。</td>
<td>追求吞吐量。     同步块执行速度较长。</td>
</tr>
</tbody>
</table>
<h3 id="_6-synchronized-对比-volatile" tabindex="-1"> 6. synchronized 对比 volatile</h3>
<ul>
<li>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。</li>
<li>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</li>
<li>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</li>
<li>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
<h2 id="原子操作的实现" tabindex="-1"> 原子操作的实现</h2>
<p>原子(atomic)本意是“不能被进一步分割的最小粒子”，而原子操作(atomic operation)意 为“不可被中断的一个或一系列操作”。</p>
<h3 id="处理器实现原子操作" tabindex="-1"> 处理器实现原子操作</h3>
<ol>
<li>使用<strong>总线锁</strong>保证原子性：处理器使用总线锁就是来解决这个问题的。所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存</li>
<li>使用<strong>缓存锁</strong>保证原子性：在同一时刻，我们只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。</li>
</ol>
<h3 id="java实现原子操作" tabindex="-1"> Java实现原子操作</h3>
<ol>
<li>使用<strong>循环CAS</strong>实现原子操作：JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止
<ul>
<li>硬件支持的原子性操作最典型的是：比较并交换(Compare-and-Swap，CAS)。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</li>
</ul>
</li>
<li>使用<strong>锁机制</strong>实现原子操作：锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</li>
</ol>
<p><strong>CAS实现原子操作的三大问题</strong></p>
<ol>
<li>ABA问题
<ul>
<li>因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</li>
</ul>
</li>
<li>循环时间长开销大
<ul>
<li>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销</li>
</ul>
</li>
<li>只能保证一个共享变量的原子操作
<ul>
<li>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作</li>
</ul>
</li>
</ol>
<h1 id="三、线程安全与锁优化" tabindex="-1"> 三、线程安全与锁优化</h1>
<h2 id="线程安全" tabindex="-1"> 线程安全</h2>
<p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的</p>
<h3 id="java语言中的线程安全" tabindex="-1"> Java语言中的线程安全</h3>
<p>Java语言中各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立</p>
<ol>
<li>不可变
<ul>
<li>不可变(Immutable)的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施，只要一个不可变的对象被正确地构建出来(没有发生this引用逃逸的情况)，那其外部的可见状态永远也不会改变，永远也不会看到它在多个线程之中处于不一致的状态。“不可变”带来的安全性是最简单和最纯粹的。</li>
</ul>
</li>
<li>绝对线程安全
<ul>
<li>一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”通常需要付出很大的，甚至有时候是不切实际的代价。在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。</li>
</ul>
</li>
<li>相对线程安全
<ul>
<li>通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</li>
</ul>
</li>
<li>线程兼容
<ul>
<li>指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。</li>
</ul>
</li>
<li>线程对立
<ul>
<li>指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于Java语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。</li>
</ul>
</li>
</ol>
<h3 id="线程安全的实现方法" tabindex="-1"> 线程安全的实现方法</h3>
<h4 id="互斥同步" tabindex="-1"> 互斥同步</h4>
<p>互斥同步(Mutual Exclusion＆Synchronization)是常见的一种并发正确性保障手段。</p>
<p>同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个(或者是一些，使用信号量的时候)线程使用。</p>
<p>而互斥是实现同步的一种手段，临界区(Critical Section)、互斥量(Mutex)和信号量(Semaphore)都是主要的互斥实现方式。</p>
<h4 id="非阻塞同步" tabindex="-1"> 非阻塞同步</h4>
<p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p>
<p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p>
<p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(不断地重试，直到成功为止)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p>
<p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换(Compare-and-Swap，CAS)。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p>
<h4 id="无同步方案" tabindex="-1"> 无同步方案</h4>
<p>同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的，</p>
<ol>
<li>栈封闭</li>
</ol>
<p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p>
<div><pre><code><span>public</span> <span>class</span> <span>StackClosedExample</span> <span>{</span>
    <span>public</span> <span>void</span> <span>add100</span><span>(</span><span>)</span> <span>{</span>
        <span>int</span> cnt <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>100</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            cnt<span>++</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>cnt<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>StackClosedExample</span> example <span>=</span> <span>new</span> <span>StackClosedExample</span><span>(</span><span>)</span><span>;</span>
    <span>ExecutorService</span> executorService <span>=</span> <span>Executors</span><span>.</span><span>newCachedThreadPool</span><span>(</span><span>)</span><span>;</span>
    executorService<span>.</span><span>execute</span><span>(</span><span>(</span><span>)</span> <span>-></span> example<span>.</span><span>add100</span><span>(</span><span>)</span><span>)</span><span>;</span>
    executorService<span>.</span><span>execute</span><span>(</span><span>(</span><span>)</span> <span>-></span> example<span>.</span><span>add100</span><span>(</span><span>)</span><span>)</span><span>;</span>
    executorService<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code>100
100
</code></pre></div><ol start="2">
<li>线程本地存储(Thread Local Storage)</li>
</ol>
<p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p>
<p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式(如“生产者-消费者”模式)都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”(Thread-per-Request)的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p>
<p>可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。</p>
<p>对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p>
<div><pre><code><span>public</span> <span>class</span> <span>ThreadLocalExample</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>ThreadLocal</span> threadLocal <span>=</span> <span>new</span> <span>ThreadLocal</span><span>(</span><span>)</span><span>;</span>
        <span>Thread</span> thread1 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
            threadLocal<span>.</span><span>set</span><span>(</span><span>1</span><span>)</span><span>;</span>
            <span>try</span> <span>{</span>
                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>
            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>threadLocal<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>
            threadLocal<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>
        <span>Thread</span> thread2 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
            threadLocal<span>.</span><span>set</span><span>(</span><span>2</span><span>)</span><span>;</span>
            threadLocal<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>
        thread1<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        thread2<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><div><pre><code>1
</code></pre></div><p>为了理解 ThreadLocal，先看以下代码：</p>
<div><pre><code><span>public</span> <span>class</span> <span>ThreadLocalExample1</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>ThreadLocal</span> threadLocal1 <span>=</span> <span>new</span> <span>ThreadLocal</span><span>(</span><span>)</span><span>;</span>
        <span>ThreadLocal</span> threadLocal2 <span>=</span> <span>new</span> <span>ThreadLocal</span><span>(</span><span>)</span><span>;</span>
        <span>Thread</span> thread1 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
            threadLocal1<span>.</span><span>set</span><span>(</span><span>1</span><span>)</span><span>;</span>
            threadLocal2<span>.</span><span>set</span><span>(</span><span>1</span><span>)</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>
        <span>Thread</span> thread2 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
            threadLocal1<span>.</span><span>set</span><span>(</span><span>2</span><span>)</span><span>;</span>
            threadLocal2<span>.</span><span>set</span><span>(</span><span>2</span><span>)</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>
        thread1<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        thread2<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>它所对应的底层结构图为：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6782674c-1bfe-4879-af39-e9d722a95d39.png" width="500px"> </div><br>
<p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。</p>
<div><pre><code><span>/* ThreadLocal values pertaining to this thread. This map is maintained
 * by the ThreadLocal class. */</span>
<span>ThreadLocal<span>.</span>ThreadLocalMap</span> threadLocals <span>=</span> <span>null</span><span>;</span>
</code></pre></div><p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。</p>
<div><pre><code><span>public</span> <span>void</span> <span>set</span><span>(</span><span>T</span> value<span>)</span> <span>{</span>
    <span>Thread</span> t <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>;</span>
    <span>ThreadLocalMap</span> map <span>=</span> <span>getMap</span><span>(</span>t<span>)</span><span>;</span>
    <span>if</span> <span>(</span>map <span>!=</span> <span>null</span><span>)</span>
        map<span>.</span><span>set</span><span>(</span><span>this</span><span>,</span> value<span>)</span><span>;</span>
    <span>else</span>
        <span>createMap</span><span>(</span>t<span>,</span> value<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><p>get() 方法类似。</p>
<div><pre><code><span>public</span> <span>T</span> <span>get</span><span>(</span><span>)</span> <span>{</span>
    <span>Thread</span> t <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>;</span>
    <span>ThreadLocalMap</span> map <span>=</span> <span>getMap</span><span>(</span>t<span>)</span><span>;</span>
    <span>if</span> <span>(</span>map <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>ThreadLocalMap<span>.</span>Entry</span> e <span>=</span> map<span>.</span><span>getEntry</span><span>(</span><span>this</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>e <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>@SuppressWarnings</span><span>(</span><span>"unchecked"</span><span>)</span>
            <span>T</span> result <span>=</span> <span>(</span><span>T</span><span>)</span>e<span>.</span>value<span>;</span>
            <span>return</span> result<span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>setInitialValue</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p>
<p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。</p>
<ol start="3">
<li>可重入代码(Reentrant Code)</li>
</ol>
<p>这种代码也叫做纯代码(Pure Code)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。</p>
<p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p>
<h2 id="锁优化" tabindex="-1"> 锁优化</h2>
<ol>
<li>自旋锁</li>
<li>自旋锁的其他种类</li>
<li>阻塞锁</li>
<li>可重入锁</li>
<li>读写锁</li>
<li>互斥锁</li>
<li>悲观锁</li>
<li>乐观锁</li>
<li>公平锁</li>
<li>非公平锁</li>
<li>偏向锁</li>
<li>对象锁</li>
<li>线程锁</li>
<li>锁粗化</li>
<li>轻量级锁</li>
<li>锁消除</li>
<li>锁膨胀</li>
<li>信号量</li>
</ol>
<p>高效并发是从JDK 1.5到JDK 1.6的一个重要改进，锁优化主要是指 JVM 对 synchronized 的优化</p>
<h3 id="自旋锁" tabindex="-1"> 自旋锁</h3>
<p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环(自旋)一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p>
<p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p>
<p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p>
<h3 id="锁消除" tabindex="-1"> 锁消除</h3>
<p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p>
<p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p>
<p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p>
<div><pre><code><span>public</span> <span>static</span> <span>String</span> <span>concatString</span><span>(</span><span>String</span> s1<span>,</span> <span>String</span> s2<span>,</span> <span>String</span> s3<span>)</span> <span>{</span>
    <span>return</span> s1 <span>+</span> s2 <span>+</span> s3<span>;</span>
<span>}</span>
</code></pre></div><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</p>
<div><pre><code><span>public</span> <span>static</span> <span>String</span> <span>concatString</span><span>(</span><span>String</span> s1<span>,</span> <span>String</span> s2<span>,</span> <span>String</span> s3<span>)</span> <span>{</span>
    <span>StringBuffer</span> sb <span>=</span> <span>new</span> <span>StringBuffer</span><span>(</span><span>)</span><span>;</span>
    sb<span>.</span><span>append</span><span>(</span>s1<span>)</span><span>;</span>
    sb<span>.</span><span>append</span><span>(</span>s2<span>)</span><span>;</span>
    sb<span>.</span><span>append</span><span>(</span>s3<span>)</span><span>;</span>
    <span>return</span> sb<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><p>每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</p>
<h3 id="锁粗化" tabindex="-1"> 锁粗化</h3>
<p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p>
<p>上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展(粗化)到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p>
<h1 id="四、java内存模型" tabindex="-1"> 四、Java内存模型</h1>
<p>在并发编程中，需要处理两个关键问题：线程之间如何通信及线程之间如何同步(这里的线程是指并发执行的活动实体)。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。</p>
<p>在共享内存的并发模型里，线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过发送消息来显式进行通信。</p>
<p>同步是指程序中用于控制不同线程间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p>
<p>Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p>
<p>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p>
<h2 id="主内存与工作内存" tabindex="-1"> 主内存与工作内存</h2>
<p>在Java中，所有实例域、静态域和数组元素都存储在堆内存中，堆内存在线程之间共享。局部变量(Local Variables)，方法定义参数(Java语言规范称之为Formal Method Parameters)和异常处理器参数(Exception Handler Parameters)不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p>
<p>JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地 内存(Local Memory)，本地内存中存储了该线程以读/写共享变量的副本。</p>
<p>处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。</p>
<p>加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/942ca0d2-9d5c-45a4-89cb-5fd89b61913f.png" width="600px"> </div><br>
<p>所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。</p>
<p>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/15851555-5abc-497d-ad34-efed10f43a6b.png" width="600px"> </div><br>
<h2 id="内存间交互操作" tabindex="-1"> 内存间交互操作</h2>
<p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8b7ebbad-9604-4375-84e3-f412099d170c.png" width="450px"> </div><br>
<ul>
<li>read：把一个变量的值从主内存传输到工作内存中</li>
<li>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li>
<li>use：把工作内存中一个变量的值传递给执行引擎</li>
<li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li>
<li>store：把工作内存的一个变量的值传送到主内存中</li>
<li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中</li>
<li>lock：作用于主内存的变量</li>
<li>unlock</li>
</ul>
<h2 id="内存模型三大特性" tabindex="-1"> 内存模型三大特性</h2>
<h3 id="_1-原子性" tabindex="-1"> 1. 原子性</h3>
<p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据(long，double)的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。</p>
<p>如果有多个线程共享一个并未声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改值的代表了“半个变量”的数值。</p>
<p>不过这种读取到“半个变量”的情况非常罕见(在目前商用Java虚拟机中不会出现)，因为Java内存模型虽然允许虚拟机不把long和double变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还“强烈建议”虚拟机这样实现。</p>
<p>有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。</p>
<p>为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。</p>
<p>下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2797a609-68db-4d7b-8701-41ac9a34b14f.jpg" width="300px"> </div><br>
<p>AtomicInteger 能保证多个线程修改的原子性。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dd563037-fcaa-4bd8-83b6-b39d93a12c77.jpg" width="300px"> </div><br>
<p>使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现：</p>
<div><pre><code><span>public</span> <span>class</span> <span>AtomicExample</span> <span>{</span>
    <span>private</span> <span>AtomicInteger</span> cnt <span>=</span> <span>new</span> <span>AtomicInteger</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>void</span> <span>add</span><span>(</span><span>)</span> <span>{</span>
        cnt<span>.</span><span>incrementAndGet</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>get</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> cnt<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
    <span>final</span> <span>int</span> threadSize <span>=</span> <span>1000</span><span>;</span>
    <span>AtomicExample</span> example <span>=</span> <span>new</span> <span>AtomicExample</span><span>(</span><span>)</span><span>;</span> <span>// 只修改这条语句</span>
    <span>final</span> <span>CountDownLatch</span> countDownLatch <span>=</span> <span>new</span> <span>CountDownLatch</span><span>(</span>threadSize<span>)</span><span>;</span>
    <span>ExecutorService</span> executorService <span>=</span> <span>Executors</span><span>.</span><span>newCachedThreadPool</span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> threadSize<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        executorService<span>.</span><span>execute</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
            example<span>.</span><span>add</span><span>(</span><span>)</span><span>;</span>
            countDownLatch<span>.</span><span>countDown</span><span>(</span><span>)</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>
    <span>}</span>
    countDownLatch<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>
    executorService<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>example<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><pre><code>1000
</code></pre></div><p>除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。</p>
<div><pre><code><span>public</span> <span>class</span> <span>AtomicSynchronizedExample</span> <span>{</span>
    <span>private</span> <span>int</span> cnt <span>=</span> <span>0</span><span>;</span>

    <span>public</span> <span>synchronized</span> <span>void</span> <span>add</span><span>(</span><span>)</span> <span>{</span>
        cnt<span>++</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>synchronized</span> <span>int</span> <span>get</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> cnt<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
    <span>final</span> <span>int</span> threadSize <span>=</span> <span>1000</span><span>;</span>
    <span>AtomicSynchronizedExample</span> example <span>=</span> <span>new</span> <span>AtomicSynchronizedExample</span><span>(</span><span>)</span><span>;</span>
    <span>final</span> <span>CountDownLatch</span> countDownLatch <span>=</span> <span>new</span> <span>CountDownLatch</span><span>(</span>threadSize<span>)</span><span>;</span>
    <span>ExecutorService</span> executorService <span>=</span> <span>Executors</span><span>.</span><span>newCachedThreadPool</span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> threadSize<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        executorService<span>.</span><span>execute</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
            example<span>.</span><span>add</span><span>(</span><span>)</span><span>;</span>
            countDownLatch<span>.</span><span>countDown</span><span>(</span><span>)</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>
    <span>}</span>
    countDownLatch<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>
    executorService<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>example<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><pre><code>1000
</code></pre></div><h3 id="_2-可见性" tabindex="-1"> 2. 可见性</h3>
<p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p>
<p>主要有三种实现可见性的方式：</p>
<ul>
<li>volatile，关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序。</li>
<li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li>
<li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸(其它线程通过 this 引用访问到初始化了一半的对象)，那么其它线程就能看见 final 字段的值。</li>
</ul>
<p>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。</p>
<h4 id="synchronized关键字和volatile关键字比较" tabindex="-1"> synchronized关键字和volatile关键字比较</h4>
<ul>
<li><strong>volatile关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以<strong>volatile性能肯定比synchronized关键字要好</strong>。但是<strong>volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块</strong>。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，<strong>实际开发中使用 synchronized 关键字的场景还是更多一些</strong>。</li>
<li><strong>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</strong></li>
<li><strong>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</strong></li>
<li><strong>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。</strong></li>
</ul>
<p><strong>双重校验锁实现对象单例(线程安全)</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>

    <span>private</span> <span>volatile</span> <span>static</span> <span>Singleton</span> uniqueInstance<span>;</span>

    <span>private</span> <span>Singleton</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>Singleton</span> <span>getUniqueInstance</span><span>(</span><span>)</span> <span>{</span>
       <span>//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span>
        <span>if</span> <span>(</span>uniqueInstance <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>//类对象加锁</span>
            <span>synchronized</span> <span>(</span><span>Singleton</span><span>.</span><span>class</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span>uniqueInstance <span>==</span> <span>null</span><span>)</span> <span>{</span>
                    uniqueInstance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> uniqueInstance<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。</p>
<p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：</p>
<ol>
<li>为 uniqueInstance 分配内存空间</li>
<li>初始化 uniqueInstance</li>
<li>将 uniqueInstance 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出先问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p>
<p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<h3 id="_3-有序性" tabindex="-1"> 3. 有序性</h3>
<p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</p>
<p>也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。</p>
<h2 id="先行发生-happens-before-原则" tabindex="-1"> 先行发生(happens-before)原则</h2>
<p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p>
<ol>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li>
<li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法(也就是说，JMM允许这种重排序)。</li>
</ol>
<p>上面的 1 是JMM对程序员的承诺；2 是JMM对编译器和处理器重排序的约束原则。</p>
<ul>
<li>as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。</li>
<li>as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。</li>
</ul>
<p>as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</p>
<h3 id="_1-单一线程原则" tabindex="-1"> 1. 单一线程原则</h3>
<blockquote>
<p>Single Thread rule</p>
</blockquote>
<p>在一个线程内，在程序前面的操作先行发生于后面的操作。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/874b3ff7-7c5c-4e7a-b8ab-a82a3e038d20.png" width="180px"> </div><br>
<h3 id="_2-管程锁定规则" tabindex="-1"> 2. 管程锁定规则</h3>
<blockquote>
<p>Monitor Lock Rule</p>
</blockquote>
<p>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8996a537-7c4a-4ec8-a3b7-7ef1798eae26.png" width="350px"> </div><br>
<h3 id="_3-volatile-变量规则" tabindex="-1"> 3. volatile 变量规则</h3>
<blockquote>
<p>Volatile Variable Rule</p>
</blockquote>
<p>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/942f33c9-8ad9-4987-836f-007de4c21de0.png" width="400px"> </div><br>
<h3 id="_4-线程启动规则" tabindex="-1"> 4. 线程启动规则</h3>
<blockquote>
<p>Thread Start Rule</p>
</blockquote>
<p>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6270c216-7ec0-4db7-94de-0003bce37cd2.png" width="380px"> </div><br>
<h3 id="_5-线程加入规则" tabindex="-1"> 5. 线程加入规则</h3>
<blockquote>
<p>Thread Join Rule</p>
</blockquote>
<p>Thread 对象的结束先行发生于 join() 方法返回。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/233f8d89-31d7-413f-9c02-042f19c46ba1.png" width="400px"> </div><br>
<h3 id="_6-线程中断规则" tabindex="-1"> 6. 线程中断规则</h3>
<blockquote>
<p>Thread Interruption Rule</p>
</blockquote>
<p>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p>
<h3 id="_7-对象终结规则" tabindex="-1"> 7. 对象终结规则</h3>
<blockquote>
<p>Finalizer Rule</p>
</blockquote>
<p>一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始。</p>
<h3 id="_8-传递性" tabindex="-1"> 8. 传递性</h3>
<blockquote>
<p>Transitivity</p>
</blockquote>
<p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</p>
<h2 id="指令重排序" tabindex="-1"> 指令重排序</h2>
<p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。</p>
<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ol>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/从源码到最终执行的指令序列的示意图.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<p>上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序(不是所有的编译器重排序都要禁止)。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障(Memory Barriers，Intel称之为Memory Fence)指令，通过内存屏障指令来禁止特定类型的处理器重排序。</p>
<p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<h3 id="内存屏障" tabindex="-1"> 内存屏障</h3>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LoadLoad Barriers</td>
<td>确保Load1数据的装载先于Load2及所有后序装置指令的装载</td>
</tr>
<tr>
<td>StoreStore Barriers</td>
<td>确保Store1数据对其他处理器可见(刷新到内存)先于Store2及所有后序存储指令的存储</td>
</tr>
<tr>
<td>LoadStore Barriers</td>
<td>确保Load1数据装载先于Store2及所有后序的存储指令刷新到内存</td>
</tr>
<tr>
<td>StoreLoad Barriers</td>
<td>确保Store1数据对其他处理器变得可见(刷新到内存)先于Load2及所有后序装载指令的装载。使该屏障之前的所有内存访问指令(存储和装载指令)完成之后，才执行该屏障之后的内存访问指令</td>
</tr>
</tbody>
</table>
<p>StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他3个屏障的效果。现代的多处理器大多支持该屏障(其他类型的屏障不一定被所有处理器支持)。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中(Buffer Fully Flush)</p>
<h3 id="数据依赖性" tabindex="-1"> 数据依赖性</h3>
<p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。</p>
<p>编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p>
<p>这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p>
<h3 id="as-if-serial语义" tabindex="-1"> as-if-serial语义</h3>
<p>as-if-serial语义的意思是：不管怎么重排序(编译器和处理器为了提高并行度)，(单线程)程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p>
<p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p>
<h3 id="顺序一致性" tabindex="-1"> 顺序一致性</h3>
<p>顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参照</p>
<p>JMM对正确同步的多线程程序的内存一致性做了如下保证。如果程序是正确同步的，程序的执行将具有顺序一致性(Sequentially Consistent)——即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。马上我们就会看到，这对于程序员来说是一个极强的保证。这里的同步是指广义上的同步，包括对常用同步原语(synchronized、volatile和final)的正确使用。</p>
<p>顺序一致性内存模型有两大特性。</p>
<ol>
<li>一个线程中的所有操作必须按照程序的顺序来执行。</li>
<li>(不管程序是否同步)所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li>
</ol>
<p>未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。</p>
<p>但是，在JMM中就没有这个保证。未同步程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。</p>
<h2 id="内存语义" tabindex="-1"> 内存语义</h2>
<h3 id="volatile内存语义" tabindex="-1"> volatile内存语义</h3>
<p>volatile变量自身具有下列特性：</p>
<ul>
<li>可见性。对一个volatile变量的读，总是能看到(任意线程)对这个volatile变量最后的写入。</li>
<li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。</li>
</ul>
<p>从内存语义的角度来说，volatile的写-读与锁的释放-获取有相同的内存效果：volatile写和锁的释放有相同的内存语义；volatile读与锁的获取有相同的内存语义。</p>
<ul>
<li>volatile写的内存语义：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</li>
<li>volatile读的内存语义：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li>
</ul>
<p>总结：</p>
<ul>
<li>线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出了(其对共享变量所做修改的)消息。</li>
<li>线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的(在写这个volatile变量之前对共享变量所做修改的)消息。</li>
<li>线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。</li>
</ul>
<h4 id="volatile内存语义的实现" tabindex="-1"> volatile内存语义的实现</h4>
<p>为了实现volatile内存语义，JMM会分别限制这编译器重排序和处理器重排序。</p>
<p>volatile重排序规则表如下：</p>
<table>
<thead>
<tr>
<th>第一个操作/第二个操作</th>
<th>普通读/写</th>
<th>volatile读</th>
<th>volatile写</th>
</tr>
</thead>
<tbody>
<tr>
<td>普通读/写</td>
<td></td>
<td></td>
<td>No</td>
</tr>
<tr>
<td>volatile读</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>volatile写</td>
<td></td>
<td>No</td>
<td>No</td>
</tr>
</tbody>
</table>
<ul>
<li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li>
<li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</li>
<li>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</li>
</ul>
<p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p>
<p>基于保守策略的JMM内存屏障插入策略。</p>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障。</li>
</ul>
<p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。</p>
<p>为了保证能正确实现volatile的内存语义，JMM在采取了保守策略：在每个volatile写的后面，或者在每个volatile读的前面插入一个StoreLoad屏障。从整体执行效率的角度考虑，JMM最终选择了在每个volatile写的后面插入一个StoreLoad屏障。因为volatile写-读内存语义的常见使用模式是：一个写线程写volatile变量，多个读线程读同一个volatile变量。当读线程的数量大大超过写线程时，选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。从这里可以看到JMM在实现上的一个特点：首先确保正确性，然后再去追求执行效率。</p>
<h3 id="锁的内存语义" tabindex="-1"> 锁的内存语义</h3>
<ul>
<li>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中</li>
<li>当线程获取锁时，JMM会把该线程对应的本地内存置为无效。</li>
</ul>
<p>锁释放和锁获取的内存语义总结：</p>
<ul>
<li>线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了(线程A对共享变量所做修改的)消息。</li>
<li>线程B获取一个锁，实质上是线程B接收了之前某个线程发出的(在释放这个锁之前对共享变量所做修改的)消息。</li>
<li>线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。</li>
</ul>
<p>由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上，锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。</p>
<h4 id="锁内存语义的实现" tabindex="-1"> 锁内存语义的实现</h4>
<p>ReentrantLock的实现依赖于Java同步器框架AbstractQueuedSynchronizer(本文简称之为AQS)。AQS使用一个整型的volatile变量(命名为state)来维护同步状态，这个volatile变量是ReentrantLock内存语义实现的关键</p>
<p>公平锁和非公平锁的内存语义做个总结：</p>
<ul>
<li>公平锁和非公平锁释放时，最后都要写一个volatile变量state。</li>
<li>公平锁获取时，首先会去读volatile变量。</li>
<li>非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volatile读和volatile写的内存语义。</li>
</ul>
<p>锁释放-获取的内存语义的实现至少有下面两种方式：</p>
<ol>
<li>利用volatile变量的写-读所具有的内存语义</li>
<li>利用CAS所附带的volatile读和volatile写的内存语义</li>
</ol>
<h4 id="concurrent包的实现" tabindex="-1"> concurrent包的实现</h4>
<p>由于Java的CAS同时具有volatile读和volatile写的内存语义，因此Java线程之间的通信现在有了下面4种方式：</p>
<ol>
<li>A线程写volatile变量，随后B线程读这个volatile变量。</li>
<li>A线程写volatile变量，随后B线程用CAS更新这个volatile变量。</li>
<li>A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。</li>
<li>A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。</li>
</ol>
<p>仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式。首先，声明共享变量为volatile。然后，使用CAS的原子条件更新来实现线程之间的同步。同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。</p>
<p>AQS，非阻塞数据结构和原子变量类(java.util.concurrent.atomic包中的类)，这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent包的实现示意图如下所示</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/concurrent包的实现示意图.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<h3 id="final内存语义" tabindex="-1"> final内存语义</h3>
<p>对final域的读和写更像是普通的变量访问。</p>
<h4 id="final域的重排序规则" tabindex="-1"> final域的重排序规则</h4>
<p>对于final域，编译器和处理器要遵守两个重排序规则：</p>
<ol>
<li>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序</li>
<li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序</li>
</ol>
<h4 id="写final域的重排序规则" tabindex="-1"> 写final域的重排序规则</h4>
<p>写final域的重排序规则禁止把final域的写重排序到构造函数之外。这个规则的实现包含下面2个方面：</p>
<ol>
<li>JMM禁止编译器把final域的写重排序到构造函数之外。</li>
<li>编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。</li>
</ol>
<p>写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。(前提是对象引用不能在构造函数中逸出：在构造函数内部，不能让这个被构造对象的引用为其他线程所见，也就是对象引用不能在构造函数中“逸出”。)</p>
<h4 id="读final域的重排序规则" tabindex="-1"> 读final域的重排序规则</h4>
<p>读final域的重排序规则是，在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作(注意，这个规则仅仅针对处理器)。编译器会在读final域操作的前面插入一个LoadLoad屏障</p>
<p>读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。</p>
<h1 id="五、java中的锁" tabindex="-1"> 五、Java中的锁</h1>
<h2 id="lock接口" tabindex="-1"> Lock接口</h2>
<p>在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而Java SE 5之后，并发包中新增了Lock接口(以及相关实现类)用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。虽然它缺少了(通过synchronized块或者方法所提供的)隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。</p>
<div><pre><code>    <span>Lock</span> lock <span>=</span> <span>new</span> <span>ReentrantLock</span><span>(</span><span>)</span><span>;</span>
    lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>
    <span>try</span> <span>{</span>
    <span>}</span> <span>finally</span> <span>{</span>
    lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
</code></pre></div><p>在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。</p>
<p>不要将获取锁的过程写在try块中，因为如果在获取锁(自定义锁的实现)时发生了异常，异常抛出的同时，也会导致锁无故释放。</p>
<p>Lock接口提供的synchronized关键字不具备的主要特性:</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>尝试非阻塞地获取锁</td>
<td>当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁</td>
</tr>
<tr>
<td>能被中断地获取锁</td>
<td>获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放</td>
</tr>
<tr>
<td>超时获取锁</td>
<td>在指定的截止时间之前获取锁，如果截止时间到了仍旧无法获取锁，则返回</td>
</tr>
</tbody>
</table>
<h2 id="队列同步器" tabindex="-1"> 队列同步器</h2>
<p>队列同步器AbstractQueuedSynchronizer(以下简称同步器)，是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作</p>
<p>同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改。子类推荐被定义为自定义同步组件的静态内部类(自定义同步组件将相应功能委托给AQS子类来实现)，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件(ReentrantLock、ReentrantReadWriteLock和CountDownLatch等)。</p>
<p>同步器提供如下3个方法来访问或修改同步状态(int成员变量)：</p>
<ol>
<li>getState()：获取当前同步状态</li>
<li>setState(int newState)：设置当前同步状态</li>
<li>compareAndSetState(int expect, int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性。</li>
</ol>
<p>同步器可重写的方法</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>protected boolean tryAcquire(int arg)</td>
<td>独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行CAS设置同步状态</td>
</tr>
<tr>
<td>protected boolean tryRelease(int arg)</td>
<td>独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态</td>
</tr>
<tr>
<td>protected int tryAcquireShared(int arg)</td>
<td>共享式获取同步状态，返回大于等于0的值，表示获取成功，反之失败</td>
</tr>
<tr>
<td>protected boolean tryReleaseShared(int arg)</td>
<td>共享式释放同步状态</td>
</tr>
<tr>
<td>protected boolean isHeldExclusively()</td>
<td>当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占</td>
</tr>
</tbody>
</table>
<p>实现自定义同步组件时，将会调用同步器提供的模板方法，</p>
<p>同步器提供的模板方法基本上分为3类：独占式获取与释放同步状态、共享式获取与释放同步状态和查询同步队列中的等待线程情况。自定义同步组件将使用同步器提供的模板方法来实现自己的同步语义。</p>
<h3 id="队列同步器的实现" tabindex="-1"> 队列同步器的实现</h3>
<ol>
<li><strong>同步队列</strong></li>
</ol>
<p>同步器依赖内部的同步队列(一个FIFO双向队列)来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点(Node)并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。</p>
<p>节点是构成同步队列(等待队列)的基础，同步器拥有首节点(head)和尾节点(tail)，没有成功获取同步状态的线程将会成为节点加入该队列的尾部。</p>
<ol start="2">
<li><strong>独占式同步状态获取与释放</strong></li>
</ol>
<p>通过调用同步器的acquire(int arg)方法可以获取同步状态，该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移出，</p>
<div><pre><code>    <span>public</span> <span>final</span> <span>void</span> <span>acquire</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span><span>tryAcquire</span><span>(</span>arg<span>)</span> <span>&amp;&amp;</span>
            <span>acquireQueued</span><span>(</span><span>addWaiter</span><span>(</span><span>Node</span><span>.</span>EXCLUSIVE<span>)</span><span>,</span> arg<span>)</span><span>)</span>
            <span>selfInterrupt</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
</code></pre></div><p>当前线程获取同步状态并执行了相应逻辑之后，就需要释放同步状态，使得后续节点能够继续获取同步状态。通过调用同步器的release(int arg)方法可以释放同步状态，该方法在释放了同步状态之后，会唤醒其后继节点(进而使后继节点重新尝试获取同步状态)。</p>
<div><pre><code>    <span>public</span> <span>final</span> <span>boolean</span> <span>release</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>tryRelease</span><span>(</span>arg<span>)</span><span>)</span> <span>{</span>
            <span>Node</span> h <span>=</span> head<span>;</span>
            <span>if</span> <span>(</span>h <span>!=</span> <span>null</span> <span>&amp;&amp;</span> h<span>.</span>waitStatus <span>!=</span> <span>0</span><span>)</span>
                <span>unparkSuccessor</span><span>(</span>h<span>)</span><span>;</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
</code></pre></div><p>在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列
(或停止自旋)的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后继节点。</p>
<ol start="3">
<li><strong>共享式同步状态获取与释放</strong></li>
</ol>
<p>共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态。</p>
<p>通过调用同步器的acquireShared(int arg)方法可以共享式地获取同步状态</p>
<div><pre><code>    <span>public</span> <span>final</span> <span>void</span> <span>acquireShared</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>tryAcquireShared</span><span>(</span>arg<span>)</span> <span>&lt;</span> <span>0</span><span>)</span>
            <span>doAcquireShared</span><span>(</span>arg<span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>doAcquireShared</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span>
        <span>final</span> <span>Node</span> node <span>=</span> <span>addWaiter</span><span>(</span><span>Node</span><span>.</span>SHARED<span>)</span><span>;</span>
        <span>boolean</span> failed <span>=</span> <span>true</span><span>;</span>
        <span>try</span> <span>{</span>
            <span>boolean</span> interrupted <span>=</span> <span>false</span><span>;</span>
            <span>for</span> <span>(</span><span>;</span> <span>;</span> <span>)</span> <span>{</span>
                <span>final</span> <span>Node</span> p <span>=</span> node<span>.</span><span>predecessor</span><span>(</span><span>)</span><span>;</span>
                <span>if</span> <span>(</span>p <span>==</span> head<span>)</span> <span>{</span>
                    <span>int</span> r <span>=</span> <span>tryAcquireShared</span><span>(</span>arg<span>)</span><span>;</span>
                    <span>if</span> <span>(</span>r <span>>=</span> <span>0</span><span>)</span> <span>{</span>
                        <span>setHeadAndPropagate</span><span>(</span>node<span>,</span> r<span>)</span><span>;</span>
                        p<span>.</span>next <span>=</span> <span>null</span><span>;</span>
                        <span>if</span> <span>(</span>interrupted<span>)</span>
                            <span>selfInterrupt</span><span>(</span><span>)</span><span>;</span>
                        failed <span>=</span> <span>false</span><span>;</span>
                        <span>return</span><span>;</span>
                    <span>}</span>
                <span>}</span>
                i
                <span>f</span><span>(</span><span>shouldParkAfterFailedAcquire</span><span>(</span>p<span>,</span> node<span>)</span> <span>&amp;&amp;</span>
                    <span>parkAndCheckInterrupt</span><span>(</span><span>)</span><span>)</span>
                interrupted <span>=</span> <span>true</span><span>;</span>
            <span>}</span>
        <span>}</span> <span>finally</span> <span>{</span>
            <span>if</span> <span>(</span>failed<span>)</span>
                <span>cancelAcquire</span><span>(</span>node<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>在acquireShared(int arg)方法中，同步器调用tryAcquireShared(int arg)方法尝试获取同步状态，tryAcquireShared(int arg)方法返回值为int类型，当返回值大于等于0时，表示能够获取到同步状态。因此，在共享式获取的自旋过程中，成功获取到同步状态并退出自旋的条件就是tryAcquireShared(int arg)方法返回值大于等于0。可以看到，在doAcquireShared(int arg)方法的自旋过程中，如果当前节点的前驱为头节点时，尝试获取同步状态，如果返回值大于等于0，表示该次获取同步状态成功并从自旋过程中退出</p>
<p>共享式获取也需要释放同步状态，通过调用releaseShared(int arg)方法可以释放同步状态</p>
<div><pre><code>    <span>public</span> <span>final</span> <span>boolean</span> <span>releaseShared</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>tryReleaseShared</span><span>(</span>arg<span>)</span><span>)</span> <span>{</span>
            <span>doReleaseShared</span><span>(</span><span>)</span><span>;</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
</code></pre></div><p>该方法在释放同步状态之后，将会唤醒后续处于等待状态的节点。对于能够支持多个线程同时访问的并发组件(比如Semaphore)，它和独占式主要区别在于tryReleaseShared(int arg)方法必须确保同步状态(或者资源数)线程安全释放，一般是通过循环和CAS来保证的，因为释放同步状态的操作会同时来自多个线程</p>
<ol start="4">
<li><strong>独占式超时获取同步状态</strong></li>
</ol>
<p>通过调用同步器的doAcquireNanos(int arg,long nanosTimeout)方法可以超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则，返回false。该方法提供了传统Java同步操作(比如synchronized关键字)所不具备的特性</p>
<h2 id="重入锁" tabindex="-1"> 重入锁</h2>
<p>重入锁ReentrantLock，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。</p>
<p><strong>实现重进入</strong></p>
<p>重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的实现需要解决以下两个问题:</p>
<ol>
<li>线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取</li>
<li>锁的最终释放。线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。</li>
</ol>
<p><strong>公平性</strong></p>
<p>公平性与否是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO</p>
<p>公平性锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平性锁虽然可能造成线程“饥饿”，但极少的线程切换，保证了其更大的吞吐量</p>
<h3 id="reentrantlock-对比-synchronized" tabindex="-1"> ReentrantLock 对比 synchronized</h3>
<p><strong>相同点</strong></p>
<ul>
<li>两者都是可重入锁</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li>锁的实现
<ul>
<li>synchronized 是依赖于 JVM 实现的，虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。</li>
<li>ReentrantLock 是 JDK 层面实现的(也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成)。</li>
</ul>
</li>
<li>性能：新版本 Java 对 synchronized 进行了很多优化，例如自旋锁、锁消除、锁粗化、偏向锁、轻量级锁，synchronized 与 ReentrantLock 大致相同。</li>
<li>ReentrantLock 的高级功能：
<ul>
<li>等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。
<ul>
<li>ReentrantLock提供了一种能够中断等待锁的线程的机制，通过<code>lock.lockInterruptibly()</code>来实现这个机制。</li>
</ul>
</li>
<li>可实现公平锁：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁
<ul>
<li>可以通过 ReentrantLock类的 <code>ReentrantLock(boolean fair)</code> 构造方法来制定是否是公平的</li>
</ul>
</li>
<li>可实现选择性通知(绑定多个条件)
<ul>
<li>synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制；ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。</li>
<li>实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例(即对象监视器)，<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong> ；这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>使用选择</strong></p>
<ul>
<li>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</li>
</ul>
<h2 id="读写锁" tabindex="-1"> 读写锁</h2>
<p>读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。</p>
<p>一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。Java并发包提供读写锁的实现是ReentrantReadWriteLock，它提供的特性如表所示。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>公平性选择</td>
<td>支持非公平(默认)和公平的所获取方式</td>
</tr>
<tr>
<td>重入</td>
<td>支持重进入</td>
</tr>
<tr>
<td>锁降级</td>
<td>遵循获取写锁、获取读锁再释放写锁的次序，写锁能降级为读锁</td>
</tr>
</tbody>
</table>
<h2 id="locksupport工具" tabindex="-1"> LockSupport工具</h2>
<ul>
<li>当需要阻塞或唤醒一个线程的时候，都会使用LockSupport工具类来完成相应工作。LockSupport定义了一组公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能，而LockSupport也成为了构建同步组建的基础工具。</li>
<li>LockSupport提供的阻塞和唤醒方法(其中参数blocker是用来标识当前线程在等待的对象，便于问题排查和系统监控)</li>
</ul>
<p>LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread)方法来唤醒一个被阻塞的线程。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>void park(Object blocker)</td>
<td>阻塞当前线程，如果调用unpark方法或者当前线程被终端，才能从park方法返回</td>
</tr>
<tr>
<td>void parkNanos(Object blocker, long nanos)</td>
<td>阻塞当前线程，最长不超过nanos纳秒，返回条件在park的基础上增加了超时返回</td>
</tr>
<tr>
<td>void parkUntil(Object blocker, long deadline)</td>
<td>阻塞当前线程，直到deadline时间</td>
</tr>
<tr>
<td>void unpark(Thread thread)</td>
<td>唤醒处于阻塞状态的线程thread</td>
</tr>
</tbody>
</table>
<h2 id="condition接口" tabindex="-1"> Condition接口</h2>
<p>任意一个Java对象，都拥有一组监视器方法(定义在java.lang.Object上)，主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式，但是这两者在使用方式以及功能特性上还是有差别的。</p>
<p>Object的监视器方法与Condition接口的对比</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th style="text-align:center">Object Monitor Methods</th>
<th style="text-align:center">Condition</th>
</tr>
</thead>
<tbody>
<tr>
<td>前置条件</td>
<td style="text-align:center">获取对象的锁</td>
<td style="text-align:center">获取Lock和Condition</td>
</tr>
<tr>
<td>调用方式</td>
<td style="text-align:center">直接调用object.wait()</td>
<td style="text-align:center">直接调用condition.await()</td>
</tr>
<tr>
<td>等待队列个数</td>
<td style="text-align:center">一个</td>
<td style="text-align:center">多个</td>
</tr>
<tr>
<td>当前线程释放锁并进入等待队列</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td>当前线程释放锁并进入等待队列，在等待中响应中断</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td>当前线程释放锁并进入限时等待队列</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td>当前线程释放锁并进入等待状态到将来某个时间</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td>唤醒等待队列一个线程</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td>唤醒等待队列全部线程</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
</tr>
</tbody>
</table>
<h1 id="六、java中的并发工具类" tabindex="-1"> 六、Java中的并发工具类</h1>
<p>在JDK的并发包里提供了几个非常有用的并发工具类。 CountDownLatch 、CyclicBarrier 和 Semaphore 工具类提供了一种并发流程控制的手段，Exchanger工具类则提供了在线程间交换数据的一种手段</p>
<h2 id="countdownlatch" tabindex="-1"> CountDownLatch</h2>
<p>等待其他线程完成可采用join，join用于让当前执行线程等待join线程执行结束。其实现原理是不停检查join线程是否存活，如果join线程存活则让当前线程永远等待。其中，wait(0)表示永远等待下去，代码片段如下</p>
<div><pre><code>    <span>while</span> <span>(</span><span>isAlive</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>wait</span><span>(</span><span>0</span><span>)</span><span>;</span>
    <span>}</span>
</code></pre></div><p>直到join线程中止后，线程的this.notifyAll()方法会被调用，调用notifyAll()方法是在JVM里实现的，所以在JDK里看不到</p>
<p>CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N。</p>
<p>当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法会阻塞当前线程，直到N变成零。由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程时，只需要把这个CountDownLatch的引用传递到线程里即可</p>
<p>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ba078291-791e-4378-b6d1-ece76c2f0b14.png" width="300px"> </div><br>
<p><strong>注意</strong>：计数器必须大于等于0，只是等于0时候，计数器就是零，调用await方法时不会阻塞当前线程。CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数器的值。一个线程调用countDown方法happen-before，另外一个线程调用await方法。</p>
<p>可以使用另外一个带指定时间的await方法——await(long time，TimeUnit unit)，这个方法等待特定时间后，就会不再阻塞当前线程。join也有类似的方法。</p>
<h2 id="cyclicbarrier" tabindex="-1"> CyclicBarrier</h2>
<p>CyclicBarrier的是可循环使用(Cyclic)的屏障(Barrier)。</p>
<p>让一组线程到达一个屏障(也可以叫同步点)时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p>
<p>CyclicBarrier 有两个构造函数：</p>
<ul>
<li>CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞</li>
<li>CyclicBarrier(int parties, Runnable barrierAction)，用于在线程到达屏障时，优先执行barrierAction(barrierAction 在所有线程都到达屏障的时候会执行一次)，方便处理更复杂的业务场景</li>
</ul>
<div><pre><code><span>public</span> <span>CyclicBarrier</span><span>(</span><span>int</span> parties<span>)</span> <span>{</span>
    <span>this</span><span>(</span>parties<span>,</span> <span>null</span><span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>CyclicBarrier</span><span>(</span><span>int</span> parties<span>,</span> <span>Runnable</span> barrierAction<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>parties <span>&lt;=</span> <span>0</span><span>)</span> <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>)</span><span>;</span>
    <span>this</span><span>.</span>parties <span>=</span> parties<span>;</span>
    <span>this</span><span>.</span>count <span>=</span> parties<span>;</span>
    <span>this</span><span>.</span>barrierCommand <span>=</span> barrierAction<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f71af66b-0d54-4399-a44b-f47b58321984.png" width="300px"> </div><br>
<p><strong>CyclicBarrier和CountDownLatch的区别</strong></p>
<ul>
<li>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。所以CyclicBarrier能处理更为复杂的业务场景.</li>
<li>CyclicBarrier还提供其他有用的方法，比如:
<ul>
<li>getNumberWaiting方法可以获得Cyclic-Barrier阻塞的线程数量</li>
<li>isBroken()方法用来了解阻塞的线程是否被中断</li>
</ul>
</li>
<li>CountDownLatch 是等待一组线程执行完，才执行后面的代码。此时这组线程已经执行完。CyclicBarrier 是等待一组线程至某个状态后再同时全部继续执行线程。此时这组线程还未执行完。</li>
</ul>
<h2 id="semaphore" tabindex="-1"> Semaphore</h2>
<p>Semaphore(信号量)是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p>
<p>Semaphore(int permits)构造方法接收一个int参数，表示可用的许可证数量。</p>
<p>每次线程使用Semaphore的acquire()方法获取一个许可证，用完后调用release()方法归还。还可以用tryAcquire()方法尝试获取许可证。</p>
<p>应用场景：流量控制，特别是公用资源有限的应用场景，比如数据库连接</p>
<p>其他方法</p>
<ul>
<li>intavailablePermits()：返回此信号量中当前可用的许可证数。</li>
<li>intgetQueueLength()：返回正在等待获取许可证的线程数。</li>
<li>booleanhasQueuedThreads()：是否有线程正在等待获取许可证。</li>
<li>void reducePermits(int reduction)：减少reduction个许可证，是个protected方法。</li>
<li>Collection getQueuedThreads()：返回所有等待获取许可证的线程集合，是个protected方法。</li>
</ul>
<h2 id="exchanger" tabindex="-1"> Exchanger</h2>
<p>Exchanger(交换者)是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p>
<p>应用场景：</p>
<ul>
<li>可以用于遗传算法：遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果</li>
<li>可以用于校对工作</li>
</ul>
<h1 id="七、java中原子操作类" tabindex="-1"> 七、Java中原子操作类</h1>
<p>Java从JDK 1.5开始提供了java.util.concurrent.atomic包(以下简称Atomic包)，这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式</p>
<h2 id="原子更新基本类型" tabindex="-1"> 原子更新基本类型</h2>
<ul>
<li>AtomicBoolean ：原子更新布尔类型</li>
<li>AtomicInteger： 原子更新整型</li>
<li>AtomicLong: 原子更新长整型</li>
</ul>
<h2 id="原子更新数组" tabindex="-1"> 原子更新数组</h2>
<ul>
<li>AtomicIntegerArray ：原子更新整型数组里的元素</li>
<li>AtomicLongArray :原子更新长整型数组里的元素</li>
<li>AtomicReferenceArray : 原子更新引用类型数组的元素</li>
</ul>
<h2 id="原子更新引用类型" tabindex="-1"> 原子更新引用类型</h2>
<ul>
<li>AtomicReference ：原子更新引用类型</li>
<li>AtomicReferenceFieldUpdater ：原子更新引用类型里的字段</li>
<li>AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和应用类型</li>
</ul>
<h2 id="原子更新字段类" tabindex="-1"> 原子更新字段类</h2>
<ul>
<li>AtomicIntegerFieldUpdater:原子更新整型的字段的更新器</li>
<li>AtomicLongFieldUpdater：原子更新长整型字段的更新器</li>
<li>AtomicStampedReference:原子更新带有版本号的引用类型。该类将整型数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的ABA问题。</li>
</ul>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li>BruceEckel. Java 编程思想: 第 4 版 [M]. 机械工业出版社, 2007.</li>
<li>周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.</li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se6/html/Threads.doc.html" target="_blank" rel="noopener noreferrer">Threads and Locks</a></li>
<li><a href="http://ifeve.com/thread-signaling/#missed_signal" target="_blank" rel="noopener noreferrer">线程通信</a></li>
<li><a href="http://www.importnew.com/12773.html" target="_blank" rel="noopener noreferrer">Java 线程面试题 Top 50</a></li>
<li><a href="http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html" target="_blank" rel="noopener noreferrer">BlockingQueue</a></li>
<li><a href="https://stackoverflow.com/questions/11265289/thread-state-java" target="_blank" rel="noopener noreferrer">thread state java</a></li>
<li><a href="http://wiki.expertiza.ncsu.edu/index.php/CSC_456_Spring_2012/ch7_MN" target="_blank" rel="noopener noreferrer">CSC 456 Spring 2012/ch7 MN</a></li>
<li><a href="https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/happens-before.html" target="_blank" rel="noopener noreferrer">Java - Understanding Happens-before relationship</a></li>
<li><a href="https://www.slideshare.net/novathinker/6-thread-synchronization" target="_blank" rel="noopener noreferrer">6장 Thread Synchronization</a></li>
<li><a href="https://stackoverflow.com/questions/1202444/how-is-javas-threadlocal-implemented-under-the-hood/15653015" target="_blank" rel="noopener noreferrer">How is Java's ThreadLocal implemented under the hood?</a></li>
<li><a href="https://sites.google.com/site/webdevelopart/21-compile/06-java/javase/concurrent?tmpl=%2Fsystem%2Fapp%2Ftemplates%2Fprint%2F&amp;showPrintDialog=1" target="_blank" rel="noopener noreferrer">Concurrent</a></li>
<li><a href="http://www.javacreed.com/java-fork-join-example/" title="Java Fork Join Example" target="_blank" rel="noopener noreferrer">JAVA FORK JOIN EXAMPLE</a></li>
<li><a href="http://ifeve.com/talk-concurrency-forkjoin/" target="_blank" rel="noopener noreferrer">聊聊并发(八)——Fork/Join 框架介绍</a></li>
<li><a href="http://www.oracle.com/technetwork/java/javase/tech/biasedlocking-oopsla2006-preso-150106.pdf" target="_blank" rel="noopener noreferrer">Eliminating SynchronizationRelated Atomic Operations with Biased Locking and Bulk Rebiasing</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java并发进阶</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">Java并发进阶</source>
      <category>Java</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[ 
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>

<h1 id="八、任务取消与关闭" tabindex="-1"> 八、任务取消与关闭</h1>
<p>要使任务和线程安全、快速、可靠的停止下来，并不是一件容易的事情。java没有提供任何机制来安全地终止线程，但提供了中断协作机制，中断能使一个线程终止另一个线程的当前工作。</p>
<h2 id="任务取消" tabindex="-1"> 任务取消</h2>
<ul>
<li>如果外部代码能在某个操作正常完成之前将其置入“完成”状态，那么这个操作就可以成为可取消的。</li>
<li>在java中没有一种安全的抢占式方法来停止线程，因此也就没有安全的抢占式方法来停止任务。只有一些协作式的机制，使请求取消的任务和代码都遵循一种协商好的协议。</li>
<li>一个可取消的任务必须拥有「取消策略」：规定How(如何取消)，When(什么时候检测取消)和What(如何处理取消)。</li>
</ul>
<p>如何取消一般有两种方法：</p>
<ul>
<li>使用volatile类型状态变量(不一定可靠)：线程中循环遍历状态变量，检测是否需要结束当前线程。通过不断查看volatile类型的状态变量是一种简单的取消策略，然而，如果任务除了检查状态变量外执行了阻塞方法，任务可能永远不会检查取消状态标志，此时永远不会结束任务。</li>
<li>使用中断(最合理的方法)：系统提供的大多数阻塞方法响应中断：清除中断状态，抛出InterruptedException异常，表示阻塞操作由于中断而提前结束。</li>
</ul>
<h3 id="中断" tabindex="-1"> 中断</h3>
<ul>
<li>通常，中断是实现取消的最合理方式</li>
<li>在取消之外的操作中使用中断，都是不合适的，并且很难支撑起更大的应用。</li>
<li>调用 interrupt() 并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息</li>
</ul>
<p>中断的正确理解是，它并不会真正地中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己(这些时刻被称为取消点)。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Thread</span> <span>{</span>
    <span>public</span> <span>void</span> <span>interrupt</span><span>(</span><span>)</span> <span>{</span> <span>.</span><span>.</span><span>.</span><span>}</span>  <span>//请求中断，设置线程的中断标记</span>

    <span>public</span> <span>boolean</span> <span>isInterrupted</span><span>(</span><span>)</span> <span>{</span><span>.</span><span>.</span><span>.</span><span>}</span> <span>//返回线程中断状态</span>

    <span>public</span> <span>static</span> <span>boolean</span> <span>interrupted</span><span>(</span><span>)</span> <span>{</span><span>.</span><span>.</span><span>.</span><span>}</span> <span>//若返回true原有的中断状态会被清除，除非想屏蔽中断，必否则须对其作出处理：可以抛出InterruptedException异常，也可再次调用interrupt来恢复中断</span>
<span>}</span>
</code></pre></div><p><strong>中断策略</strong></p>
<ul>
<li>最合理的中断策略是某种形式的线程级取消操作或服务及取消操作：尽快退出，在必要时进行清理，通知某个所有者该线程已经退出。</li>
<li>一个中断请求可以有一个或多个接受者。</li>
<li>大多数可阻塞库函数只抛出InterruptedException作为中断响应，也是最合理的取消策略：尽快退出执行流程并把中断信息传递给调用者，从而使栈中的上层代码可以采取进一步的操作。</li>
<li>由于每个线程拥有各自的中断策略，除非知道中断对该线程的含义，否则就不应该中断这个线程。</li>
</ul>
<p>当线程在活动之前或活动期间处于正在等待、休眠或占用状态且该线程被中断时，抛出该异常InterruptedException</p>
<p>抛 InterruptedException 的代表方法有：</p>
<ul>
<li>java.lang.Object 类的 wait 方法</li>
<li>java.lang.Thread 类的 sleep 方法</li>
<li>java.lang.Thread 类的 join 方法</li>
</ul>
<p><strong>响应中断</strong></p>
<p>当调用可中断的阻塞函数，例如Thread.sleep等，有两种实用策略可用于处理InterruptedException：</p>
<ol>
<li>传递异常(可能在执行某个特定于任务的清除操作之后)：从而使你的方法也成为可中断的阻塞方法</li>
<li>恢复中断状态：从而使调用栈的上层代码能对其进行处理</li>
</ol>
<p>如果你不想或无法传递InterruptedException(或许通过Runnable来定义任务)，一种标准方法是再次调用interrupt来恢复中断，不能屏蔽InterruptedException。</p>
<ul>
<li>只有实现了线程中断策略的代码才可以屏蔽中断请求，在常规的任务和库代码中都不应该屏蔽中断请求。</li>
<li>如果代码不会调用可中断的阻塞方法，那么仍然可以通过在任务代码中轮询当前线程的中断状态来响应中断。</li>
<li>join的不足：无法知道执行控制是因为线程正常退出而返回还是因为join超时而返回。</li>
</ul>
<h3 id="通过future来取消" tabindex="-1"> 通过Future来取消</h3>
<p>ExecutorService.submit将返回一个Future来描述任务，</p>
<ul>
<li>执行任务的线程是由Executor创建的，实现了一种中断策略使得任务可以通过中断被取消，</li>
<li>当尝试取消某个任务时，不宜直接中断线程池，因为并不知道当中断请求到达时正在运行什么任务，只能通过任务的Future来实现取消。</li>
<li>当Future.get抛出InterruptedException或TimeoutException时，如果知道不再需要结果，就可以调用Future.cancel来取消任务。</li>
</ul>
<h3 id="处理不可中断的阻塞" tabindex="-1"> 处理不可中断的阻塞</h3>
<p>对于那些由于执行不可中断操作而被阻塞的线程，可以使用类似于中断的手段来停止这些线程，但要求知道线程阻塞的原因。</p>
<p>常见的不可阻塞中断包括</p>
<ul>
<li>Java.io包中的Socket I/O</li>
<li>Java.io包中的同步I/O</li>
<li>Selector的异步I/O</li>
<li>获取某个锁</li>
</ul>
<h3 id="采用newtaskfor来封装非标准化的取消" tabindex="-1"> 采用newTaskFor来封装非标准化的取消</h3>
<h3 id="停止基于线程的服务" tabindex="-1"> 停止基于线程的服务</h3>
<ul>
<li>如果硬要程序准备退出，那么这些服务所拥有的线程也需要结束。</li>
<li>正确的封装原则是，除非拥有某个线程，否则不能对该线程进行操控。</li>
<li>对于持有线程的服务，只要服务的存在时间大于创建线程的方法的存在时间，那么就应该提供生命周期方法。</li>
</ul>
<h3 id="executorservice-中的关闭" tabindex="-1"> ExecutorService 中的关闭</h3>
<ul>
<li>正常关闭：shutdown() 方法会等待线程都执行完毕之后再关闭</li>
<li>强行关闭：shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法，无法通过常规方法来找出哪些任务已经开始但尚未结束</li>
</ul>
<h2 id="jvm关闭" tabindex="-1"> JVM关闭</h2>
<p><strong>关闭钩子</strong></p>
<ul>
<li>指通过Runtime.addShutdownHook注册的但尚未开始的线程。</li>
<li>不应该依赖可能被应用程序或其他关闭钩子关闭的服务，对所有服务使用同一个关闭钩子，各个关闭操作串行执行。</li>
</ul>
<p><strong>守护线程</strong></p>
<ul>
<li>应尽可能少地使用守护线程，很少有操作能够在不进行清理的情况下被安全地抛弃。</li>
<li>守护线程通常不能用来替代应用程序管理中各个服务的生命周期。</li>
</ul>
<p><strong>终结器</strong></p>
<ul>
<li>避免使用。</li>
</ul>
<h1 id="九、java并发容器" tabindex="-1"> 九、Java并发容器</h1>
<h2 id="concurrenthashmap" tabindex="-1"> ConcurrentHashMap</h2>
<p>ConcurrentHashMap是线程安全且高效的HashMap。</p>
<p>在并发编程中使用HashMap可能导致程序死循环。而使用线程安全的HashTable效率又非常低下，基于以上两个原因，便有了ConcurrentHashMap。</p>
<ul>
<li>
<p>线程不安全的HashMap<br>
在多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。例如，执行以下代码会引起死循环</p>
</li>
<li>
<p>效率低下的HashTable<br>
HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或轮询状态。</p>
</li>
<li>
<p>ConcurrentHashMap的锁分段技术可有效提升并发访问率<br>
HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
</li>
</ul>
<p><strong>ConcurrentHashMap的结构</strong></p>
<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁(ReentrantLock)，在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组。Segment的结构和HashMap类似，是一种数组和链表结构。一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁，</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/ConcurrentHashMap的结构图.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<h2 id="copyonwritearraylist" tabindex="-1"> CopyOnWriteArrayList</h2>
<p>在很多应用场景中，读操作可能会远远大于写操作。由于读操作根本不会修改原有的数据，因此对于每次读取都进行加锁其实是一种资源浪费。我们应该允许多个线程同时访问List的内部数据，毕竟读取操作是安全的。</p>
<p>ReentrantReadWriteLock 读写锁的思想非常类似，也就是读读共享、写写互斥、读写互斥、写读互斥。JDK中提供了 CopyOnWriteArrayList 类比相比于在读写锁的思想又更进一步。为了将读取的性能发挥到极致，CopyOnWriteArrayList 读取是完全不用加锁的，并且更厉害的是：写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待。</p>
<h3 id="读取操作实现" tabindex="-1"> 读取操作实现</h3>
<p>读取操作没有任何同步控制和锁操作，理由就是内部数组 array 不会发生修改，只会被另外一个 array 替换，因此可以保证数据安全。</p>
<div><pre><code>    <span>/** The array, accessed only via getArray/setArray. */</span>
    <span>private</span> <span>transient</span> <span>volatile</span> <span>Object</span><span>[</span><span>]</span> array<span>;</span>
    <span>public</span> <span>E</span> <span>get</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>return</span> <span>get</span><span>(</span><span>getArray</span><span>(</span><span>)</span><span>,</span> index<span>)</span><span>;</span>
    <span>}</span>
    <span>@SuppressWarnings</span><span>(</span><span>"unchecked"</span><span>)</span>
    <span>private</span> <span>E</span> <span>get</span><span>(</span><span>Object</span><span>[</span><span>]</span> a<span>,</span> <span>int</span> index<span>)</span> <span>{</span>
        <span>return</span> <span>(</span><span>E</span><span>)</span> a<span>[</span>index<span>]</span><span>;</span>
    <span>}</span>
    <span>final</span> <span>Object</span><span>[</span><span>]</span> <span>getArray</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> array<span>;</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="写入操作实现" tabindex="-1"> 写入操作实现</h3>
<p>CopyOnWriteArrayList 写入操作 add() 方法在添加集合的时候加了锁，保证了同步，避免了多线程写的时候会 copy 出多个副本出来。</p>
<div><pre><code>    <span>/**
     * Appends the specified element to the end of this list.
     *
     * <span>@param</span> <span>e</span> element to be appended to this list
     * <span>@return</span> <span>{</span><span>@code</span> <span><span><span>true</span></span></span><span>}</span> (as specified by <span>{</span><span>@link</span> <span><span>Collection</span><span>#</span><span>add</span></span><span>}</span>)
     */</span>
    <span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>
        <span>final</span> <span>ReentrantLock</span> lock <span>=</span> <span>this</span><span>.</span>lock<span>;</span>
        lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span><span>//加锁</span>
        <span>try</span> <span>{</span>
            <span>Object</span><span>[</span><span>]</span> elements <span>=</span> <span>getArray</span><span>(</span><span>)</span><span>;</span>
            <span>int</span> len <span>=</span> elements<span>.</span>length<span>;</span>
            <span>Object</span><span>[</span><span>]</span> newElements <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elements<span>,</span> len <span>+</span> <span>1</span><span>)</span><span>;</span><span>//拷贝新数组</span>
            newElements<span>[</span>len<span>]</span> <span>=</span> e<span>;</span>
            <span>setArray</span><span>(</span>newElements<span>)</span><span>;</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span> <span>finally</span> <span>{</span>
            lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span><span>//释放锁</span>
        <span>}</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id="concurrentlinkedqueue" tabindex="-1"> ConcurrentLinkedQueue</h2>
<p>Java提供的线程安全的 Queue 可以分为阻塞队列和非阻塞队列，其中阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子是ConcurrentLinkedQueue，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。</p>
<p>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部；当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait-free”算法(即CAS算法)来实现。</p>
<p><strong>ConcurrentLinkedQueue的结构</strong>：
ConcurrentLinkedQueue由head节点和tail节点组成，每个节点(Node)由节点元素(item)和指向下一个节点(next)的引用组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。</p>
<p>ConcurrentLinkedQueue 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的ConcurrentLinkedQueue来替代。</p>
<h2 id="blockingqueue" tabindex="-1"> BlockingQueue</h2>
<p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。</p>
<ul>
<li>支持阻塞的插入方法：当队列满时，队列会阻塞插入元素的线程，直到队列不满。</li>
<li>支持阻塞的移除方法：当队列空时，获取元素的线程会等待队列变为非空。</li>
</ul>
<p>插入和移除操作的4种处理方式</p>
<table>
<thead>
<tr>
<th>方法/处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time, unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody>
</table>
<ul>
<li>抛出异常：当队列满时，如果再往队列里插入元素会抛出IllegalStateException(&quot;Queue full&quot;)异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。</li>
<li>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则从队列里取出一个元素，如果没有则返回null。</li>
<li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列列take元素，队列会阻塞消费者线程，直到队列不为空。</li>
<li>超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超时则退出。</li>
</ul>
<p>如果是无界阻塞队列，队列不可能会出现满的情况，所以使用put或offer方法永远不会被阻塞，而且使用offer方法时，该方法永远返回true</p>
<h3 id="java里的blockingqueue" tabindex="-1"> Java里的BlockingQueue</h3>
<ul>
<li>ArrayBlockingQueue：用数组实现的有界阻塞队列，按FIFO原则对元素进行排序。
<ul>
<li>一旦创建，容量不能改变</li>
<li>并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作</li>
<li>默认情况下不能保证线程访问队列的公平性,(所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 ArrayBlockingQueue。)为了保证公平性，通常会降低吞吐量</li>
</ul>
</li>
<li>LinkedBlockingQueue：用<strong>单向链表</strong>实现的有界阻塞队列，默认和最大长度为Integer.MAX_VALUE，按FIFO原则对元素进行排序。
<ul>
<li>与ArrayBlockingQueue 相比起来具有更高的吞吐量，为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建LinkedBlockingQueue 对象时，会指定其大小，如果未指定，容量等于Integer.MAX_VALUE。</li>
</ul>
</li>
<li>PriorityBlockingQueue：支持优先级的无界阻塞队列，默认情况下元素采取自然顺序升序排列。不保证同优先级元素的顺序。
<ul>
<li>并发控制采用的是 ReentrantLock</li>
<li>只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容)</li>
<li>PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的(comparable)，否则报 ClassCastException 异常</li>
<li>它的插入操作 put 方法不会 block，因为它是无界队列(take 方法在队列为空的时候会阻塞)</li>
</ul>
</li>
<li>DelayQueue：支持延时获取元素的无界阻塞队列。队列使用PriorityQueue实现，队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。可应用于：
<ul>
<li>缓存系统的设计：用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素表示缓存有效期到了。</li>
<li>定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的。</li>
</ul>
</li>
<li>SynchronousQueue：不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。</li>
<li>LinkedTransferQueue：链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。
<ul>
<li>transfer方法：如果当前有消费者正在等待接收元素，transfer方法可以把生产者传入的元素立刻传给消费者。如果没有消费者在等待接收元素，则将元素存放在队列tail节点并等到钙元素被消费者消费了才返回。</li>
<li>tryTransfer方法：如果没有消费者等待接收元素，则立即返回false。</li>
</ul>
</li>
<li>LinkedBlockingDeque：链表结构组成的双向阻塞队列。</li>
</ul>
<h3 id="blockingqueue实现原理" tabindex="-1"> BlockingQueue实现原理</h3>
<p>使用通知模式实现。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。</p>
<h2 id="concurrentskiplistmap" tabindex="-1"> ConcurrentSkipListMap</h2>
<p><strong>跳表</strong></p>
<p>对于一个单链表，即使链表是有序的，如果我们想要在其中查找某个数据，也只能从头到尾遍历链表，这样效率自然就会很低，跳表就不一样了。跳表是一种可以用来快速查找的数据结构，有点类似于平衡树。它们都可以对元素进行快速的查找。但一个重要的区别是：对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整。而对跳表的插入和删除只需要对整个数据结构的局部进行操作即可。这样带来的好处是：在高并发的情况下，你会需要一个全局锁来保证整个平衡树的线程安全。而对于跳表，你只需要部分锁即可。这样，在高并发环境下，你就可以拥有更好的性能。而就查询的性能而言，跳表的时间复杂度也是 O(logn) 所以在并发数据结构中，JDK 使用跳表来实现一个 Map。</p>
<p>跳表的本质是同时维护了多个链表，并且链表是分层的，</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/跳表结构.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<p>最低层的链表维护了跳表内所有的元素，每上面一层链表都是下面一层的子集。</p>
<p>跳表内的所有链表的元素都是排序的。查找时，可以从顶级链表开始找。一旦发现被查找的元素大于当前链表中的取值，就会转入下一层链表继续找。这也就是说在查找过程中，搜索是跳跃式的。</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/跳表查找.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<p>查找18 的时候原来需要遍历 18 次，现在只需要 7 次即可。针对链表长度比较大的时候，构建索引查找效率的提升就会非常明显。</p>
<p>从上面很容易看出，跳表是一种利用空间换时间的算法。</p>
<p>使用跳表实现Map 和使用哈希算法实现Map的另外一个不同之处是：哈希并不会保存元素的顺序，而跳表内所有的元素都是排序的。因此在对跳表进行遍历时，你会得到一个有序的结果。所以，如果你的应用需要有序性，那么跳表就是你不二的选择。JDK 中实现这一数据结构的类是ConcurrentSkipListMap。</p>
<h1 id="十、线程池和executor框架" tabindex="-1"> 十、线程池和Executor框架</h1>
<h2 id="线程池" tabindex="-1"> 线程池</h2>
<blockquote>
<p>池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p>
</blockquote>
<p>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。</p>
<p>在开发过程中，合理地使用线程池能够带来3个好处:</p>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌。</li>
</ul>
<h3 id="实现原理" tabindex="-1"> 实现原理</h3>
<p>当提交一个新任务到线程池时，线程池的处理流程如下。</p>
<ol>
<li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</li>
<li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li>
<li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务</li>
</ol>
<p>线程池的主要处理流程如图</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/线程池的主要处理流程.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<p>ThreadPoolExecutor执行execute方法分下面4种情况：</p>
<ol>
<li>如果当前运行的线程少于corePoolSize，则创建新线程来执行任务</li>
<li>如果运行的线程等于或多于corePollSize，则将任务加入BlockingQueue</li>
<li>如果无法将任务加入BlockingQueue(队列已满)，则创建新的线程来处理任务</li>
<li>如果创建新线程将导致当前运行的线程数超过maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</li>
</ol>
<p>程池中的线程执行任务分两种情况，如下：</p>
<ol>
<li>在execute()方法中创建一个线程时，会让这个线程执行当前任务。</li>
<li>这个线程执行完一个任务后，会反复从BlockingQueue获取任务来执行。</li>
</ol>
<h3 id="线程池的使用" tabindex="-1"> 线程池的使用</h3>
<p>通过ThreadPoolExecutor来<strong>创建</strong>一个线程池</p>
<div><pre><code>    <span>new</span> <span>ThreadPoolExecutor</span><span>(</span>corePoolSize<span>,</span> maximumPoolSize<span>,</span> keepAliveTime<span>,</span> milliseconds<span>,</span>runnableTaskQueue<span>,</span> handler<span>)</span><span>;</span>
</code></pre></div><ol>
<li>corePoolSize(线程池的基本大小)：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，直到需要执行的任务数大于线程池基本大小。如果调用了线程prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</li>
<li>runnableTaskQueue(任务队列)：用于保存等待执行的任务的阻塞队列。可以选择ArratBlockingQueue, LinkedBlockingQueue, SynchronousQueue, PriorityBlockingQueue。</li>
<li>maximumPoolSize(线程池最大数量)：线程池允许创建的最大线程数。</li>
<li>ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</li>
<li>RejectedExecutionHandler(饱和策略)：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。策略有下列几种：
<ul>
<li>AbortPolicy：直接抛出异常</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>
<li>DiscardPolicy：不处理，丢弃掉。</li>
<li>其他应用场景需要实现RejectedExecutionHandler接口自定义。</li>
</ul>
</li>
<li>keepAliveTime(线程活动保持时间)：线程池的工作线程空闲后，保持存活的时间。如果任务多且执行时间短，可以调高存活时间提高线程利用率。</li>
<li>TimeUnit(线程活动保持时间的单位)</li>
</ol>
<p>向线程池<strong>提交任务</strong>有两种方式：</p>
<ul>
<li>execute(Runnable command)：方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li>
<li>submit(Callable task)：方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get(long timeout，TimeUnit unit)方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ul>
<p>线程池的<strong>关闭</strong>有两种方法：</p>
<ul>
<li>shutdown()：关闭线程池，线程池的状态变为 SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li>
<li>shutdownNow()：关闭线程池，线程的状态变为 STOP。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li>
</ul>
<p><strong>查询关闭</strong>状态</p>
<ul>
<li>isShutDown 当调用 shutdown() 方法或 shutdownNow() 后返回为 true。</li>
<li>isTerminated 当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true；当且仅当所有任务都关闭，CIA表示线程池关闭成功，这是isTerminaed()方法才会返回true。</li>
</ul>
<p><strong>合理配置线程池</strong>(设N为CPU个数)</p>
<ul>
<li>CPU密集型任务，应配置尽可能少的线程，如N+1。</li>
<li>IO密集型任务，应配置尽可能多的线程，如2N。</li>
<li>优先级不同的任务可以考虑使用优先级队列priorityBlockingQueue来处理，但优先级低的任务可能永远不被执行。</li>
<li>使用有界队列能增加系统的稳定性和预警性，避免队列越来越多撑满内存，导致系统不可用。</li>
</ul>
<p><strong>线程池的监控</strong>:
监控线程池的时候可以使用以下属性：</p>
<ul>
<li>taskCount：线程池需要执行的任务数量。</li>
<li>completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。</li>
<li>largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。</li>
<li>getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。</li>
<li>getActiveCount：获取活动的线程数。</li>
</ul>
<p>可以通过继承线程池来自定义线程池，重写线程池的beforeExecute, afterExecute和terminated方法，也可以在任务执行前后和线程池关闭前执行一些代码来进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时间等。这几个方法在线程池里都是空方法。</p>
<h2 id="executor框架" tabindex="-1"> Executor框架</h2>
<p>在Java中，使用线程来异步执行任务。Java线程的创建与销毁需要一定的开销，如果我们为每一个任务创建一个新线程来执行，这些线程的创建与销毁将消耗大量的计算资源。同时，为每一个任务创建一个新线程来执行，这种策略可能会使处于高负荷状态的应用最终崩溃。</p>
<p>Java的线程既是工作单元，也是执行机制。从JDK5开始，把工作单元与执行机制分离开来。工作单元包括Runnable和Callable，而执行机制由Executor框架提供。</p>
<h3 id="两级调度模型" tabindex="-1"> 两级调度模型</h3>
<p>在上层，Java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器(Executor框架)将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。</p>
<p>应用程序通过Executor框架控制上层的调度；而下层的调度由操作系统内核控制，下层的调度不受应用程序的控制。</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/任务的两级调度模型.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<h3 id="框架结构" tabindex="-1"> 框架结构</h3>
<p>Executor框架主要由3大部分组成如下</p>
<ul>
<li>任务(Runnable / Callable)：<br>
执行任务需要实现的 Runnable 接口 或 Callable接口。Runnable 接口或 Callable 接口 实现类都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。</li>
<li>任务的执行(Executor)<br>
包括任务执行机制的核心接口Executor，以及继承自Executor的ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口(<strong>ThreadPoolExecutor</strong> 和 <strong>ScheduledThreadPoolExecutor</strong>)
<blockquote>
<p>注意： 通过查看 ScheduledThreadPoolExecutor 源代码我们发现 ScheduledThreadPoolExecutor 实际上是继承了 ThreadPoolExecutor 并实现了 ScheduledExecutorService ，而 ScheduledExecutorService 又实现了 ExecutorService，正如我们下面给出的类关系图显示的一样。</p>
</blockquote>
</li>
</ul>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/任务的执行相关接口.png" alt="" title=":size=500" loading="lazy"></p>
</div> 
<ul>
<li>异步计算的结果(Future)<br>
Future 接口以及 Future 接口的实现类 FutureTask 类都可以代表异步计算的结果。<br>
当我们把 Runnable接口 或 Callable 接口 的实现类提交给 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。(调用 submit() 方法时会返回一个 FutureTask 对象)</li>
</ul>
<h3 id="框架使用" tabindex="-1"> 框架使用</h3>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/框架使用示意图.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<ol>
<li>主线程首先要创建实现 Runnable 或者 Callable 接口的任务对象。</li>
<li>把创建完成的实现 Runnable/Callable接口的 对象直接交给 ExecutorService 执行: <code>ExecutorService.execute(Runnable command))</code>或者也可以把 Runnable 对象或Callable 对象提交给 ExecutorService 执行 <code>ExecutorService.submit(Runnable task)</code>或 <code>ExecutorService.submit(Callable &lt;T&gt; task))</code>。</li>
<li>如果执行 ExecutorService.submit(…)，ExecutorService 将返回一个实现 Future 接口的对象(我们刚刚也提到过了执行 execute() 方法和 submit() 方法的区别，submit()会返回一个 FutureTask 对象)。由于 FutureTask 实现了 Runnable，我们也可以创建 FutureTask，然后直接交给 ExecutorService 执行。</li>
<li>最后，主线程可以执行 FutureTask.get() 方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel(boolean mayInterruptIfRunning)来取消此任务的执行。</li>
</ol>
<h3 id="executor框架的成员" tabindex="-1"> Executor框架的成员</h3>
<h4 id="threadpoolexecutor" tabindex="-1"> ThreadPoolExecutor</h4>
<p>ThreadPoolExecutor通常使用工厂类Executors来创建。Executors可以创建3种类型的ThreadPoolExecutor：</p>
<ul>
<li>FixedThreadPool 被称为可重用固定线程数的线程池,适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，它适用于负载比较重的服务器</li>
<li>SingleThreadExecutor 是只有一个线程的线程池,适用于需要保证顺序地执行各个任务；并且在任意时间点，不会有多个线程是活动的应用场景</li>
<li>CachedThreadPool: 是一个会根据需要创建新线程的线程池,是大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器。</li>
</ul>
<h4 id="scheduledthreadpoolexecutor" tabindex="-1"> ScheduledThreadPoolExecutor</h4>
<p>ScheduledThreadPoolExecutor通常使用工厂类Executors来创建。Executors可以创建2种类型的ScheduledThreadPoolExecutor，如下:</p>
<ul>
<li>ScheduledThreadPoolExecutor。包含若干个线程的ScheduledThreadPoolExecutor</li>
<li>SingleThreadScheduledExecutor。只包含一个线程的ScheduledThreadPoolExecutor</li>
</ul>
<h4 id="future接口" tabindex="-1"> Future接口</h4>
<p>Future接口和实现Future接口的FutureTask类用来表示异步计算的结果。当我们把Runnable接口或Callable接口的实现类提交(submit)给ThreadPoolExecutor或ScheduledThreadPoolExecutor时，ThreadPoolExecutor或ScheduledThreadPoolExecutor会向我们返回一个FutureTask对象。</p>
<h4 id="runnable接口和callable接口" tabindex="-1"> Runnable接口和Callable接口</h4>
<p>Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。它们之间的区别是Runnable不会返回结果，而Callable可以返回结果</p>
<p><strong>比较</strong></p>
<ul>
<li>Runnable自 Java 1.0 以来一直存在，但Callable仅在 Java 1.5 中引入,目的就是为了来处理Runnable不支持的用例。Runnable 接口不会返回结果或抛出检查异常，但是Callable 接口可以。所以，如果任务不需要返回结果或抛出异常推荐使用 Runnable 接口，这样代码看起来会更加简洁。</li>
</ul>
<h3 id="threadpoolexecutor详解" tabindex="-1"> ThreadPoolExecutor详解</h3>
<div><pre><code>    <span>/**
     * 用给定的初始参数创建一个新的ThreadPoolExecutor。
     */</span>
    <span>public</span> <span>ThreadPoolExecutor</span><span>(</span><span>int</span> corePoolSize<span>,</span><span>//线程池的核心线程数量</span>
                              <span>int</span> maximumPoolSize<span>,</span><span>//线程池的最大线程数</span>
                              <span>long</span> keepAliveTime<span>,</span><span>//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span>
                              <span>TimeUnit</span> unit<span>,</span><span>//时间单位</span>
                              <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> workQueue<span>,</span><span>//任务队列，用来储存等待执行任务的队列</span>
                              <span>ThreadFactory</span> threadFactory<span>,</span><span>//线程工厂，用来创建线程，一般默认即可</span>
                              <span>RejectedExecutionHandler</span> handler<span>//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span>
                               <span>)</span> <span>{</span>
        <span>if</span> <span>(</span>corePoolSize <span>&lt;</span> <span>0</span> <span>||</span>
            maximumPoolSize <span>&lt;=</span> <span>0</span> <span>||</span>
            maximumPoolSize <span>&lt;</span> corePoolSize <span>||</span>
            keepAliveTime <span>&lt;</span> <span>0</span><span>)</span>
            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>workQueue <span>==</span> <span>null</span> <span>||</span> threadFactory <span>==</span> <span>null</span> <span>||</span> handler <span>==</span> <span>null</span><span>)</span>
            <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>corePoolSize <span>=</span> corePoolSize<span>;</span>
        <span>this</span><span>.</span>maximumPoolSize <span>=</span> maximumPoolSize<span>;</span>
        <span>this</span><span>.</span>workQueue <span>=</span> workQueue<span>;</span>
        <span>this</span><span>.</span>keepAliveTime <span>=</span> unit<span>.</span><span>toNanos</span><span>(</span>keepAliveTime<span>)</span><span>;</span>
        <span>this</span><span>.</span>threadFactory <span>=</span> threadFactory<span>;</span>
        <span>this</span><span>.</span>handler <span>=</span> handler<span>;</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>ThreadPoolExecutor 3 个最重要的参数：</p>
<ul>
<li>corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。</li>
<li>maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li>workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，信任就会被存放在队列中。</li>
</ul>
<p>ThreadPoolExecutor其他常见参数:</p>
<ul>
<li>keepAliveTime:当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；</li>
<li>unit : keepAliveTime 参数的时间单位。</li>
<li>threadFactory :executor 创建新线程的时候会用到。</li>
<li>handler :饱和策略。关于饱和策略下面单独介绍一下。</li>
</ul>
<p>线程池中各个参数的相互关系</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/线程池各个参数的关系.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<p>ThreadPoolExecutor 饱和策略定义:</p>
<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，ThreadPoolTaskExecutor 定义一些策略:</p>
<ul>
<li>ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。</li>
<li>ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li>
<li>ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。</li>
</ul>
<blockquote>
<p>Spring 通过 ThreadPoolTaskExecutor 或者我们直接通过 ThreadPoolExecutor 的构造函数创建线程池的时候，当我们不指定 RejectedExecutionHandler 饱和策略的话来配置线程池的时候默认使用的是 ThreadPoolExecutor.AbortPolicy。在默认情况下，ThreadPoolExecutor 将抛出 RejectedExecutionException 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 ThreadPoolExecutor.CallerRunsPolicy。当最大池被填满时，此策略为我们提供可伸缩队列。(这个直接查看 ThreadPoolExecutor 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了。)</p>
</blockquote>
<p>在《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。</p>
<blockquote>
<p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p>
</blockquote>
<p>另外《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<blockquote>
<p>Executors 返回线程池对象的弊端如下：</p>
</blockquote>
<ul>
<li>FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。</li>
<li>CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li>
</ul>
<h4 id="fixedthreadpool" tabindex="-1"> FixedThreadPool</h4>
<div><pre><code>    <span>/**
     * 创建一个可重用固定数量线程的线程池
     */</span>
    <span>public</span> <span>static</span> <span>ExecutorService</span> <span>newFixedThreadPool</span><span>(</span><span>int</span> nThreads<span>,</span> <span>ThreadFactory</span> threadFactory<span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ThreadPoolExecutor</span><span>(</span>nThreads<span>,</span> nThreads<span>,</span>
                                      <span>0L</span><span>,</span> <span>TimeUnit</span><span>.</span>MILLISECONDS<span>,</span>
                                      <span>new</span> <span>LinkedBlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>)</span><span>,</span>
                                      threadFactory<span>)</span><span>;</span>
    <span>}</span>
</code></pre></div><p>可以看出新创建的 FixedThreadPool 的 corePoolSize 和 maximumPoolSize 都被设置为 nThreads，这个 nThreads 参数是使用的时传递的。</p>
<p>FixedThreadPool 的 execute() 方法运行示意图</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/FixedThreadPool运行示意.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<ol>
<li>如果当前运行的线程数小于 corePoolSize， 如果再来新任务的话，就创建新的线程来执行任务；</li>
<li>当前运行的线程数等于 corePoolSize 后， 如果再来新任务的话，会将任务加入 LinkedBlockingQueue；</li>
<li>线程池中的线程执行完手头的任务后，会在循环中反复从 LinkedBlockingQueue 中获取任务来执行；</li>
</ol>
<p><strong>不推荐使用FixedThreadPool</strong></p>
<p>FixedThreadPool 使用无界队列 LinkedBlockingQueue(队列的容量为 Intger.MAX_VALUE)作为线程池的工作队列会对线程池带来如下影响 ：</p>
<ol>
<li>当线程池中的线程数达到 corePoolSize 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 corePoolSize；</li>
<li>由于使用无界队列时 maximumPoolSize 将是一个无效参数，因为不可能存在任务队列满的情况。所以，通过创建 FixedThreadPool的源码可以看出创建的 FixedThreadPool 的 corePoolSize 和 maximumPoolSize 被设置为同一个值。</li>
<li>由于 1 和 2，使用无界队列时 keepAliveTime 将是一个无效参数；</li>
<li>运行中的 FixedThreadPool(未执行 shutdown()或 shutdownNow())不会拒绝任务，在任务比较多的时候会导致 OOM(内存溢出)。</li>
</ol>
<h4 id="singlethreadexecutor" tabindex="-1"> SingleThreadExecutor</h4>
<div><pre><code>    <span>/**
     *返回只有一个线程的线程池
     */</span>
    <span>public</span> <span>static</span> <span>ExecutorService</span> <span>newSingleThreadExecutor</span><span>(</span><span>ThreadFactory</span> threadFactory<span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>FinalizableDelegatedExecutorService</span>
            <span>(</span><span>new</span> <span>ThreadPoolExecutor</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>,</span>
                                    <span>0L</span><span>,</span> <span>TimeUnit</span><span>.</span>MILLISECONDS<span>,</span>
                                    <span>new</span> <span>LinkedBlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>)</span><span>,</span>
                                    threadFactory<span>)</span><span>)</span><span>;</span>
    <span>}</span>
   <span>public</span> <span>static</span> <span>ExecutorService</span> <span>newSingleThreadExecutor</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>FinalizableDelegatedExecutorService</span>
            <span>(</span><span>new</span> <span>ThreadPoolExecutor</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>,</span>
                                    <span>0L</span><span>,</span> <span>TimeUnit</span><span>.</span>MILLISECONDS<span>,</span>
                                    <span>new</span> <span>LinkedBlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>可以看出新创建的 SingleThreadExecutor 的 corePoolSize 和 maximumPoolSize 都被设置为 1.其他参数和 FixedThreadPool 相同。</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/SingleThreadExecutor运行示意.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<ol>
<li>如果当前运行的线程数少于 corePoolSize，则创建一个新的线程执行任务；</li>
<li>当前线程池中有一个运行的线程后，将任务加入 LinkedBlockingQueue</li>
<li>线程执行完当前的任务后，会在循环中反复从LinkedBlockingQueue 中获取任务来执行；</li>
</ol>
<p><strong>不推荐使用 SingleThreadExecutor</strong></p>
<p>SingleThreadExecutor 使用无界队列 LinkedBlockingQueue 作为线程池的工作队列(队列的容量为 Intger.MAX_VALUE)。SingleThreadExecutor 使用无界队列作为线程池的工作队列会对线程池带来的影响与 FixedThreadPool 相同。说简单点就是可能会导致 OOM，</p>
<h4 id="cachedthreadpool" tabindex="-1"> CachedThreadPool</h4>
<div><pre><code>    <span>/**
     * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。
     */</span>
    <span>public</span> <span>static</span> <span>ExecutorService</span> <span>newCachedThreadPool</span><span>(</span><span>ThreadFactory</span> threadFactory<span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ThreadPoolExecutor</span><span>(</span><span>0</span><span>,</span> <span>Integer</span><span>.</span>MAX_VALUE<span>,</span>
                                      <span>60L</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>,</span>
                                      <span>new</span> <span>SynchronousQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>)</span><span>,</span>
                                      threadFactory<span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>static</span> <span>ExecutorService</span> <span>newCachedThreadPool</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ThreadPoolExecutor</span><span>(</span><span>0</span><span>,</span> <span>Integer</span><span>.</span>MAX_VALUE<span>,</span>
                                      <span>60L</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>,</span>
                                      <span>new</span> <span>SynchronousQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>CachedThreadPool 的corePoolSize 被设置为空(0)，maximumPoolSize被设置为 Integer.MAX.VALUE，即它是无界的，这也就意味着如果主线程提交任务的速度高于 maximumPool 中线程处理任务的速度时，CachedThreadPool 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/CachedThreadPool运行示意.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<ol>
<li>首先执行 SynchronousQueue.offer(Runnable task) 提交任务到任务队列。如果当前 maximumPool 中有闲线程正在执行 SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)，那么主线程执行 offer 操作与空闲线程执行的 poll 操作配对成功，主线程把任务交给空闲线程执行，execute()方法执行完成，否则执行下面的步骤 2；</li>
<li>当初始 maximumPool 为空，或者 maximumPool 中没有空闲线程时，将没有线程执行 SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)。这种情况下，步骤 1 将失败，此时 CachedThreadPool 会创建新线程执行任务，execute 方法执行完成；</li>
</ol>
<h3 id="scheduledthreadpoolexecutor详解" tabindex="-1"> ScheduledThreadPoolExecutor详解</h3>
<p>ScheduledThreadPoolExecutor 使用的任务队列 DelayQueue 封装了一个 PriorityQueue，PriorityQueue 会对队列中的任务进行排序，执行所需时间短的放在前面先被执行(ScheduledFutureTask 的 time 变量小的先执行)，如果执行所需时间相同则先提交的任务将被先执行(ScheduledFutureTask 的 squenceNumber 变量小的先执行)。</p>
<p>ScheduledThreadPoolExecutor 和 Timer 的比较：</p>
<ul>
<li>Timer 对系统时钟的变化敏感，ScheduledThreadPoolExecutor不是；</li>
<li>Timer 只有一个执行线程，因此长时间运行的任务可以延迟其他任务。 ScheduledThreadPoolExecutor 可以配置任意数量的线程。 此外，如果你想(通过提供 ThreadFactory)，你可以完全控制创建的线程;</li>
<li>在TimerTask 中抛出的运行时异常会杀死一个线程，从而导致 Timer 死机:
<ul>
<li>( ...即计划任务将不再运行。ScheduledThreadExecutor 不仅捕获运行时异常，还允许您在需要时处理它们(通过重写 afterExecute 方法ThreadPoolExecutor)。抛出异常的任务将被取消，但其他任务将继续运行。</li>
</ul>
</li>
</ul>
<p>综上，在 JDK1.5 之后，你没有理由再使用 Timer 进行任务调度了。</p>
<blockquote>
<p>备注： Quartz 是一个由 java 编写的任务调度库，由 OpenSymphony 组织开源出来。在实际项目开发中使用 Quartz 的还是居多，比较推荐使用 Quartz。因为 Quartz 理论上能够同时对上万个任务进行调度，拥有丰富的功能特性，包括任务调度、任务持久化、可集群化、插件等等。</p>
</blockquote>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/ScheduledThreadPoolExecutor运行示意.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<p><strong>ScheduledThreadPoolExecutor 的执行主要分为两大部分：</strong></p>
<ol>
<li>当调用 ScheduledThreadPoolExecutor 的 scheduleAtFixedRate() 方法或者scheduleWirhFixedDelay() 方法时，会向 ScheduledThreadPoolExecutor 的 DelayQueue 添加一个实现了 RunnableScheduledFuture 接口的 ScheduledFutureTask 。</li>
<li>线程池中的线程从 DelayQueue 中获取 ScheduledFutureTask，然后执行任务。</li>
</ol>
<p>ScheduledThreadPoolExecutor 为了实现周期性的执行任务，对 ThreadPoolExecutor做了如下修改：</p>
<ul>
<li>使用 DelayQueue 作为任务队列；</li>
<li>获取任务的方不同</li>
<li>执行周期任务后，增加了额外的处理</li>
</ul>
<p><strong>ScheduledThreadPoolExecutor执行周期任务的步骤</strong></p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/ScheduledThreadPoolExecutor执行周期任务运行示意.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<ol>
<li>线程 1 从 DelayQueue 中获取已到期的 ScheduledFutureTask(DelayQueue.take())。到期任务是指 ScheduledFutureTask的 time 大于等于当前系统的时间；</li>
<li>线程 1 执行这个 ScheduledFutureTask；</li>
<li>线程 1 修改 ScheduledFutureTask 的 time 变量为下次将要被执行的时间；</li>
<li>线程 1 把这个修改 time 之后的 ScheduledFutureTask 放回 DelayQueue 中(DelayQueue.add())。</li>
</ol>
<h3 id="futuretask详解" tabindex="-1"> FutureTask详解</h3>
<p>FutureTask除了实现Future接口外，还实现了Runnable接口。因此，FutureTask可以交给Executor执行，也可以由调用线程直接执行(FutureTask.run())。根据FutureTask.run()方法被执行的时机，FutureTask可以处于下面3种状态：</p>
<ol>
<li>未启动。FutureTask.run()方法还没有被执行之前，FutureTask处于未启动状态。当创建一个FutureTask，且没有执行FutureTask.run()方法之前，这个FutureTask处于未启动状态。</li>
<li>已启动。FutureTask.run()方法被执行的过程中，FutureTask处于已启动状态。</li>
<li>已完成。FutureTask.run()方法执行完后正常结束，或被取消(FutureTask.cancel(…))，或执行FutureTask.run()方法时抛出异常而异常结束，FutureTask处于已完成状态</li>
</ol>
<p>FutureTask的状态迁移的示意:</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/FutureTask的状态迁移示意图.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<p>当FutureTask处于未启动或已启动状态时，执行FutureTask.get()方法将导致调用线程阻塞；当FutureTask处于已完成状态时，执行FutureTask.get()方法将导致调用线程立即返回结果或抛出异常。</p>
<p>当FutureTask处于未启动状态时，执行FutureTask.cancel()方法将导致此任务永远不会被执行；当FutureTask处于已启动状态时，执行FutureTask.cancel(true)方法将以中断执行此任务线程的方式来试图停止任务；当FutureTask处于已启动状态时，执行FutureTask.cancel(false)方法将不会对正在执行此任务的线程产生影响(让正在执行的任务运行完成)；当FutureTask处于已完成状态时，执行FutureTask.cancel(…)方法将返回false。</p>
<p><strong>FutureTask 的使用</strong></p>
<p>可以把FutureTask交给Executor执行；也可以通过ExecutorService.submit(…)方法返回一个FutureTask，然后执行FutureTask.get()方法或FutureTask.cancel(…)方法。除此以外，还可以单独使用FutureTask。</p>
<p><strong>FutureTask 的实现</strong></p>
<p>FutureTask的实现基于AbstractQueuedSynchronizer(以下简称为AQS)。</p>
<p>基于“复合优先于继承”的原则，FutureTask声明了一个内部私有的继承于AQS的子类Sync，对FutureTask所有公有方法的调用都会委托给这个内部子类。</p>
<p>AQS被作为“模板方法模式”的基础类提供给FutureTask的内部子类Sync，这个内部子类只需要实现状态检查和状态更新的方法即可，这些方法将控制FutureTask的获取和释放操作。具体来说，Sync实现了AQS的tryAcquireShared(int)方法和tryReleaseShared(int)方法，Sync通过这两个方法来检查和更新同步状态</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/FutureTask的设计示意图.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<p>FutureTask.get()方法会调用AQS.acquireSharedInterruptibly(int arg)方法，这个方法的执行过程如下。</p>
<ol>
<li>调用AQS.acquireSharedInterruptibly(int arg)方法，这个方法首先会回调在子类Sync中实现的tryAcquireShared()方法来判断acquire操作是否可以成功。acquire操作可以成功的条件为：state为执行完成状态RAN或已取消状态CANCELLED，且runner不为null。</li>
<li>如果成功则get()方法立即返回。如果失败则到线程等待队列中去等待其他线程执行release操作。</li>
<li>当其他线程执行release操作(比如FutureTask.run()或FutureTask.cancel(…))唤醒当前线程后，当前线程再次执行tryAcquireShared()将返回正值1，当前线程将离开线程等待队列并唤醒它的后继线程(这里会产生级联唤醒的效果，后面会介绍)。</li>
<li>最后返回计算的结果或抛出异常。</li>
</ol>
<p>FutureTask.run()的执行过程如下。</p>
<ol>
<li>执行在构造函数中指定的任务(Callable.call())。</li>
<li>以原子方式来更新同步状态(调用AQS.compareAndSetState(int expect，int update)，设置state为执行完成状态RAN)。如果这个原子操作成功，就设置代表计算结果的变量result的值为Callable.call()的返回值，然后调用AQS.releaseShared(int arg)。</li>
<li>AQS.releaseShared(int arg)首先会回调在子类Sync中实现的tryReleaseShared(arg)来执行release操作(设置运行任务的线程runner为null，然会返回true)；AQS.releaseShared(int arg)，然后唤醒线程等待队列中的第一个线程。</li>
<li>调用FutureTask.done()。</li>
</ol>
<p>当执行FutureTask.get()方法时，如果FutureTask不是处于执行完成状态RAN或已取消状态CANCELLED，当前执行线程将到AQS的线程等待队列中等待(见下图的线程A、B、C和D)。当某个线程执行FutureTask.run()方法或FutureTask.cancel(...)方法时，会唤醒线程等待队列的第一个线程(见图所示的线程E唤醒线程A)</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/FutureTask的级联唤醒示意图.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<p>假设开始时FutureTask处于未启动状态或已启动状态，等待队列中已经有3个线程(A、B和C)在等待。此时，线程D执行get()方法将导致线程D也到等待队列中去等待。</p>
<p>当线程E执行run()方法时，会唤醒队列中的第一个线程A。线程A被唤醒后，首先把自己从队列中删除，然后唤醒它的后继线程B，最后线程A从get()方法返回。线程B、C和D重复A线程的处理流程。最终，在队列中等待的所有线程都被级联唤醒并从get()方法返回</p>
<h2 id="fork-join框架" tabindex="-1"> Fork/Join框架</h2>
<p>Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/java-concurrent/Fork-Join的运行流程图.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<p><strong>工作窃取(work-stealing)算法</strong>：假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p>
<ul>
<li>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，</li>
<li>缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</li>
</ul>
<h3 id="fork-join框架的设计" tabindex="-1"> Fork/Join框架的设计</h3>
<ul>
<li>步骤1 分割任务。首先我们需要有一个fork类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停地分割，直到分割出的子任务足够小。</li>
<li>步骤2 执行任务并合并结果。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</li>
</ul>
<p>Fork/Join使用两个类来完成以上两件事情</p>
<ul>
<li>ForkJoinTask：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制，通常情况下我们不需要直接继承ForkJoinTask类，而只需要继承它的子类，Fork/Join框架提供了以下两个子类：
<ul>
<li>RecursiveAction：用于没有返回结果的任务。</li>
<li>RecursiveTask ：用于有返回结果的任务。</li>
</ul>
</li>
<li>ForkJoinPool ：ForkJoinTask需要通过ForkJoinPool来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</li>
</ul>
<h3 id="fork-join框架的使用" tabindex="-1"> Fork/Join框架的使用</h3>
<p>ForkJoinTask与一般任务的主要区别在于它需要实现compute方法，在这个方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果不足够小，就必须分割成两个子任务，每个子任务在调用fork方法时，又会进入compute方法，看看当前子任务是否需要继续分割成子任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完并得到其结果。</p>
<p>ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否一件抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常。其中，getException方法返回Throwable对象，如果任务被取消了则返回CancellationException，如果任务没有完成或者没有抛出异常则返回null。</p>
<h3 id="fork-join框架的实现原理" tabindex="-1"> Fork/Join框架的实现原理</h3>
<p>ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，ForkJoinTask数组负责将存放程序提交给ForkJoinPool的任务，而ForkJoinWorkerThread数组负责执行这些任务</p>
<ol>
<li>ForkJoinTask的<strong>fork</strong>方法实现原理<br>
当我们调用ForkJoinTask的fork方法时，程序会调用ForkJoinWorkerThread的pushTask方法异步地执行这个任务，然后立即返回结果。</li>
</ol>
<div><pre><code>    <span>public</span> <span>final</span> <span>ForkJoinTask</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>fork</span><span>(</span><span>)</span> <span>{</span>
        <span>(</span><span>(</span><span>ForkJoinWorkerThread</span><span>)</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>)</span>
            <span>.</span><span>pushTask</span><span>(</span><span>this</span><span>)</span><span>;</span>
        <span>return</span> <span>this</span><span>;</span>
    <span>}</span>
</code></pre></div><p>pushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务</p>
<div><pre><code>    <span>final</span> <span>void</span> <span>pushTask</span><span>(</span><span>ForkJoinTask</span><span><span>&lt;</span><span>></span></span> t<span>)</span> <span>{</span>
        <span>ForkJoinTask</span><span><span>&lt;</span><span>></span></span><span>[</span><span>]</span> q<span>;</span> <span>int</span> s<span>,</span> m<span>;</span>
        <span>if</span> <span>(</span><span>(</span>q <span>=</span> queue<span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span> <span>// ignore if queue removed</span>
            <span>long</span> u <span>=</span> <span>(</span><span>(</span><span>(</span>s <span>=</span> queueTop<span>)</span> <span>&amp;</span> <span>(</span>m <span>=</span> q<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>)</span> <span>&lt;&lt;</span> ASHIFT<span>)</span> <span>+</span> ABASE<span>;</span>
            UNSAFE<span>.</span><span>putOrderedObject</span><span>(</span>q<span>,</span> u<span>,</span> t<span>)</span><span>;</span>
            queueTop <span>=</span> s <span>+</span> <span>1</span><span>;</span> <span>// or use putOrderedInt</span>
            <span>if</span> <span>(</span><span>(</span>s <span>-=</span> queueBase<span>)</span> <span>&lt;=</span> <span>2</span><span>)</span>
                pool<span>.</span><span>signalWork</span><span>(</span><span>)</span><span>;</span>
            <span>else</span> <span>if</span> <span>(</span>s <span>==</span> m<span>)</span>
                <span>growQueue</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ol start="2">
<li>ForkJoinTask的<strong>join</strong>方法实现原理<br>
Join方法的主要作用是阻塞当前线程并等待获取结果</li>
</ol>
<div><pre><code>    <span>public</span> <span>final</span> <span>V</span> <span>join</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>doJoin</span><span>(</span><span>)</span> <span>!=</span> NORMAL<span>)</span>
            <span>return</span> <span>reportResult</span><span>(</span><span>)</span><span>;</span>
        <span>else</span>
            <span>return</span> <span>getRawResult</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>V</span> <span>reportResult</span><span>(</span><span>)</span> <span>{</span>
        <span>int</span> s<span>;</span>
        <span>Throwable</span> ex<span>;</span>
        <span>if</span> <span>(</span><span>(</span>s <span>=</span> status<span>)</span> <span>==</span> CANCELLED<span>)</span>
            <span>throw</span> <span>new</span> <span>CancellationException</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>s <span>==</span> EXCEPTIONAL <span>&amp;&amp;</span> <span>(</span>ex <span>=</span> <span>getThrowableException</span><span>(</span><span>)</span><span>)</span> <span>!=</span> <span>null</span><span>)</span>
            UNSAFE<span>.</span><span>throwException</span><span>(</span>ex<span>)</span><span>;</span>
        <span>return</span> <span>getRawResult</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>首先，它调用了doJoin()方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有4种：已完成(NORMAL)、被取消(CANCELLED)、信号(SIGNAL)和出现异常(EXCEPTIONAL)。</p>
<ul>
<li>如果任务状态是已完成，则直接返回任务结果。</li>
<li>如果任务状态是被取消，则直接抛出CancellationException。</li>
<li>如果任务状态是抛出异常，则直接抛出对应的异常。</li>
</ul>
<div><pre><code>    <span>private</span> <span>int</span> <span>doJoin</span><span>(</span><span>)</span> <span>{</span>
        <span>Thread</span> t<span>;</span>
        <span>ForkJoinWorkerThread</span> w<span>;</span>
        <span>int</span> s<span>;</span>
        <span>boolean</span> completed<span>;</span>
        <span>if</span> <span>(</span><span>(</span>t <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>)</span> <span>instanceof</span> <span>ForkJoinWorkerThread</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>(</span>s <span>=</span> status<span>)</span> <span>&lt;</span> <span>0</span><span>)</span>
                <span>return</span> s<span>;</span>
            <span>if</span> <span>(</span><span>(</span>w <span>=</span> <span>(</span><span>ForkJoinWorkerThread</span><span>)</span> t<span>)</span><span>.</span><span>unpushTask</span><span>(</span><span>this</span><span>)</span><span>)</span> <span>{</span>
                <span>try</span> <span>{</span>
                    completed <span>=</span> <span>exec</span><span>(</span><span>)</span><span>;</span>
                <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> rex<span>)</span> <span>{</span>
                    <span>return</span> <span>setExceptionalCompletion</span><span>(</span>rex<span>)</span><span>;</span>
                <span>}</span>
                <span>if</span> <span>(</span>completed<span>)</span>
                    <span>return</span> <span>setCompletion</span><span>(</span>NORMAL<span>)</span><span>;</span>
            <span>}</span>
            <span>return</span> w<span>.</span><span>joinTask</span><span>(</span><span>this</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span>
            <span>return</span> <span>externalAwaitDone</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>在doJoin()方法里，首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；如果没有执行完，则从任务数组里取出任务并执行。如果任务顺利执行完成，则设置任务状态为NORMAL，如果出现异常，则记录异常，并将任务状态设置为EXCEPTIONAL。</p>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li>BruceEckel. Java 编程思想: 第 4 版 [M]. 机械工业出版社, 2007.</li>
<li>周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.</li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se6/html/Threads.doc.html" target="_blank" rel="noopener noreferrer">Threads and Locks</a></li>
<li><a href="http://ifeve.com/thread-signaling/#missed_signal" target="_blank" rel="noopener noreferrer">线程通信</a></li>
<li><a href="http://www.importnew.com/12773.html" target="_blank" rel="noopener noreferrer">Java 线程面试题 Top 50</a></li>
<li><a href="http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html" target="_blank" rel="noopener noreferrer">BlockingQueue</a></li>
<li><a href="https://stackoverflow.com/questions/11265289/thread-state-java" target="_blank" rel="noopener noreferrer">thread state java</a></li>
<li><a href="http://wiki.expertiza.ncsu.edu/index.php/CSC_456_Spring_2012/ch7_MN" target="_blank" rel="noopener noreferrer">CSC 456 Spring 2012/ch7 MN</a></li>
<li><a href="https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/happens-before.html" target="_blank" rel="noopener noreferrer">Java - Understanding Happens-before relationship</a></li>
<li><a href="https://www.slideshare.net/novathinker/6-thread-synchronization" target="_blank" rel="noopener noreferrer">6장 Thread Synchronization</a></li>
<li><a href="https://stackoverflow.com/questions/1202444/how-is-javas-threadlocal-implemented-under-the-hood/15653015" target="_blank" rel="noopener noreferrer">How is Java's ThreadLocal implemented under the hood?</a></li>
<li><a href="https://sites.google.com/site/webdevelopart/21-compile/06-java/javase/concurrent?tmpl=%2Fsystem%2Fapp%2Ftemplates%2Fprint%2F&amp;showPrintDialog=1" target="_blank" rel="noopener noreferrer">Concurrent</a></li>
<li><a href="http://www.javacreed.com/java-fork-join-example/" title="Java Fork Join Example" target="_blank" rel="noopener noreferrer">JAVA FORK JOIN EXAMPLE</a></li>
<li><a href="http://ifeve.com/talk-concurrency-forkjoin/" target="_blank" rel="noopener noreferrer">聊聊并发(八)——Fork/Join 框架介绍</a></li>
<li><a href="http://www.oracle.com/technetwork/java/javase/tech/biasedlocking-oopsla2006-preso-150106.pdf" target="_blank" rel="noopener noreferrer">Eliminating SynchronizationRelated Atomic Operations with Biased Locking and Bulk Rebiasing</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java8特性</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/Java%E7%89%B9%E6%80%A7.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/Java%E7%89%B9%E6%80%A7.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">Java8特性</source>
      <category>Java</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>

<h1 id="java-8-特性" tabindex="-1"> Java 8 特性</h1>
<h2 id="java语言" tabindex="-1"> Java语言</h2>
<h3 id="接口的默认方法" tabindex="-1"> 接口的默认方法</h3>
<p><strong>Default Methods for Interfaces</strong></p>
<p>Java 8 使用两个新概念扩展了接口的含义：默认方法和静态方法。</p>
<p>默认方法使得开发者可以在不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。</p>
<p>默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写</p>
<p>不管是抽象类还是接口，都可以通过匿名内部类的方式访问。不能通过抽象类或者接口直接创建对象。对于通过匿名内部类方式访问接口，我们可以这样理解：一个内部类实现了接口里的抽象方法并且返回一个内部类对象，之后我们让接口的引用来指向这个对象。</p>
<h3 id="接口静态方法" tabindex="-1"> 接口静态方法</h3>
<p>Java 8 带来的另一个有趣的特性是在接口中可以定义静态方法</p>
<p>由于JVM上的默认方法的实现在字节码层面提供了支持，因此效率非常高。默认方法允许在不打破现有继承体系的基础上改进接口。</p>
<p>该特性在官方库中的应用是：给java.util.Collection接口添加新方法，如stream()、parallelStream()、forEach()和removeIf()等等。</p>
<p>尽管默认方法有这么多好处，但在实际开发中应该谨慎使用：在复杂的继承体系中，默认方法可能引起歧义和编译错误。</p>
<h3 id="lambda表达式" tabindex="-1"> Lambda表达式</h3>
<p><strong>Lambda expressions</strong></p>
<p>传统匿名内部类缺点：代码臃肿，难以阅读</p>
<p>lambda表达式本质上是一段匿名内部类，也可以是一段可以传递的代码；Lambda 表达式将函数当成参数传递给某个方法，或者把代码本身当作数据处理；</p>
<p>Lambda表达式在大多数虚拟机中采用invokeDynamic指令实现，相对于匿名内部类在效率上会更高一些。</p>
<h4 id="lamda-表达式作用域" tabindex="-1"> Lamda 表达式作用域</h4>
<p><strong>Lambda Scopes</strong></p>
<p><strong>访问局部变量</strong></p>
<p>可以直接在 lambda 表达式中访问外部的局部变量，和匿名对象不同的是，这里的变量可以不用声明为final，不过这里的变量必须不可被后面的代码修改（即隐性的具有final的语义）</p>
<p><strong>访问字段和静态变量</strong></p>
<p>与局部变量相比，我们对lambda表达式中的实例字段和静态变量都有读写访问权限。 该行为和匿名对象是一致的。</p>
<p><strong>访问默认接口方法</strong></p>
<p>可以从包含匿名对象的每个接口实现实例访问该默认方法方法， 这不适用于lambda表达式；无法从 lambda 表达式中访问默认方法</p>
<h4 id="lambda-表达式实现方式" tabindex="-1"> Lambda 表达式实现方式</h4>
<ul>
<li>在类编译时，会生成一个私有静态方法+一个内部类。</li>
<li>在内部类中实现了函数式接口，在实现接口的方法中，会调用编译器生成的静态方法。</li>
<li>在使用lambda表达式的地方，通过传递内部类实例，来调用函数式接口方法。</li>
</ul>
<h4 id="函数式接口" tabindex="-1"> 函数式接口</h4>
<p><strong>Functional Interfaces</strong></p>
<p>Java 语言设计者们投入了大量精力来思考如何使现有的函数友好地支持Lambda。最终采取的方法是：增加函数式接口的概念。<strong>“函数式接口”是指仅仅只包含一个抽象方法,但是可以有多个非抽象方法(默认方法和静态方法)的接口</strong>。 像这样的接口，可以被隐式转换为lambda表达式。</p>
<ul>
<li>接口中只能有一个抽象接口方法</li>
<li>可以有静态方法和默认方法</li>
<li>建议在接口上使用@FunctionalInterface 注解进行声明，这样的话，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的</li>
<li>默认方法可以被覆写</li>
</ul>
<p>大部分函数式接口都不用我们自己写，Java8都给我们实现好了，这些接口都在java.util.function包里</p>
<h4 id="内置函数式接口" tabindex="-1"> 内置函数式接口</h4>
<p><strong>Built-in Functional Interfaces</strong></p>
<p>Java 8 API包含许多内置函数式接口。 其中一些接口在老版本的 Java 中是比较常见的比如： Comparator 或Runnable，这些接口都增加了@FunctionalInterface注解以便能用在 lambda 表达式上。</p>
<p>但是 Java 8 API 同样还提供了很多全新的函数式接口来让你的编程工作更加方便，有一些接口是来自 Google Guava 库里的。</p>
<ul>
<li><code>Function&lt;T,R&gt;</code> T 作为输入，返回的 R 作为输出</li>
<li><code>Predicate&lt;T&gt;</code> T 作为输入 ，返回 boolean 值的输出</li>
<li><code>Consumer&lt;T&gt;</code> T 作为输入 ，没有输出</li>
<li><code>Supplier&lt;R&gt;</code> 没有输入 , R 作为输出</li>
<li><code>BinaryOperator&lt;T&gt;</code> 两个 T 作为输入 ，T 同样是输出</li>
<li><code>UnaryOperator&lt;T&gt;</code> 是 Function 的变种 ，输入输出者是 T</li>
</ul>
<h5>Predicates</h5>
<p>Predicate 接口是只有一个参数的返回布尔类型值的 断言型 接口。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）</p>
<div><pre><code><span>package</span> <span>java<span>.</span>util<span>.</span>function</span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Objects</span></span><span>;</span>

<span>@FunctionalInterface</span>
<span>public</span> <span>interface</span> <span>Predicate</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>

    <span>// 该方法是接受一个传入类型,返回一个布尔值.此方法应用于判断.</span>
    <span>boolean</span> <span>test</span><span>(</span><span>T</span> t<span>)</span><span>;</span>

    <span>//and方法与关系型运算符"&amp;&amp;"相似，两边都成立才返回true</span>
    <span>default</span> <span>Predicate</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>and</span><span>(</span><span>Predicate</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span></span> other<span>)</span> <span>{</span>
        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>other<span>)</span><span>;</span>
        <span>return</span> <span>(</span>t<span>)</span> <span>-></span> <span>test</span><span>(</span>t<span>)</span> <span>&amp;&amp;</span> other<span>.</span><span>test</span><span>(</span>t<span>)</span><span>;</span>
    <span>}</span>

    <span>// 与关系运算符"!"相似，对判断进行取反</span>
    <span>default</span> <span>Predicate</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>negate</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>(</span>t<span>)</span> <span>-></span> <span>!</span><span>test</span><span>(</span>t<span>)</span><span>;</span>
    <span>}</span>

    <span>//or方法与关系型运算符"||"相似，两边只要有一个成立就返回true</span>
    <span>default</span> <span>Predicate</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>or</span><span>(</span><span>Predicate</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span></span> other<span>)</span> <span>{</span>
        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>other<span>)</span><span>;</span>
        <span>return</span> <span>(</span>t<span>)</span> <span>-></span> <span>test</span><span>(</span>t<span>)</span> <span>||</span> other<span>.</span><span>test</span><span>(</span>t<span>)</span><span>;</span>
    <span>}</span>

    <span>// 该方法接收一个Object对象,返回一个Predicate类型.此方法用于判断第一个test的方法与第二个test方法相同(equal).</span>
    <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>Predicate</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>isEqual</span><span>(</span><span>Object</span> targetRef<span>)</span> <span>{</span>
        <span>return</span> <span>(</span><span>null</span> <span>==</span> targetRef<span>)</span>
            <span>?</span> <span>Objects</span><span>::</span><span>isNull</span>
            <span>:</span> object <span>-></span> targetRef<span>.</span><span>equals</span><span>(</span>object<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h5>Functions</h5>
<p>Function 接口接受一个参数并生成结果。默认方法可用于将多个函数链接在一起（compose, andThen）</p>
<div><pre><code><span>package</span> <span>java<span>.</span>util<span>.</span>function</span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Objects</span></span><span>;</span>

<span>@FunctionalInterface</span>
<span>public</span> <span>interface</span> <span>Function</span><span><span>&lt;</span><span>T</span><span>,</span> <span>R</span><span>></span></span> <span>{</span>

    <span>//将Function对象应用到输入的参数上，然后返回计算结果。</span>
    <span>R</span> <span>apply</span><span>(</span><span>T</span> t<span>)</span><span>;</span>

    <span>//将两个Function整合，并返回一个能够执行两个Function对象功能的Function对象。</span>
    <span>default</span> <span><span>&lt;</span><span>V</span><span>></span></span> <span>Function</span><span><span>&lt;</span><span>V</span><span>,</span> <span>R</span><span>></span></span> <span>compose</span><span>(</span><span>Function</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>V</span><span>,</span> <span>?</span> <span>extends</span> <span>T</span><span>></span></span> before<span>)</span> <span>{</span>
        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>before<span>)</span><span>;</span>
        <span>return</span> <span>(</span><span>V</span> v<span>)</span> <span>-></span> <span>apply</span><span>(</span>before<span>.</span><span>apply</span><span>(</span>v<span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>//</span>
    <span>default</span> <span><span>&lt;</span><span>V</span><span>></span></span> <span>Function</span><span><span>&lt;</span><span>T</span><span>,</span> <span>V</span><span>></span></span> <span>andThen</span><span>(</span><span>Function</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>R</span><span>,</span> <span>?</span> <span>extends</span> <span>V</span><span>></span></span> after<span>)</span> <span>{</span>
        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>after<span>)</span><span>;</span>
        <span>return</span> <span>(</span><span>T</span> t<span>)</span> <span>-></span> after<span>.</span><span>apply</span><span>(</span><span>apply</span><span>(</span>t<span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>Function</span><span><span>&lt;</span><span>T</span><span>,</span> <span>T</span><span>></span></span> <span>identity</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> t <span>-></span> t<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h5>Suppliers</h5>
<p>Supplier 接口产生给定泛型类型的结果。 与 Function 接口不同，Supplier 接口不接受参数。</p>
<h5>Consumers</h5>
<p>Consumer 接口表示要对单个输入参数执行的操作</p>
<h5>Comparators</h5>
<p>Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法：</p>
<div><pre><code>    <span>Comparator</span><span><span>&lt;</span><span>Person</span><span>></span></span> comparator <span>=</span> <span>(</span>p1<span>,</span> p2<span>)</span> <span>-></span> p1<span>.</span>firstName<span>.</span><span>compareTo</span><span>(</span>p2<span>.</span>firstName<span>)</span><span>;</span>

    <span>Person</span> p1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"John"</span><span>,</span> <span>"Doe"</span><span>)</span><span>;</span>
    <span>Person</span> p2 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"Alice"</span><span>,</span> <span>"Wonderland"</span><span>)</span><span>;</span>

    comparator<span>.</span><span>compare</span><span>(</span>p1<span>,</span> p2<span>)</span><span>;</span>             <span>// > 0</span>
    comparator<span>.</span><span>reversed</span><span>(</span><span>)</span><span>.</span><span>compare</span><span>(</span>p1<span>,</span> p2<span>)</span><span>;</span>  <span>// &lt; 0</span>
</code></pre></div><h3 id="方法和构造函数引用" tabindex="-1"> 方法和构造函数引用</h3>
<p><strong>Method and Constructor References</strong></p>
<p>通常与Lambda表达式联合使用，方法引用使得可以直接引用已有Java类或对象的方法</p>
<p>Java 8允许您通过::关键字传递方法或构造函数的引用，</p>
<ol>
<li>构造器引用，语法是<code>Class::new</code>，或者更一般的形式：<code>Class&lt;T&gt;::new</code></li>
<li>静态方法引用，语法是<code>Class::static_method</code></li>
<li>某个类的成员方法的引用，语法是<code>Class::method</code></li>
<li>某个实例对象的成员方法的引用，语法是<code>instance::method</code></li>
</ol>
<h3 id="多重注解" tabindex="-1"> 多重注解</h3>
<p>在Java 5中使用注解有一个限制，即相同的注解在同一位置只能声明一次。Java 8引入重复注解，这样相同的注解在同一地方也可以声明多次。重复注解机制本身需要用@Repeatable注解。Java 8在编译器层做了优化，相同注解会以集合的方式保存，因此底层的原理并没有变化。</p>
<p>另外，反射API提供了一个新的方法：getAnnotationsByType()，可以返回某个类型的重复注解</p>
<h3 id="foreach" tabindex="-1"> forEach</h3>
<p>Collection 接口实现了 Iterable 接口，而 Iterable 接口在 Java 8开始具有一个新的 API：</p>
<div><pre><code>    <span>public</span> <span>interface</span> <span>Collection</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>Iterable</span><span><span>&lt;</span><span>E</span><span>></span></span>

    <span>void</span> <span>forEach</span><span>(</span><span>Consumer</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span></span> action<span>)</span><span>//对 Iterable的每个元素执行给定的操作，直到所有元素都被处理或动作引发异常。</span>
</code></pre></div><p>使用forEach，我们可以迭代一个集合并对每个元素执行给定的操作，就像任何其他迭代器一样。</p>
<p>迭代和打印字符串集合的for循环版本和forEach版本</p>
<div><pre><code>    <span>for</span> <span>(</span><span>String</span> name <span>:</span> names<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name<span>)</span><span>;</span>
    <span>}</span>

    names<span>.</span><span>forEach</span><span>(</span>name <span>-></span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name<span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
</code></pre></div><h4 id="foreach的方法使用" tabindex="-1"> forEach的方法使用</h4>
<h5>匿名类</h5>
<p>使用 forEach迭代集合并对每个元素执行特定操作。要执行的操作包含在实现Consumer接口的类中，并作为参数传递给forEach 。</p>
<p>所述消费者接口是一个功能接口(具有单个抽象方法的接口）。它接受输入并且不返回任何结果。</p>
<div><pre><code>    <span>Consumer</span><span><span>&lt;</span><span>String</span><span>></span></span> printConsumer <span>=</span> <span>new</span> <span>Consumer</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span> <span>{</span>
        <span>public</span> <span>void</span> <span>accept</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name<span>)</span><span>;</span>
        <span>}</span><span>;</span>
    <span>}</span><span>;</span>
    <span>//可以作为参数传递给forEach：</span>
    names<span>.</span><span>forEach</span><span>(</span>printConsumer<span>)</span><span>;</span>
</code></pre></div><h5>lambda表达式</h5>
<p>由于 Consumer 接口属于函数式接口，可以通过以下形式在Lambda中表达它</p>
<div><pre><code>    names<span>.</span><span>forEach</span><span>(</span>name <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name<span>)</span><span>)</span><span>;</span>
</code></pre></div><h5>方法引用</h5>
<p>以使用方法引用语法而不是普通的Lambda语法，其中已存在一个方法来对类执行操作</p>
<div><pre><code>    names<span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>
</code></pre></div><h4 id="foreach在集合中的使用" tabindex="-1"> forEach在集合中的使用</h4>
<h5>迭代集合</h5>
<p>任何类型Collection的可迭代 - 列表，集合，队列 等都具有使用forEach的相同语法。</p>
<div><pre><code>    <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> names <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>"Larry"</span><span>,</span> <span>"Steve"</span><span>,</span> <span>"James"</span><span>)</span><span>;</span>
    names<span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>
</code></pre></div><h5>迭代Map</h5>
<ol>
<li><strong>使用Map的forEach</strong></li>
</ol>
<p>Map没有实现Iterable接口，但它提供了自己的<strong>forEach 变体</strong>，它接受<strong>BiConsumer</strong>。</p>
<div><pre><code>    <span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>></span></span> namesMap <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    namesMap<span>.</span><span>put</span><span>(</span><span>1</span><span>,</span> <span>"Larry"</span><span>)</span><span>;</span>
    namesMap<span>.</span><span>put</span><span>(</span><span>2</span><span>,</span> <span>"Steve"</span><span>)</span><span>;</span>
    namesMap<span>.</span><span>put</span><span>(</span><span>3</span><span>,</span> <span>"James"</span><span>)</span><span>;</span>
    namesMap<span>.</span><span>forEach</span><span>(</span><span>(</span>key<span>,</span> value<span>)</span> <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>key <span>+</span> <span>" "</span> <span>+</span> value<span>)</span><span>)</span><span>;</span>
</code></pre></div><ol start="2">
<li>通过迭代entrySet</li>
</ol>
<div><pre><code>    namesMap<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>.</span><span>forEach</span><span>(</span>entry <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>entry<span>.</span><span>getKey</span><span>(</span><span>)</span> <span>+</span> <span>" "</span> <span>+</span> entry<span>.</span><span>getValue</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
</code></pre></div><h5>迭代Map</h5>
<h2 id="java-官方库" tabindex="-1"> Java 官方库</h2>
<h3 id="streams" tabindex="-1"> Streams</h3>
<p>Stream API是把真正的函数式编程风格引入到Java中。其实简单来说可以把Stream理解为MapReduce，当然Google的MapReduce的灵感也是来自函数式编程。其实是一连串支持连续、并行聚集操作的元素。</p>
<p>java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回一个新的 Stream(这样可以将多个操作依次串起来)，只是把要做的操作记录起来而已，并不会真的执行，最终操作才会真的遍历列表并执行所有操作。Stream 的创建需要指定一个数据源，比如java.util.Collection 的子类，List 或者 Set， Map 不支持。Stream 的操作可以串行执行或者并行执行。</p>
<p>Java 8 扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。</p>
<p><strong>Maps</strong></p>
<p>Map 类型不支持 streams，不过Map提供了一些新的有用的方法来处理一些日常任务。Map接口本身没有可用的 stream（）方法，但是你可以在键，值上创建专门的流或者通过 map.keySet().stream(),map.values().stream()和map.entrySet().stream()。</p>
<p>此外,Maps 支持各种新的和有用的方法来执行常见任务</p>
<ul>
<li><code>putIfAbsent</code> 阻止我们在null检查时写入额外的代码;</li>
<li><code>forEach</code> 接受一个 BiConsumer 来对 map 中的每个元素操作。</li>
<li><code>computeIfPresent</code></li>
<li><code>getOrDefault</code></li>
<li><code>merge</code></li>
<li>...</li>
</ul>
<p>Stream API 简化了集合的操作，并扩展了集合的分组，求和，mapReduce，flatMap ，排序等功能。</p>
<h4 id="filter-过滤" tabindex="-1"> Filter(过滤)</h4>
<p>过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。</p>
<div><pre><code>    <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> stringList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    stringList<span>.</span><span>add</span><span>(</span><span>"ddd2"</span><span>)</span><span>;</span>
    stringList<span>.</span><span>add</span><span>(</span><span>"aaa2"</span><span>)</span><span>;</span>
    stringList<span>.</span><span>add</span><span>(</span><span>"bbb1"</span><span>)</span><span>;</span>
    stringList<span>.</span><span>add</span><span>(</span><span>"aaa1"</span><span>)</span><span>;</span>
    stringList<span>.</span><span>add</span><span>(</span><span>"bbb3"</span><span>)</span><span>;</span>
    stringList<span>.</span><span>add</span><span>(</span><span>"ccc"</span><span>)</span><span>;</span>
    stringList<span>.</span><span>add</span><span>(</span><span>"bbb2"</span><span>)</span><span>;</span>
    stringList<span>.</span><span>add</span><span>(</span><span>"ddd1"</span><span>)</span><span>;</span>
</code></pre></div><div><pre><code>    stringList
            <span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>filter</span><span>(</span><span>(</span>s<span>)</span> <span>-></span> s<span>.</span><span>startsWith</span><span>(</span><span>"a"</span><span>)</span><span>)</span>
            <span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span><span>//aaa2 aaa1</span>
</code></pre></div><p>forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便</p>
<h4 id="sorted-排序" tabindex="-1"> Sorted(排序)</h4>
<p>排序是一个 中间操作，返回的是排序好后的 Stream。如果你不指定一个自定义的 Comparator 则会使用默认排序。</p>
<div><pre><code>    <span>// 测试 Sort (排序)</span>
    stringList
            <span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>sorted</span><span>(</span><span>)</span><span>.</span><span>filter</span><span>(</span><span>(</span>s<span>)</span> <span>-></span> s<span>.</span><span>startsWith</span><span>(</span><span>"a"</span><span>)</span><span>)</span>
            <span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span><span>// aaa1 aaa2</span>
</code></pre></div><p><strong>注意</strong>：
排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的</p>
<h4 id="map-映射" tabindex="-1"> Map(映射)</h4>
<p>中间操作 map 会将元素根据指定的 Function 接口来依次将元素转成另外的对象。</p>
<p>下面的示例展示了将字符串转换为大写字符串。你也可以通过map来将对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。</p>
<div><pre><code>    <span>// 测试 Map 操作</span>
    stringList
        <span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>map</span><span>(</span><span>String</span><span>::</span><span>toUpperCase</span><span>)</span><span>.</span><span>sorted</span><span>(</span><span>(</span>a<span>,</span> b<span>)</span> <span>-></span> b<span>.</span><span>compareTo</span><span>(</span>a<span>)</span><span>)</span>
        <span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span><span>// "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1"</span>
</code></pre></div><h4 id="match-匹配" tabindex="-1"> Match(匹配)</h4>
<p>Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是 最终操作 ，并返回一个 boolean 类型的值。</p>
<div><pre><code>    <span>// 测试 Match (匹配)操作</span>
    <span>boolean</span> anyStartsWithA <span>=</span>
        stringList
            <span>.</span><span>stream</span><span>(</span><span>)</span>
            <span>.</span><span>anyMatch</span><span>(</span><span>(</span>s<span>)</span> <span>-></span> s<span>.</span><span>startsWith</span><span>(</span><span>"a"</span><span>)</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>anyStartsWithA<span>)</span><span>;</span>      <span>// true</span>

    <span>boolean</span> allStartsWithA <span>=</span>
        stringList
            <span>.</span><span>stream</span><span>(</span><span>)</span>
            <span>.</span><span>allMatch</span><span>(</span><span>(</span>s<span>)</span> <span>-></span> s<span>.</span><span>startsWith</span><span>(</span><span>"a"</span><span>)</span><span>)</span><span>;</span>

    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>allStartsWithA<span>)</span><span>;</span>      <span>// false</span>

    <span>boolean</span> noneStartsWithZ <span>=</span>
        stringList
            <span>.</span><span>stream</span><span>(</span><span>)</span>
            <span>.</span><span>noneMatch</span><span>(</span><span>(</span>s<span>)</span> <span>-></span> s<span>.</span><span>startsWith</span><span>(</span><span>"z"</span><span>)</span><span>)</span><span>;</span>

    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>noneStartsWithZ<span>)</span><span>;</span>      <span>// true</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h4 id="count-计数" tabindex="-1"> Count(计数)</h4>
<p>计数是一个 最终操作，返回Stream中元素的个数，返回值类型是 long。</p>
<div><pre><code>    <span>//测试 Count (计数)操作</span>
    <span>long</span> startsWithB <span>=</span>
        stringList
            <span>.</span><span>stream</span><span>(</span><span>)</span>
            <span>.</span><span>filter</span><span>(</span><span>(</span>s<span>)</span> <span>-></span> s<span>.</span><span>startsWith</span><span>(</span><span>"b"</span><span>)</span><span>)</span>
            <span>.</span><span>count</span><span>(</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>startsWithB<span>)</span><span>;</span>    <span>// 3</span>
</code></pre></div><h4 id="reduce-规约" tabindex="-1"> Reduce(规约)</h4>
<p>这是一个最终操作 ，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规约后的结果是通过Optional 接口表示的：</p>
<div><pre><code>    <span>/</span>测试 <span>Reduce</span> <span>(</span>规约<span>)</span>操作
    <span>Optional</span><span><span>&lt;</span><span>String</span><span>></span></span> reduced <span>=</span>
        stringList
            <span>.</span><span>stream</span><span>(</span><span>)</span>
            <span>.</span><span>sorted</span><span>(</span><span>)</span>
            <span>.</span><span>reduce</span><span>(</span><span>(</span>s1<span>,</span> s2<span>)</span> <span>-></span> s1 <span>+</span> <span>"#"</span> <span>+</span> s2<span>)</span><span>;</span>

    reduced<span>.</span><span>ifPresent</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span><span>//aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2</span>
</code></pre></div><p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于Integer sum = integers.reduce(0, (a, b) -&gt; a+b);也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。</p>
<h3 id="parallel-streams" tabindex="-1"> Parallel Streams</h3>
<p>Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。</p>
<h3 id="optional" tabindex="-1"> Optional</h3>
<p>Java 8引入Optional类来防止空指针异常，Optional类最先是由Google的Guava项目引入的。Optional类实际上是个容器：它可以保存类型T的值，或者保存null。使用Optional类我们就不用显式进行空指针检查了。在Java 8之前一般某个函数应该返回非空对象但是有时却什么也没有返回，而在Java 8中，你应该返回 Optional 而不是 null。</p>
<h3 id="日期相关api-date-api" tabindex="-1"> 日期相关API(Date API)</h3>
<p>时间和日期的管理一直是最令Java开发者痛苦的问题。java.util.Date和后来的java.util.Calendar一直没有解决这个问题。（甚至令开发者更加迷茫）。因为这些原因，诞生了第三方库Joda-Time，可以替代Java的时间管理API。</p>
<p>Java 8中新的时间和日期管理API深受Joda-Time影响，并吸收了很多Joda-Time的精华。新的java.time包包含了所有关于日期、时间、时区、Instant（跟日期类似但是精确到纳秒）、duration（持续时间）和时钟操作的类。新设计的API认真考虑了这些类的不变性（从java.util.Calendar吸取的教训），如果某个实例需要修改，则返回一个新的对象。</p>
<blockquote>
<ul>
<li>jdk1.8中新增了 LocalDate 与 LocalDateTime等类来解决日期处理方法，同时引入了一个新的类DateTimeFormatter 来解决日期格式化问题。</li>
<li>可以使用Instant代替 Date，LocalDateTime代替 Calendar，DateTimeFormatter 代替 SimpleDateFormat。</li>
</ul>
</blockquote>
<h4 id="clock" tabindex="-1"> Clock</h4>
<p>Clock 类提供了访问当前日期和时间的方法，Clock 是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用 Instant 类来表示，Instant 类也可以用来创建旧版本的java.util.Date 对象。</p>
<div><pre><code>    <span>Clock</span> clock <span>=</span> <span>Clock</span><span>.</span><span>systemDefaultZone</span><span>(</span><span>)</span><span>;</span>
    <span>long</span> millis <span>=</span> clock<span>.</span><span>millis</span><span>(</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>millis<span>)</span><span>;</span><span>//1552379579043</span>
    <span>Instant</span> instant <span>=</span> clock<span>.</span><span>instant</span><span>(</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>instant<span>)</span><span>;</span>
    <span>Date</span> legacyDate <span>=</span> <span>Date</span><span>.</span><span>from</span><span>(</span>instant<span>)</span><span>;</span> <span>//2019-03-12T08:46:42.588Z</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>legacyDate<span>)</span><span>;</span><span>//Tue Mar 12 16:32:59 CST 2019</span>
</code></pre></div><h4 id="timezones-时区" tabindex="-1"> Timezones(时区)</h4>
<p>在新API中时区使用 ZoneId 来表示。时区可以很方便的使用静态方法of来获取到。 抽象类ZoneId（在java.time包中）表示一个区域标识符。 它有一个名为getAvailableZoneIds的静态方法，它返回所有区域标识符。</p>
<div><pre><code>    <span>//输出所有区域标识符</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>ZoneId</span><span>.</span><span>getAvailableZoneIds</span><span>(</span><span>)</span><span>)</span><span>;</span>

    <span>ZoneId</span> zone1 <span>=</span> <span>ZoneId</span><span>.</span><span>of</span><span>(</span><span>"Europe/Berlin"</span><span>)</span><span>;</span>
    <span>ZoneId</span> zone2 <span>=</span> <span>ZoneId</span><span>.</span><span>of</span><span>(</span><span>"Brazil/East"</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>zone1<span>.</span><span>getRules</span><span>(</span><span>)</span><span>)</span><span>;</span><span>// ZoneRules[currentStandardOffset=+01:00]</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>zone2<span>.</span><span>getRules</span><span>(</span><span>)</span><span>)</span><span>;</span><span>// ZoneRules[currentStandardOffset=-03:00]</span>
</code></pre></div><h4 id="localtime-本地时间" tabindex="-1"> LocalTime(本地时间)</h4>
<p>LocalTime 定义了一个没有时区信息的时间，例如 晚上10点或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：</p>
<div><pre><code>    <span>LocalTime</span> now1 <span>=</span> <span>LocalTime</span><span>.</span><span>now</span><span>(</span>zone1<span>)</span><span>;</span>
    <span>LocalTime</span> now2 <span>=</span> <span>LocalTime</span><span>.</span><span>now</span><span>(</span>zone2<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>now1<span>.</span><span>isBefore</span><span>(</span>now2<span>)</span><span>)</span><span>;</span>  <span>// false</span>

    <span>long</span> hoursBetween <span>=</span> <span>ChronoUnit</span><span>.</span>HOURS<span>.</span><span>between</span><span>(</span>now1<span>,</span> now2<span>)</span><span>;</span>
    <span>long</span> minutesBetween <span>=</span> <span>ChronoUnit</span><span>.</span>MINUTES<span>.</span><span>between</span><span>(</span>now1<span>,</span> now2<span>)</span><span>;</span>

    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>hoursBetween<span>)</span><span>;</span>       <span>// -3</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>minutesBetween<span>)</span><span>;</span>     <span>// -239</span>
</code></pre></div><p>LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串.</p>
<div><pre><code>    <span>LocalTime</span> late <span>=</span> <span>LocalTime</span><span>.</span><span>of</span><span>(</span><span>23</span><span>,</span> <span>59</span><span>,</span> <span>59</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>late<span>)</span><span>;</span>       <span>// 23:59:59</span>
    <span>DateTimeFormatter</span> germanFormatter <span>=</span>
        <span>DateTimeFormatter</span>
            <span>.</span><span>ofLocalizedTime</span><span>(</span><span>FormatStyle</span><span>.</span>SHORT<span>)</span>
            <span>.</span><span>withLocale</span><span>(</span><span>Locale</span><span>.</span>GERMAN<span>)</span><span>;</span>

    <span>LocalTime</span> leetTime <span>=</span> <span>LocalTime</span><span>.</span><span>parse</span><span>(</span><span>"13:37"</span><span>,</span> germanFormatter<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>leetTime<span>)</span><span>;</span>   <span>// 13:37</span>
</code></pre></div><h4 id="localdate-本地日期" tabindex="-1"> LocalDate(本地日期)</h4>
<p>LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。</p>
<h4 id="localdatetime-本地日期时间" tabindex="-1"> LocalDateTime(本地日期时间)</h4>
<p>LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime 和 LocalTime还有 LocalDate 一样，都是不可变的。</p>
<h3 id="base64" tabindex="-1"> Base64</h3>
<p>在Java 8中，Base64编码成为了Java类库的标准。Base64类同时还提供了对URL、MIME友好的编码器与解码器。</p>
<h2 id="jvm" tabindex="-1"> JVM</h2>
<p>使用Metaspace（JEP 122）代替持久代（PermGen space）。在JVM参数方面，使用-XX:MetaSpaceSize和-XX:MaxMetaspaceSize代替原来的-XX:PermSize和-XX:MaxPermSize。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java虚拟机JVM调优</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E8%B0%83%E4%BC%98.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E8%B0%83%E4%BC%98.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">Java虚拟机JVM调优</source>
      <category>Java</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
</ul>

<p>本文大部分内容参考  <strong>周志明《深入理解 Java 虚拟机》</strong> ，想要深入学习的话请看原书。</p>
<h1 id="jdk监控" tabindex="-1"> JDK监控</h1>
<p>1、jps：查看本机java进程信息。</p>
<p>2、jstack：打印线程的栈信息，制作线程dump文件。</p>
<p>3、jmap：打印内存映射，制作堆dump文件</p>
<p>4、jstat：性能监控工具</p>
<p>5、jhat：内存分析工具</p>
<p>6、jconsole：简易的可视化控制台</p>
<p>7、jvisualvm：功能强大的控制台</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java虚拟机内存管理</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">Java虚拟机内存管理</source>
      <category>Java</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>

<p>本文大部分内容参考  <strong>周志明《深入理解 Java 虚拟机》</strong> ，想要深入学习的话请看原书。</p>
<h1 id="一、运行时数据区域" tabindex="-1"> 一、运行时数据区域</h1>
<p><strong>JDK 1.8 之前：</strong></p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5778d113-8e13-4c53-b5bf-801e58080b97.png" width="400px"> </div><br>
<p><strong>JDK 1.8 ：</strong></p>
<div align="center"> 
<p><img src="@source/assets/cs-note/jvm/2019-3Java运行时数据区域JDK1.8.png" alt="" title=":size=550" loading="lazy"></p>
</div>
<p><strong>线程私有的：</strong></p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
<p><strong>线程共享的：</strong></p>
<ul>
<li>堆</li>
<li>方法区</li>
<li>直接内存 (非运行时数据区的一部分)</li>
</ul>
<h2 id="程序计数器" tabindex="-1"> 程序计数器</h2>
<p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p>
<p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p>
<p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p>程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>
<p><strong>注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p>
<p>记录正在执行的虚拟机字节码指令的地址(如果正在执行的是本地方法则为空)。</p>
<h2 id="java-虚拟机栈" tabindex="-1"> Java 虚拟机栈</h2>
<p><strong>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</strong></p>
<p><strong>Java 内存可以粗糙的区分为堆内存(Heap)和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> (实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。)</p>
<p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8442519f-0b4d-48f4-8229-56f984363c69.png" width="400px"> </div><br>
<p><strong>局部变量表主要存放了编译器可知的各种数据类型</strong>(boolean、byte、char、short、int、float、long、double)、<strong>对象引用</strong>(reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)。</p>
<p>可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M：</p>
<div><pre><code>java <span>-</span><span>Xss2M</span> <span>HackTheJava</span>
</code></pre></div><p>该区域可能抛出以下异常：</p>
<ul>
<li><strong>StackOverFlowError：</strong> 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 异常。</li>
<li><strong>OutOfMemoryError：</strong> 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 异常。</li>
</ul>
<p>Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p>
<p>为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<p><strong>扩展：那么方法/函数如何调用？</strong></p>
<p>Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p>
<p>Java 方法有两种返回方式：</p>
<ol>
<li>return 语句。</li>
<li>抛出异常。</li>
</ol>
<p>不管哪种返回方式都会导致栈帧被弹出。</p>
<h2 id="本地方法栈" tabindex="-1"> 本地方法栈</h2>
<p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>
<p>本地方法一般是用其它语言(C、C++ 或汇编语言等)编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66a6899d-c6b0-4a47-8569-9d08f0baf86c.png" width="300px"> </div><br>
<h2 id="堆" tabindex="-1"> 堆</h2>
<p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
<p>所有对象都在这里分配内存，是垃圾收集的主要区域(&quot;GC 堆&quot;)。</p>
<p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：</p>
<ul>
<li>新生代(Young Generation)</li>
<li>老年代(Old Generation)</li>
</ul>
<blockquote>
<p>Java虚拟机规范中：
Java堆可以处于物理上不连续的内存空间，只要逻辑上连续即可。实现时既可以实现成固定大小的也可是可扩展的，当前主流虚拟机都是可扩展来实现的(通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值)。</p>
</blockquote>
<p>如果堆中没有内存完成实例分配，且无法扩展时，会抛出 OutOfMemoryError 异常。</p>
<h2 id="方法区" tabindex="-1"> 方法区</h2>
<p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<blockquote>
<p>Java虚拟机规范中，方法区描述为堆的一个逻辑部分，但却有一个别名Non-Heap(非堆)，目的与Java堆区分；和堆一样不需要连续的内存，可以选择固定大小或者可动态扩展，无法满足内存分配需求时一样会抛出 OutOfMemoryError 异常。</p>
</blockquote>
<p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p>
<p>HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常(永久代有 -XX:MaxPermSize的上限)。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代(JDK1.7 就已经开始了)，并把方法区移至元空间，它位于本地内存(直接内存)中，而不是虚拟机内存中。</p>
<p><strong>方法区和永久代的关系</strong></p>
<p>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。</p>
<blockquote>
<p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。  <strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p>
</blockquote>
<p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</strong></p>
<ul>
<li>移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。</li>
<li>整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到 java.lang.OutOfMemoryError。你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</li>
</ul>
<p>当然这只是其中一个原因，还有很多底层的原因，这里就不提了。</p>
<p>推荐阅读：</p>
<ul>
<li>《Java8内存模型—永久代(PermGen)和元空间(Metaspace)》：<a href="http://www.cnblogs.com/paddix/p/5309550.html" target="_blank" rel="noopener noreferrer">http://www.cnblogs.com/paddix/p/5309550.html</a></li>
</ul>
<h2 id="运行时常量池" tabindex="-1"> 运行时常量池</h2>
<p>运行时常量池是方法区的一部分。</p>
<p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息(用于存放编译期生成的各种字面量和符号引用)</p>
<p>Class 文件中的常量池(编译器生成的字面量和符号引用)会在类加载后被放入这个区域。</p>
<p><strong>JDK1.7 及之后版本的 JVM 已经将字符串常量池从方法区中移了出来，在 Java 堆(Heap)中开辟了一块区域存放运行时常量池。</strong></p>
<div align="center"> 
<p><img src="@source/assets/cs-note/jvm/26038433.jpg" alt="" title=":size=600" loading="lazy"></p>
</div>
<p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</p>
<p>常量池无法再申请到内存时抛出OutOfMemoryError异常</p>
<p>推荐阅读：</p>
<ul>
<li>《Java 中几种常量池的区分》： <a href="https://blog.csdn.net/qq_26222859/article/details/73135660" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qq_26222859/article/details/73135660</a></li>
</ul>
<h3 id="全局字符串池-string-pool也有叫做string-literal-pool" tabindex="-1"> 全局字符串池(string pool也有叫做string literal pool)</h3>
<p>全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中(记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。)。 在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用(而不是驻留字符串实例本身)，也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了&quot;驻留字符串&quot;的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。</p>
<h3 id="class文件常量池-class-constant-pool" tabindex="-1"> class文件常量池(class constant pool)</h3>
<p>我们都知道，class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。 字面量就是我们所说的常量概念，如文本字符串、被声明为final的常量值等。 符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可(它与直接引用区分一下，直接引用一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄)。一般包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<h3 id="对比" tabindex="-1"> 对比</h3>
<ol>
<li>全局常量池在每个VM中只有一份，存放的是字符串常量的引用值。</li>
<li>class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量的符号引用。</li>
<li>运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。</li>
</ol>
<h3 id="常量池补充内容" tabindex="-1"> 常量池补充内容</h3>
<h4 id="_1-string-类和常量池" tabindex="-1"> 1. String 类和常量池</h4>
<p>在JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代</p>
<p>在JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代</p>
<p>在JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</p>
<p><strong>String 对象的两种创建方式：</strong></p>
<div><pre><code><span>String</span> str1 <span>=</span> <span>"abcd"</span><span>;</span><span>//先检查字符串常量池中有没有"abcd"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向"abcd""；</span>
<span>String</span> str2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"abcd"</span><span>)</span><span>;</span><span>//堆中创建一个新的对象</span>
<span>String</span> str3 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"abcd"</span><span>)</span><span>;</span><span>//堆中创建一个新的对象</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str1<span>==</span>str2<span>)</span><span>;</span><span>//false</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str2<span>==</span>str3<span>)</span><span>;</span><span>//false</span>
</code></pre></div><p>这两种不同的创建方法是有差别的。</p>
<ul>
<li>第一种方式是在常量池中拿对象；</li>
<li>第二种方式是直接在堆内存空间创建一个新的对象。</li>
</ul>
<p>记住一点：<strong>只要使用 new 方法，便需要创建新的对象。</strong></p>
<div align="center"> 
<p><img src="@source/assets/cs-note/jvm/2019-3String-Pool-Java1-450x249.png" alt="" title=":size=500" loading="lazy"></p>
</div>
<p><strong>String s1 = new String(&quot;abc&quot;);这句话创建了几个字符串对象？</strong></p>
<p><strong>将创建 1 或 2 个字符串。如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。如果池中没有字符串常量“abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。</strong></p>
<p><strong>验证：</strong></p>
<div><pre><code>		<span>String</span> s1 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"abc"</span><span>)</span><span>;</span><span>// 堆内存的地址值</span>
		<span>String</span> s2 <span>=</span> <span>"abc"</span><span>;</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1 <span>==</span> s2<span>)</span><span>;</span><span>// 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1<span>.</span><span>equals</span><span>(</span>s2<span>)</span><span>)</span><span>;</span><span>// 输出 true</span>
</code></pre></div><p><strong>String 类型的常量池比较特殊。它的主要使用方法有两种：</strong></p>
<ul>
<li>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</li>
<li>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7之前(不包含1.7)的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串首次出现的实例引用，并返回该引用，不会在复制实例。</li>
</ul>
<div><pre><code>	      <span>String</span> s1 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"计算机"</span><span>)</span><span>;</span>
	      <span>String</span> s2 <span>=</span> s1<span>.</span><span>intern</span><span>(</span><span>)</span><span>;</span>
	      <span>String</span> s3 <span>=</span> <span>"计算机"</span><span>;</span>
	      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s2<span>)</span><span>;</span><span>//计算机</span>
	      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1 <span>==</span> s2<span>)</span><span>;</span><span>//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，new的操作实例了两个对象</span>
	      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s3 <span>==</span> s2<span>)</span><span>;</span><span>//true，因为两个都是常量池中的 String 对象</span>
</code></pre></div><div><pre><code>        <span>String</span> str1 <span>=</span> <span>"str"</span><span>;</span>
        <span>String</span> str2 <span>=</span> <span>"ing"</span><span>;</span>
        <span>String</span> str <span>=</span> str1<span>+</span>str2<span>;</span> <span>//在堆上创建的新的对象，常量池中还不存在对应实例</span>
        <span>String</span> s<span>=</span>str<span>.</span><span>intern</span><span>(</span><span>)</span><span>;</span>
        <span>String</span> str3<span>=</span><span>"string"</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s<span>==</span>str<span>)</span><span>;</span><span>//true 常量池中字面量的引用是堆中的引用实例，因为"string"第一次出现是在堆中</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>==</span>str3<span>)</span><span>;</span><span>//true 常量池中字面量的引用是堆中的引用实例，str3查找时已出现在常量池中</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>System</span><span>.</span><span>identityHashCode</span><span>(</span>s<span>)</span><span>)</span><span>;</span><span>//460141958 地址</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>System</span><span>.</span><span>identityHashCode</span><span>(</span>str<span>)</span><span>)</span><span>;</span><span>//460141958 地址</span>
</code></pre></div><p><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noopener noreferrer">深入解析String#intern</a></p>
<p><strong>字符串拼接:</strong></p>
<div><pre><code>		  <span>String</span> str1 <span>=</span> <span>"str"</span><span>;</span>
		  <span>String</span> str2 <span>=</span> <span>"ing"</span><span>;</span>
		 
		  <span>String</span> str3 <span>=</span> <span>"str"</span> <span>+</span> <span>"ing"</span><span>;</span><span>//常量池中的对象</span>
		  <span>String</span> str4 <span>=</span> str1 <span>+</span> str2<span>;</span> <span>//在堆上创建的新的对象，常量池中还不存在对应实例</span>
		  <span>String</span> str5 <span>=</span> <span>"string"</span><span>;</span><span>//常量池中的对象</span>
		  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str3 <span>==</span> str4<span>)</span><span>;</span><span>//false</span>
		  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str3 <span>==</span> str5<span>)</span><span>;</span><span>//true</span>
		  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str4 <span>==</span> str5<span>)</span><span>;</span><span>//false</span>
</code></pre></div><div align="center"> 
<p><img src="@source/assets/cs-note/jvm/字符串拼接.png" alt="" title=":size=400" loading="lazy"></p>
</div>
<p>尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。</p>
<p><strong>&quot;+&quot;的拼接</strong></p>
<ul>
<li>常量字符串的“+”操作，编译阶段直接会合成为一个字符串</li>
<li>对于final字段，编译期直接进行了常量替换(而对于非final字段则是在运行期进行赋值处理的)。</li>
<li>常量字符串和变量拼接时(如：String str3=baseStr + &quot;01&quot;;)会调用stringBuilder.append()在堆上创建新的对象</li>
<li>变量和变量拼接时同样会调用stringBuilder.append()在堆上创建新的对象</li>
</ul>
<h4 id="_2-8种基本类型的包装类和常量池" tabindex="-1"> 2. 8种基本类型的包装类和常量池</h4>
<ul>
<li><strong>Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；这 5 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。</strong></li>
<li><strong>两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。</strong></li>
</ul>
<div><pre><code>		<span>Integer</span> i1 <span>=</span> <span>33</span><span>;</span>
		<span>Integer</span> i2 <span>=</span> <span>33</span><span>;</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i1 <span>==</span> i2<span>)</span><span>;</span><span>// 输出 true</span>
		<span>Integer</span> i11 <span>=</span> <span>333</span><span>;</span>
		<span>Integer</span> i22 <span>=</span> <span>333</span><span>;</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i11 <span>==</span> i22<span>)</span><span>;</span><span>// 输出 false</span>
		<span>Double</span> i3 <span>=</span> <span>1.2</span><span>;</span>
		<span>Double</span> i4 <span>=</span> <span>1.2</span><span>;</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i3 <span>==</span> i4<span>)</span><span>;</span><span>// 输出 false</span>
</code></pre></div><p><strong>Integer 缓存源代码：</strong></p>
<div><pre><code><span>/**
*此方法将始终缓存-128 到 127(包括端点)范围内的值，并可以缓存此范围之外的其他值。
*/</span>
    <span>public</span> <span>static</span> <span>Integer</span> <span>valueOf</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>i <span>>=</span> <span>IntegerCache</span><span>.</span>low <span>&amp;&amp;</span> i <span>&lt;=</span> <span>IntegerCache</span><span>.</span>high<span>)</span>
            <span>return</span> <span>IntegerCache</span><span>.</span>cache<span>[</span>i <span>+</span> <span>(</span><span>-</span><span>IntegerCache</span><span>.</span>low<span>)</span><span>]</span><span>;</span>
        <span>return</span> <span>new</span> <span>Integer</span><span>(</span>i<span>)</span><span>;</span>
    <span>}</span>

</code></pre></div><p><strong>应用场景：</strong></p>
<ol>
<li>Integer i1=40；Java 在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。</li>
<li>Integer i1 = new Integer(40);这种情况下会创建新的对象。</li>
</ol>
<div><pre><code>  <span>Integer</span> i1 <span>=</span> <span>40</span><span>;</span>
  <span>Integer</span> i2 <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>40</span><span>)</span><span>;</span>
  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i1<span>==</span>i2<span>)</span><span>;</span><span>//输出 false</span>
</code></pre></div><p><strong>Integer 比较更丰富的一个例子:</strong></p>
<div><pre><code>  <span>Integer</span> i1 <span>=</span> <span>40</span><span>;</span>
  <span>Integer</span> i2 <span>=</span> <span>40</span><span>;</span>
  <span>Integer</span> i3 <span>=</span> <span>0</span><span>;</span>
  <span>Integer</span> i4 <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>40</span><span>)</span><span>;</span>
  <span>Integer</span> i5 <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>40</span><span>)</span><span>;</span>
  <span>Integer</span> i6 <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>0</span><span>)</span><span>;</span>
  
  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"i1=i2   "</span> <span>+</span> <span>(</span>i1 <span>==</span> i2<span>)</span><span>)</span><span>;</span>
  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"i1=i2+i3   "</span> <span>+</span> <span>(</span>i1 <span>==</span> i2 <span>+</span> i3<span>)</span><span>)</span><span>;</span>
  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"i1=i4   "</span> <span>+</span> <span>(</span>i1 <span>==</span> i4<span>)</span><span>)</span><span>;</span>
  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"i4=i5   "</span> <span>+</span> <span>(</span>i4 <span>==</span> i5<span>)</span><span>)</span><span>;</span>
  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"i4=i5+i6   "</span> <span>+</span> <span>(</span>i4 <span>==</span> i5 <span>+</span> i6<span>)</span><span>)</span><span>;</span>   
  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"40=i5+i6   "</span> <span>+</span> <span>(</span><span>40</span> <span>==</span> i5 <span>+</span> i6<span>)</span><span>)</span><span>;</span>     
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>结果：</p>
<div><pre><code>i1=i2   true
i1=i2+i3   true
i1=i4   false
i4=i5   false
i4=i5+i6   true
40=i5+i6   true
</code></pre></div><p>解释：</p>
<p>语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。</p>
<h2 id="直接内存" tabindex="-1"> 直接内存</h2>
<p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。</strong></p>
<p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道(Channel)</strong> 与<strong>缓存区(Buffer)</strong> 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p>
<p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p>
<h1 id="二、对象探秘" tabindex="-1"> 二、对象探秘</h1>
<p>通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p>
<h2 id="对象的创建" tabindex="-1"> 对象的创建</h2>
<p>下图便是 Java 对象的创建过程，我建议最好是能默写出来，并且要掌握每一步在做什么。</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/jvm/Java创建对象的过程.png" alt="" title=":size=450" loading="lazy"></p>
</div>
<h4 id="step1-类加载检查" tabindex="-1"> Step1:类加载检查</h4>
<p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<h4 id="step2-分配内存" tabindex="-1"> Step2:分配内存</h4>
<p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p>
<p><strong>内存分配的两种方式：(补充内容，需要掌握)</strong></p>
<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是&quot;标记-清除&quot;，还是&quot;标记-整理&quot;(也称作&quot;标记-压缩&quot;)，值得注意的是，复制算法内存也是规整的</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/jvm/内存分配的两种方式.png" alt="" title=":size=800" loading="lazy"></p>
</div>
<p><strong>内存分配并发问题(补充内容，需要掌握)</strong></p>
<p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB(本地线程分配缓冲Thread Local Allocation Buffer)：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配(-XX:+/-UseTLAB)</li>
</ul>
<h4 id="step3-初始化零值" tabindex="-1"> Step3:初始化零值</h4>
<p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)，这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h4 id="step4-设置对象头" tabindex="-1"> Step4:设置对象头</h4>
<p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头(Object Header)中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h4 id="step5-执行-init-方法" tabindex="-1"> Step5:执行 init 方法</h4>
<p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h2 id="对象的内存布局" tabindex="-1"> 对象的内存布局</h2>
<p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p>
<p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的自身运行时数据</strong>(哈希码、GC 分代年龄、锁状态标志等等)，<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p>
<p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。父类继承的和子类定义的都需要记录，存储顺序受到虚拟机分配策略函数和字段定义顺序影响。</p>
<p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数(1 倍或 2 倍)，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h2 id="对象的访问定位" tabindex="-1"> 对象的访问定位</h2>
<p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象(reference类型在虚拟机规范中只规定了一个指向对象的引用)。对象的访问方式(引用通过何种方式去定位)由虚拟机实现而定，目前主流的访问方式有<strong>①使用句柄</strong>和<strong>②直接指针</strong>两种：</p>
<ol>
<li><strong>句柄：</strong> 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</li>
</ol>
<div align="center"> 
<p><img src="@source/assets/cs-note/jvm/对象的访问定位-使用句柄.png" alt="" title=":size=600" loading="lazy"></p>
</div>
<ol start="2">
<li><strong>直接指针：</strong>  如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</li>
</ol>
<div align="center"> 
<p><img src="@source/assets/cs-note/jvm/对象的访问定位-直接指针.png" alt="" title=":size=600" loading="lazy"></p>
</div>
<p><strong>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p>
<p>HotSpot使用第二种方式进行对象访问</p>
<h1 id="三、垃圾收集" tabindex="-1"> 三、垃圾收集</h1>
<p>垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</p>
<h2 id="判断一个对象是否可被回收" tabindex="-1"> 判断一个对象是否可被回收</h2>
<h3 id="_1-引用计数算法" tabindex="-1"> 1. 引用计数算法</h3>
<p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p>
<p>在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>

    <span>public</span> <span>Object</span> instance <span>=</span> <span>null</span><span>;</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Test</span> a <span>=</span> <span>new</span> <span>Test</span><span>(</span><span>)</span><span>;</span>
        <span>Test</span> b <span>=</span> <span>new</span> <span>Test</span><span>(</span><span>)</span><span>;</span>
        a<span>.</span>instance <span>=</span> b<span>;</span>
        b<span>.</span>instance <span>=</span> a<span>;</span>
        a <span>=</span> <span>null</span><span>;</span>
        b <span>=</span> <span>null</span><span>;</span>
        <span>doSomething</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。</p>
<h3 id="_2-可达性分析算法" tabindex="-1"> 2. 可达性分析算法</h3>
<p>以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。</p>
<p>Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：</p>
<ul>
<li>虚拟机栈中局部变量表中引用的对象</li>
<li>本地方法栈中 JNI (即一般所说的Native方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/83d909d2-3858-4fe1-8ff4-16471db0b180.png" width="350px"> </div><br>
<h3 id="_3-不可达的对象并非-非死不可" tabindex="-1"> 3. 不可达的对象并非“非死不可”</h3>
<p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p>
<p>被判定为需要执行 finalize 的对象将会被放在一个F-Queue的队列中进行第二次标记；在 finalize() 中拯救自己除非这个对象与引用链上的任何一个对象建立关联(譬如把自己this关键字赋值给某个类变量或对象的成员变量)，否则就会被真的回收。</p>
<h3 id="_4-finalize" tabindex="-1"> 4. finalize()</h3>
<p>类似 C++ 的析构函数，用于关闭外部资源(自我安慰)。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p>
<p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。</p>
<h3 id="_5-方法区的回收" tabindex="-1"> 5. 方法区的回收</h3>
<p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</p>
<p>主要是对常量池的回收和对类的卸载。</p>
<p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p>
<h4 id="常量的回收" tabindex="-1"> 常量的回收</h4>
<p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p>
<p>常量池中字面量的回收为例，假如在常量池中存在字符串 &quot;abc&quot;，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 &quot;abc&quot; 就是废弃常量，如果这时发生内存回收的话而且有必要的话，&quot;abc&quot; 就会被系统清理出常量池。</p>
<p>常量池中其他类(接口)、方法、字段的符号引用也类似。</p>
<h4 id="无用类的回收" tabindex="-1"> 无用类的回收</h4>
<p>类的卸载条件很多，需要满足以下三个条件(仅仅可以而不是必然回收)，并且满足了条件也不一定会被卸载：</p>
<ul>
<li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li>
</ul>
<p>在大量使用反射、动态代理、CGLIB等ByteCode框架、动态生成JSP以及OSGI这类频繁定义ClassLoader的场景需要虚拟机具备类卸载功能，保证方法区(永久代)不会溢出</p>
<h2 id="引用类型" tabindex="-1"> 引用类型</h2>
<p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p>
<p>Java 提供了四种强度不同的引用类型。</p>
<h3 id="_1-强引用" tabindex="-1"> 1. 强引用</h3>
<p>被强引用关联的对象不会被回收。</p>
<p>使用 new 一个新对象的方式来创建强引用。</p>
<div><pre><code><span>Object</span> obj <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>
</code></pre></div><h3 id="_2-软引用" tabindex="-1"> 2. 软引用</h3>
<p>描述一些还有用但并非必需的对象
被软引用关联的对象只有在内存不够的情况下才会被回收。</p>
<p>使用 SoftReference 类来创建软引用。</p>
<div><pre><code><span>Object</span> obj <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>
<span>SoftReference</span><span><span>&lt;</span><span>Object</span><span>></span></span> sf <span>=</span> <span>new</span> <span>SoftReference</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span>obj<span>)</span><span>;</span>
obj <span>=</span> <span>null</span><span>;</span>  <span>// 使对象只被软引用关联</span>
</code></pre></div><p>软引用可以和一个引用队列(ReferenceQueue)联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<h3 id="_3-弱引用" tabindex="-1"> 3. 弱引用</h3>
<p>描述非必需的对象
被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p>
<p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>使用 WeakReference 类来创建弱引用。</p>
<div><pre><code><span>Object</span> obj <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>
<span>WeakReference</span><span><span>&lt;</span><span>Object</span><span>></span></span> wf <span>=</span> <span>new</span> <span>WeakReference</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span>obj<span>)</span><span>;</span>
obj <span>=</span> <span>null</span><span>;</span>
</code></pre></div><p>弱引用可以和一个引用队列(ReferenceQueue)联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<h3 id="_4-虚引用" tabindex="-1"> 4. 虚引用</h3>
<p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p>
<p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p>
<p>使用 PhantomReference 来创建虚引用。</p>
<div><pre><code><span>Object</span> obj <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>
<span>PhantomReference</span><span><span>&lt;</span><span>Object</span><span>></span></span> pf <span>=</span> <span>new</span> <span>PhantomReference</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span>obj<span>,</span> <span>null</span><span>)</span><span>;</span>
obj <span>=</span> <span>null</span><span>;</span>
</code></pre></div><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p>
<p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
<p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出(OutOfMemory)等问题的产生</strong>。</p>
<h2 id="垃圾收集算法" tabindex="-1"> 垃圾收集算法</h2>
<p>垃圾收集算法的实现涉及大量程序细节，各个平台虚拟机操作内存方法各不相同</p>
<h3 id="_1-标记-清除" tabindex="-1"> 1. 标记 - 清除</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/005b481b-502b-4e3f-985d-d043c2b330aa.png" width="400px"> </div><br>
<p>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。</p>
<p>在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。</p>
<p>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。</p>
<p>不足：</p>
<ul>
<li>标记和清除过程效率都不高；</li>
<li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li>
</ul>
<h3 id="_2-标记-整理" tabindex="-1"> 2. 标记 - 整理</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ccd773a5-ad38-4022-895c-7ac318f31437.png" width="400px"> </div><br>
<p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>优点:</p>
<ul>
<li>不会产生内存碎片</li>
</ul>
<p>不足:</p>
<ul>
<li>需要移动大量对象，处理效率比较低。</li>
</ul>
<h3 id="_3-复制" tabindex="-1"> 3. 复制</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b2b77b9e-958c-4016-8ae5-9c6edd83871e.png" width="400px"> </div><br>
<p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p>
<p>主要不足是只使用了内存的一半。</p>
<p>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。</p>
<p>HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</p>
<h3 id="_4-分代收集" tabindex="-1"> 4. 分代收集</h3>
<p>HotSpot 为什么要分为新生代和老年代？</p>
<p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p>
<p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p>
<p>一般将堆分为新生代和老年代。</p>
<ul>
<li>新生代使用：复制算法</li>
<li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li>
</ul>
<h2 id="垃圾收集器" tabindex="-1"> 垃圾收集器</h2>
<p>垃圾收集算法是内存回收的方法论，垃圾收集器是内存回收的具体实现。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg" width=""/> </div><br>
<p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p>
<ul>
<li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li>
<li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li>
</ul>
<h3 id="_1-serial-收集器" tabindex="-1"> 1. Serial 收集器</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/22fda4ae-4dd5-489d-ab10-9ebfdad22ae0.jpg" width=""/> </div><br>
<p>Serial 翻译为串行，也就是说它以串行的方式执行。</p>
<p>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程( <strong>&quot;Stop The World&quot;</strong> )，直到它收集结束。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p>
<p>它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p>
<p>它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。</p>
<h3 id="_2-parnew-收集器" tabindex="-1"> 2. ParNew 收集器</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/81538cd5-1bcf-4e31-86e5-e198df1e013b.jpg" width=""/> </div><br>
<p>它是 Serial 收集器的多线程版本。除了使用多线程进行垃圾收集外，其余行为(控制参数、收集算法、回收策略等等)和 Serial 收集器完全一样。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p>
<p>它是 Server 场景下首选的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用(CMS收集器的默认搭配新生代收集器)。</p>
<p><strong>并行和并发概念补充：</strong></p>
<ul>
<li>
<p><strong>并行(Parallel)</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p>
</li>
<li>
<p><strong>并发(Concurrent)</strong>：指用户线程与垃圾收集线程同时执行(但不一定是并行，可能会交替执行)，用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</p>
</li>
</ul>
<p>ParNew 收集器在单CPU环境中绝不会有比Seriel收集器更好的效果，</p>
<h3 id="_3-parallel-scavenge-收集器" tabindex="-1"> 3. Parallel Scavenge 收集器</h3>
<p>与 ParNew 一样是并行的多线程收集器。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p>
<p>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p>
<p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p>
<p>可以通过一个开关参数打开 <strong>GC 自适应的调节策略</strong>(GC Ergonomics)，就不需要手工指定新生代的大小(-Xmn)、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
<h3 id="_4-serial-old-收集器" tabindex="-1"> 4. Serial Old 收集器</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/08f32fd3-f736-4a67-81ca-295b2a7972f2.jpg" width=""/> </div><br>
<p>是 Serial 收集器的老年代版本，<strong>使用单线程和“标记-整理”算法</strong>，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：</p>
<ul>
<li>在 JDK 1.5 以及之前版本(Parallel Old 诞生以前)中与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ul>
<h3 id="_5-parallel-old-收集器" tabindex="-1"> 5. Parallel Old 收集器</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/278fe431-af88-4a95-a895-9c3b80117de3.jpg" width=""/> </div><br>
<p>是 Parallel Scavenge 收集器的老年代版本。<strong>使用多线程和“标记-整理”算法</strong></p>
<p>由于老年代Serial Old 收集器在服务端应用性能上的“拖累”，单线程的老年代手机无法充分利用服务器多CPU的处理能力，Parallel Scavenge收集器未必能在整体上获得吞吐量最大化效果。</p>
<p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>
<h3 id="_6-cms-收集器" tabindex="-1"> 6. CMS 收集器</h3>
<p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e77997-6957-4b68-8d12-bfd609bb2c68.jpg" width=""/> </div><br>
<p>CMS(Concurrent Mark Sweep)，Mark Sweep 指的是标记 - 清除算法。</p>
<p>分为以下四个流程：</p>
<ul>
<li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li>
<li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li>
<li>并发清除：不需要停顿。</li>
</ul>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<p>优点：并发收集、低停顿</p>
<p>具有以下缺点：</p>
<ul>
<li>吞吐量低(对 CPU 资源敏感)：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li>
<li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li>
<li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li>
</ul>
<h3 id="_7-g1-收集器" tabindex="-1"> 7. G1 收集器</h3>
<p>G1(Garbage-First)，它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p>
<p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征，具备如下特点：</p>
<ul>
<li>并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU(CPU 或者 CPU 核心)来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 Java 程序继续执行。</li>
<li>分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>
<li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部(两个 Region 之间)上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒(这几乎已经是实时Java(RTSJ)的垃圾收集器特征)。</li>
</ul>
<p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4cf711a8-7ab2-4152-b85c-d5c226733807.png" width="600"/> </div><br>
<p>G1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png" width="600"/> </div><br>
<p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分带来了很大的灵活性，使得可预测的停顿时间模型成为可能，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，并后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region ( Garbage-First 的由来)。</p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f99ee771-c56f-47fb-9148-c0036695b5fe.jpg" width=""/> </div><br>
<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿</li>
<li>并发标记：从GC Roots开始对堆中对象进行可达性分析</li>
<li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ul>
<h1 id="四、内存分配与回收策略" tabindex="-1"> 四、内存分配与回收策略</h1>
<p>Java技术体系中的自动内存管理可以归结为自动化解决两个问题：给对象分配内存以及回收分配对象的内存。</p>
<h2 id="内存分配策略" tabindex="-1"> 内存分配策略</h2>
<h3 id="_1-对象优先在-eden-分配" tabindex="-1"> 1. 对象优先在 Eden 分配</h3>
<p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p>
<h3 id="_2-大对象直接进入老年代" tabindex="-1"> 2. 大对象直接进入老年代</h3>
<p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p>
<p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p>
<p><strong>为什么要这样呢？</strong></p>
<p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p>
<p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。(参数只对Serial和ParNew收集器有效)</p>
<h3 id="_3-长期存活的对象进入老年代" tabindex="-1"> 3. 长期存活的对象进入老年代</h3>
<p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p>
<p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p>
<h3 id="_4-动态对象年龄判定" tabindex="-1"> 4. 动态对象年龄判定</h3>
<p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p>
<h3 id="_5-空间分配担保" tabindex="-1"> 5. 空间分配担保</h3>
<p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p>
<p>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p>
<p>JDK6 Update 24后 HandlePromotionFailure 参数不会再影响空间分配担保策略，规则变为老年代最大可用的连续空间大于新生代所有对象总空间或者历次晋升到老年代对象的平均大小，就会进行Minor GC，否则进行Full GC。</p>
<h2 id="minor-gc-和-full-gc" tabindex="-1"> Minor GC 和 Full GC</h2>
<ul>
<li>
<p>新生代GC(Minor GC)：发生在新生代的垃圾收集动作，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</p>
</li>
<li>
<p>老年代GC(Full GC/Major GC)：发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC(但并非绝对)，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多(10倍以上)。</p>
</li>
</ul>
<h2 id="full-gc-的触发条件" tabindex="-1"> Full GC 的触发条件</h2>
<p>对于 Minor GC，其触发条件非常简单，当 Eden 空间不满足继续分配时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p>
<h3 id="_1-调用-system-gc" tabindex="-1"> 1. 调用 System.gc()</h3>
<p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>
<h3 id="_2-老年代空间不足" tabindex="-1"> 2. 老年代空间不足</h3>
<p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p>
<p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p>
<h3 id="_3-空间分配担保失败" tabindex="-1"> 3. 空间分配担保失败</h3>
<p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。</p>
<h3 id="_4-jdk-1-7-及以前的永久代空间不足" tabindex="-1"> 4. JDK 1.7 及以前的永久代空间不足</h3>
<p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p>
<p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p>
<h3 id="_5-concurrent-mode-failure" tabindex="-1"> 5. Concurrent Mode Failure</h3>
<p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足(可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足)，便会报 Concurrent Mode Failure 错误，并触发 Full GC (Serial Old 的后备方案)。</p>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li>周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.</li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4" target="_blank" rel="noopener noreferrer">Chapter 2. The Structure of the Java Virtual Machine</a></li>
<li><a href="https://www.slideshare.net/benewu/jvm-memory" target="_blank" rel="noopener noreferrer">Jvm memory</a>
<a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html" target="_blank" rel="noopener noreferrer">Getting Started with the G1 Garbage Collector</a></li>
<li><a href="http://electrofriends.com/articles/jni/jni-part1-java-native-interface/" target="_blank" rel="noopener noreferrer">JNI Part1: Java Native Interface Introduction and “Hello World” application</a></li>
<li><a href="https://hackthejava.wordpress.com/2015/01/09/memory-architecture-by-jvmruntime-data-areas/" target="_blank" rel="noopener noreferrer">Memory Architecture Of JVM(Runtime Data Areas)</a></li>
<li><a href="https://www.programcreek.com/2013/04/jvm-run-time-data-areas/" target="_blank" rel="noopener noreferrer">JVM Run-Time Data Areas</a></li>
<li><a href="http://www.drdobbs.com/architecture-and-design/android-on-x86-java-native-interface-and/240166271" target="_blank" rel="noopener noreferrer">Android on x86: Java Native Interface and the Android Native Development Kit</a></li>
<li><a href="https://crowhawk.github.io/2017/08/10/jvm_2/" target="_blank" rel="noopener noreferrer">深入理解 JVM(2)——GC 算法与内存分配策略</a></li>
<li><a href="https://crowhawk.github.io/2017/08/15/jvm_3/" target="_blank" rel="noopener noreferrer">深入理解 JVM(3)——7 种垃圾收集器</a></li>
<li><a href="http://blog.jamesdbloom.com/JVMInternals.html" target="_blank" rel="noopener noreferrer">JVM Internals</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html#code6" target="_blank" rel="noopener noreferrer">深入探讨 Java 类加载器</a></li>
<li><a href="http://www.baeldung.com/java-weakhashmap" target="_blank" rel="noopener noreferrer">Guide to WeakHashMap in Java</a></li>
<li><a href="https://alvinalexander.com/java/jwarehouse/apache-tomcat-6.0.16/java/org/apache/el/util/ConcurrentCache.java.shtml" target="_blank" rel="noopener noreferrer">Tomcat example source code file (ConcurrentCache.java)</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java虚拟机执行系统</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">Java虚拟机执行系统</source>
      <category>Java</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>

<p>本文大部分内容参考  <strong>周志明《深入理解 Java 虚拟机》</strong> ，想要深入学习的话请看原书。</p>
<h1 id="五、类文件结构" tabindex="-1"> 五、类文件结构</h1>
<p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>(即扩展名为 <code>.class</code> 的文件)，它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
<p>各种不同的虚拟机与所有平台都统一使用字节码(ByteCode)是构成平台无关性的基石，实现语言无关性的基础仍然是虚拟机和字节码的存储格式。Java虚拟机不和包括Java在内的任何语言绑定，至于&quot;Class文件&quot;这种特定二进制文件格式所关联，虚拟机不关心Class的来源是何种语言。</p>
<p>Clojure(Lisp 语言的一种方言)、Groovy、Scala 等语言都是运行在 Java 虚拟机之上。下图展示了不同的语言被不同的编译器编译成<code>.class</code>文件最终运行在 Java 虚拟机之上。</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/jvm/编译字节码.png" alt="" title=":size=600" loading="lazy"></p>
</div>
<p>可以说.class文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因。</p>
<p>Java语言中各种变量、关键字和运算符号的寓意最终都是有多条字节码命令组成，因此字节码命令所能提供的语义描述能力比Java语言本身更加强大。</p>
<h2 id="class类文件的结构" tabindex="-1"> Class类文件的结构</h2>
<p><strong>注意</strong>  任何一个Class文件都对应着唯一一个类或接口的定义信息，但反之不一定，类或接口并不一定都得定义在文件里(譬如类或接口也可通过类加载器直接加载)。将一个有效的类或接口锁应满足的格式成为“Class文件格式”，不一定以磁盘文件形式存在。(一串二进制字节流，无论以何种形式存在)</p>
<p>Class文件是一组以8位字节为基础单位的二进制流，各个数据项严格按照顺序紧凑排列在Class文件中，中间无任何分隔符，当遇到需要占用8位字节以上数据项，则按照高位在前(大端)的方式分隔成若干8位字节存储。</p>
<p>根据 Java 虚拟机规范，类文件格式采用类似C语言结构体的伪结构存储数据，伪结构只有两种数据类型：无符号数和表。</p>
<p>无符号数属于基本数据类型，u1,u2,u4,u8;无符号数用来描述数字、索引引用、数量值或按照UTF-8编码构成字符串值；</p>
<p>表是由多个无符号数或其他表作为数据项构成的复合数据类型，习惯性以&quot;_info&quot;结尾。
Class文件就是一张表。</p>
<p>类文件由单个 ClassFile 结构组成：</p>
<div><pre><code><span>ClassFile</span> <span>{</span>
    u4             magic<span>;</span> <span>//Class 文件的标志</span>
    u2             minor_version<span>;</span><span>//Class 的小版本号</span>
    u2             major_version<span>;</span><span>//Class 的大版本号</span>
    u2             constant_pool_count<span>;</span><span>//常量池的数量</span>
    cp_info        constant_pool<span>[</span>constant_pool_count<span>-</span><span>1</span><span>]</span><span>;</span><span>//常量池</span>
    u2             access_flags<span>;</span><span>//Class 的访问标记</span>
    u2             this_class<span>;</span><span>//当前类</span>
    u2             super_class<span>;</span><span>//父类</span>
    u2             interfaces_count<span>;</span><span>//接口</span>
    u2             interfaces<span>[</span>interfaces_count<span>]</span><span>;</span><span>//一个类可以实现多个接口</span>
    u2             fields_count<span>;</span><span>//Class 文件的字段属性</span>
    field_info     fields<span>[</span>fields_count<span>]</span><span>;</span><span>//一个类会可以有个字段</span>
    u2             methods_count<span>;</span><span>//Class 文件的方法数量</span>
    method_info    methods<span>[</span>methods_count<span>]</span><span>;</span><span>//一个类可以有个多个方法</span>
    u2             attributes_count<span>;</span><span>//此类的属性表中的属性数</span>
    attribute_info attributes<span>[</span>attributes_count<span>]</span><span>;</span><span>//属性表集合</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><strong>Class文件字节码结构组织示意图</strong></p>
<div align="center"> 
<p><img src="@source/assets/cs-note/jvm/类文件字节码结构组织示意图.png" alt="" title=":size=600" loading="lazy"></p>
</div>
<h3 id="_1-魔数" tabindex="-1"> 1. 魔数</h3>
<div><pre><code>    u4             magic<span>;</span> <span>//Class 文件的标志</span>
</code></pre></div><p>每个 Class 文件的头四个字节称为魔数(Magic Number),它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接收的 Class 文件</strong>。</p>
<p>程序设计者很多时候都喜欢用一些特殊的数字表示固定的文件类型或者其它特殊的含义。</p>
<h3 id="_2-class文件版本" tabindex="-1"> 2. Class文件版本</h3>
<div><pre><code>    u2             minor_version<span>;</span><span>//Class 的小版本号</span>
    u2             major_version<span>;</span><span>//Class 的大版本号</span>
</code></pre></div><p>紧接着魔数的四个字节存储的是 Class 文件的版本号：第五和第六是<strong>次版本号</strong>，第七和第八是<strong>主版本号</strong>。</p>
<p>高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。</p>
<h3 id="_3-常量池" tabindex="-1"> 3. 常量池</h3>
<div><pre><code>    u2             constant_pool_count<span>;</span><span>//常量池的数量</span>
    cp_info        constant_pool<span>[</span>constant_pool_count<span>-</span><span>1</span><span>]</span><span>;</span><span>//常量池</span>
</code></pre></div><p>紧接着主次版本号之后的是常量池，常量池的数量是 constant_pool_count-1(<strong>常量池计数器是从1开始计数的，将第0项常量空出来是有特殊考虑的，索引值为0代表“不引用任何一个常量池项”</strong>)。</p>
<p>常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>常量池中每一项常量都是一个表，这14种表有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">标志(tag)</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CONSTANT_utf8_info</td>
<td style="text-align:center">1</td>
<td style="text-align:center">UTF-8编码的字符串</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Integer_info</td>
<td style="text-align:center">3</td>
<td style="text-align:center">整形字面量</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Float_info</td>
<td style="text-align:center">4</td>
<td style="text-align:center">浮点型字面量</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Long_info</td>
<td style="text-align:center">5</td>
<td style="text-align:center">长整型字面量</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Double_info</td>
<td style="text-align:center">6</td>
<td style="text-align:center">双精度浮点型字面量</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Class_info</td>
<td style="text-align:center">7</td>
<td style="text-align:center">类或接口的符号引用</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_String_info</td>
<td style="text-align:center">8</td>
<td style="text-align:center">字符串类型字面量</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Fieldref_info</td>
<td style="text-align:center">9</td>
<td style="text-align:center">字段的符号引用</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Methodref_info</td>
<td style="text-align:center">10</td>
<td style="text-align:center">类中方法的符号引用</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_InterfaceMethodref_info</td>
<td style="text-align:center">11</td>
<td style="text-align:center">接口中方法的符号引用</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_NameAndType_info</td>
<td style="text-align:center">12</td>
<td style="text-align:center">字段或方法的符号引用</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_MothodType_info</td>
<td style="text-align:center">16</td>
<td style="text-align:center">标志方法类型</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_MethodHandle_info</td>
<td style="text-align:center">15</td>
<td style="text-align:center">表示方法句柄</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_InvokeDynamic_info</td>
<td style="text-align:center">18</td>
<td style="text-align:center">表示一个动态方法调用点</td>
</tr>
</tbody>
</table>
<p><code>.class</code> 文件可以通过<code>javap -v class类名</code> 指令来看一下其常量池中的信息(<code>javap -v  class类名-&gt; temp.txt</code> ：将结果输出到 temp.txt 文件)。</p>
<p>Class文件中方法、字段等都需要引用CONSTANT_utf8_info型常量来描述名称，该常量最大长度就是Java方法、字段名最大长度，即u2类型最大值65535.</p>
<h3 id="_4-访问标志" tabindex="-1"> 4. 访问标志</h3>
<p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</p>
<p>具体标志位及标志含义如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">标志名称</th>
<th style="text-align:center">标志值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ACC_PUBLIC</td>
<td style="text-align:center">0x0001</td>
<td style="text-align:center">是否为public</td>
</tr>
<tr>
<td style="text-align:center">ACC_FINAL</td>
<td style="text-align:center">0x0010</td>
<td style="text-align:center">是否被声明为final，只有类可以被设置</td>
</tr>
<tr>
<td style="text-align:center">ACC_SUPER</td>
<td style="text-align:center">0x0020</td>
<td style="text-align:center">是否允许使用invokespecial字节码新语意</td>
</tr>
<tr>
<td style="text-align:center">ACC_INTERFACE</td>
<td style="text-align:center">0x0200</td>
<td style="text-align:center">标识接口</td>
</tr>
<tr>
<td style="text-align:center">ACC_ABSTRACT</td>
<td style="text-align:center">0x0400</td>
<td style="text-align:center">是否为abstract类型，对于接口和抽象类来说是真</td>
</tr>
<tr>
<td style="text-align:center">ACC_SYNTHETIC</td>
<td style="text-align:center">0x1000</td>
<td style="text-align:center">标识该类并非有用户代码产生</td>
</tr>
<tr>
<td style="text-align:center">ACC_ANNOTATION</td>
<td style="text-align:center">0x2000</td>
<td style="text-align:center">标识注解</td>
</tr>
<tr>
<td style="text-align:center">ACC_ENUM</td>
<td style="text-align:center">0x4000</td>
<td style="text-align:center">标识枚举</td>
</tr>
</tbody>
</table>
<h3 id="_5-当前类索引-父类索引与接口索引集合" tabindex="-1"> 5. 当前类索引,父类索引与接口索引集合</h3>
<div><pre><code>    u2             this_class<span>;</span><span>//当前类索引</span>
    u2             super_class<span>;</span><span>//父类索引</span>
    u2             interfaces_count<span>;</span><span>//接口数目</span>
    u2             interfaces<span>[</span>interfaces_count<span>]</span><span>;</span><span>//一个类可以实现多个接口</span>
</code></pre></div><p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</p>
<p>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按<code>implents</code>(如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</p>
<p>类索引和父类索引采用两个u2类型索引值表示，各自指向一个 CONSTANT_Class_info 的类描述符常量，通过 CONSTANT_Class_info 类型的常量中的索引值可以找到定义在 CONSTANT_utf8_info 类型的常量中的全限定名字符串。</p>
<h3 id="_6-字段表集合" tabindex="-1"> 6. 字段表集合</h3>
<div><pre><code>    u2             fields_count<span>;</span><span>//Class 文件的字段的个数</span>
    field_info     fields<span>[</span>fields_count<span>]</span><span>;</span><span>//一个类会可以有个字段</span>
</code></pre></div><p>字段表(field info)用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。包括的信息有：字段作用域(public、private、protected)、实例变量或类变量(static)、可变性(final)、并发可见性(volatile)、可否被序列化(transient)、字段数据类型(基本类型、对象、数组)、字段名称。</p>
<p>field info(字段表) 的结构:</p>
<div><pre><code>field_info<span>{</span>
    u2                  access_flags<span>;</span><span>//字段作用域</span>
    u2                  name_index<span>;</span><span>//字段名称索引，对常量池的引用，表示的字段的名称</span>
    u2                  descriptor_index<span>;</span><span>//描述符索引，对常量池的引用，表示字段的描述符</span>
    u2                  attributes_count<span>;</span><span>//属性数目，一个字段还会拥有一些额外的属性</span>
    atrribute_info      attributes<span>[</span>attributes_count<span>]</span><span>;</span><span>//属性表，存放具体属性具体内容</span>

<span>}</span>
</code></pre></div><ul>
<li><strong>access_flags:</strong>  字段的作用域(<code>public</code> ,<code>private</code>,<code>protected</code>修饰符)，是实例变量还是类变量(<code>static</code>修饰符),可否被序列化(<code>transient</code> 修饰符),可变性(<code>final</code>),可见性(<code>volatile</code> 修饰符，是否强制从主内存读写)。</li>
</ul>
<p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。</p>
<p>字段访问标志如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">标志名称</th>
<th style="text-align:center">标志值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ACC_PUBLIC</td>
<td style="text-align:center">0x0001</td>
<td style="text-align:center">是否为 public</td>
</tr>
<tr>
<td style="text-align:center">ACC_PRIVATE</td>
<td style="text-align:center">0x0002</td>
<td style="text-align:center">是否为 private</td>
</tr>
<tr>
<td style="text-align:center">ACC_PROTECTED</td>
<td style="text-align:center">0x0004</td>
<td style="text-align:center">是否为 protected</td>
</tr>
<tr>
<td style="text-align:center">ACC_STATIC</td>
<td style="text-align:center">0x0008</td>
<td style="text-align:center">是否被声明为 static 类变量</td>
</tr>
<tr>
<td style="text-align:center">ACC_FINAL</td>
<td style="text-align:center">0x0010</td>
<td style="text-align:center">是否被声明为 final</td>
</tr>
<tr>
<td style="text-align:center">ACC_VOLATILE</td>
<td style="text-align:center">0x0040</td>
<td style="text-align:center">是否为 volatile</td>
</tr>
<tr>
<td style="text-align:center">ACC_TRANIENT</td>
<td style="text-align:center">0x0080</td>
<td style="text-align:center">是否为 transient</td>
</tr>
<tr>
<td style="text-align:center">ACC_SYNTHETIC</td>
<td style="text-align:center">0x1000</td>
<td style="text-align:center">字段是否由编译器自动产生</td>
</tr>
<tr>
<td style="text-align:center">ACC_ENUM</td>
<td style="text-align:center">0x4000</td>
<td style="text-align:center">是否为 enum</td>
</tr>
</tbody>
</table>
<p>字段表中不会列出从超类或负借口中继承而来的字段，但有可能列出原本Java代码中不存在的字段(譬如在内部类中国为了保持对外部类的访问行，自动添加指向外部类的实例的字段)</p>
<p>另外，Java语言中字段是无法重载的，但对于字节码来讲，如果两个字段描述符不一致，字段重名就是合法的。</p>
<h3 id="_7-方法表集合" tabindex="-1"> 7. 方法表集合</h3>
<div><pre><code>    u2             methods_count<span>;</span><span>//Class 文件的方法的数量</span>
    method_info    methods<span>[</span>methods_count<span>]</span><span>;</span><span>//一个类可以有个多个方法</span>
</code></pre></div><p>methods_count 表示方法的数量，而 method_info 表示的方法表。</p>
<p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</p>
<p>method_info(方法表)结构如下：</p>
<div><pre><code>method_info<span>{</span>
    u2                  access_flags<span>;</span>
    u2                  name_index<span>;</span>
    u2                  descriptor_index<span>;</span>
    u2                  attributes_count<span>;</span>
    atrribute_info      attributes<span>[</span>attributes_count<span>]</span><span>;</span>
<span>}</span>
</code></pre></div><p>注意：因为<code>volatile</code>修饰符和<code>transient</code>修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了<code>synchronized</code>、<code>native</code>、<code>abstract</code>等关键字修饰方法，所以也就多了这些关键字对应的标志。</p>
<p>方法访问标志如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">标志名称</th>
<th style="text-align:center">标志值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ACC_PUBLIC</td>
<td style="text-align:center">0x0001</td>
<td style="text-align:center">是否为 public</td>
</tr>
<tr>
<td style="text-align:center">ACC_PRIVATE</td>
<td style="text-align:center">0x0002</td>
<td style="text-align:center">是否为 private</td>
</tr>
<tr>
<td style="text-align:center">ACC_PROTECTED</td>
<td style="text-align:center">0x0004</td>
<td style="text-align:center">是否为 protected</td>
</tr>
<tr>
<td style="text-align:center">ACC_STATIC</td>
<td style="text-align:center">0x0008</td>
<td style="text-align:center">是否为 static</td>
</tr>
<tr>
<td style="text-align:center">ACC_FINAL</td>
<td style="text-align:center">0x0010</td>
<td style="text-align:center">是否被声明为 final</td>
</tr>
<tr>
<td style="text-align:center">ACC_SYNCHRONIZED</td>
<td style="text-align:center">0x0020</td>
<td style="text-align:center">是否为 synchronize</td>
</tr>
<tr>
<td style="text-align:center">ACC_BRIDGE</td>
<td style="text-align:center">0x0040</td>
<td style="text-align:center">是否为 编译器产生的桥接方法</td>
</tr>
<tr>
<td style="text-align:center">ACC_VARARGS</td>
<td style="text-align:center">0x0080</td>
<td style="text-align:center">是否接受不定参数</td>
</tr>
<tr>
<td style="text-align:center">ACC_NATIVE</td>
<td style="text-align:center">0x0100</td>
<td style="text-align:center">是否为 native</td>
</tr>
<tr>
<td style="text-align:center">ACC_ABSTRACT</td>
<td style="text-align:center">0x0400</td>
<td style="text-align:center">是否为 abstract</td>
</tr>
<tr>
<td style="text-align:center">ACC_STRICTFP</td>
<td style="text-align:center">0x0800</td>
<td style="text-align:center">是否为 strictfp</td>
</tr>
<tr>
<td style="text-align:center">ACC_SYNTHETIC</td>
<td style="text-align:center">0x1000</td>
<td style="text-align:center">字段是否由编译器自动产生</td>
</tr>
</tbody>
</table>
<p>在Java语言中，重载一个方法，要与原方法具有相同简单名称，还必须有不同的特征签名，特征签名是方法中各个参数在常量池中字段符号引用的集合，返回值不在特征签名中，因此Java是无法仅靠返回值不同来重载方法。但Class文件格式中，特征签名的范围更大，只要描述符不是完全一致的两个方法可以共存。</p>
<p><strong>描述符</strong></p>
<p>描述符的作用是描述字段的数据类型、方法的参数列表(包括数量、类型及顺序)和返回值。</p>
<p>描述符标识字符含义如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">标识字符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">byte</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">char</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">double</td>
</tr>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center">float</td>
</tr>
<tr>
<td style="text-align:center">I</td>
<td style="text-align:center">int</td>
</tr>
<tr>
<td style="text-align:center">J</td>
<td style="text-align:center">long</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">short</td>
</tr>
<tr>
<td style="text-align:center">Z</td>
<td style="text-align:center">boolean</td>
</tr>
<tr>
<td style="text-align:center">V</td>
<td style="text-align:center">void</td>
</tr>
<tr>
<td style="text-align:center">L</td>
<td style="text-align:center">对象类型(如 Ljava/lang/String)</td>
</tr>
</tbody>
</table>
<p>对于数组类型，每一位度使用一个前置的 &quot;[&quot;字符来描述，如&quot;String[][]&quot;被记录为&quot;[[Ljava/lang/String&quot;；&quot;int[]&quot;被记录为&quot;[I&quot;。</p>
<h3 id="_8-属性表集合" tabindex="-1"> 8. 属性表集合</h3>
<div><pre><code>   u2             attributes_count<span>;</span><span>//此类的属性表中的属性数</span>
   attribute_info attributes<span>[</span>attributes_count<span>]</span><span>;</span><span>//属性表集合</span>
</code></pre></div><p>attribute_info(属性表)结构如下：</p>
<div><pre><code>attribute_info<span>{</span>
    u2                  attribute_name_index<span>;</span>
    u4                  attribute_length<span>;</span>
    u1                  info<span>[</span>attribute_length<span>]</span><span>;</span>
<span>}</span>
</code></pre></div><p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p>
<p><strong>虚拟机规范预定义的属性</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">使用位置</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Code</td>
<td style="text-align:center">方法表</td>
<td style="text-align:center">编译成的字节码指令</td>
</tr>
<tr>
<td style="text-align:center">ConstantValue</td>
<td style="text-align:center">字段表</td>
<td style="text-align:center">final 关键字定义的常量值</td>
</tr>
<tr>
<td style="text-align:center">Deprecated</td>
<td style="text-align:center">类、方法表、字段表</td>
<td style="text-align:center">被声明为 Deprecated 的方法和字段</td>
</tr>
<tr>
<td style="text-align:center">Exceptions</td>
<td style="text-align:center">方法表</td>
<td style="text-align:center">方法抛出的异常</td>
</tr>
<tr>
<td style="text-align:center">EnclosingMethod</td>
<td style="text-align:center">类文件</td>
<td style="text-align:center">当一个类为局部类或匿名类时，这个属性标识这个类的外围方法</td>
</tr>
<tr>
<td style="text-align:center">InnerClasses</td>
<td style="text-align:center">类文件</td>
<td style="text-align:center">内部类列表</td>
</tr>
<tr>
<td style="text-align:center">LineNumberTable</td>
<td style="text-align:center">Code 属性</td>
<td style="text-align:center">Java源码行号与字节码指令对应关系</td>
</tr>
<tr>
<td style="text-align:center">LocalVariableTable</td>
<td style="text-align:center">Code 属性</td>
<td style="text-align:center">方法局部变量描述</td>
</tr>
<tr>
<td style="text-align:center">StackMapTable</td>
<td style="text-align:center">Code 属性</td>
<td style="text-align:center">JDK1.6</td>
</tr>
<tr>
<td style="text-align:center">Signature</td>
<td style="text-align:center">类、方法表、字段表</td>
<td style="text-align:center">JDK1.5 用于支持泛型情况下的签名</td>
</tr>
<tr>
<td style="text-align:center">SourceFile</td>
<td style="text-align:center">类文件</td>
<td style="text-align:center">记录源文件名称</td>
</tr>
<tr>
<td style="text-align:center">SourceDebugExtension</td>
<td style="text-align:center">类文件</td>
<td style="text-align:center">JDK1.6</td>
</tr>
<tr>
<td style="text-align:center">Synthetic</td>
<td style="text-align:center">类、方法表、字段表</td>
<td style="text-align:center">标识方法或字段是编译器自动生成的</td>
</tr>
<tr>
<td style="text-align:center">LocalVariableTypeTable</td>
<td style="text-align:center">类</td>
<td style="text-align:center">JDK1.5 使用特征签名代替描述符，为了引入反省与法之后能描述泛型参数化类型而添加</td>
</tr>
<tr>
<td style="text-align:center">RuntimeVisibleAnnotations</td>
<td style="text-align:center">类、方法表、字段表</td>
<td style="text-align:center">JDK1.5</td>
</tr>
<tr>
<td style="text-align:center">RuntimeInVisibleAnnotations</td>
<td style="text-align:center">类、方法表、字段表</td>
<td style="text-align:center">JDK1.5</td>
</tr>
<tr>
<td style="text-align:center">RuntimeVisibleParameterAnnotations</td>
<td style="text-align:center">方法表</td>
<td style="text-align:center">JDK1.5</td>
</tr>
<tr>
<td style="text-align:center">RuntimeInVisibleParameterAnnotations</td>
<td style="text-align:center">方法表</td>
<td style="text-align:center">JDK1.5</td>
</tr>
<tr>
<td style="text-align:center">AnnotationDefault</td>
<td style="text-align:center">方法表</td>
<td style="text-align:center">JDK1.5 用于记录注解类元素的默认值</td>
</tr>
<tr>
<td style="text-align:center">BootstrapMethods</td>
<td style="text-align:center">类文件</td>
<td style="text-align:center">JDK1.7</td>
</tr>
</tbody>
</table>
<h4 id="code-属性" tabindex="-1"> Code 属性</h4>
<p>code_attribute_info(Code 属性表)结构如下：</p>
<div><pre><code>attribute_info<span>{</span>
    u2                  attribute_name_index<span>;</span><span>//属性字段名称索引，对常量池的引用，表示的属性字段的名称</span>
    u4                  attribute_length<span>;</span><span>//属性长度</span>
    u2                  max_stack<span>;</span><span>//操作数栈深度最大值</span>
    u2                  max_locals<span>;</span><span>//局部变量表所需存储空间</span>
    u4                  code_length<span>;</span><span>//字节码长度</span>
    u1                  code<span>;</span><span>//存储字节码指令的一系列字节流</span>
    u2                  exception_table_length<span>;</span><span>//异常表长度</span>
    exception_info      exception_table<span>;</span><span>//异常表</span>
    u2                  attributes_count<span>;</span><span>//</span>
    attribute_info      attributes<span>[</span>attributes_count<span>]</span><span>;</span><span>//</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><blockquote>
<p>虚拟机规范中明确闲置一个方法不允许超过65535条字节码指令，即只使用u2的长度，如果超过限制，javac编译器拒绝编译。</p>
</blockquote>
<p>Code 属性是 Class 文件最重要的一个属性，Java程序中信息分为代码(Code,方法体里面Java代码)和元数据(Metadata,包括类、字段、方法定义及其他信息)两部分，那么整个Class文件中，Code属性用于描述代码，所有的其他数据项目都用于描述元数据。</p>
<h2 id="字节码指令" tabindex="-1"> 字节码指令</h2>
<p>Java虚拟机的指令由一个字节长度、代表着某种特定操作含义的数字(操作码)以及跟随其后的零至多个代表此操作所需要参数(操作数)而构成。</p>
<p>字节码指令集是一种具有鲜明特点、优劣势都很突出的指令集架构，由于限制了 Java 虚拟机操作码的长度为一个字节(即 0 ~ 255)，这意味着指令集的操作码总数不可能超过 256 条；又由于 Class 文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机处理那些超过一个字节数据的时候，不得不在运行时从字节中重建出具体数据的结构，如果要将一个 16 位长度的无符号整数使用两个无符号字节存储起来(将它们命名为 byte1 和 byte2)，那它们的值应该是这样的：</p>
<div><pre><code>(byte1&lt;&lt;8 | byte2)
</code></pre></div><p>用一个字节来代表操作码，也是为了尽可能获得短小精干的编译代码。这种追求尽可能小数据量、高传输效率的设计是由 Java 语言设计之初面向网络、智能家电的技术背景所决定的，并一直沿用至今。</p>
<h3 id="_1-字节码和数据类型" tabindex="-1"> 1. 字节码和数据类型</h3>
<p>在Java虚拟机的指令集中，大多数指令都包含了其操作所对应的数据类型信息，Java虚拟机的操作码长度只有一个字节，如果每一种数据类型相关的指令都支持Java虚拟机所有运行时数据类型的话，那指令的数据恐怕就会超过一个字节所能表示的数量范围了。因此，Java虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它。</p>
<h3 id="_2-加载和存储指令" tabindex="-1"> 2. 加载和存储指令</h3>
<p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数据栈之间来回传输</p>
<ul>
<li>将一个局部变量加载到操作栈: iload, iload<sub>n</sub>, lload, fload .....</li>
<li>将一个数值从操作数栈存储到局部变量表: istore, istore<sub>n</sub>....</li>
<li>将一个常量加载到操作数栈: bipush, sipush, ldc.....</li>
<li>扩充局部变量表的访问索引的指令: wide</li>
</ul>
<h3 id="_3-运算指令" tabindex="-1"> 3. 运算指令</h3>
<p>运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。</p>
<p>由于没有直接支持byte，short, chart和boolean类型的算术指令，对于这类数据的运算，应使用操作int类型的指令代替。</p>
<ul>
<li>加法： idadd, ladd, fadd, dadd</li>
<li>减法：isub, lsub, fsub, dsub</li>
<li>乘法：imul, lmul, fmul, dmul</li>
<li>除法：idiv, ldiv, fdiv, ddiv</li>
<li>求余： irem, lrem, frem, drem</li>
<li>取反： ineg, lneg, fneg, dneg</li>
<li>位移： ishl, ishr, iushr, lshl, lshr, lushr</li>
<li>按位或指令： ior, lor</li>
<li>按位与指令： iand, land</li>
<li>按位异或指令: ixor, lxor</li>
<li>局部变量自增指令: iinc</li>
<li>比较指令： dcmpg, dcmpl, fcmpg, fcmpl, lcmp</li>
</ul>
<h3 id="_4-类型转换指令" tabindex="-1"> 4. 类型转换指令</h3>
<p>类型转换指令：可以将两种不同的数据类型进行相互转换，一般用户实现代码中显示类型转换操作。</p>
<p>Java虚拟机直接支持(即转换无需显式的转换指令)以下数据类型的宽化类型转换(Widening Numeric Conversions，即小范围类型向大范围类型的安全转换。</p>
<ul>
<li>int类型到long, float 或者 double类型，</li>
<li>long类型到float, double类型，</li>
<li>float类型到double类型</li>
</ul>
<p>相对的，处理窄化类型转换( Narrowing Numeric Conversions)时，必须显式地使用转换指令来完成，这些转换指令包括：i2b, i2c, i2s........</p>
<h3 id="_5-对象创建与访问指令" tabindex="-1"> 5. 对象创建与访问指令</h3>
<ul>
<li>创建类实例的指令： new</li>
<li>创建数组的指令： newarray, anewarray, multianewarray</li>
<li>访问类字段(static字段)和实例字段(非static字段，或者称为实例变量)的指令: getfield, putfield, getstatic, putstatic</li>
<li>把一个数组元素加载到操作数栈的指令： baload, caload, saload, iaload, laload......</li>
<li>将一个操作数栈的值存储到数组元素中的指令： bastore, castore,sastore....</li>
<li>取数组长度的指令： arraylength</li>
<li>检查类实例类型的指令： instanceof, checkcast</li>
</ul>
<h3 id="_6-操作数栈管理指令" tabindex="-1"> 6. 操作数栈管理指令</h3>
<p>Java虚拟机提供了直接操作操作数栈的指令。</p>
<ul>
<li>将操作数栈的栈顶一个或两个元素出栈： pop, pop2</li>
<li>复制栈顶一个或两个数值并将复制值或双份的复制值 重新压入栈顶：dup, dup2, dpu_x1....</li>
<li>将栈最顶端的两个数值互换： swap</li>
</ul>
<h3 id="_7-控制转移指令" tabindex="-1"> 7. 控制转移指令</h3>
<p>可以让Java虚拟机有条件或无条件地从指定的位置指令继续执行</p>
<ul>
<li>条件分支：ifeq, iflt, ifle....</li>
<li>复合条件分支： tableswitch, lookpuswitch</li>
<li>无条件分支： goto, toto_w....</li>
</ul>
<p>对于boolean、byte、char、short类型的条件分支比较操作，都是使用int类型比较指令完成，而对于long、float、double类型的条件分支操作，则会先执行相应的比较运算指令，返回整数值到操作数栈，随后执行int类型条件分支比较操作来完成分支跳转。</p>
<p>由于各种类型的比较最终都会转化为int类型的比较操作，所以Java虚拟机提供的int类型条件分支指令是最为丰富和强大的。</p>
<h3 id="_8-方法调用和返回指令" tabindex="-1"> 8. 方法调用和返回指令</h3>
<ul>
<li>invokevirtual 用于调用对象的实例方法。</li>
<li>invokeinterface 用于调用接口方法</li>
<li>invokespecial 用于调用需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法</li>
<li>invokestatic 用于调用类方法(static方法)</li>
<li>invokedynamic 用于在运行时动态解析出调用点限定符所引用的方法</li>
</ul>
<p>前4条调用指令的分派逻辑固化在Java虚拟机内部，而invokedynamic 指令的分派逻辑是由用户所设定的引导方法决定的。</p>
<p>方法调用指令与数据类型无关，而方法返回指令是根据返回值类型区分，包括</p>
<ul>
<li>ireturn (boolean、byte、char、short和int类型)</li>
<li>lreturn</li>
<li>freturn</li>
<li>dreturn</li>
<li>areturn</li>
<li>return (void方法、实例初始化方法、类和接口的类初始化方法)</li>
</ul>
<h3 id="_9-异常处理" tabindex="-1"> 9. 异常处理</h3>
<p>在Java程序中显式异常的操作(throw语句)都由athrow指令实现</p>
<p>Java虚拟机中，处理异常(catch语句)不是由字节码指令实现(很久前曾使用jsr和ret指令实现)，而是采用异常表实现。</p>
<h3 id="_10-同步指令" tabindex="-1"> 10. 同步指令</h3>
<p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步。这两种同步结构都是使用管程(Monitor)实现的。</p>
<p>方法级的同步是隐式的，无需通过字节码指令控制，实现在方法调用和返回中，虚拟机可以从方法常量池的方法表结构中ACC_SYNCHRONIZED访问标志得知是否为同步方法。如果设置：执行线程要求先持有monitor，然后执行方法，最后方法完成(正常完成或非正常完成)时释放monitor。如果一个同步方法执行期间抛出异常并且在方法内部无法处理此异常，那么该同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。</p>
<p>同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要javac编译器和Java虚拟机两者共同协作支持。编译器必须确保无论方法通过何种方式完成，方法调用过的monitorenter指令都必须执行其对应的monitorexit指令，而无论方法正常结束还是异常结束。</p>
<h2 id="公有设计和私有实现" tabindex="-1"> 公有设计和私有实现</h2>
<p>java虚拟机规范描述了java虚拟机应有的共同程序存储格式：class文件格式以及字节码指令集。这些内容与硬件、操作系统以及具体的java虚拟机实现之间是完全独立的，具体实现方式是实现着自己的事，只要外部接口与规范描述一致即可。</p>
<p>虚拟机实现的方式主要有一下两种：</p>
<ol>
<li>将输入的java虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集。</li>
<li>将输入的java虚拟机代码在加载或者执行时翻译成宿主机cpu的本地指令集。</li>
</ol>
<h1 id="六、类加载机制" tabindex="-1"> 六、类加载机制</h1>
<p>与那些在编译时需要进行连接工作的语言不同，在JAVA中，类型的加载和连接过程都是在程序运行期间完成的，这样会在类加载时稍微增加一些性能开销，但是却能为JAVA应用程序提高高度的灵活性，JAVA中天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。</p>
<p>类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。</p>
<h2 id="类的生命周期" tabindex="-1"> 类的生命周期</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/335fe19c-4a76-45ab-9320-88c90d6a0d7e.png" width="600px"> </div><br>
<p>包括以下 7 个阶段：</p>
<ul>
<li><strong>加载(Loading)</strong></li>
<li><strong>验证(Verification)</strong></li>
<li><strong>准备(Preparation)</strong></li>
<li><strong>解析(Resolution)</strong></li>
<li><strong>初始化(Initialization)</strong></li>
<li>使用(Using)</li>
<li>卸载(Unloading)</li>
</ul>
<h2 id="类加载过程" tabindex="-1"> 类加载过程</h2>
<p>类加载过程：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步:<strong>验证-&gt;准备-&gt;解析</strong>。</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/jvm/类加载过程.png" alt="" title=":size=600" loading="lazy"></p>
</div>
<p>包含了加载、验证、准备、解析和初始化这 5 个阶段。</p>
<p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类加载过程必须按照这种顺序按部就班<strong>开始</strong>(互相交叉地混合式进行),二解析阶段则不一定</p>
<h3 id="_1-加载" tabindex="-1"> 1. 加载</h3>
<p>加载是类加载的一个阶段，注意不要混淆。</p>
<p>加载过程完成以下三件事：</p>
<ul>
<li>通过类的完全限定名称获取定义该类的二进制字节流。</li>
<li>将该字节流表示的静态存储结构转换为方法区的运行时数据存储结构。</li>
<li>在内存中生成一个代表该类的 java.lang.Class 对象，作为方法区中该类各种数据的访问入口。</li>
</ul>
<p>其中二进制字节流可以从以下方式中获取：</p>
<ul>
<li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。</li>
<li>从网络中获取，最典型的应用是 Applet。</li>
<li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</li>
<li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类。</li>
<li>......</li>
</ul>
<p>非数组类的加载阶段是开发人员控性最强的，加载阶段既可以使用系统提供的引导类加载器完成，也可用户自定义类加载器完成；</p>
<p>对于数组类来说，它不通过类加载器创建，由Java虚拟机直接创建，但数组中的元素类型(Element Type , 去掉所有维度的类型)还是需要类加载器去创建。</p>
<p>数组类创建遵循以下规则：</p>
<ul>
<li>如果数组的组件类型(Component Type , 去掉一个维度的类型)是引用类型，就递归地去加载这个组件类型</li>
<li>如果数组的组件类型不是引用类型(例如 int[] 一些基本数据的数组)，数组会被标记与引导类加载器关联</li>
<li>如果数组类的可见性与它的组件类型一致，如果组件类型不是引用类型，那数组类的可见性将默认为public</li>
</ul>
<p>加载完成后，二进制字节流按照虚拟机所需的格式存储在方法区之中。然后在内存中实例一个java.lang.Class对象，虽然它为对象，但是它在方法区中。此对象作为程序访问方法区中的这些类型数据的外部接口。</p>
<p>加载阶段与连接阶段的部分内容(如部分字节码文件格式验证动作)是交叉运行的。</p>
<h3 id="_2-验证" tabindex="-1"> 2. 验证</h3>
<p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>4个阶段的检验动作</p>
<ol>
<li>文件格式验证：验证字节流是否符事Class文件格式的规范，并且能被当前版本的虚拟机处理
<ul>
<li>是否以魔数0xCAFEBABE开头</li>
<li>主、次版本号是否在当前虚拟机处理范围之内</li>
<li>常量池的常量中是否有不被支持的常量类型</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li>
<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据</li>
<li>Class文件中各个部分以及文件本身是否有被删除的或附加的其他信息</li>
<li>......</li>
</ul>
</li>
<li>元数据验证：对字节码描述的信息进行语义分析,保证其描述信息符合Java语言规范
<ul>
<li>类是否有父亲(除了java.lang.Obejct之外，所有的类都应当有父类)</li>
<li>类的父亲是否继承了不允许被继承的类(被final修饰的类)</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</li>
<li>类中的字段、方法是否与父类产生了矛盾</li>
<li>......</li>
</ul>
</li>
<li>字节码验证：主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况，在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上</li>
<li>保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，反之则是危险的。</li>
<li>......</li>
</ul>
</li>
<li>符号引用验证 最后一阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段--解析阶段中发生。符号引用验证可以看做是对类自身以外的信息进行匹配性校验。
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类；</li>
<li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段</li>
<li>符号引用中的类、字段和方法的访问行(private,protected,public,default)是否可被当前类访问</li>
<li>......</li>
</ul>
</li>
</ol>
<h3 id="_3-准备" tabindex="-1"> 3. 准备</h3>
<p>正式为类变量(static 修饰)分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配</p>
<p>实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。</p>
<p><strong>通常情况下</strong>，初始值一般为零值，例如下面的类变量 value 被初始化为 0 而不是 123；value被赋值为123，会在类的初始化<code>&lt;clinit&gt;()</code>阶段才会执行。</p>
<div><pre><code><span>public</span> <span>static</span> <span>int</span> value <span>=</span> <span>123</span><span>;</span>
</code></pre></div><p><strong>特殊情况</strong>：如果类变量是常量，即类字段字段属性表中存在ConstantValue属性，那么准备阶段就会被初始化ConstantValue属性所指定的值。例如下面的常量 value 被初始化为 123 而不是 0。</p>
<div><pre><code><span>public</span> <span>static</span> <span>final</span> <span>int</span> value <span>=</span> <span>123</span><span>;</span>
</code></pre></div><p><strong>基本数据类型的零值：</strong></p>
<div align="center"> 
<p><img src="@source/assets/cs-note/jvm/基本数据类型的零值.png" alt="" title=":size=600" loading="lazy"></p>
</div>
<h3 id="_4-解析" tabindex="-1"> 4. 解析</h3>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。</p>
<blockquote>
<p>符号引用：以一组符号来描述所引用的目标，可以是任意形式的字面量，只要使用时能无歧义的定位到目标。符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。
直接引用：可以是直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。它与虚拟机内存布局相关。同一符号引用被不同虚拟机实例翻译出来的直接引用一般不会相同，如果有了直接引用，那引用目标必定已经在内存中存在。</p>
</blockquote>
<p>符号引用就是一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p>
<p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p>
<p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p>
<div data="补充为什么可以支持动态绑定 --> <--"></div>
<h3 id="_5-初始化" tabindex="-1"> 5. 初始化</h3>
<div data="modify -->"></div>
<p>初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</p>
<p><code>&lt;clinit&gt;()</code> 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>
    <span>static</span> <span>{</span>
        i <span>=</span> <span>0</span><span>;</span>                <span>// 给变量赋值可以正常编译通过</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>i<span>)</span><span>;</span>  <span>// 这句编译器会提示“非法向前引用”</span>
    <span>}</span>
    <span>static</span> <span>int</span> i <span>=</span> <span>1</span><span>;</span>
<span>}</span>
</code></pre></div><p>由于父类的 <code>&lt;clinit&gt;()</code> 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：</p>
<div><pre><code><span>static</span> <span>class</span> <span>Parent</span> <span>{</span>
    <span>public</span> <span>static</span> <span>int</span> <span>A</span> <span>=</span> <span>1</span><span>;</span>
    <span>static</span> <span>{</span>
        <span>A</span> <span>=</span> <span>2</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>static</span> <span>class</span> <span>Sub</span> <span>extends</span> <span>Parent</span> <span>{</span>
    <span>public</span> <span>static</span> <span>int</span> <span>B</span> <span>=</span> <span>A</span><span>;</span>
<span>}</span>

<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
     <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Sub<span>.</span>B</span><span>)</span><span>;</span>  <span>// 2</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><code>&lt;clinit&gt;()</code>方法对类和接口并不是必须的，当类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。</p>
<p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 <code>&lt;clinit&gt;()</code> 方法。但接口与类不同的是，执行接口的 <code>&lt;clinit&gt;()</code> 方法不需要先执行父接口的 <code>&lt;clinit&gt;()</code> 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <code>&lt;clinit&gt;()</code> 方法。</p>
<p>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 <code>&lt;clinit&gt;()</code> 方法，其它线程都会阻塞等待，直到活动线程执行 <code>&lt;clinit&gt;()</code> 方法完毕。如果在一个类的 <code>&lt;clinit&gt;()</code> 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</p>
<p><strong>注意</strong> 同一个类加载器下，一个类型只会初始化一次</p>
<h2 id="类初始化时机" tabindex="-1"> 类初始化时机</h2>
<h3 id="_1-主动引用" tabindex="-1"> 1. 主动引用</h3>
<p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化(加载、验证、准备都会随之发生)：</p>
<ul>
<li>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段的时候(被 final 修饰、已在编译期把结果放入常量池的静态字段除外)；以及调用一个类的静态方法的时候。</li>
<li>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类(包含 main() 方法的那个类)，虚拟机会先初始化这个主类；</li>
<li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</li>
</ul>
<h3 id="_2-被动引用" tabindex="-1"> 2. 被动引用</h3>
<p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p>
<ul>
<li>通过子类引用父类的静态字段，不会导致子类初始化。</li>
</ul>
<div><pre><code><span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>SubClass</span><span>.</span>value<span>)</span><span>;</span>  <span>// value 字段在 SuperClass 中定义</span>
</code></pre></div><ul>
<li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法，创建动作由字节码指令newarray触发。</li>
</ul>
<div><pre><code><span>SuperClass</span><span>[</span><span>]</span> sca <span>=</span> <span>new</span> <span>SuperClass</span><span>[</span><span>10</span><span>]</span><span>;</span>
</code></pre></div><ul>
<li>常量在编译阶段会存入调用类的常量池中(常量传播优化)，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li>
</ul>
<div><pre><code><span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>ConstClass</span><span>.</span>HELLOWORLD<span>)</span><span>;</span>
</code></pre></div><h2 id="类与类加载器" tabindex="-1"> 类与类加载器</h2>
<p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。</p>
<p>这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。</p>
<h2 id="类加载器分类" tabindex="-1"> 类加载器分类</h2>
<p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</p>
<ul>
<li>
<p>启动类加载器(Bootstrap ClassLoader)，使用 C++ 实现，是虚拟机自身的一部分；</p>
</li>
<li>
<p>所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。</p>
</li>
</ul>
<p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：</p>
<ul>
<li>
<p>启动类加载器(Bootstrap ClassLoader)此类加载器负责将存放在 &lt;JRE_HOME&gt;\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的(仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载)类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。</p>
</li>
<li>
<p>扩展类加载器(Extension ClassLoader)这个类加载器是由 ExtClassLoader(sun.misc.Launcher$ExtClassLoader)实现的。它负责将 &lt;JAVA_HOME&gt;/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</p>
</li>
<li>
<p>应用程序类加载器(Application ClassLoader)这个类加载器是由 AppClassLoader(sun.misc.Launcher$AppClassLoader)实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径(ClassPath)上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
</li>
</ul>
<h2 id="双亲委派模型" tabindex="-1"> 双亲委派模型</h2>
<p>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。</p>
<p>下图展示了类加载器之间的层次关系，称为双亲委派模型(Parents Delegation Model)。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系(Composition)来实现，而不是继承关系(Inheritance)。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0dd2d40a-5b2b-4d45-b176-e75a4cd4bdbf.png" width="500px"> </div><br>
<h3 id="_1-工作过程" tabindex="-1"> 1. 工作过程</h3>
<p>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/jvm/classloader.png" alt="" title=":size=600" loading="lazy"></p>
</div>
<h3 id="_2-好处" tabindex="-1"> 2. 好处</h3>
<p>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。</p>
<p>双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载(JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类)。</p>
<p>例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。</p>
<p><strong>如果我们不想用双亲委派模型怎么办？</strong></p>
<p>为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重载 <code>loadClass()</code> 即可。</p>
<h3 id="_3-实现" tabindex="-1"> 3. 实现</h3>
<p>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。</p>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>ClassLoader</span> <span>{</span>
    <span>// The parent class loader for delegation</span>
    <span>private</span> <span>final</span> <span>ClassLoader</span> parent<span>;</span>

    <span>public</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>loadClass</span><span>(</span><span>String</span> name<span>)</span> <span>throws</span> <span>ClassNotFoundException</span> <span>{</span>
        <span>return</span> <span>loadClass</span><span>(</span>name<span>,</span> <span>false</span><span>)</span><span>;</span>
    <span>}</span>

    <span>protected</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>loadClass</span><span>(</span><span>String</span> name<span>,</span> <span>boolean</span> resolve<span>)</span> <span>throws</span> <span>ClassNotFoundException</span> <span>{</span>
        <span>synchronized</span> <span>(</span><span>getClassLoadingLock</span><span>(</span>name<span>)</span><span>)</span> <span>{</span>
            <span>// 首先，检查请求的类是否已经被加载过</span>
            <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> c <span>=</span> <span>findLoadedClass</span><span>(</span>name<span>)</span><span>;</span>
            <span>if</span> <span>(</span>c <span>==</span> <span>null</span><span>)</span> <span>{</span>
                <span>try</span> <span>{</span>
                    <span>if</span> <span>(</span>parent <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                        c <span>=</span> parent<span>.</span><span>loadClass</span><span>(</span>name<span>,</span> <span>false</span><span>)</span><span>;</span>
                    <span>}</span> <span>else</span> <span>{</span>
                        c <span>=</span> <span>findBootstrapClassOrNull</span><span>(</span>name<span>)</span><span>;</span>
                    <span>}</span>
                <span>}</span> <span>catch</span> <span>(</span><span>ClassNotFoundException</span> e<span>)</span> <span>{</span>
                    <span>// 父类加载器抛出ClassNotFoundException</span>
                    <span>// 说明父类加载器无法完成加载要求</span>
                <span>}</span>

                <span>if</span> <span>(</span>c <span>==</span> <span>null</span><span>)</span> <span>{</span>
                    <span>// 父类加载器无法加载时</span>
                    <span>// 调用本身的findClass方法进行类加载</span>
                    c <span>=</span> <span>findClass</span><span>(</span>name<span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
            <span>if</span> <span>(</span>resolve<span>)</span> <span>{</span>
                <span>resolveClass</span><span>(</span>c<span>)</span><span>;</span>
            <span>}</span>
            <span>return</span> c<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>protected</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>findClass</span><span>(</span><span>String</span> name<span>)</span> <span>throws</span> <span>ClassNotFoundException</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>ClassNotFoundException</span><span>(</span>name<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h3 id="_4-破坏" tabindex="-1"> 4. “破坏”</h3>
<ul>
<li>自定义类加载器</li>
<li>线程上下文加载器</li>
<li>OSGI</li>
</ul>
<h2 id="自定义类加载器实现" tabindex="-1"> 自定义类加载器实现</h2>
<p>以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件(.class 文件)，然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。</p>
<p>java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。</p>
<div><pre><code><span>public</span> <span>class</span> <span>FileSystemClassLoader</span> <span>extends</span> <span>ClassLoader</span> <span>{</span>

    <span>private</span> <span>String</span> rootDir<span>;</span>

    <span>public</span> <span>FileSystemClassLoader</span><span>(</span><span>String</span> rootDir<span>)</span> <span>{</span>
        <span>this</span><span>.</span>rootDir <span>=</span> rootDir<span>;</span>
    <span>}</span>

    <span>protected</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>findClass</span><span>(</span><span>String</span> name<span>)</span> <span>throws</span> <span>ClassNotFoundException</span> <span>{</span>
        <span>byte</span><span>[</span><span>]</span> classData <span>=</span> <span>getClassData</span><span>(</span>name<span>)</span><span>;</span>
        <span>if</span> <span>(</span>classData <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>throw</span> <span>new</span> <span>ClassNotFoundException</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>return</span> <span>defineClass</span><span>(</span>name<span>,</span> classData<span>,</span> <span>0</span><span>,</span> classData<span>.</span>length<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>private</span> <span>byte</span><span>[</span><span>]</span> <span>getClassData</span><span>(</span><span>String</span> className<span>)</span> <span>{</span>
        <span>String</span> path <span>=</span> <span>classNameToPath</span><span>(</span>className<span>)</span><span>;</span>
        <span>try</span> <span>{</span>
            <span>InputStream</span> ins <span>=</span> <span>new</span> <span>FileInputStream</span><span>(</span>path<span>)</span><span>;</span>
            <span>ByteArrayOutputStream</span> baos <span>=</span> <span>new</span> <span>ByteArrayOutputStream</span><span>(</span><span>)</span><span>;</span>
            <span>int</span> bufferSize <span>=</span> <span>4096</span><span>;</span>
            <span>byte</span><span>[</span><span>]</span> buffer <span>=</span> <span>new</span> <span>byte</span><span>[</span>bufferSize<span>]</span><span>;</span>
            <span>int</span> bytesNumRead<span>;</span>
            <span>while</span> <span>(</span><span>(</span>bytesNumRead <span>=</span> ins<span>.</span><span>read</span><span>(</span>buffer<span>)</span><span>)</span> <span>!=</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
                baos<span>.</span><span>write</span><span>(</span>buffer<span>,</span> <span>0</span><span>,</span> bytesNumRead<span>)</span><span>;</span>
            <span>}</span>
            <span>return</span> baos<span>.</span><span>toByteArray</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>String</span> <span>classNameToPath</span><span>(</span><span>String</span> className<span>)</span> <span>{</span>
        <span>return</span> rootDir <span>+</span> <span>File</span><span>.</span>separatorChar
                <span>+</span> className<span>.</span><span>replace</span><span>(</span><span>'.'</span><span>,</span> <span>File</span><span>.</span>separatorChar<span>)</span> <span>+</span> <span>".class"</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><h1 id="七、字节码执行引擎" tabindex="-1"> 七、字节码执行引擎</h1>
<p>执行引擎是jvm最核心的部分，jvm是java虚拟机，有自己实现的指令集和执行引擎结构体系，能够支持那些不被硬件直接支持的指令集。</p>
<p>执行引擎在不同的jvm实现中是不同的，jvm可以选择解释执行或编译执行，也可能两者兼具，甚至包括几个不同级别的编译器执行引擎。</p>
<h2 id="运行时栈帧结构" tabindex="-1"> 运行时栈帧结构</h2>
<p>栈帧是虚拟机栈中的元素，是用于支持方法调用和执行的数据结构，栈帧储存了方法的局部变量表，操作数栈，动态链接和方法返回地址等信息。</p>
<p>每个方法从调用到完成的过程，就对应着一个栈帧在栈里从入栈到出栈的过程。在程序编译为字节码时，栈帧中有多大的局部变量表，多深的操作数栈已经完全确定了，写入到了方法表的Code属性之中了。在活动线程中，只有位于栈顶的栈帧才是有效的，被称为当前栈帧。这个栈帧关联的方法叫当前方法。</p>
<h3 id="_1-局部变量表" tabindex="-1"> 1. 局部变量表</h3>
<p>是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在方法的Code属性中max_locals确定了该方法所需要分配的局部变量表的最大容量。</p>
<p>局部变量表的容量以变量槽(slot)为最小单位。一个Slot可以存放一个32位以内的数据类型(boolean、byte、char、short、int、float、reference、returnAddress)(Java虚拟机规范中没有明确reference类型长度，长度与32位或64位虚拟机有关，若是64位还和是否开启某些对象指针压缩优化有关)(与明确指出“每个Slot占用32位长度内存空间”有一些差别)</p>
<p>对于64位数据类型，虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。不过，由于局部变量表建立在线程的堆栈上，是线程私有的数据，无论读写两个连续的Slot是否为原子操作，都不会引起数据安全问题。</p>
<ul>
<li>虚拟机通过索引定位的方式使用局部变量表，索引值范围从0开始至最大的Slot数量</li>
<li>在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程。如果执行的是实例方法(非static的方法)，那局部变量表中第0位索引的Slot默认用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数，其余参数则按照参数顺序排列，占用从1开始的局部变量slot。</li>
<li>为尽可能节省栈空间，局部变量表中Slot是可以重用的</li>
</ul>
<p><strong>注意</strong>：类变量会经历两次赋值(有默认值)(一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的初始值)。而局部变量不会，所以局部变量如果定义但是不赋值是不能使用的。</p>
<h3 id="_2-操作数栈" tabindex="-1"> 2. 操作数栈</h3>
<p>Operand Stack也常称为操作栈，它是一个后入先出(Last In First Out, LIFO)栈。</p>
<p>当方法刚开始执行时，操作数栈是空的，然后执行时，字节码指令往操作数栈中写入和提取内容，也就是入栈、出栈操作(例如，算数运算通过操作数栈进行，又或者用在调用其他方法时通过操作数栈来进行参数传递)。</p>
<p>操作数栈的元素的数据类型必须和字节码指令的序列严格匹配。javac编译器和类加载时的验证阶段都要严格保证这一点。</p>
<p>在概念模型中，两个栈帧是完全独立的，但在虚拟机实现中会做一些优化处理，让两个栈出现一部分重叠。</p>
<p>jvm的解释执行引擎称为&quot;基于栈的执行引擎&quot;,其中所指的栈就是操作数栈。</p>
<h3 id="_3-动态连接" tabindex="-1"> 3. 动态连接</h3>
<p>每个栈帧都包含一个执行运行时常量池(在方法区)中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接的。</p>
<p>Class文件中的常量池中有大量的符号引用，这些常量池在类加载完成后会方法运行时常量池中，字节码中的方法调用指令就是以运行时常量池中的方法符号引用作为参数。</p>
<p>这些符号引用中，一部分在类加载阶段或第一次使用的时候转化为直接引用，这种成为静态解析。另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。</p>
<h3 id="_4-方法返回地址" tabindex="-1"> 4. 方法返回地址</h3>
<p>当一个方法开始执行后，只有两种方式可以退出该方法：</p>
<ol>
<li>正常完成出口：执行引擎遇到任意一个方法返回的字节码指令，正常退出</li>
<li>异常完成出口：在方法执行过程中出现异常，并且这个那异常没有在方法体内得到处理。(不会给上层调用者产生任何返回值)</li>
</ol>
<p>方法退出后，会返回到方法被调用的位置。方法返回是需要保存一些信息，用来帮助他的上层方法恢复执行状态。</p>
<ol>
<li>正常退出时：栈帧需要保存调用者的PC计数器的值作为返回地址</li>
<li>异常退出时：返回地址要通过异常处理表来确定，栈帧中一般不会保存这部分信息</li>
</ol>
<h2 id="方法调用" tabindex="-1"> 方法调用</h2>
<p>方法调用阶段唯一的任务就是确定被调用方法的版本(即调用哪一个方法)</p>
<p>Class文件中只是储存的符号引用，而不是直接引用。这样就有了灵活性，但也使得方法调用变得复杂，需要在类加载期间，甚至运行期间才能确定目标方法的直接引用。</p>
<h3 id="_1-解析" tabindex="-1"> 1. 解析</h3>
<p>在类加载的解析阶段有一部分符号引用就能转化为直接引用，前提是：方法在程序运行之前就有一个可确定的调用版本，并且这个方法的调用版本是运行起不可改变的。(调用目标在程序代码写好，编译器进行编译时就必须确定下来)</p>
<p>Java中符合&quot;编译器可知，运行期不变&quot;这个要求的方法，主要是静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可知。</p>
<p>Java虚拟机中提供了5条方法调用字节码指令：</p>
<ul>
<li>invokestatic 用于调用类方法(static方法)</li>
<li>invokespecial 用于调用需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法</li>
<li>invokevirtual 调用所有虚方法</li>
<li>invokeinterface 用于调用接口方法，会在运行时再确定一个实现此接口的对象</li>
<li>invokedynamic 先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条指令，分配逻辑是固话在Java虚拟机内的，而这个指令的分配逻辑是用户所设定的引导方法决定的。</li>
</ul>
<p>只有被invokestatic和invokespecial调用的方法，才能在解析阶段中确定唯一的调用版本，符合条件的静态方法、私有方法、实例构造器、父类方法四种方法被称为非虚方法，其他方法称为虚方法(除去final方法，虽然final方法是使用invokevirtual调用的，但final方法无法被重写，没有其他版本，所以无法进行多态，所以final方法为非虚方法)。</p>
<p>静态方法的继承：</p>
<ul>
<li>在Java中静态方法可以被继承，但是不能被覆盖，即不能重写。</li>
<li>如果子类中也含有一个返回类型、方法名、参数列表均与之相同的静态方法，那么该子类实际上只是将父类中的该同名方法进行了隐藏，而非重写。</li>
<li>父类引用指向子类对象时，只会调用父类的静态方法。所以，它们的行为也并不具有多态性。</li>
</ul>
<h3 id="_2-分派" tabindex="-1"> 2. 分派</h3>
<p>解析调用一定是一个静态过程，在编译期间就能确定。而分派调用则可能是静态分派，也可能是动态分派。根据分派的宗量数可以分为单分派和多分派。</p>
<p>Java包括三个基本特征：继承、封装和多态。
分派调用将会揭示多态的原理。
重载和重写属于多态的特性。</p>
<h4 id="静态分派" tabindex="-1"> 静态分派</h4>
<p>静态类型和实际类型都可以在程序运行时都可以发生一下变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是编译器可知的。而实际类型是在运行起才能确定。编译器在编译程序时并不知道一个对象的实际类型是什么。</p>
<p>编译器在重载时使用参数的静态类型而不是动态类型做为判定依据。因为静态类型是编译期可知的，所以在编译阶段，javac会根据参数的静态类型决定使用那个重载版本。选择了重载版本之后，会使用invokevirtual指令在方法的字节码中把选择的重载版本作为参数。</p>
<p>所以利用静态类型的定位方法执行版本的分派动作成为静态分派。</p>
<p><strong>静态分派的典型应用是方法重载。</strong>
静态分派发生在编译阶段，因此确定静态分派的动作不是由Java虚拟机执行的。</p>
<p>这里还需要注意的是，方法重载时，为了匹配参数可能会发生自动类型转换。
char &gt;&gt; int &gt;&gt; long &gt;&gt; Character &gt;&gt; Serializable &gt;&gt; Object &gt;&gt; char ...</p>
<p>静态方法也能够被重载，所以静态方法的重载版本的选择也是通过静态分派完成的。</p>
<h4 id="动态分派" tabindex="-1"> 动态分派</h4>
<p><strong>动态分派与重写相关</strong></p>
<p>在invokevirtual指令在运行时解析过程大致分为以下几个步骤：</p>
<ul>
<li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记做C</li>
<li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，若通过校验则返回这个方法的直接引用，查找过程结束，若不通过，则抛出错误</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程</li>
<li>若最后没有找到合适的方法，则抛出错误</li>
</ul>
<p>Java编译器在编译时期并不总是知道哪一些代码会被执行，因为编译器仅仅知道对象的静态类型， 而不知道对象的真实类型，而方法的调用则是根据真实类型，而不是静态类型。</p>
<p>由于invokevirtual指令执行的第一步是在运行期确定接受者的实际类型，所以调用中的invokevirtual指令把常量池中类方法符号引用解析到了不同的直接引用上。</p>
<p>这个过程是Java语言重写的本质。在运行期间根据实际类型确定执行版本的分派过程称为动态分派。</p>
<p>重载是静态的，重写是动态的，因此有人认为只有重写算是多态性的体现，重载不算多态。(概念仅仅是说明问题的一种工具)</p>
<h4 id="单分派与多分派" tabindex="-1"> 单分派与多分派</h4>
<p>方法的接收者与方法的参数统称为方法的宗量。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多余一个宗量对目标方法进行选择</p>
<p>目前的Java是一个静态多分派，动态单分派的语言</p>
<h4 id="虚拟机动态分派的实现" tabindex="-1"> 虚拟机动态分派的实现</h4>
<p>由于动态分派是非常频繁的动作，虚拟机实现中基于性能考虑，大部分实现都不会那么频繁的搜索。</p>
<p>常用的稳定优化手段是为类在方法区中建立一个虚方法表(vtable)，(与此对应,invokeinterface执行会用到接口方法表(itable))使用虚方法表索引来代替元数据查找以提高性能。</p>
<ul>
<li>虚方法表存放着各个方法的实际入口地址，如果子类没有重写父类的方法，那子类的虚方法表和父类是一致的，都指向父类的实现入口。如果子类重写了父类的方法，则子类方法表中的地址会替换为指向子类实现版本的入口地址。</li>
<li>具有相同签名的方法，在子类父类的虚方法表中都应当具有一样的索引号，这样当类型转换时，仅需变更查找的方法表，而不需要变索引。</li>
</ul>
<p>方法表在类加载的连接阶段进行初始化，当类变量初始化后，会初始化虚方法表。</p>
<h3 id="_3-动态类型语言支持" tabindex="-1"> 3. 动态类型语言支持</h3>
<h4 id="动态类型语言" tabindex="-1"> 动态类型语言</h4>
<p>动态类型语言的关键特征是他的类型语言检查的主体过程是在运行期而不是编译期，变量无类型而变量的值有类型也是动态类型语言的重要特征。</p>
<p>静态类型语言在编译期确定类型,最显著的好处是编译器可以提供严谨的类型检查,这样与类型相关的问题能在编码的时候就及时发现,利于稳定性及代码达到更大规模。而动态类型语言在运行期确定类型,这可以为开发人员提供更大的灵活性 ,某些在静态类型语言中需用大量“臃肿”代码来实现的功能,由动态类型语言来实现可能 会更加清晰和简洁,清晰和简洁通常也就意味着开发效率的提升。</p>
<h4 id="jdk7与动态类型" tabindex="-1"> jdk7与动态类型</h4>
<p>现在，一些动态语言已经可以运行在jvm之上了，比如scala。动态类型的支持需要在jvm层面上解决才最合适，因此，jdk7引入了invokedynamic指令和java.lang.invoke包。</p>
<h4 id="java-lang-invoke包" tabindex="-1"> java.lang.invoke包</h4>
<p>这个包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法这种方式以外,提供一种新的动态确定目标方法的机制,<strong>称为MethodHandle</strong></p>
<p>举个例子, 如果我们要实现一个带谓词的排序函数,在C/C++中常用的做法是把谓词定义为函数,用函数指针把谓词传递到排序方法</p>
<div><pre><code>void sort(int list[],const int size,int(*compare)(int,int))
</code></pre></div><p>Java没办法把一个函数作为参数进行传递，普遍的做法是设计一个接口，然后以实现了这个接口的对象作为参数。</p>
<div><pre><code><span>void</span> sort <span>(</span><span>List</span> list<span>,</span><span>Comparator</span> c<span>)</span>
</code></pre></div><p><strong>Reflection和MethodHandle</strong></p>
<ul>
<li>两种机制都是在模拟方法调用，但Reflection是在模拟Java代码层次的方法调用，而MethodHandle是在模拟字节码层次的方法调用。在 MethodHandles.lookup中的3个方法——findStatic()、fmdVirtual()、fmdSpecial()正是为了对应于invokestatic、invokevirtual、invokeinterface和invokespecial这几条字节码指令的执行权限校验行为,而这些底层细节在使用Reflection API时是不需要关心的</li>
<li>Reflection中的java.lang.reflect.Method对象远比MethodHandle机制中的 java.lang.invoke.MethodHandle对象所包含的信息多。前者是方法在Java一端的全面映像,包含了方法的签名、描述符以及方法属性表中各种属性的Java端表示方式,还包含执行权限等的运行期信息。而后者仅仅包含与执行该方法相关的信息。通俗的话来讲,Reflection是重量级 ,而MethodHandle是轻量级。</li>
<li>由于MethodHandle是对字节码的方法指令调用的模拟,所以理论上虚拟机在这方面做的各种优化(如方法内联),在MethodHandle上也应当可以采用类似思路去支持(但目前实现还不完善)。而通过反射去调用方法则不行。</li>
</ul>
<p>MethodHandle与Reflection除了上面列举的区别外,最关键的一点还在于去掉前面讨论施加的前提“仅站在Java语言的角度来看” : Reflection API的设计目标是只为Java语言服务的, 而MethodHandle则设计成可服务于所有Java虚拟机之上的语言,其中也包括Java语言。</p>
<h4 id="invokedynamic指令" tabindex="-1"> invokedynamic指令</h4>
<p>在某种程度上,invokedynamic指令与MethodHandle机制的作用是一样的,都是为了解决原有4条“invoke*”指令方法分派规则固化在虚拟机之中的问题,把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中,让用户(包含其他语言的设计者)有更高的自由度。 而且 ,它们两者的思路也是可类比的,可以把它们想象成为了达成同一个目的,一个采用上层Java代码和API来实现,另一个用字节码和Class中其他属性、常量来完成。</p>
<p>每一处含有invokedynamic指令的位置都称做“动态调用点” ( Dynamic Call Site ) , 这条指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量 ,而变为JDK 1.7新加入的CONSTANT_InvokeDynamic_info常量,从这个新常量中可以得到3项信息:引导方法(Bootstrap Method,此方法存放在新增的BootstrapMethods属性中)、方法类型 ( MethodType ) 和名称。引导方法是有固定的参数,并且返回A是java.langinvoke.CallSite对象 ,这个代表真正要执行的目标方法调用。根据CONSTANT_InvokeDynamic_info常量中提供的信息,虚拟机可以找到并且执行引导方法,从而获得一个CallSite对象,最终调用要执行的目标方法。</p>
<h2 id="基于栈的字节码解释执行引擎" tabindex="-1"> 基于栈的字节码解释执行引擎</h2>
<h3 id="_1-解释执行" tabindex="-1"> 1. 解释执行</h3>
<p>如今,基于物理机、Java虚拟机,或者非Java的其他高级语言虚拟机(HLLVM )的语 言 ,大多都会遵循这种基于现代经典编译原理的思路,在执行前先对程序源码进行词法分析和语法分析处理,把源码转化为抽象语法树( Abstract Syntax Tree,AST)。对于一门具体语言的实现来说,词法分析、语法分析以至后面的优化器和目标代码生成器都可以选择独立于执行引擎,形成一个完整意义的编译器去实现,这类代表是C/C++语言。也可以选择把其中一部分步骤(如生成抽象语法树之前的步骤)实现为一个半独立的编译器,这类代表是Java 语言。又或者把这些步骤和执行引擎全部集中封装在一个封闭的黑匣子之中,如大多数的JavaScript执行器。</p>
<p>Java语言中 ,Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树,再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的, 而解释器在虚拟机的内部,所以Java程序的编译就是半独立的实现。</p>
<h3 id="_2-指令集" tabindex="-1"> 2. 指令集</h3>
<p>Java编译器输出的指令流，基本上是一种基于栈的指令集架构( Instruction Set Architecture,ISA ) , 指令流中的指令大部分都是零地址指令,它们包赖操作数栈进行工作。</p>
<p>与之相对的另外一套常用的指令集架构是基于寄存器的指令集,最典型的就是x86的二地址指令集。</p>
<p>虽然栈架构指令集的代码非常紧凑,但是完成相同功能所需的指令数量一般会比寄存器架构多,因为出栈、入栈操作本身就产生了相当多的指令数量。更重要的是 ,栈实现在内存之中 ,频繁的栈访问也就意味着频繁的内存访问,<strong>相对于处理器来说,内存始终是执行速度的瓶颈</strong>。尽管虚拟机可以采取栈顶缓存的手段,把最常用的操作映射到寄存器中避免直接内存访问 ,但这也只能是优化措施而不是解决本质问题的方法。 <strong>由于指令数量和内存访问的原因 ,所以导致了栈架构指令集的执行速度会相对较慢。</strong></p>
<p>栈结构指令集的运算过程的中间变量都以操作数栈的出栈、入栈为信息交换途径。</p>
<h1 id="八、程序编译与代码优化" tabindex="-1"> 八、程序编译与代码优化</h1>
<h2 id="早期-编译期-优化" tabindex="-1"> 早期(编译期)优化</h2>
<p>Java编译器可能是指一个前端编译器(其实叫“编译器的前端”更准备一些)，把*.java文件转变成*.class文件的过程；也可能是指虚拟机的后端运行期编译器(JIT编译器，Just In Time Compiler)把字节码转变成机器码的过程；还可能是指使用静态提前编译器(AOT编译器，Ahead Of Time Compiler)直接把*.java文件编译成本地机器代码的过程。例如：</p>
<ul>
<li>前端编译器：Sun的javac，Eclipse JDT中的增量式编译器(ECJ)；</li>
<li>JIT编译器：HotSpot VM的C1、C2编译器；</li>
<li>AOT编译器：GUN Complier for the Java(GCJ)，Excelsior JET；</li>
</ul>
<p>javac做了许多针对java语言编码过程的优化措施来改善程序员的编码风格和提高编码效率。相当多新生的Java语法特性，都是靠编译器的“语法糖”来实现，而不是依赖虚拟机的底层改进来支持，可以说，Java中即时编译器在运行期的优化过程对于程序运行来说更重要，而前端编译器在编译期的优化过程对于程序编码来说关系更加密切。</p>
<h3 id="_1-javac编译器" tabindex="-1"> 1. javac编译器</h3>
<h4 id="解析与填充符号表" tabindex="-1"> 解析与填充符号表</h4>
<ol>
<li>词法、语法分析
<ul>
<li>词法分析是将源代码的字符流转变为标记(Token)集合。</li>
<li>语法分析是根据Token序列构造抽象语法树的过程，抽象语法树(Abstract Syntax Tree，AST)是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构，例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以使一个语法结构。</li>
</ul>
</li>
<li>填充符号表：符号表(Symbol Table)是由一组符号地址和符号信息构成的表格。</li>
</ol>
<h4 id="插入式注解处理器的注解处理过程" tabindex="-1"> 插入式注解处理器的注解处理过程</h4>
<p>注解与普通的java代码一样，是在运行期间发挥作用的。JDK 1.6提供了插入式注解处理器的标准API在编译期间对注解进行处理，这些API类似插件，它们可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，那么编译器将回到解析及符号填充表的过程重新处理，直到所有的插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round。</p>
<h4 id="分析与字节码生成过程" tabindex="-1"> 分析与字节码生成过程</h4>
<ol>
<li>标注检查：
<ul>
<li>变量使用前是否被声明</li>
<li>变量与赋值之间的数据类型是否能够匹配</li>
</ul>
</li>
<li>数据及控制流分析：是对程序上下文逻辑更进一步的验证
<ul>
<li>局部变量在使用前是否赋值</li>
<li>方法的每条路径是否有返回值</li>
<li>是否所有的受检异常都正确处理</li>
</ul>
</li>
<li>解语法糖：Java中最常用的语法糖主要是泛型、变长参数、自动装箱/拆箱等，虚拟机运行时不支持这些语法，它们在编译阶段还原回简单的基础语法结构，这个过程称为解语法糖</li>
<li>字节码生成是javac编译过程的最后一个阶段，字节码生成阶段不仅仅是把前面各个步骤锁生成的信息(语法树、符号表)转换成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作
<ul>
<li>代码添加：实例构造器和类构造器在这个阶段添加到语法树</li>
<li>代码转换：字符串的&quot;+&quot;替换为StringBuffer或StringBuilder的append操作</li>
</ul>
</li>
</ol>
<h3 id="_2-java语法糖" tabindex="-1"> 2. Java语法糖</h3>
<p>语法糖(Syntactic Sugar)，也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说，使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</p>
<p>语法糖可以看做是编译期实现的一些“小把戏”，这些“小把戏”可能会使得效率“大提升”</p>
<h4 id="泛型与类型擦除" tabindex="-1"> 泛型与类型擦除</h4>
<p>泛型的本质是参数化类型(Parametersized Type)的应用，也就是说所操作的数据类型被指定为一个参数</p>
<p><strong>泛型分类</strong></p>
<ul>
<li>真实泛型：在C#语言里面，泛型无论在程序源码中、编译后的IL中(中间语言，这时候泛型是一个占位符)，或是运行期的CLR中，都是切实存在的，<code>List&lt;int&gt;</code>与<code>List&lt;String&gt;</code>就是两种不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨胀，基于这种方法实现的泛型称为真实泛型。</li>
<li>伪泛型：在Java语言里面，泛型只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型了，并且在相应的地方插入了强制转型代码。因此对于运行期的Java语言来说，<code>ArrayList&lt;int&gt;</code>与<code>ArrayList&lt;String&gt;</code>就是同一个类。所以泛型技术实际上是Java语言的一个语法糖。Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。</li>
</ul>
<p>Java语言中的泛型只在源码中存在，在编译后的字节码中，就已经替换为原来的原生类型(Raw Type，也称为裸类型)，所以泛型是java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型</p>
<p><strong>本质</strong>：参数化类型的应用，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以应用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。</p>
<p><strong>原本的方法</strong>：在没有泛型以前，只能通过Object是所有类型的父类和类型强制转换两个特点的配合来实现类型泛化。——问题：在编译期间，编译器无法检查这个Object的强制转型是否成功，如果仅仅依赖程序员去保障这项操作的正确性，许多ClassCastException的风险就会嫁接到程序运行期之中去。</p>
<p>引入Signature、LocalVariableTable等属性用于解决伴随泛型而来的参数化类型的识别；
Signature：作用是存储一个方法在字节码层面的特征签名，保存的类型不是原生类型，而是包含了参数化类型的信息</p>
<p><strong>存在的问题</strong></p>
<ul>
<li>泛型方法的重载：泛型擦除成相同的原生类型无法重载(无法通过编译，JDK1.6中通过不同返回值可以编译通过)</li>
</ul>
<p>擦除法所谓的擦除，仅仅是对方法的code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能够通过反射手段获取到参数化类型的根本依据</p>
<h4 id="自动装箱、拆箱与遍历循环" tabindex="-1"> 自动装箱、拆箱与遍历循环</h4>
<ul>
<li>自动装箱、拆箱在编译之后被转化为了对应的包装和还原方法，如Integer.valueOf()与Integer.intValue()方法</li>
<li>遍历循环则把代码还原成了迭代器的实现，这也是为何遍历循环需要被遍历的类实现Iterable接口的原因</li>
<li>变长参数在调用的时候变成了一个数组类型的参数</li>
</ul>
<p>包装类的&quot;==&quot;运算在不遇到算术运算的情况下不会自动拆箱；包装类equals()方法不处理数据转型的关系</p>
<h4 id="条件编译" tabindex="-1"> 条件编译</h4>
<p>Java语言中条件编译的实现也是Java语言的一颗语法糖，根据布尔常量值的真假编译器将会把分支中不成立的代码块消除掉，这一工作将在编译器解除语法糖阶段完成。</p>
<h2 id="晚期-运行期-优化" tabindex="-1"> 晚期(运行期)优化</h2>
<p>Java 程序最初是通过解释器解释执行的，当虚拟机发现有个方法或代码块运行特别频繁时，就会把这些代码认定为“热点代码”。为了提高热点代码的执行效率，虚拟机会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器被称为即时编译器(Just In Time Compiler，简称 JIT 编译器)。</p>
<p>介绍 <strong>Hotspot 虚拟机内的即时编译器</strong></p>
<h3 id="_1-解释器与编译器" tabindex="-1"> 1. 解释器与编译器</h3>
<p>解释器与编译器有各自的优势：当程序需要快速启动时，解释器可以发挥作用，省去编译时间立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码后，可以获取更高的执行效率。</p>
<p>当程序运行环境的内存资源限制较大时，使用<strong>解释器执行节省内存</strong>，反之可以使用<strong>编译执行提升效率</strong>。同时，解释器还可以作为编译器激进优化时的一个“<strong>逃生门</strong>”，让编译器根据概率选择一个大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立时，比如加载了新类后类型继承结构出现变化，出现“罕见陷阱”时可以通过逆优化退回到解释状态继续执行。因此，在虚拟机中解释器和编译器经常配合工作，</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/jvm/解释器与编译器交互.png" alt="" title=":size=550" loading="lazy"></p>
</div>
<p>HotSpot 虚拟机内置了两个即时编译器：Client Compiler 和 Server Compiler，简称 C1 编译器和 C2 编译器。默认采用解释器和其中一个编译器直接配合的方式工作</p>
<p>由于即时编译器编译本地代码需要占用程序运行时间，要编译出优化程度更高的代码，所需时间会更长。同时，解释器还要替编译器收集性能监控信息，这对解释执行速度也有影响。为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot 虚拟机又引入了分层编译的策略。分层编译根据编译器编译、优化的规模与耗时，划分为不同的编译层次，包括：</p>
<ol>
<li>第 0 层，程序解释执行，不开启性能监控功能，可触发第 1 层编译。</li>
<li>第 1 层，称为 C1 编译，将字节码编译为本地代码，并进行简单可靠的优化，如有必要将加入性能监控逻辑。</li>
<li>第 2 层，称为 C2 编译，也是将字节码编译为本地代码，但是会进行耗时较长的优化，甚至会根据性能监控信息进行一些不完全可靠的激进优化。</li>
</ol>
<p>实施分层编译后，Client Compiler 和 Server Compiler 会同时工作，许多代码可能会被编译多次，用 Client Compiler 获得更快的编译速度，用 Server Compiler 获取更好的编译质量，在解释执行的时候也无需再承担收集性能监控信息的任务。</p>
<h3 id="_2-编译对象与触发条件" tabindex="-1"> 2. 编译对象与触发条件</h3>
<p>在运行过程中，会被即时编译器编译的<strong>热点代码</strong>有两类：</p>
<ul>
<li>被多次调用的方法。</li>
<li>被多次执行的循环体。</li>
</ul>
<p>这两种情况，编译器都会编译整个方法。因为编译发生在方法执行过程中，因此形象地称之为栈上替换(On Stack Replacement，简称 OSR，即方法栈帧还在栈上，方法就被替换了)</p>
<p>判断一段代码是不是热点代码，是否需要触发即时编译，这样的行为称为<strong>热点探测</strong>(Hot Spot Detection)，热点探测方式主要有两种：</p>
<ul>
<li>基于采样的热点探测：采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果某个方法经常出现在栈顶，那它就是热点方法。其优点是简单、高效，还可以获取方法调用关系；缺点是不够精确，容易受到线程阻塞或其他外接因素的影响。</li>
<li>基于计数的热点探测：采用这种方法的虚拟机会为每个方法(甚至是代码块)建立计数器，统计方法执行次数，次数超过一定阈值就认为是热点方法。这种方法实现起来麻烦，但是其统计结果相对来说更加精确和严谨。</li>
</ul>
<p>在 HotSpot 虚拟机里使用的是第二种方法，因此它为每个方法准备了两类计数器：方法调用计数器(Invocation Counter)和回边计数器(Back edge Counter)。</p>
<p><strong>方法调用计数器</strong></p>
<div align="center"> 
<p><img src="@source/assets/cs-note/jvm/方法调用计数器.png" alt="" title=":size=550" loading="lazy"></p>
</div>
<p>方法调用计数器统计的不是方法被调用的绝对次数，而是一段时间内的方法被调用的次数。当超过一段的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半。这个过程称为热度衰减(Counter Decay)，这段时间称为方法统计的半衰周期(Counter Half Life Time)。进行热度衰减的动作是虚拟机在垃圾收集时顺便进行的</p>
<p><strong>回边计数器</strong></p>
<p>回边计数器的作用是统计方法体中循环体代码执行次数，在字节码中遇到遇到控制流向后调整的指令称为回边。显然，建立回边计数器统计的目的就是为了触发 OSR 编译。</p>
<div align="center"> 
<p><img src="@source/assets/cs-note/jvm/回边计数器.png" alt="" title=":size=550" loading="lazy"></p>
</div>
<p>回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出状态，这样下次再进入该方法的时候就会执行标准编译过程。</p>
<h3 id="_3-编译过程" tabindex="-1"> 3. 编译过程</h3>
<p>默认情况下，即时编译是在后台进行的，编译完成之前还是按照解释方式执行，用户可以通过参数 -XX:-BackgroundCompilation 来禁止后台编译。</p>
<p>Client Compiler 和 Server Compiler 两个编译器的编译过程是不一样的。</p>
<p><strong>Client Compiler</strong> 是一个简单快速的三段式编译器，主要关注点在于局部优化，放弃了许多耗时的全局优化手段。</p>
<ol>
<li>在第一个阶段，一个平台独立的前端将字节码构造成一种高级中间代码(High Level Intermediate Representation，HIR)表示。HIR 使用静态单分配的形式来代表代码值，这使得一些在 HIR 之后和之中进行的优化动作更容易实现。在此之前编译器会在字节码上完成一部分基础优化，如方法内敛、常量传播等。</li>
<li>在第二个阶段，一个平台相关的后端从 HIR 中产生低级中间代码表示(Low Level Intermediate Representation，LIR)表示。在此之前，会在 HIR 上完成另一些优化，比如空值检查消除、范围检查消除，以便让 HIR 达到更高效的代码表示形式。</li>
<li>最后阶段，是在平台相关的后端，使用线性扫描算法在 LIR 上分配寄存器，并在 LIR 上做窥孔优化，然后产生机器代码。</li>
</ol>
<div align="center"> 
<p>![](../../assets/cs-note/jvm/Client Compiler过程.png.png ':size=550')</p>
</div>
<p><strong>Server Compiler</strong> 是面向服务端的，并且为服务端性能配置进行了特别调整，是一个充分优化过的高级编译器，几乎能达到 GNU 编译器使用 -O2 参数时的优化强度。它会执行所有经典的优化动作，比如无用代码消除、循环展开、循环表达式外提、消除公共子表达式、常量传播、基本块重排序等，还会实施一些与 Java 语言特征密切相关的技术，比如范围检查消除、空值检查消除。另外，还可能根据解释器或 Client Compiler 提供的性能监控信息，进行一些不稳定的激进优化，如守护内联、分支频率预测等。</p>
<p>Server Compiler 的寄存器分配器是一个全局图着色分配器，它可以充分利用某些处理器架构上的大寄存器集合。以即时编译的标准来看，Server Compiler 无疑是比较缓慢的，但它的编译速度依然超过传统的静态优化编译器，而且相对于 Client Compiler 来说代码质量有所提高，可以减少本地代码执行时间，从而抵消了额外的编译时间开销。</p>
<h3 id="_4-编译优化技术" tabindex="-1"> 4. 编译优化技术</h3>
<ul>
<li>语言无关的经典优化技术之一：公共子表达式消除</li>
<li>语言相关的经典优化技术之一：数组范围检查消除</li>
<li>最重要的优化技术之一：方法内联</li>
<li>最前沿的优化技术之一：逃逸分析</li>
</ul>
<h4 id="公共子表达式消除" tabindex="-1"> 公共子表达式消除</h4>
<p>公共子表达式消除是一个普遍应用于各种编译器的经典优化技术，它的原理是：如果一个表达式 E 已经计算过了，并且从先前计算到现在 E 中所有变量的值都没有发生变化，那么 E 的这次计算就称为公共子表达。对于这种表达式，就没有必要再对其进行计算了，使用之前计算过的值即可。</p>
<h4 id="数组边界检查消除" tabindex="-1"> 数组边界检查消除</h4>
<p>数组边界检查消除是即时编译器中语言相关的经典优化技术。编译器会对代码进行分析，如果确定某次数组访问一定不会越界，就可以去掉数组的上下界检查。</p>
<p>与数组边界检查消除类似的优化，还有隐式异常处理，Java 中空指针检查和除数为零检查都采用了这种思路。</p>
<h4 id="方法内联" tabindex="-1"> 方法内联</h4>
<p>方法内联是编译器最重要的优化手段之一，除了消除方法调用成本之外，它更重要的意义是为其他优化手段建立良好的基础。</p>
<p>方法内联看起来简单，但实际中很多方法都无法直接进行内联。除了使用 invokespecial 指令调用的私有方法、实例构造器、父类方法以及使用 invokestatic 指令调用的静态方法，还有部分 final 方法能够在编译时唯一确定执行的方法版本，这一类称为非虚方法。</p>
<p>为了解决虚方法的内联问题，Java 虚拟机引入了一种称为“类型继承关系分析”(Class Hierarchy Analysis，CHA)的技术，这是一种基于整个查询的类型分析技术，它用于确定在目前已加载的类中，某个接口是否有多于一种实现，某个类是否存在子类、子类是否为抽象类等信息。</p>
<p>如果通过 CHA 分析得知某个方法只有一个版本，就可以进行内联，不过这种内联属于“<strong>激进优化</strong>”，需要预留一个“逃生门”，称为守护内联。如果程序在执行过程中，虚拟机一直没有加载到令这个类继承关系发生变化的类，那这个内联优化的代码就可以一直使用下去。但如果加载了导致继承关系发生变化的新类，那就需要抛弃已经编译的代码，返回到解释状态执行，或者重新进行编译。</p>
<p><strong>内联缓存</strong>: 在未发生方法调用之前，内联缓存状态为空，当第一次调用发生后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较接收者版本，如果以后进来的每次调用的方法接收者版本都是一样的，那这个内联还可以一直用下去。如果发生了方法接收者不一致的情况，就说明程序真正使用了虚方法的多态特性，这时才会取消内联，查找虚方法表进行方法分派。</p>
<h4 id="逃逸分析" tabindex="-1"> 逃逸分析</h4>
<p>逃逸分析是目前 Java 虚拟机中比较前言的优化技术，它与类型继承关系分析一样，并不是直接优化代码的技术，而是为其他优化手段提供依据的分析技术。逃逸分析的基本行为是分析对象动态作用域：当一个对象在方法里定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为<strong>方法逃逸</strong>。甚至还有可能被外部方法访问到，譬如赋值给类变量或其他线程中访问的实例变量，称为<strong>线程逃逸</strong>。</p>
<p>如果能证明一个对象不会逃逸到方法或线程之外，就可以为这个变量进行一些高效优化：</p>
<ul>
<li>栈上分配(Stack Allocation)</li>
<li>同步消除(Synchronization Elimination)</li>
<li>标量替换(Scalar Replacement)：
<ul>
<li>标量是指一个数据已经无法再分解成更小的数据来表示了</li>
<li>如果把一个Java对象拆散，根据程序访问的情况，将其使用到的成员变量恢复原始类型来访问就叫做标量替换</li>
<li>程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替</li>
</ul>
</li>
</ul>
<h3 id="_5-java与c-c-的编译器对比" tabindex="-1"> 5. Java与C/C++的编译器对比</h3>
<p>Java虚拟机的即时编译器与C/C++的静态优化编译器相比，可能会由于下列这些原因而导致输出的本地代码有一些<strong>劣势</strong>：</p>
<ol>
<li>因为即时编译器运行占用的是用户程序的运行时间，具有很大的时间压力，它能提供的优化手段也严重受制于编译成本。</li>
<li>Java语言是动态的类型安全语言，这就意味着需要由虚拟机来确保程序不会违反语言语义或访问非结构化内存，要消耗不少的运行时间</li>
<li>Java语言中虽然没有virtual关键字，但是使用虚方法的频率却远远大于C/C++语言，这意味着运行时对方法接收者进行多态选择的频率要远远大于C/C++语言，也意味着即时编译器在进行一些优化(如前面提到的方法内联)时的难度要远大于C/C++的静态优化编译器。</li>
<li>Java语言是可以动态扩展的语言，运行时加载新的类可能改变程序类型的继承关系，这使得很多全局的优化都难以进行</li>
<li>Java语言中对象的内存分配都是堆上进行的，只有方法中的局部变量才能在栈上分配。而C/C++的对象则有多种内存分配方式，既可能在堆上分配，又可能在栈上分配，如果可以在栈上分配线程私有的对象，将减轻内存回收的压力。另外，C/C++中主要由用户程序代码来回收分配的内存，这就不存在无用对象筛选的过程，因此效率上(仅指运行效率，排除了开发效率)也比垃圾收集机制要高。</li>
</ol>
<p><strong>好处</strong>：</p>
<ol>
<li>在C/C++中，别名分析(Alias Analysis)的难度就要远高于Java。</li>
<li>由于C/C++编译器所有优化都在编译期完成，以运行期性能监控为基础的优化措施它都无法进行，如调用频率预测(Call Frequency Prediction)、分支频率预测(Branch Frequency Prediction)、裁剪未被选择的分支(Untaken Branch Pruning)等，这些都会成为Java语言独有的性能优势。</li>
</ol>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li>周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.</li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4" target="_blank" rel="noopener noreferrer">Chapter 2. The Structure of the Java Virtual Machine</a></li>
<li><a href="https://www.slideshare.net/benewu/jvm-memory" target="_blank" rel="noopener noreferrer">Jvm memory</a>
<a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html" target="_blank" rel="noopener noreferrer">Getting Started with the G1 Garbage Collector</a></li>
<li><a href="http://electrofriends.com/articles/jni/jni-part1-java-native-interface/" target="_blank" rel="noopener noreferrer">JNI Part1: Java Native Interface Introduction and “Hello World” application</a></li>
<li><a href="https://hackthejava.wordpress.com/2015/01/09/memory-architecture-by-jvmruntime-data-areas/" target="_blank" rel="noopener noreferrer">Memory Architecture Of JVM(Runtime Data Areas)</a></li>
<li><a href="https://www.programcreek.com/2013/04/jvm-run-time-data-areas/" target="_blank" rel="noopener noreferrer">JVM Run-Time Data Areas</a></li>
<li><a href="http://www.drdobbs.com/architecture-and-design/android-on-x86-java-native-interface-and/240166271" target="_blank" rel="noopener noreferrer">Android on x86: Java Native Interface and the Android Native Development Kit</a></li>
<li><a href="https://crowhawk.github.io/2017/08/10/jvm_2/" target="_blank" rel="noopener noreferrer">深入理解 JVM(2)——GC 算法与内存分配策略</a></li>
<li><a href="https://crowhawk.github.io/2017/08/15/jvm_3/" target="_blank" rel="noopener noreferrer">深入理解 JVM(3)——7 种垃圾收集器</a></li>
<li><a href="http://blog.jamesdbloom.com/JVMInternals.html" target="_blank" rel="noopener noreferrer">JVM Internals</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html#code6" target="_blank" rel="noopener noreferrer">深入探讨 Java 类加载器</a></li>
<li><a href="http://www.baeldung.com/java-weakhashmap" target="_blank" rel="noopener noreferrer">Guide to WeakHashMap in Java</a></li>
<li><a href="https://alvinalexander.com/java/jwarehouse/apache-tomcat-6.0.16/java/org/apache/el/util/ConcurrentCache.java.shtml" target="_blank" rel="noopener noreferrer">Tomcat example source code file (ConcurrentCache.java)</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>sa</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/Java%E9%AB%98%E7%BA%A7.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/Java%E9%AB%98%E7%BA%A7.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">sa</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
</ul>

<h1 id="sa" tabindex="-1"> sa</h1>
]]></content:encoded>
    </item>
    <item>
      <title>中介者模式</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">中介者模式</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="中介者-mediator" tabindex="-1"> 中介者（Mediator）</h1>
<h2 id="介绍" tabindex="-1"> 介绍</h2>
<h3 id="定义" tabindex="-1"> 定义</h3>
<p>中介者模式(Mediator Pattern)定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式</p>
<p>集中相关对象之间复杂的沟通和控制方式。</p>
<h3 id="类图" tabindex="-1"> 类图</h3>
<ul>
<li>Mediator：中介者，定义一个接口用于与各同事（Colleague）对象通信。</li>
<li>Colleague：同事，相关对象</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/30d6e95c-2e3c-4d32-bf4f-68128a70bc05.png"/> </div><br>
<h3 id="角色划分" tabindex="-1"> 角色划分</h3>
<ul>
<li>Mediator: 抽象中介者</li>
<li>ConcreteMediator: 具体中介者</li>
<li>Colleague: 抽象同事类</li>
<li>ConcreteColleague: 具体同事类</li>
</ul>
<h2 id="实现" tabindex="-1"> 实现</h2>
<p>Alarm（闹钟）、CoffeePot（咖啡壶）、Calendar（日历）、Sprinkler（喷头）是一组相关的对象，在某个对象的事件产生时需要去操作其它对象，形成了下面这种依赖结构：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/82cfda3b-b53b-4c89-9fdb-26dd2db0cd02.jpg"/> </div><br>
<p>使用中介者模式可以将复杂的依赖结构变成星形结构：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5359cbf5-5a79-4874-9b17-f23c53c2cb80.jpg"/> </div><br>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>Colleague</span> <span>{</span>
    <span>public</span> <span>abstract</span> <span>void</span> <span>onEvent</span><span>(</span><span>Mediator</span> mediator<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Alarm</span> <span>extends</span> <span>Colleague</span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>onEvent</span><span>(</span><span>Mediator</span> mediator<span>)</span> <span>{</span>
        mediator<span>.</span><span>doEvent</span><span>(</span><span>"alarm"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>doAlarm</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"doAlarm()"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>CoffeePot</span> <span>extends</span> <span>Colleague</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>onEvent</span><span>(</span><span>Mediator</span> mediator<span>)</span> <span>{</span>
        mediator<span>.</span><span>doEvent</span><span>(</span><span>"coffeePot"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>doCoffeePot</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"doCoffeePot()"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Calender</span> <span>extends</span> <span>Colleague</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>onEvent</span><span>(</span><span>Mediator</span> mediator<span>)</span> <span>{</span>
        mediator<span>.</span><span>doEvent</span><span>(</span><span>"calender"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>doCalender</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"doCalender()"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Sprinkler</span> <span>extends</span> <span>Colleague</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>onEvent</span><span>(</span><span>Mediator</span> mediator<span>)</span> <span>{</span>
        mediator<span>.</span><span>doEvent</span><span>(</span><span>"sprinkler"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>doSprinkler</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"doSprinkler()"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>Mediator</span> <span>{</span>
    <span>public</span> <span>abstract</span> <span>void</span> <span>doEvent</span><span>(</span><span>String</span> eventType<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteMediator</span> <span>extends</span> <span>Mediator</span> <span>{</span>
    <span>private</span> <span>Alarm</span> alarm<span>;</span>
    <span>private</span> <span>CoffeePot</span> coffeePot<span>;</span>
    <span>private</span> <span>Calender</span> calender<span>;</span>
    <span>private</span> <span>Sprinkler</span> sprinkler<span>;</span>

    <span>public</span> <span>ConcreteMediator</span><span>(</span><span>Alarm</span> alarm<span>,</span> <span>CoffeePot</span> coffeePot<span>,</span> <span>Calender</span> calender<span>,</span> <span>Sprinkler</span> sprinkler<span>)</span> <span>{</span>
        <span>this</span><span>.</span>alarm <span>=</span> alarm<span>;</span>
        <span>this</span><span>.</span>coffeePot <span>=</span> coffeePot<span>;</span>
        <span>this</span><span>.</span>calender <span>=</span> calender<span>;</span>
        <span>this</span><span>.</span>sprinkler <span>=</span> sprinkler<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>doEvent</span><span>(</span><span>String</span> eventType<span>)</span> <span>{</span>
        <span>switch</span> <span>(</span>eventType<span>)</span> <span>{</span>
            <span>case</span> <span>"alarm"</span><span>:</span>
                <span>doAlarmEvent</span><span>(</span><span>)</span><span>;</span>
                <span>break</span><span>;</span>
            <span>case</span> <span>"coffeePot"</span><span>:</span>
                <span>doCoffeePotEvent</span><span>(</span><span>)</span><span>;</span>
                <span>break</span><span>;</span>
            <span>case</span> <span>"calender"</span><span>:</span>
                <span>doCalenderEvent</span><span>(</span><span>)</span><span>;</span>
                <span>break</span><span>;</span>
            <span>default</span><span>:</span>
                <span>doSprinklerEvent</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>doAlarmEvent</span><span>(</span><span>)</span> <span>{</span>
        alarm<span>.</span><span>doAlarm</span><span>(</span><span>)</span><span>;</span>
        coffeePot<span>.</span><span>doCoffeePot</span><span>(</span><span>)</span><span>;</span>
        calender<span>.</span><span>doCalender</span><span>(</span><span>)</span><span>;</span>
        sprinkler<span>.</span><span>doSprinkler</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>doCoffeePotEvent</span><span>(</span><span>)</span> <span>{</span>
        <span>// ...</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>doCalenderEvent</span><span>(</span><span>)</span> <span>{</span>
        <span>// ...</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>doSprinklerEvent</span><span>(</span><span>)</span> <span>{</span>
        <span>// ...</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Alarm</span> alarm <span>=</span> <span>new</span> <span>Alarm</span><span>(</span><span>)</span><span>;</span>
        <span>CoffeePot</span> coffeePot <span>=</span> <span>new</span> <span>CoffeePot</span><span>(</span><span>)</span><span>;</span>
        <span>Calender</span> calender <span>=</span> <span>new</span> <span>Calender</span><span>(</span><span>)</span><span>;</span>
        <span>Sprinkler</span> sprinkler <span>=</span> <span>new</span> <span>Sprinkler</span><span>(</span><span>)</span><span>;</span>
        <span>Mediator</span> mediator <span>=</span> <span>new</span> <span>ConcreteMediator</span><span>(</span>alarm<span>,</span> coffeePot<span>,</span> calender<span>,</span> sprinkler<span>)</span><span>;</span>
        <span>// 闹钟事件到达，调用中介者就可以操作相关对象</span>
        alarm<span>.</span><span>onEvent</span><span>(</span>mediator<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>doAlarm</span><span>(</span><span>)</span>
<span>doCoffeePot</span><span>(</span><span>)</span>
<span>doCalender</span><span>(</span><span>)</span>
<span>doSprinkler</span><span>(</span><span>)</span>
</code></pre></div><h2 id="分析" tabindex="-1"> 分析</h2>
<p>中介者模式可以使对象之间的关系数量急剧减少。</p>
<p>中介者承担两方面的职责：</p>
<ul>
<li>中转作用（结构性）：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，通过中介者即可。该中转作用属于中介者在结构上的支持。</li>
<li>协调作用（行为性）：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。</li>
</ul>
<h3 id="优点" tabindex="-1"> 优点</h3>
<ul>
<li>简化了对象之间的交互。</li>
<li>将各同事解耦。</li>
<li>减少子类生成。</li>
<li>可以简化各同事类的设计和实现。</li>
</ul>
<h3 id="缺点" tabindex="-1"> 缺点</h3>
<ul>
<li>在具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。</li>
</ul>
<h3 id="适用环境" tabindex="-1"> 适用环境</h3>
<ul>
<li>系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解。</li>
<li>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。</li>
<li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象。</li>
<li>交互的公共行为，如果需要改变行为则可以增加新的中介者类。</li>
</ul>
<h2 id="应用" tabindex="-1"> 应用</h2>
<h3 id="开发场景" tabindex="-1"> 开发场景</h3>
<ul>
<li>
<p>MVC架构中控制器：Controller 作为一种中介者，它负责控制视图对象View和模型对象Model之间的交互。如在Struts中，Action就可以作为JSP页面与业务对象之间的中介者。</p>
</li>
<li>
<p>GUI开发</p>
<ul>
<li>中介者模式可以方便地应用于图形界面(GUI)开发中，在比较复杂的界面中可能存在多个界面组件之间的交互关系。</li>
<li>对于这些复杂的交互关系，有时候我们可以引入一个中介者类，将这些交互的组件作为具体的同事类，将它们之间的引用和控制关系交由中介者负责，在一定程度上简化系统的交互，这也是中介者模式的常见应用之一。</li>
</ul>
</li>
</ul>
<h3 id="模式扩展" tabindex="-1"> 模式扩展</h3>
<p><strong>中介者模式与迪米特法则</strong></p>
<p>在中介者模式中，通过创造出一个中介者对象，将系统中有关的对象所引用的其他对象数目减少到最少，使得一个对象与其同事之间的相互作用被这个对象与中介者对象之间的相互作用所取代。因此，中介者模式就是迪米特法则的一个典型应用。</p>
<h3 id="jdk" tabindex="-1"> JDK</h3>
<ul>
<li>All scheduleXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Timer.html" target="_blank" rel="noopener noreferrer">java.util.Timer</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html#execute-java.lang.Runnable-" target="_blank" rel="noopener noreferrer">java.util.concurrent.Executor#execute()</a></li>
<li>submit() and invokeXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html" target="_blank" rel="noopener noreferrer">java.util.concurrent.ExecutorService</a></li>
<li>scheduleXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html" target="_blank" rel="noopener noreferrer">java.util.concurrent.ScheduledExecutorService</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-" target="_blank" rel="noopener noreferrer">java.lang.reflect.Method#invoke()</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>享元模式</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">享元模式</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
</ul>
</li>
</ul>

<h1 id="享元-flyweight" tabindex="-1"> 享元（Flyweight）</h1>
<h2 id="介绍" tabindex="-1"> 介绍</h2>
<h3 id="定义" tabindex="-1"> 定义</h3>
<p>享元模式（Flyweight Pattern），又称轻量级模式（这也是其英文名为FlyWeight的原因），通过共享技术有效地实现了大量细粒度对象的复用。</p>
<p>利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。</p>
<h3 id="类图" tabindex="-1"> 类图</h3>
<ul>
<li>Flyweight：享元对象</li>
<li>IntrinsicState：内部状态，享元对象共享内部状态</li>
<li>ExtrinsicState：外部状态，每个享元对象的外部状态不同</li>
</ul>
<p><strong>内部状态</strong> vs <strong>外部状态</strong></p>
<ul>
<li>内部状态是存储在享元对象内部，一般在构造时确定或通过setter设置，并且不会随环境改变而改变的状态，因此内部状态可以共享。</li>
<li>外部状态是随环境改变而改变、不可以共享的状态。外部状态在需要使用时通过客户端传入享元对象。外部状态必须由客户端保存。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5f5c22d5-9c0e-49e1-b5b0-6cc7032724d4.png"/> </div><br>
<h3 id="角色划分" tabindex="-1"> 角色划分</h3>
<ul>
<li>FlyWeight 享元接口或者（抽象享元类），定义共享接口</li>
<li>ConcreteFlyWeight 具体享元类，该类实例将实现共享</li>
<li>FlyWeightFactory 享元工厂类，控制实例的创建和共享</li>
</ul>
<h2 id="实现" tabindex="-1"> 实现</h2>
<div><pre><code><span>public</span> <span>interface</span> <span>Flyweight</span> <span>{</span>
    <span>void</span> <span>doOperation</span><span>(</span><span>String</span> extrinsicState<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteFlyweight</span> <span>implements</span> <span>Flyweight</span> <span>{</span>

    <span>private</span> <span>String</span> intrinsicState<span>;</span>

    <span>public</span> <span>ConcreteFlyweight</span><span>(</span><span>String</span> intrinsicState<span>)</span> <span>{</span>
        <span>this</span><span>.</span>intrinsicState <span>=</span> intrinsicState<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>doOperation</span><span>(</span><span>String</span> extrinsicState<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Object address: "</span> <span>+</span> <span>System</span><span>.</span><span>identityHashCode</span><span>(</span><span>this</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"IntrinsicState: "</span> <span>+</span> intrinsicState<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ExtrinsicState: "</span> <span>+</span> extrinsicState<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>FlyweightFactory</span> <span>{</span>

    <span>private</span> <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Flyweight</span><span>></span></span> flyweights <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

    <span>Flyweight</span> <span>getFlyweight</span><span>(</span><span>String</span> intrinsicState<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span>flyweights<span>.</span><span>containsKey</span><span>(</span>intrinsicState<span>)</span><span>)</span> <span>{</span>
            <span>Flyweight</span> flyweight <span>=</span> <span>new</span> <span>ConcreteFlyweight</span><span>(</span>intrinsicState<span>)</span><span>;</span>
            flyweights<span>.</span><span>put</span><span>(</span>intrinsicState<span>,</span> flyweight<span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> flyweights<span>.</span><span>get</span><span>(</span>intrinsicState<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>FlyweightFactory</span> factory <span>=</span> <span>new</span> <span>FlyweightFactory</span><span>(</span><span>)</span><span>;</span>
        <span>Flyweight</span> flyweight1 <span>=</span> factory<span>.</span><span>getFlyweight</span><span>(</span><span>"aa"</span><span>)</span><span>;</span>
        <span>Flyweight</span> flyweight2 <span>=</span> factory<span>.</span><span>getFlyweight</span><span>(</span><span>"aa"</span><span>)</span><span>;</span>
        flyweight1<span>.</span><span>doOperation</span><span>(</span><span>"x"</span><span>)</span><span>;</span>
        flyweight2<span>.</span><span>doOperation</span><span>(</span><span>"y"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code>Object address: 1163157884
IntrinsicState: aa
ExtrinsicState: x
Object address: 1163157884
IntrinsicState: aa
ExtrinsicState: y
</code></pre></div><h2 id="分析" tabindex="-1"> 分析</h2>
<h3 id="优点" tabindex="-1"> 优点</h3>
<ul>
<li>享元模式的外部状态相对独立，使得对象可以在不同的环境中被复用（共享对象可以适应不同的外部环境）</li>
<li>享元模式可共享相同或相似的细粒度对象，从而减少了内存消耗，同时降低了对象创建与垃圾回收的开销</li>
</ul>
<h3 id="缺点" tabindex="-1"> 缺点</h3>
<ul>
<li>外部状态由客户端保存，共享对象读取外部状态的开销可能比较大</li>
<li>享元模式要求将内部状态与外部状态分离，这使得程序的逻辑复杂化，同时也增加了状态维护成本</li>
</ul>
<h2 id="oop原则" tabindex="-1"> OOP原则</h2>
<p><strong>已遵循的OOP原则</strong></p>
<ul>
<li>依赖倒置原则</li>
<li>迪米特法则</li>
<li>里氏替换原则</li>
<li>接口隔离原则</li>
<li>单一职责原则</li>
<li>开闭原则</li>
</ul>
<p><strong>未遵循的OOP原则</strong></p>
<ul>
<li>NA</li>
</ul>
<h2 id="应用" tabindex="-1"> 应用</h2>
<p>Java 利用缓存来加速大量小对象的访问时间。</p>
<p><strong>JDK</strong></p>
<ul>
<li>java.lang.Integer#valueOf(int)</li>
<li>java.lang.Boolean#valueOf(boolean)</li>
<li>java.lang.Byte#valueOf(byte)</li>
<li>java.lang.Character#valueOf(char)</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>代理模式</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">代理模式</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="代理-proxy" tabindex="-1"> 代理（Proxy）</h1>
<h2 id="介绍" tabindex="-1"> 介绍</h2>
<h3 id="定义" tabindex="-1"> 定义</h3>
<p>控制对其它对象的访问。</p>
<h3 id="类图" tabindex="-1"> 类图</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9b679ff5-94c6-48a7-b9b7-2ea868e828ed.png"/> </div><br>
<p>代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类</p>
<h3 id="角色划分" tabindex="-1"> 角色划分</h3>
<ul>
<li>Subject（抽象主题角色）：声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。</li>
<li>Proxy（代理主题角色）：包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。</li>
<li>RealSubject（真实主题角色）：定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。</li>
</ul>
<h2 id="实现" tabindex="-1"> 实现</h2>
<h3 id="静态代理" tabindex="-1"> 静态代理</h3>
<p>静态代理的实现模式一般是：首先创建一个接口（JDK代理都是面向接口的），然后创建具体实现类来实现这个接口，然后再创建一个代理类同样实现这个接口，不同之处在于，具体实现类的方法中需要将接口中定义的方法的业务逻辑功能实现，而代理类中的方法只要调用具体类中的对应方法即可，这样我们在需要使用接口中的某个方法的功能时直接调用代理类的方法即可，将具体的实现类隐藏在底层。</p>
<p>以下是一个虚拟代理的实现，模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。</p>
<div><pre><code><span>public</span> <span>interface</span> <span>Image</span> <span>{</span>
    <span>void</span> <span>showImage</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>HighResolutionImage</span> <span>implements</span> <span>Image</span> <span>{</span>

    <span>private</span> <span>URL</span> imageURL<span>;</span>
    <span>private</span> <span>long</span> startTime<span>;</span>
    <span>private</span> <span>int</span> height<span>;</span>
    <span>private</span> <span>int</span> width<span>;</span>

    <span>public</span> <span>int</span> <span>getHeight</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> height<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getWidth</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> width<span>;</span>
    <span>}</span>

    <span>public</span> <span>HighResolutionImage</span><span>(</span><span>URL</span> imageURL<span>)</span> <span>{</span>
        <span>this</span><span>.</span>imageURL <span>=</span> imageURL<span>;</span>
        <span>this</span><span>.</span>startTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>width <span>=</span> <span>600</span><span>;</span>
        <span>this</span><span>.</span>height <span>=</span> <span>600</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>boolean</span> <span>isLoad</span><span>(</span><span>)</span> <span>{</span>
        <span>// 模拟图片加载，延迟 3s 加载完成</span>
        <span>long</span> endTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
        <span>return</span> endTime <span>-</span> startTime <span>></span> <span>3000</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>showImage</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Real Image: "</span> <span>+</span> imageURL<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>ImageProxy</span> <span>implements</span> <span>Image</span> <span>{</span>

    <span>private</span> <span>HighResolutionImage</span> highResolutionImage<span>;</span>

    <span>public</span> <span>ImageProxy</span><span>(</span><span>HighResolutionImage</span> highResolutionImage<span>)</span> <span>{</span>
        <span>this</span><span>.</span>highResolutionImage <span>=</span> highResolutionImage<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>showImage</span><span>(</span><span>)</span> <span>{</span>
        <span>while</span> <span>(</span><span>!</span>highResolutionImage<span>.</span><span>isLoad</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>try</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Temp Image: "</span> <span>+</span> highResolutionImage<span>.</span><span>getWidth</span><span>(</span><span>)</span> <span>+</span> <span>" "</span> <span>+</span> highResolutionImage<span>.</span><span>getHeight</span><span>(</span><span>)</span><span>)</span><span>;</span>
                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>100</span><span>)</span><span>;</span>
            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        highResolutionImage<span>.</span><span>showImage</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>ImageViewer</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>String</span> image <span>=</span> <span>"http://image.jpg"</span><span>;</span>
        <span>URL</span> url <span>=</span> <span>new</span> <span>URL</span><span>(</span>image<span>)</span><span>;</span>
        <span>HighResolutionImage</span> highResolutionImage <span>=</span> <span>new</span> <span>HighResolutionImage</span><span>(</span>url<span>)</span><span>;</span>
        <span>ImageProxy</span> imageProxy <span>=</span> <span>new</span> <span>ImageProxy</span><span>(</span>highResolutionImage<span>)</span><span>;</span>
        imageProxy<span>.</span><span>showImage</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="动态代理" tabindex="-1"> 动态代理</h3>
<p>动态代理是指在运行时动态生成代理类。即，代理类的字节码将在运行时生成并载入当前代理的 ClassLoader。</p>
<p>与静态处理类相比，动态类有诸多好处。首先，不需要为真实主题写一个形式上完全一样的封装类，假如主题接口中的方法很多，为每一个接口写一个代理方法也很麻烦。如果接口有变动，则真实主题和代理类都要修改，不利于系统维护；其次，使用一些动态代理的生成方法甚至可以在运行时制定代理类的执行逻辑，从而大大提升系统的灵活性。</p>
<p>动态代理类使用字节码动态生成加载技术，在运行时生成加载类。生成动态代理类的方法很多，如，JDK 自带的动态处理、CGLIB、Javassist 或者 ASM 库。</p>
<ul>
<li>JDK 的动态代理使用简单，它内置在 JDK 中，因此不需要引入第三方 Jar 包，但相对功能比较弱。
<ul>
<li>java.lang.reflect.Proxy 作用：动态生成代理类和对象</li>
<li>java.lang.reflect.InvocationHandler(处理器接口)
<ul>
<li>可以通过invoke方法实现对真实角色的代理访问。</li>
<li>每次通过Proxy生成代理类对象对象时都要指定对应的处理器对象</li>
</ul>
</li>
</ul>
</li>
<li>CGLIB 和 Javassist 都是高级的字节码生成库，总体性能比 JDK 自带的动态代理好，而且功能十分强大。</li>
<li>ASM 是低级的字节码生成工具，使用 ASM 已经近乎于在使用 Java bytecode 编程，对开发人员要求最高，当然，也是性能最好的一种动态代理生成工具。但 ASM 的使用很繁琐，而且性能也没有数量级的提升，与 CGLIB 等高级字节码生成工具相比，ASM 程序的维护性较差，如果不是在对性能有苛刻要求的场合，还是推荐 CGLIB 或者 Javassist。</li>
</ul>
<p><a href="http://www.jasongj.com/design_pattern/dynamic_proxy_cglib/" target="_blank" rel="noopener noreferrer">JDK动态代理 vs CGlib</a></p>
<p>JDK动态代理与cglib对比</p>
<ul>
<li>字节码创建方式：JDK动态代理通过JVM实现代理类字节码的创建，cglib通过ASM创建字节码</li>
<li>对被代理对象的要求：JDK动态代理要求被代理对象实现接口，cglib要求被代理对象未被final修饰，通过继承被代理类实现</li>
</ul>
<p>两者性能对比(教科书描述)</p>
<ul>
<li>CGLib所创建的动态代理对象在实际运行时候的性能要比JDK动态代理高不少，有研究表明，大概要高10倍；</li>
<li>但是CGLib在创建对象的时候所花费的时间却比JDK动态代理要多很多，有研究表明，大概有8倍的差距；</li>
<li>因此，对于singleton的代理对象或者具有实例池的代理，因为无需频繁的创建代理对象，所以比较适合采用CGLib动态代理，反正，则比较适用JDK动态代理。</li>
</ul>
<p>经测试后<a href="https://blog.csdn.net/xlgen157387/article/details/82497594" target="_blank" rel="noopener noreferrer">效率对比</a></p>
<p>在1.6和1.7的时候，JDK动态代理的创建对象的运行速度要比CGLib动态代理的速度要慢，但是并没有教科书上的10倍差距，在JDK1.8的时候，JDK动态代理的速度已经比CGLib动态代理的速度快很多</p>
<h2 id="分析" tabindex="-1"> 分析</h2>
<h3 id="与装饰模式对比" tabindex="-1"> 与装饰模式对比</h3>
<ul>
<li>从语意上讲，代理模式是为控制对被代理对象的访问，而装饰模式是为了增加被装饰对象的功能</li>
<li>代理类所能代理的类完全由代理类确定，装饰类装饰的对象需要根据实际使用时客户端的组合来确定</li>
<li>被代理对象由代理对象创建，客户端甚至不需要知道被代理类的存在；被装饰对象由客户端创建并传给装饰对象</li>
<li>装饰模式的本质是动态组合。动态是手段，组合是目的。每个装饰类可以只负责添加一项额外功能，然后通过组合为被装饰类添加复杂功能。由于每个装饰类的职责比较简单单一，增加了这些装饰类的可重用性，同时也更符合单一职责原则。</li>
</ul>
<h2 id="应用" tabindex="-1"> 应用</h2>
<h3 id="应用场合" tabindex="-1"> 应用场合</h3>
<ul>
<li>远程代理（Remote Proxy）：控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。</li>
<li>虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。</li>
<li>保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。</li>
<li>智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。</li>
<li>缓冲代理（Cache Proxy）：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li>
<li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象。</li>
</ul>
<h3 id="开发场景" tabindex="-1"> 开发场景</h3>
<ul>
<li>struts2中拦截器的实现</li>
<li>数据库连接池关闭处理</li>
<li>Hibernate中延时加载的实现</li>
<li>mybatis中实现拦截器插件</li>
<li>AspectJ的实现</li>
<li>spring中AOP的实现：默认使用Java动态代理来创建AOP代理</li>
<li>日志拦截</li>
<li>声明式事务处理</li>
<li>web service</li>
<li>RMI远程方法调用</li>
</ul>
<h3 id="jdk" tabindex="-1"> JDK</h3>
<ul>
<li>java.lang.reflect.Proxy</li>
<li>RMI</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>单例模式</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">单例模式</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="单例-singleton" tabindex="-1"> 单例（Singleton）</h1>
<h2 id="介绍" tabindex="-1"> 介绍</h2>
<h3 id="定义" tabindex="-1"> 定义</h3>
<p>确保一个类只有一个实例，并提供该实例的全局访问点。</p>
<h3 id="类图" tabindex="-1"> 类图</h3>
<p>使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。</p>
<p>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eca1f422-8381-409b-ad04-98ef39ae38ba.png"/> </div><br>
<h2 id="实现" tabindex="-1"> 实现</h2>
<p>通常单例模式在Java语言中，有两种构建方式：</p>
<ul>
<li>饿汉方式：指全局的单例实例在类装载时构建</li>
<li>懒汉方式：指全局的单例实例在第一次被使用时构建</li>
</ul>
<p>不管是那种创建方式，它们通常都存在下面几点相似处：</p>
<ul>
<li>单例类必须要有一个 private 访问级别的构造函数，只有这样，才能确保单例不会在系统中的其他代码内被实例化;</li>
<li>instance 成员变量和 uniqueInstance 方法必须是 static 的。</li>
</ul>
<h3 id="i-懒汉式-线程不安全" tabindex="-1"> Ⅰ 懒汉式-线程不安全</h3>
<p>以下实现中，私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。</p>
<p>这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 <code>if (uniqueInstance == null)</code> ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 <code>uniqueInstance = new Singleton();</code> 语句，这将导致实例化多次 uniqueInstance。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>

    <span>private</span> <span>static</span> <span>Singleton</span> uniqueInstance<span>;</span>

    <span>private</span> <span>Singleton</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>Singleton</span> <span>getUniqueInstance</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>uniqueInstance <span>==</span> <span>null</span><span>)</span> <span>{</span>
            uniqueInstance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> uniqueInstance<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="ii-懒汉式-线程安全" tabindex="-1"> Ⅱ 懒汉式-线程安全</h3>
<p>只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次 uniqueInstance。</p>
<p>但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。</p>
<div><pre><code><span>public</span> <span>static</span> <span>synchronized</span> <span>Singleton</span> <span>getUniqueInstance</span><span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>uniqueInstance <span>==</span> <span>null</span><span>)</span> <span>{</span>
        uniqueInstance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> uniqueInstance<span>;</span>
<span>}</span>
</code></pre></div><h3 id="iii-饿汉式-线程安全" tabindex="-1"> Ⅲ 饿汉式-线程安全</h3>
<p>线程不安全问题主要是由于 uniqueInstance 被实例化多次，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。</p>
<p>但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。</p>
<div><pre><code><span>private</span> <span>static</span> <span>Singleton</span> uniqueInstance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>
</code></pre></div><h3 id="iv-懒汉式-双重校验锁-线程安全" tabindex="-1"> Ⅳ 懒汉式-双重校验锁-线程安全</h3>
<p>uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。</p>
<p>双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>

    <span>private</span> <span>volatile</span> <span>static</span> <span>Singleton</span> uniqueInstance<span>;</span>

    <span>private</span> <span>Singleton</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>Singleton</span> <span>getUniqueInstance</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>uniqueInstance <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>synchronized</span> <span>(</span><span>Singleton</span><span>.</span><span>class</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span>uniqueInstance <span>==</span> <span>null</span><span>)</span> <span>{</span>
                    uniqueInstance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> uniqueInstance<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>考虑下面的实现，也就是只使用了一个 if 语句。在 uniqueInstance == null 的情况下，如果两个线程都执行了 if 语句，那么两个线程都会进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 <code>uniqueInstance = new Singleton();</code> 这条语句，只是先后的问题，那么就会进行两次实例化。因此必须使用双重校验锁，也就是需要使用两个 if 语句：第一个 if 语句用来避免 uniqueInstance 已经被实例化之后的加锁操作，而第二个 if 语句进行了加锁，所以只能有一个线程进入，就不会出现 uniqueInstance == null 时两个线程同时进行实例化操作。</p>
<div><pre><code><span>if</span> <span>(</span>uniqueInstance <span>==</span> <span>null</span><span>)</span> <span>{</span>
    <span>synchronized</span> <span>(</span><span>Singleton</span><span>.</span><span>class</span><span>)</span> <span>{</span>
        uniqueInstance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p>
<ol>
<li>为 uniqueInstance 分配内存空间</li>
<li>初始化 uniqueInstance</li>
<li>将 uniqueInstance 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T<sub>1</sub> 执行了 1 和 3，此时 T<sub>2</sub> 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p>
<p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<h3 id="v-懒汉式-静态内部类实现" tabindex="-1"> Ⅴ 懒汉式-静态内部类实现</h3>
<p>当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 <code>getUniqueInstance()</code> 方法从而触发 <code>SingletonHolder.INSTANCE</code> 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。</p>
<p>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>

    <span>private</span> <span>Singleton</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>

    <span>private</span> <span>static</span> <span>class</span> <span>SingletonHolder</span> <span>{</span>
        <span>private</span> <span>static</span> <span>final</span> <span>Singleton</span> INSTANCE <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>Singleton</span> <span>getUniqueInstance</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>SingletonHolder</span><span>.</span>INSTANCE<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="vi-饿汉式-枚举实现" tabindex="-1"> Ⅵ 饿汉式-枚举实现</h3>
<div><pre><code><span>public</span> <span>enum</span> <span>Singleton</span> <span>{</span>

    INSTANCE<span>;</span>

    <span>private</span> <span>String</span> objName<span>;</span>


    <span>public</span> <span>String</span> <span>getObjName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> objName<span>;</span>
    <span>}</span>


    <span>public</span> <span>void</span> <span>setObjName</span><span>(</span><span>String</span> objName<span>)</span> <span>{</span>
        <span>this</span><span>.</span>objName <span>=</span> objName<span>;</span>
    <span>}</span>


    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>

        <span>// 单例测试</span>
        <span>Singleton</span> firstSingleton <span>=</span> <span>Singleton</span><span>.</span>INSTANCE<span>;</span>
        firstSingleton<span>.</span><span>setObjName</span><span>(</span><span>"firstName"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>firstSingleton<span>.</span><span>getObjName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>Singleton</span> secondSingleton <span>=</span> <span>Singleton</span><span>.</span>INSTANCE<span>;</span>
        secondSingleton<span>.</span><span>setObjName</span><span>(</span><span>"secondName"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>firstSingleton<span>.</span><span>getObjName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>secondSingleton<span>.</span><span>getObjName</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>// 反射获取实例测试</span>
        <span>try</span> <span>{</span>
            <span>Singleton</span><span>[</span><span>]</span> enumConstants <span>=</span> <span>Singleton</span><span>.</span><span>class</span><span>.</span><span>getEnumConstants</span><span>(</span><span>)</span><span>;</span>
            <span>for</span> <span>(</span><span>Singleton</span> enumConstant <span>:</span> enumConstants<span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>enumConstant<span>.</span><span>getObjName</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><div><pre><code>firstName
secondName
secondName
secondName
</code></pre></div><p>该实现可以防止反射攻击。在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。</p>
<p>该实现在多次序列化和序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。</p>
<blockquote>
<p>**《Java与模式》**中:使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式</p>
</blockquote>
<h2 id="分析" tabindex="-1"> 分析</h2>
<h3 id="优点" tabindex="-1"> 优点</h3>
<ul>
<li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li>
<li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li>
</ul>
<h3 id="特点" tabindex="-1"> 特点</h3>
<ul>
<li>单例类只有一个实例对象；</li>
<li>该单例对象必须由单例类自行创建；</li>
<li>单例类对外提供一个访问该单例的全局访问点；</li>
</ul>
<h3 id="适用场景" tabindex="-1"> 适用场景</h3>
<ul>
<li>在应用场景中，某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。</li>
<li>当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</li>
<li>当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。</li>
</ul>
<h2 id="应用" tabindex="-1"> 应用</h2>
<h3 id="开发场景" tabindex="-1"> 开发场景</h3>
<ul>
<li>Windows的Task Manager（任务管理器）就是很典型的单例模式</li>
<li>windows的Recycle Bin（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。</li>
<li>项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，每次new一个对象去读取。</li>
<li>网站的计数器，一般也是采用单例模式实现，否则难以同步。</li>
<li>应用程序的日志应用，一般都用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作 ，否则内容不好追加。</li>
<li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。</li>
<li>操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。</li>
<li>Application 也是单例的典型应用（Servlet编程中会涉及到）</li>
<li>在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理</li>
<li>在servlet编程中，每个Servlet也是单例</li>
<li>在spring MVC框架/struts1框架中，控制器对象也是单例</li>
</ul>
<h3 id="jdk" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#getRuntime%28%29" target="_blank" rel="noopener noreferrer">java.lang.Runtime#getRuntime()</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/awt/Desktop.html#getDesktop--" target="_blank" rel="noopener noreferrer">java.awt.Desktop#getDesktop()</a></li>
<li>[java.lang.System#getSecurityManager()](</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>原型模式</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">原型模式</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="原型模式-prototype" tabindex="-1"> 原型模式（Prototype）</h1>
<h2 id="介绍" tabindex="-1"> 介绍</h2>
<h3 id="定义" tabindex="-1"> 定义</h3>
<p>使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。</p>
<h3 id="类图" tabindex="-1"> 类图</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b8922f8c-95e6-4187-be85-572a509afb71.png"/> </div><br>
<h3 id="角色划分" tabindex="-1"> 角色划分</h3>
<ul>
<li>Prototype（抽象原型类）:负责定义用于复制现有实例来生成新实例的方法。</li>
<li>ConcretePrototype（具体原型类）:负责实现复制现有实例并生成新实例的方法。</li>
<li>Client（客户类/使用者）:负责使用复制实例的方法生成新的实例。</li>
</ul>
<h2 id="实现" tabindex="-1"> 实现</h2>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>Prototype</span> <span>{</span>
    <span>abstract</span> <span>Prototype</span> <span>myClone</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcretePrototype</span> <span>extends</span> <span>Prototype</span> <span>{</span>

    <span>private</span> <span>String</span> filed<span>;</span>

    <span>public</span> <span>ConcretePrototype</span><span>(</span><span>String</span> filed<span>)</span> <span>{</span>
        <span>this</span><span>.</span>filed <span>=</span> filed<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>Prototype</span> <span>myClone</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ConcretePrototype</span><span>(</span>filed<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> filed<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Prototype</span> prototype <span>=</span> <span>new</span> <span>ConcretePrototype</span><span>(</span><span>"abc"</span><span>)</span><span>;</span>
        <span>Prototype</span> clone <span>=</span> prototype<span>.</span><span>myClone</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>clone<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code>abc
</code></pre></div><h2 id="分析" tabindex="-1"> 分析</h2>
<h3 id="优点" tabindex="-1"> 优点</h3>
<ul>
<li>当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过一个已有实例可以提高新实例的创建效率。</li>
<li>可以动态增加或减少产品类。</li>
<li>原型模式提供了简化的创建结构。</li>
<li>可以使用深克隆的方式保存对象的状态。</li>
</ul>
<h3 id="缺点" tabindex="-1"> 缺点</h3>
<ul>
<li>需要为每一个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码，违背了“开闭原则”。</li>
<li>在实现深克隆时需要编写较为复杂的代码。</li>
</ul>
<h3 id="适用场景" tabindex="-1"> 适用场景</h3>
<p>现在一般会使用new关键字指定类名生成类的实例（PS：以前使用java.lang.Cloneable的一个很大原因是使用new创建对象的速度相对来说会慢一些，随着JVM性能的提升，new的速度和Object的clone（）方法的速度差不多了。）。</p>
<ul>
<li>通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式</li>
<li>克隆类似于new，但是不同于new。new创建新的对象属性采用的是默认值。克隆出的对象的属性值完全和原型对象相同。</li>
</ul>
<p>使用new关键字创建类的时候必须指定类名，但是在开发过程中也会有“在不指定类名的前提下生成实例”的需求。例如，在下面这些情况下，就需要根据现有的实例来生成新的实例</p>
<ul>
<li>对象种类繁多，无法将他们整合到一个类的时候；</li>
<li>难以根据类生成实例时；</li>
<li>想解耦框架与生成的实例时。</li>
</ul>
<p>如果想要让生成实例的框架不再依赖于具体的类，这时，不能指定类名来生成实例，而要事先“注册”一个“原型”实例，然后通过复制该实例来生成新的实例。</p>
<p>能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持复制。</p>
<p><strong>注意</strong>： <code>java.lang.Cloneable</code> 只是起到告诉程序可以调用<strong>clone</strong>方法的作用，它本身并没有定义任何方法。</p>
<h2 id="应用" tabindex="-1"> 应用</h2>
<h3 id="开发场景" tabindex="-1"> 开发场景</h3>
<ul>
<li>原型模式应用于很多软件中，如果每次创建一个对象要花大量时间，原型模式是最好的解决方案。很多软件提供的复制(Ctrl + C)和粘贴(Ctrl + V)操作就是原型模式的应用，复制得到的对象与原型对象是两个类型相同但内存地址不同的对象，通过原型模式可以大大提高对象的创建效率</li>
<li>在Struts2中为了保证线程的安全性，Action对象的创建使用了原型模式，访问一个已经存在的`Action对象时将通过克隆的方式创建出一个新的对象，从而保证其中定义的变量无须进行加锁实现同步，每一个Action中都有自己的成员变量，避免Struts1因使用单例模式而导致的并发和同步问题。</li>
<li>在Spring中，用户也可以采用原型模式来创建新的bean实例，从而实现每次获取的是通过克隆生成的新实例，对其进行修改时对原有实例对象不造成任何影响。
<ul>
<li>原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者。 spring中bean的创建实际就是两种：单例模式和原型模式。（当然，原型模式需要和工厂模式搭配起来）</li>
</ul>
</li>
</ul>
<h3 id="jdk" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone%28%29" target="_blank" rel="noopener noreferrer">java.lang.Object#clone()</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>命令模式</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">命令模式</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="命令-command" tabindex="-1"> 命令（Command）</h1>
<h2 id="介绍" tabindex="-1"> 介绍</h2>
<h3 id="定义" tabindex="-1"> 定义</h3>
<p><strong>模式动机</strong><br>
命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。</p>
<p>命令模式(Command Pattern)：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。别名为动作(Action)模式或事务(Transaction)模式</p>
<p>将命令封装成对象中，具有以下作用：</p>
<ul>
<li>使用命令来参数化其它对象</li>
<li>将命令放入队列中进行排队</li>
<li>将命令的操作记录到日志中</li>
<li>支持可撤销的操作</li>
</ul>
<h3 id="类图" tabindex="-1"> 类图</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c44a0342-f405-4f17-b750-e27cf4aadde2.png"/> </div><br>
<h3 id="角色划分" tabindex="-1"> 角色划分</h3>
<ul>
<li>Command：抽象命令类</li>
<li>ConcreteCommand: 具体命令类</li>
<li>Receiver：命令接收者，也就是命令真正的执行者</li>
<li>Invoker：通过它来调用命令</li>
<li>Client：可以设置命令与命令的接收者</li>
</ul>
<h2 id="实现" tabindex="-1"> 实现</h2>
<p>设计一个遥控器，可以控制电灯开关。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e6bded8e-41a0-489a-88a6-638e88ab7666.jpg"/> </div><br>
<p>抽象命令</p>
<div><pre><code><span>public</span> <span>interface</span> <span>Command</span> <span>{</span>
    <span>void</span> <span>execute</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><p>具体命令</p>
<div><pre><code><span>public</span> <span>class</span> <span>LightOnCommand</span> <span>implements</span> <span>Command</span> <span>{</span>
    <span>Light</span> light<span>;</span>

    <span>public</span> <span>LightOnCommand</span><span>(</span><span>Light</span> light<span>)</span> <span>{</span>
        <span>this</span><span>.</span>light <span>=</span> light<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>execute</span><span>(</span><span>)</span> <span>{</span>
        light<span>.</span><span>on</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>LightOffCommand</span> <span>implements</span> <span>Command</span> <span>{</span>
    <span>Light</span> light<span>;</span>

    <span>public</span> <span>LightOffCommand</span><span>(</span><span>Light</span> light<span>)</span> <span>{</span>
        <span>this</span><span>.</span>light <span>=</span> light<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>execute</span><span>(</span><span>)</span> <span>{</span>
        light<span>.</span><span>off</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>命令接收者</p>
<div><pre><code><span>public</span> <span>class</span> <span>Light</span> <span>{</span>

    <span>public</span> <span>void</span> <span>on</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Light is on!"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>off</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Light is off!"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>命令调用者</p>
<div><pre><code><span>/**
 * 遥控器
 */</span>
<span>public</span> <span>class</span> <span>Invoker</span> <span>{</span>
    <span>private</span> <span>Command</span><span>[</span><span>]</span> onCommands<span>;</span>
    <span>private</span> <span>Command</span><span>[</span><span>]</span> offCommands<span>;</span>
    <span>private</span> <span>final</span> <span>int</span> slotNum <span>=</span> <span>7</span><span>;</span>

    <span>public</span> <span>Invoker</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>onCommands <span>=</span> <span>new</span> <span>Command</span><span>[</span>slotNum<span>]</span><span>;</span>
        <span>this</span><span>.</span>offCommands <span>=</span> <span>new</span> <span>Command</span><span>[</span>slotNum<span>]</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setOnCommand</span><span>(</span><span>Command</span> command<span>,</span> <span>int</span> slot<span>)</span> <span>{</span>
        onCommands<span>[</span>slot<span>]</span> <span>=</span> command<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setOffCommand</span><span>(</span><span>Command</span> command<span>,</span> <span>int</span> slot<span>)</span> <span>{</span>
        offCommands<span>[</span>slot<span>]</span> <span>=</span> command<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>onButtonWasPushed</span><span>(</span><span>int</span> slot<span>)</span> <span>{</span>
        onCommands<span>[</span>slot<span>]</span><span>.</span><span>execute</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>offButtonWasPushed</span><span>(</span><span>int</span> slot<span>)</span> <span>{</span>
        offCommands<span>[</span>slot<span>]</span><span>.</span><span>execute</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Invoker</span> invoker <span>=</span> <span>new</span> <span>Invoker</span><span>(</span><span>)</span><span>;</span>
        <span>Light</span> light <span>=</span> <span>new</span> <span>Light</span><span>(</span><span>)</span><span>;</span>
        <span>Command</span> lightOnCommand <span>=</span> <span>new</span> <span>LightOnCommand</span><span>(</span>light<span>)</span><span>;</span>
        <span>Command</span> lightOffCommand <span>=</span> <span>new</span> <span>LightOffCommand</span><span>(</span>light<span>)</span><span>;</span>
        invoker<span>.</span><span>setOnCommand</span><span>(</span>lightOnCommand<span>,</span> <span>0</span><span>)</span><span>;</span>
        invoker<span>.</span><span>setOffCommand</span><span>(</span>lightOffCommand<span>,</span> <span>0</span><span>)</span><span>;</span>
        invoker<span>.</span><span>onButtonWasPushed</span><span>(</span><span>0</span><span>)</span><span>;</span>
        invoker<span>.</span><span>offButtonWasPushed</span><span>(</span><span>0</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="分析" tabindex="-1"> 分析</h2>
<p>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。</p>
<ul>
<li>每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。</li>
<li>命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li>
<li>命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li>
<li>命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。</li>
</ul>
<h3 id="优点" tabindex="-1"> 优点</h3>
<ul>
<li>降低系统的耦合度。</li>
<li>新的命令可以很容易地加入到系统中。</li>
<li>可以比较容易地设计一个命令队列和宏命令（组合命令）。</li>
<li>可以方便地实现对请求的Undo和Redo。</li>
</ul>
<h3 id="缺点" tabindex="-1"> 缺点</h3>
<ul>
<li>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。</li>
</ul>
<h2 id="应用" tabindex="-1"> 应用</h2>
<h3 id="开发场景" tabindex="-1"> 开发场景</h3>
<ul>
<li>Struts2中，action的整个调用过程中就有命令模式。</li>
<li>数据库事务机制的底层实现</li>
<li>命令的撤销和恢复</li>
<li>很多系统都提供了宏命令功能，如UNIX平台下的Shell编程，可以将多条命令封装在一个命令对象中，只需要一条简单的命令即可执行一个命令序列，这也是命令模式的应用实例之一</li>
</ul>
<h3 id="模式扩展" tabindex="-1"> 模式扩展</h3>
<p>宏命令又称为组合命令，它是命令模式和组合模式联用的产物。</p>
<ul>
<li>宏命令也是一个具体命令，不过它包含了对其他命令对象的引用，在调用宏命令的execute()方法时，将递归调用它所包含的每个成员命令的execute()方法，一个宏命令的成员对象可以是简单命令，还可以继续是宏命令。执行一个宏命令将执行多个具体命令，从而实现对命令的批处理。</li>
</ul>
<h3 id="jdk" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html" target="_blank" rel="noopener noreferrer">java.lang.Runnable</a></li>
<li><a href="https://github.com/Netflix/Hystrix/wiki" target="_blank" rel="noopener noreferrer">Netflix Hystrix</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/swing/Action.html" target="_blank" rel="noopener noreferrer">javax.swing.Action</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>备忘录模式</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">备忘录模式</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="备忘录-memento" tabindex="-1"> 备忘录（Memento）</h1>
<h2 id="介绍" tabindex="-1"> 介绍</h2>
<h3 id="定义" tabindex="-1"> 定义</h3>
<p>在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。</p>
<p>备忘录（Memento）模式的定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。</p>
<h3 id="类图" tabindex="-1"> 类图</h3>
<ul>
<li>Originator：原始对象</li>
<li>Caretaker：负责保存好备忘录</li>
<li>Menento：备忘录，存储原始对象的的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许 Originator 访问本备忘录的内部状态。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/50678f34-694f-45a4-91c6-34d985c83fee.png"/> </div><br>
<h3 id="角色划分" tabindex="-1"> 角色划分</h3>
<ul>
<li>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</li>
<li>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li>
<li>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li>
</ul>
<h2 id="实现" tabindex="-1"> 实现</h2>
<p>以下实现了一个简单计算器程序，可以输入两个值，然后计算这两个值的和。备忘录模式允许将这两个值存储起来，然后在某个时刻用存储的状态进行恢复。</p>
<p>实现参考：<a href="https://www.oodesign.com/memento-pattern-calculator-example-java-sourcecode.html" target="_blank" rel="noopener noreferrer">Memento Pattern - Calculator Example - Java Sourcecode</a></p>
<div><pre><code><span>/**
 * Originator Interface
 */</span>
<span>public</span> <span>interface</span> <span>Calculator</span> <span>{</span>

    <span>// Create Memento</span>
    <span>PreviousCalculationToCareTaker</span> <span>backupLastCalculation</span><span>(</span><span>)</span><span>;</span>

    <span>// setMemento</span>
    <span>void</span> <span>restorePreviousCalculation</span><span>(</span><span>PreviousCalculationToCareTaker</span> memento<span>)</span><span>;</span>

    <span>int</span> <span>getCalculationResult</span><span>(</span><span>)</span><span>;</span>

    <span>void</span> <span>setFirstNumber</span><span>(</span><span>int</span> firstNumber<span>)</span><span>;</span>

    <span>void</span> <span>setSecondNumber</span><span>(</span><span>int</span> secondNumber<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><pre><code><span>/**
 * Originator Implementation
 */</span>
<span>public</span> <span>class</span> <span>CalculatorImp</span> <span>implements</span> <span>Calculator</span> <span>{</span>

    <span>private</span> <span>int</span> firstNumber<span>;</span>
    <span>private</span> <span>int</span> secondNumber<span>;</span>

    <span>@Override</span>
    <span>public</span> <span>PreviousCalculationToCareTaker</span> <span>backupLastCalculation</span><span>(</span><span>)</span> <span>{</span>
        <span>// create a memento object used for restoring two numbers</span>
        <span>return</span> <span>new</span> <span>PreviousCalculationImp</span><span>(</span>firstNumber<span>,</span> secondNumber<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>restorePreviousCalculation</span><span>(</span><span>PreviousCalculationToCareTaker</span> memento<span>)</span> <span>{</span>
        <span>this</span><span>.</span>firstNumber <span>=</span> <span>(</span><span>(</span><span>PreviousCalculationToOriginator</span><span>)</span> memento<span>)</span><span>.</span><span>getFirstNumber</span><span>(</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>secondNumber <span>=</span> <span>(</span><span>(</span><span>PreviousCalculationToOriginator</span><span>)</span> memento<span>)</span><span>.</span><span>getSecondNumber</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>int</span> <span>getCalculationResult</span><span>(</span><span>)</span> <span>{</span>
        <span>// result is adding two numbers</span>
        <span>return</span> firstNumber <span>+</span> secondNumber<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>setFirstNumber</span><span>(</span><span>int</span> firstNumber<span>)</span> <span>{</span>
        <span>this</span><span>.</span>firstNumber <span>=</span> firstNumber<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>setSecondNumber</span><span>(</span><span>int</span> secondNumber<span>)</span> <span>{</span>
        <span>this</span><span>.</span>secondNumber <span>=</span> secondNumber<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><div><pre><code><span>/**
 * Memento Interface to Originator
 *
 * This interface allows the originator to restore its state
 */</span>
<span>public</span> <span>interface</span> <span>PreviousCalculationToOriginator</span> <span>{</span>
    <span>int</span> <span>getFirstNumber</span><span>(</span><span>)</span><span>;</span>
    <span>int</span> <span>getSecondNumber</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>/**
 *  Memento interface to CalculatorOperator (Caretaker)
 */</span>
<span>public</span> <span>interface</span> <span>PreviousCalculationToCareTaker</span> <span>{</span>
    <span>// no operations permitted for the caretaker</span>
<span>}</span>
</code></pre></div><div><pre><code><span>/**
 * Memento Object Implementation
 * <span><span><span>&lt;</span>p</span><span>></span></span>
 * Note that this object implements both interfaces to Originator and CareTaker
 */</span>
<span>public</span> <span>class</span> <span>PreviousCalculationImp</span> <span>implements</span> <span>PreviousCalculationToCareTaker</span><span>,</span>
        <span>PreviousCalculationToOriginator</span> <span>{</span>

    <span>private</span> <span>int</span> firstNumber<span>;</span>
    <span>private</span> <span>int</span> secondNumber<span>;</span>

    <span>public</span> <span>PreviousCalculationImp</span><span>(</span><span>int</span> firstNumber<span>,</span> <span>int</span> secondNumber<span>)</span> <span>{</span>
        <span>this</span><span>.</span>firstNumber <span>=</span> firstNumber<span>;</span>
        <span>this</span><span>.</span>secondNumber <span>=</span> secondNumber<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>int</span> <span>getFirstNumber</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> firstNumber<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>int</span> <span>getSecondNumber</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> secondNumber<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><div><pre><code><span>/**
 * CareTaker object
 */</span>
<span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// program starts</span>
        <span>Calculator</span> calculator <span>=</span> <span>new</span> <span>CalculatorImp</span><span>(</span><span>)</span><span>;</span>

        <span>// assume user enters two numbers</span>
        calculator<span>.</span><span>setFirstNumber</span><span>(</span><span>10</span><span>)</span><span>;</span>
        calculator<span>.</span><span>setSecondNumber</span><span>(</span><span>100</span><span>)</span><span>;</span>

        <span>// find result</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>calculator<span>.</span><span>getCalculationResult</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>// Store result of this calculation in case of error</span>
        <span>PreviousCalculationToCareTaker</span> memento <span>=</span> calculator<span>.</span><span>backupLastCalculation</span><span>(</span><span>)</span><span>;</span>

        <span>// user enters a number</span>
        calculator<span>.</span><span>setFirstNumber</span><span>(</span><span>17</span><span>)</span><span>;</span>

        <span>// user enters a wrong second number and calculates result</span>
        calculator<span>.</span><span>setSecondNumber</span><span>(</span><span>-</span><span>290</span><span>)</span><span>;</span>

        <span>// calculate result</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>calculator<span>.</span><span>getCalculationResult</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>// user hits CTRL + Z to undo last operation and see last result</span>
        calculator<span>.</span><span>restorePreviousCalculation</span><span>(</span>memento<span>)</span><span>;</span>

        <span>// result restored</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>calculator<span>.</span><span>getCalculationResult</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><div><pre><code>110
-273
110
</code></pre></div><h2 id="分析" tabindex="-1"> 分析</h2>
<h3 id="优点" tabindex="-1"> 优点</h3>
<ul>
<li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</li>
<li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li>
<li>简化了发起人。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li>
</ul>
<h3 id="缺点" tabindex="-1"> 缺点</h3>
<p>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源</p>
<h3 id="适用场景" tabindex="-1"> 适用场景</h3>
<ul>
<li>需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。</li>
<li>需要提供一个可回滚操作的场景，</li>
</ul>
<h2 id="应用" tabindex="-1"> 应用</h2>
<h3 id="模式扩展" tabindex="-1"> 模式扩展</h3>
<p>在备忘录模式中，通过定义“备忘录”来备份“发起人”的信息，而原型模式的 clone() 方法具有自备份功能，所以，如果让发起人实现 Cloneable 接口就有备份自己的功能，这时可以删除备忘录类</p>
<div align="center">
<p><img src="@source/assets/cs-note/oop-pattern/备忘录-原型模式.gif" alt="" loading="lazy"></p>
</div>
<h3 id="开发场景" tabindex="-1"> 开发场景</h3>
<ul>
<li>棋类游戏中的，悔棋</li>
<li>普通软件中的，撤销操作</li>
<li>数据库软件中的，事务管理中的，回滚操作</li>
<li>Photoshop软件中的，历史记录</li>
</ul>
<h3 id="jdk" tabindex="-1"> JDK</h3>
<ul>
<li>java.io.Serializable</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>外观门面模式</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">外观门面模式</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="外观-facade" tabindex="-1"> 外观（Facade）</h1>
<h2 id="介绍" tabindex="-1"> 介绍</h2>
<h3 id="定义" tabindex="-1"> 定义</h3>
<p>隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的接口。</p>
<p>提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。</p>
<h3 id="类图" tabindex="-1"> 类图</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f9978fa6-9f49-4a0f-8540-02d269ac448f.png"/> </div><br>
<h3 id="角色划分" tabindex="-1"> 角色划分</h3>
<ul>
<li>门面角色：外观模式的核心。它被客户角色调用，它熟悉子系统的功能。内部根据客户角色的需求预定了几种功能的组合。</li>
<li>子系统角色:实现了子系统的功能。它对客户角色和Facade时未知的。它内部可以有系统内的相互交互，也可以由供外界调用的接口。</li>
<li>客户角色:通过调用Facede来完成要实现的功能。</li>
</ul>
<h2 id="实现" tabindex="-1"> 实现</h2>
<p>观看电影需要操作很多电器，使用外观模式实现一键看电影功能。</p>
<div><pre><code><span>public</span> <span>class</span> <span>SubSystem</span> <span>{</span>
    <span>public</span> <span>void</span> <span>turnOnTV</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"turnOnTV()"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setCD</span><span>(</span><span>String</span> cd<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"setCD( "</span> <span>+</span> cd <span>+</span> <span>" )"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>startWatching</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"startWatching()"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Facade</span> <span>{</span>
    <span>private</span> <span>SubSystem</span> subSystem <span>=</span> <span>new</span> <span>SubSystem</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>void</span> <span>watchMovie</span><span>(</span><span>)</span> <span>{</span>
        subSystem<span>.</span><span>turnOnTV</span><span>(</span><span>)</span><span>;</span>
        subSystem<span>.</span><span>setCD</span><span>(</span><span>"a movie"</span><span>)</span><span>;</span>
        subSystem<span>.</span><span>startWatching</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Facade</span> facade <span>=</span> <span>new</span> <span>Facade</span><span>(</span><span>)</span><span>;</span>
        facade<span>.</span><span>watchMovie</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><h2 id="分析" tabindex="-1"> 分析</h2>
<h3 id="设计原则" tabindex="-1"> 设计原则</h3>
<p>最少知识原则：只和你的密友谈话。也就是说客户对象所需要交互的对象应当尽可能少。</p>
<h3 id="优点" tabindex="-1"> 优点</h3>
<ul>
<li>松散耦合：使得客户端和子系统之间解耦，让子系统内部的模块功能更容易扩展和维护；</li>
<li>简单易用：客户端根本不需要知道子系统内部的实现，或者根本不需要知道子系统内部的构成，它只需要跟Facade类交互即可。</li>
<li>更好的划分访问层次：有些方法是对系统外的，有些方法是系统内部相互交互的使用的。子系统把那些暴露给外部的功能集中到门面中，这样就可以实现客户端的使用，很好的隐藏了子系统内部的细节。</li>
</ul>
<h3 id="适用场景" tabindex="-1"> 适用场景</h3>
<ul>
<li>为复杂的模块或子系统提供外界访问的模块；</li>
<li>子系统相互独立；</li>
<li>在层析结构中，可以使用外观模式定义系统的每一层的入口。</li>
</ul>
<h2 id="应用" tabindex="-1"> 应用</h2>
<h3 id="开发场景" tabindex="-1"> 开发场景</h3>
<ul>
<li>JDBC封装后的，commons提供的DBUtils类， Hibernate提供的工具类、Spring JDBC工具类等</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>工厂模式</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">工厂模式</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="工厂模式" tabindex="-1"> 工厂模式</h1>
<p>在基类中定义创建对象的一个接口，让子类决定实例化哪个类。工厂方法让一个类的实例化延迟到子类中进行。</p>
<p><strong>分类</strong></p>
<ol>
<li>简单工厂（Simple Factory）模式，又称静态工厂方法模式（Static Factory Method Pattern）</li>
<li>工厂方法（Factory Method）模式，又称多态性工厂（Polymorphic Factory）模式或虚拟构造子（Virtual Constructor）模式</li>
<li>抽象工厂（Abstract Factory）模式，又称工具箱（Kit 或Toolkit）模式</li>
</ol>
<p><strong>为什么要用工厂模式</strong></p>
<ol>
<li>解耦 ：把对象的创建和使用的过程分开</li>
<li>降低代码重复: 如果创建某个对象的过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码。</li>
<li>降低维护成本 ：由于创建过程都由工厂统一管理，所以发生业务逻辑变化，不需要找到所有需要创建对象B的地方去逐个修正，只需要在工厂里修改即可，降低维护成本。</li>
</ol>
<p><strong>应用场景</strong></p>
<ul>
<li>JDK中Calendar的getInstance方法</li>
<li>JDBC中Connection对象的获取</li>
<li>Hibernate中SessionFactory创建Session</li>
<li>spring中IOC容器创建管理bean对象</li>
<li>XML解析时的DocumentBuilderFactory创建解析器对象</li>
<li>反射中Class对象的newInstance()</li>
</ul>
<h2 id="简单工厂-simple-factory" tabindex="-1"> 简单工厂（Simple Factory）</h2>
<h3 id="介绍" tabindex="-1"> 介绍</h3>
<h4 id="定义" tabindex="-1"> 定义</h4>
<p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</p>
<p>它违背了 <strong>开放-封闭原则</strong>；因为每次要新添加一个功能，都需要在生switch-case 语句（或者if-else 语句）中去修改代码，添加分支条件。</p>
<p><strong>适用场景</strong></p>
<ol>
<li>需要创建的对象较少。</li>
<li>客户端不关心对象的创建过程。</li>
</ol>
<h3 id="类图" tabindex="-1"> 类图</h3>
<p>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。</p>
<p>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/40c0c17e-bba6-4493-9857-147c0044a018.png"/> </div><br>
<h4 id="角色划分" tabindex="-1"> 角色划分</h4>
<ul>
<li>工厂(Factory)角色 :简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。</li>
<li>抽象产品(Product)角色 :简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。</li>
<li>具体产品(Concrete Product)角色:简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。</li>
</ul>
<h3 id="实现" tabindex="-1"> 实现</h3>
<p><strong>产品接口和产品类</strong></p>
<div><pre><code><span>public</span> <span>interface</span> <span>Product</span> <span>{</span>
<span>}</span>

<span>public</span> <span>class</span> <span>ConcreteProduct</span> <span>implements</span> <span>Product</span> <span>{</span>
<span>}</span>

<span>public</span> <span>class</span> <span>ConcreteProduct1</span> <span>implements</span> <span>Product</span> <span>{</span>
<span>}</span>

<span>public</span> <span>class</span> <span>ConcreteProduct2</span> <span>implements</span> <span>Product</span> <span>{</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>以下的 Client 类包含了实例化的代码，这是一种错误的实现。如果在客户类中存在这种实例化代码，就需要考虑将代码放到简单工厂中。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span> type <span>=</span> <span>1</span><span>;</span>
        <span>Product</span> product<span>;</span>
        <span>if</span> <span>(</span>type <span>==</span> <span>1</span><span>)</span> <span>{</span>
            product <span>=</span> <span>new</span> <span>ConcreteProduct1</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>type <span>==</span> <span>2</span><span>)</span> <span>{</span>
            product <span>=</span> <span>new</span> <span>ConcreteProduct2</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            product <span>=</span> <span>new</span> <span>ConcreteProduct</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>// do something with the product</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>以下的 SimpleFactory 是<strong>简单工厂</strong>实现，它被所有需要进行实例化的客户类调用。</p>
<div><pre><code><span>public</span> <span>class</span> <span>SimpleFactory</span> <span>{</span>

    <span>public</span> <span>Product</span> <span>createProduct</span><span>(</span><span>int</span> type<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>type <span>==</span> <span>1</span><span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>ConcreteProduct1</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>type <span>==</span> <span>2</span><span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>ConcreteProduct2</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>new</span> <span>ConcreteProduct</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>SimpleFactory</span> simpleFactory <span>=</span> <span>new</span> <span>SimpleFactory</span><span>(</span><span>)</span><span>;</span>
        <span>Product</span> product <span>=</span> simpleFactory<span>.</span><span>createProduct</span><span>(</span><span>1</span><span>)</span><span>;</span>
        <span>// do something with the product</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>SimpleFactory</span> <span>{</span>

    <span>public</span> <span>static</span> <span>Object</span> <span>getClass</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Product</span><span>></span></span> clazz<span>)</span> <span>{</span>
        <span>Object</span> obj <span>=</span> <span>null</span><span>;</span>

        <span>try</span> <span>{</span>
            obj <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span>clazz<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>ClassNotFoundException</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>InstantiationException</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>IllegalAccessException</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>

        <span>return</span> obj<span>;</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>Test2</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>

        <span>Product</span> product <span>=</span> <span>(</span><span>ConcreteProduct</span><span>)</span> <span>SimpleFactory</span><span>.</span><span>getClass</span><span>(</span><span><span>factory_pattern<span>.</span></span>ConcreteProduct</span><span>.</span><span>class</span><span>)</span><span>;</span>
        circle<span>.</span><span>draw</span><span>(</span><span>)</span><span>;</span>

        <span>Product</span> product1 <span>=</span> <span>(</span><span>ConcreteProduct1</span><span>)</span> <span>SimpleFactory</span><span>.</span><span>getClass</span><span>(</span><span><span>factory_pattern<span>.</span></span>ConcreteProduct1</span><span>.</span><span>class</span><span>)</span><span>;</span>
        rectangle<span>.</span><span>draw</span><span>(</span><span>)</span><span>;</span>

        <span>Product</span> product2 <span>=</span> <span>(</span><span>ConcreteProduct2</span><span>)</span> <span>SimpleFactory</span><span>.</span><span>getClass</span><span>(</span><span><span>factory_pattern<span>.</span></span>ConcreteProduct2</span><span>.</span><span>class</span><span>)</span><span>;</span>
        square<span>.</span><span>draw</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>利用反射解决简单工厂每次增加新了产品类都要修改产品工厂的弊端；这种方式的虽然符合了 开放-关闭原则 ，但是每一次传入的都是产品类的全部路径，这样比较麻烦。如果需要改善的话可以通过 反射+配置文件 的形式来改善，这种方式使用的也是比较多的</p>
<h2 id="工厂方法-factory-method" tabindex="-1"> 工厂方法（Factory Method）</h2>
<h3 id="介绍-1" tabindex="-1"> 介绍</h3>
<h4 id="定义-1" tabindex="-1"> 定义</h4>
<p>定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</p>
<p>工厂方法模式应该是在工厂模式家族中是用的最多模式，一般项目中存在最多的就是这个模式。</p>
<p>工厂方法模式是简单工厂的进一步深化， 在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说 每个对象都有一个与之对应的工厂 。</p>
<p><strong>适用场景</strong></p>
<ul>
<li>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</li>
<li>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏</li>
<li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无需关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li>
</ul>
<h3 id="类图-1" tabindex="-1"> 类图</h3>
<p>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。</p>
<p>下图中，Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f4d0afd0-8e78-4914-9e60-4366eaf065b5.png"/> </div><br>
<h4 id="角色划分-1" tabindex="-1"> 角色划分</h4>
<ul>
<li>抽象工厂(Abstract Factory)角色：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口或抽象类。</li>
<li>具体工厂(Concrete Factory)角色 ：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。</li>
<li>抽象产品(AbstractProduct)角色 ：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。</li>
<li>具体产品(Concrete Product)角色 ：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应</li>
</ul>
<h3 id="实现-1" tabindex="-1"> 实现</h3>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>Factory</span> <span>{</span>
    <span>abstract</span> <span>public</span> <span>Product</span> <span>factoryMethod</span><span>(</span><span>)</span><span>;</span>
    <span>public</span> <span>void</span> <span>doSomething</span><span>(</span><span>)</span> <span>{</span>
        <span>Product</span> product <span>=</span> <span>factoryMethod</span><span>(</span><span>)</span><span>;</span>
        <span>// do something with the product</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>ConcreteFactory</span> <span>extends</span> <span>Factory</span> <span>{</span>
    <span>public</span> <span>Product</span> <span>factoryMethod</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ConcreteProduct</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>ConcreteFactory1</span> <span>extends</span> <span>Factory</span> <span>{</span>
    <span>public</span> <span>Product</span> <span>factoryMethod</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ConcreteProduct1</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>ConcreteFactory2</span> <span>extends</span> <span>Factory</span> <span>{</span>
    <span>public</span> <span>Product</span> <span>factoryMethod</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ConcreteProduct2</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id="应用" tabindex="-1"> 应用</h3>
<h4 id="jdk" tabindex="-1"> JDK</h4>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html#getInstance--" target="_blank" rel="noopener noreferrer">java.util.Calendar</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html#getBundle-java.lang.String-" target="_blank" rel="noopener noreferrer">java.util.ResourceBundle</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/text/NumberFormat.html#getInstance--" target="_blank" rel="noopener noreferrer">java.text.NumberFormat</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html#forName-java.lang.String-" target="_blank" rel="noopener noreferrer">java.nio.charset.Charset</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/net/URLStreamHandlerFactory.html#createURLStreamHandler-java.lang.String-" target="_blank" rel="noopener noreferrer">java.net.URLStreamHandlerFactory</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/EnumSet.html#of-E-" target="_blank" rel="noopener noreferrer">java.util.EnumSet</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/JAXBContext.html#createMarshaller--" target="_blank" rel="noopener noreferrer">javax.xml.bind.JAXBContext</a></li>
</ul>
<h2 id="抽象工厂-abstract-factory" tabindex="-1"> 抽象工厂（Abstract Factory）</h2>
<h3 id="介绍-2" tabindex="-1"> 介绍</h3>
<h4 id="定义-2" tabindex="-1"> 定义</h4>
<p>提供一个接口，用于创建   <strong>相关的对象家族</strong>  。</p>
<p>在工厂方法模式中，其实我们有一个潜在意识的意识。那就是我们生产的都是同一类产品。抽象工厂模式是工厂方法的仅一步深化，在这个模式中的工厂类不单单可以创建一种产品，而是可以创建一组产品。</p>
<h4 id="适用场景" tabindex="-1"> 适用场景</h4>
<ul>
<li>和工厂方法一样客户端不需要知道它所创建的对象的类。</li>
<li>需要一组对象共同完成某种功能时，并且可能存在多组对象完成不同功能的情况。（同属于同一个产品族的产品）</li>
<li>系统结构稳定，不会频繁的增加对象。（因为一旦增加就需要修改原有代码，不符合开闭原则）</li>
</ul>
<h3 id="类图-2" tabindex="-1"> 类图</h3>
<p>抽象工厂是生产一整套有产品的（至少要生产两个产品)，这些产品必须相互是有关系或有依赖的，而工厂方法中的工厂是生产单一产品的工厂。</p>
<div align="center">
<p><img src="@source/assets/cs-note/oop-pattern/抽象工厂.png" alt="" loading="lazy"></p>
</div>
<p>抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。</p>
<p>抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。</p>
<p>至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。</p>
<p>从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e2190c36-8b27-4690-bde5-9911020a1294.png"/> </div><br>
<h4 id="角色划分-2" tabindex="-1"> 角色划分</h4>
<ul>
<li>抽象工厂（AbstractFactory）角色 ：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口或抽象类。</li>
<li>具体工厂类（ConreteFactory）角色 ：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。</li>
<li>抽象产品（Abstract Product）角色 ：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。</li>
<li>具体产品（Concrete Product）角色 ：抽象工厂模式所创建的任何产品对象都是某一个具体产品类的实例。在抽象工厂中创建的产品属于同一产品族，这不同于工厂模式中的工厂只创建单一产品</li>
</ul>
<h3 id="实现-2" tabindex="-1"> 实现</h3>
<p><strong>抽象产品</strong>和<strong>具体产品</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>AbstractProductA</span> <span>{</span>
<span>}</span>

<span>public</span> <span>class</span> <span>AbstractProductB</span> <span>{</span>
<span>}</span>

<span>public</span> <span>class</span> <span>ProductA1</span> <span>extends</span> <span>AbstractProductA</span> <span>{</span>
<span>}</span>

<span>public</span> <span>class</span> <span>ProductA2</span> <span>extends</span> <span>AbstractProductA</span> <span>{</span>
<span>}</span>

<span>public</span> <span>class</span> <span>ProductB1</span> <span>extends</span> <span>AbstractProductB</span> <span>{</span>
<span>}</span>

<span>public</span> <span>class</span> <span>ProductB2</span> <span>extends</span> <span>AbstractProductB</span> <span>{</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><strong>抽象工厂</strong>和<strong>具体工厂</strong></p>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>AbstractFactory</span> <span>{</span>
    <span>abstract</span> <span>AbstractProductA</span> <span>createProductA</span><span>(</span><span>)</span><span>;</span>
    <span>abstract</span> <span>AbstractProductB</span> <span>createProductB</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>class</span> <span>ConcreteFactory1</span> <span>extends</span> <span>AbstractFactory</span> <span>{</span>
    <span>AbstractProductA</span> <span>createProductA</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ProductA1</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>AbstractProductB</span> <span>createProductB</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ProductB1</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>ConcreteFactory2</span> <span>extends</span> <span>AbstractFactory</span> <span>{</span>
    <span>AbstractProductA</span> <span>createProductA</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ProductA2</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>AbstractProductB</span> <span>createProductB</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ProductB2</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>AbstractFactory</span> abstractFactory <span>=</span> <span>new</span> <span>ConcreteFactory1</span><span>(</span><span>)</span><span>;</span>
        <span>AbstractProductA</span> productA <span>=</span> abstractFactory<span>.</span><span>createProductA</span><span>(</span><span>)</span><span>;</span>
        <span>AbstractProductB</span> productB <span>=</span> abstractFactory<span>.</span><span>createProductB</span><span>(</span><span>)</span><span>;</span>
        <span>// do something with productA and productB</span>
    <span>}</span>
<span>}</span>
</code></pre></div><h3 id="应用-1" tabindex="-1"> 应用</h3>
<h4 id="jdk-1" tabindex="-1"> JDK</h4>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/parsers/DocumentBuilderFactory.html" target="_blank" rel="noopener noreferrer">javax.xml.parsers.DocumentBuilderFactory</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/transform/TransformerFactory.html#newInstance--" target="_blank" rel="noopener noreferrer">javax.xml.transform.TransformerFactory</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/xpath/XPathFactory.html#newInstance--" target="_blank" rel="noopener noreferrer">javax.xml.xpath.XPathFactory</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>建造者模式</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">建造者模式</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="建造者模式-builder" tabindex="-1"> 建造者模式（Builder）</h1>
<h3 id="定义" tabindex="-1"> 定义</h3>
<p>封装一个对象的构造过程，并允许按步骤构造。</p>
<p>建造者模式（Builder Pattern） 又名生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</p>
<p>建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p>
<h3 id="类图" tabindex="-1"> 类图</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/db5e376d-0b3e-490e-a43a-3231914b6668.png"/> </div><br>
<h3 id="角色划分" tabindex="-1"> 角色划分</h3>
<ul>
<li>Product（产品角色）：一个具体的产品对象。</li>
<li>Builder（抽象建造者）：创建一个Product对象的各个部件指定的抽象接口。</li>
<li>ConcreteBuilder（具体建造者）：实现抽象接口，构建和装配各个部件。</li>
<li>Director（指挥者）：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。</li>
</ul>
<h2 id="实现" tabindex="-1"> 实现</h2>
<div><pre><code><span>public</span> <span>class</span> <span>Product</span> <span>{</span>
    <span>private</span> <span>String</span> partA<span>;</span> <span>//可以是任意类型</span>
    <span>private</span> <span>String</span> partB<span>;</span>
    <span>private</span> <span>String</span> partC<span>;</span>
<span>}</span>
</code></pre></div><p>抽象建造者类中定义了产品的创建方法和返回方法</p>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>Builder</span>
<span>{</span>
    <span>protected</span> <span>Product</span> product<span>=</span><span>new</span> <span>Product</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>abstract</span> <span>void</span> <span>buildPartA</span><span>(</span><span>)</span><span>;</span>
    <span>public</span> <span>abstract</span> <span>void</span> <span>buildPartB</span><span>(</span><span>)</span><span>;</span>
    <span>public</span> <span>abstract</span> <span>void</span> <span>buildPartC</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>Product</span> <span>getResult</span><span>(</span><span>)</span>
    <span>{</span>
        <span>return</span> product<span>;</span>
    <span>}</span>
<span>}</span> 
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>具体建造者。实现抽象接口，构建和装配各个部件</p>
<div><pre><code><span>public</span> <span>class</span> <span>ConcreteBuilder</span> <span>extends</span> <span>Builder</span><span>{</span>
    <span>public</span> <span>void</span> <span>buildPartA</span><span>(</span><span>)</span><span>{</span>
    <span>.</span><span>.</span><span>.</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>buildPartB</span><span>(</span><span>)</span><span>{</span>
    <span>.</span><span>.</span><span>.</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>buildPartC</span><span>(</span><span>)</span><span>{</span>
    <span>.</span><span>.</span><span>.</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Director</span>
<span>{</span>
    <span>private</span> <span>Builder</span> builder<span>;</span>
    <span>//1 构造方法的方式注入builder对象</span>
    <span>public</span> <span>Director</span><span>(</span><span>Builder</span> builder<span>)</span>
    <span>{</span>
        <span>this</span><span>.</span>builder<span>=</span>builder<span>;</span>
    <span>}</span>
    <span>//2 set方法注入builder对象</span>
    <span>public</span> <span>void</span> <span>setBuilder</span><span>(</span><span>Builder</span> builder<span>)</span>
    <span>{</span>
        <span>this</span><span>.</span>builder<span>=</span>builer<span>;</span>
    <span>}</span>

    <span>public</span> <span>Product</span> <span>construct</span><span>(</span><span>)</span>
    <span>{</span>
        builder<span>.</span><span>buildPartA</span><span>(</span><span>)</span><span>;</span>
        builder<span>.</span><span>buildPartB</span><span>(</span><span>)</span><span>;</span>
        builder<span>.</span><span>buildPartC</span><span>(</span><span>)</span><span>;</span>
        <span>return</span> builder<span>.</span><span>getResult</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span> 
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。</p>
<div><pre><code>    <span>Builder</span> builder <span>=</span> <span>new</span> <span>ConcreteBuilder</span><span>(</span><span>)</span><span>;</span>
    <span>Director</span> director <span>=</span> <span>new</span> <span>Director</span><span>(</span>builder<span>)</span><span>;</span>
    <span>Product</span> product <span>=</span> director<span>.</span><span>construct</span><span>(</span><span>)</span><span>;</span>
</code></pre></div><p>以下是一个简易的 StringBuilder 实现，参考了 JDK 1.8 源码。</p>
<div><pre><code><span>public</span> <span>class</span> <span>AbstractStringBuilder</span> <span>{</span>
    <span>protected</span> <span>char</span><span>[</span><span>]</span> value<span>;</span>

    <span>protected</span> <span>int</span> count<span>;</span>

    <span>public</span> <span>AbstractStringBuilder</span><span>(</span><span>int</span> capacity<span>)</span> <span>{</span>
        count <span>=</span> <span>0</span><span>;</span>
        value <span>=</span> <span>new</span> <span>char</span><span>[</span>capacity<span>]</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>AbstractStringBuilder</span> <span>append</span><span>(</span><span>char</span> c<span>)</span> <span>{</span>
        <span>ensureCapacityInternal</span><span>(</span>count <span>+</span> <span>1</span><span>)</span><span>;</span>
        value<span>[</span>count<span>++</span><span>]</span> <span>=</span> c<span>;</span>
        <span>return</span> <span>this</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>ensureCapacityInternal</span><span>(</span><span>int</span> minimumCapacity<span>)</span> <span>{</span>
        <span>// overflow-conscious code</span>
        <span>if</span> <span>(</span>minimumCapacity <span>-</span> value<span>.</span>length <span>></span> <span>0</span><span>)</span>
            <span>expandCapacity</span><span>(</span>minimumCapacity<span>)</span><span>;</span>
    <span>}</span>

    <span>void</span> <span>expandCapacity</span><span>(</span><span>int</span> minimumCapacity<span>)</span> <span>{</span>
        <span>int</span> newCapacity <span>=</span> value<span>.</span>length <span>*</span> <span>2</span> <span>+</span> <span>2</span><span>;</span>
        <span>if</span> <span>(</span>newCapacity <span>-</span> minimumCapacity <span>&lt;</span> <span>0</span><span>)</span>
            newCapacity <span>=</span> minimumCapacity<span>;</span>
        <span>if</span> <span>(</span>newCapacity <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>minimumCapacity <span>&lt;</span> <span>0</span><span>)</span> <span>// overflow</span>
                <span>throw</span> <span>new</span> <span>OutOfMemoryError</span><span>(</span><span>)</span><span>;</span>
            newCapacity <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>;</span>
        <span>}</span>
        value <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>value<span>,</span> newCapacity<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>StringBuilder</span> <span>extends</span> <span>AbstractStringBuilder</span> <span>{</span>
    <span>public</span> <span>StringBuilder</span><span>(</span><span>)</span> <span>{</span>
        <span>super</span><span>(</span><span>16</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>
        <span>// Create a copy, don't share the array</span>
        <span>return</span> <span>new</span> <span>String</span><span>(</span>value<span>,</span> <span>0</span><span>,</span> count<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>StringBuilder</span> sb <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
        <span>final</span> <span>int</span> count <span>=</span> <span>26</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> count<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            sb<span>.</span><span>append</span><span>(</span><span>(</span><span>char</span><span>)</span> <span>(</span><span>'a'</span> <span>+</span> i<span>)</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>sb<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code>abcdefghijklmnopqrstuvwxyz
</code></pre></div><h2 id="分析" tabindex="-1"> 分析</h2>
<h3 id="优点" tabindex="-1"> 优点</h3>
<ol>
<li>客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li>
<li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。</li>
<li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li>
<li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合 “开闭原则”</li>
</ol>
<h3 id="缺点" tabindex="-1"> 缺点</h3>
<ul>
<li>产品之间差异性很大的情况：建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li>
<li>产品内部变化很复杂的情况： 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li>
</ul>
<h3 id="适用场景" tabindex="-1"> 适用场景</h3>
<ul>
<li>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</li>
<li>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的</li>
</ul>
<h3 id="抽象工厂模式vs建造者模式" tabindex="-1"> 抽象工厂模式VS建造者模式</h3>
<p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。</p>
<h2 id="应用" tabindex="-1"> 应用</h2>
<h3 id="开发场景" tabindex="-1"> 开发场景</h3>
<ul>
<li>StringBuilder类的append方法</li>
<li>SQL中的PreparedStatement</li>
<li>JDOM中，DomBuilder、SAXBuilder</li>
</ul>
<h3 id="jdk" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" target="_blank" rel="noopener noreferrer">java.lang.StringBuilder</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html#put-byte-" target="_blank" rel="noopener noreferrer">java.nio.ByteBuffer</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#append-boolean-" target="_blank" rel="noopener noreferrer">java.lang.StringBuffer</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Appendable.html" target="_blank" rel="noopener noreferrer">java.lang.Appendable</a></li>
<li><a href="https://github.com/apache/camel/tree/0e195428ee04531be27a0b659005e3aa8d159d23/camel-core/src/main/java/org/apache/camel/builder" target="_blank" rel="noopener noreferrer">Apache Camel builders</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>桥接模式</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">桥接模式</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="桥接-bridge" tabindex="-1"> 桥接（Bridge）</h1>
<h2 id="介绍" tabindex="-1"> 介绍</h2>
<h3 id="定义" tabindex="-1"> 定义</h3>
<p>桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<p>将<strong>抽象化</strong>(Abstraction)与<strong>实现化</strong>(Implementation)<strong>脱耦</strong>，使得二者可以独立地变化</p>
<p>所谓耦合，就是两个实体的行为的某种强关联。而将它们的强关联去掉，就是耦合的解脱，或称脱耦。在这里，脱耦是指将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联。</p>
<p>如何将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化</p>
<ul>
<li>抽象化：抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。</li>
<li>实现化：针对抽象化给出的具体实现，就是实现化，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。</li>
<li>脱耦：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。</li>
</ul>
<h3 id="类图" tabindex="-1"> 类图</h3>
<ul>
<li>Abstraction：定义抽象类的接口</li>
<li>Implementor：定义实现类接口</li>
</ul>
<p>系统含有两个等级结构：</p>
<ul>
<li>由抽象化角色和修正抽象化角色组成的抽象化等级结构</li>
<li>由实现化角色和两个具体实现化角色所组成的实现化等级结构</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2a1f8b0f-1dd7-4409-b177-a381c58066ad.png"/> </div><br>
<h3 id="角色划分" tabindex="-1"> 角色划分</h3>
<ul>
<li>抽象化(Abstraction)角色：抽象化给出的定义，并保存一个对实现化对象的引用。</li>
<li>修正抽象化(Refined Abstraction)角色：扩展抽象化角色，改变和修正父类对抽象化的定义。</li>
<li>实现化(Implementor)角色：这个角色给出实现化角色的接口，但不给出具体的实现。必须指出的是，这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。</li>
<li>具体实现化(Concrete Implementor)角色：这个角色给出实现化角色接口的具体实现。</li>
</ul>
<h2 id="实现" tabindex="-1"> 实现</h2>
<div><pre><code><span>public</span> <span>interface</span> <span>Implementor</span>
<span>{</span>
	<span>public</span> <span>void</span> <span>operationImpl</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
 
<span>public</span> <span>class</span> <span>ConcreteImplementor</span> <span>implements</span> <span>Implementor</span>
<span>{</span>
	<span>public</span> <span>void</span> <span>operationImpl</span><span>(</span><span>)</span>
	<span>{</span>
		<span>//具体实现</span>
	<span>}</span>
<span>}</span>
 
<span>public</span> <span>abstract</span> <span>class</span> <span>Abstraction</span>
<span>{</span>
	<span>protected</span> <span>Implementor</span> impl<span>;</span>
	
	<span>public</span> <span>void</span> <span>setImpl</span><span>(</span><span>Implementor</span> impl<span>)</span>
	<span>{</span>
		<span>this</span><span>.</span>impl<span>=</span>impl<span>;</span>
	<span>}</span>
	
	<span>public</span> <span>abstract</span> <span>void</span> <span>operation</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
 
<span>public</span> <span>class</span> <span>RefinedAbstraction</span> <span>extends</span> <span>Abstraction</span>
<span>{</span>
	<span>public</span> <span>void</span> <span>operation</span><span>(</span><span>)</span>
	<span>{</span>
		<span>//代码</span>
		impl<span>.</span><span>operationImpl</span><span>(</span><span>)</span><span>;</span>
		<span>//代码</span>
	<span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><p>RemoteControl 表示遥控器，指代 Abstraction。</p>
<p>TV 表示电视，指代 Implementor。</p>
<p>桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。</p>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>TV</span> <span>{</span>
    <span>public</span> <span>abstract</span> <span>void</span> <span>on</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>abstract</span> <span>void</span> <span>off</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>abstract</span> <span>void</span> <span>tuneChannel</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Sony</span> <span>extends</span> <span>TV</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>on</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Sony.on()"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>off</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Sony.off()"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>tuneChannel</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Sony.tuneChannel()"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>RCA</span> <span>extends</span> <span>TV</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>on</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"RCA.on()"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>off</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"RCA.off()"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>tuneChannel</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"RCA.tuneChannel()"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>RemoteControl</span> <span>{</span>
    <span>protected</span> <span>TV</span> tv<span>;</span>

    <span>public</span> <span>RemoteControl</span><span>(</span><span>TV</span> tv<span>)</span> <span>{</span>
        <span>this</span><span>.</span>tv <span>=</span> tv<span>;</span>
    <span>}</span>

    <span>public</span> <span>abstract</span> <span>void</span> <span>on</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>abstract</span> <span>void</span> <span>off</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>abstract</span> <span>void</span> <span>tuneChannel</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteRemoteControl1</span> <span>extends</span> <span>RemoteControl</span> <span>{</span>
    <span>public</span> <span>ConcreteRemoteControl1</span><span>(</span><span>TV</span> tv<span>)</span> <span>{</span>
        <span>super</span><span>(</span>tv<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>on</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ConcreteRemoteControl1.on()"</span><span>)</span><span>;</span>
        tv<span>.</span><span>on</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>off</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ConcreteRemoteControl1.off()"</span><span>)</span><span>;</span>
        tv<span>.</span><span>off</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>tuneChannel</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ConcreteRemoteControl1.tuneChannel()"</span><span>)</span><span>;</span>
        tv<span>.</span><span>tuneChannel</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteRemoteControl2</span> <span>extends</span> <span>RemoteControl</span> <span>{</span>
    <span>public</span> <span>ConcreteRemoteControl2</span><span>(</span><span>TV</span> tv<span>)</span> <span>{</span>
        <span>super</span><span>(</span>tv<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>on</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ConcreteRemoteControl2.on()"</span><span>)</span><span>;</span>
        tv<span>.</span><span>on</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>off</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ConcreteRemoteControl2.off()"</span><span>)</span><span>;</span>
        tv<span>.</span><span>off</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>tuneChannel</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ConcreteRemoteControl2.tuneChannel()"</span><span>)</span><span>;</span>
        tv<span>.</span><span>tuneChannel</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>RemoteControl</span> remoteControl1 <span>=</span> <span>new</span> <span>ConcreteRemoteControl1</span><span>(</span><span>new</span> <span>RCA</span><span>(</span><span>)</span><span>)</span><span>;</span>
        remoteControl1<span>.</span><span>on</span><span>(</span><span>)</span><span>;</span>
        remoteControl1<span>.</span><span>off</span><span>(</span><span>)</span><span>;</span>
        remoteControl1<span>.</span><span>tuneChannel</span><span>(</span><span>)</span><span>;</span>
        <span>RemoteControl</span> remoteControl2 <span>=</span> <span>new</span> <span>ConcreteRemoteControl2</span><span>(</span><span>new</span> <span>Sony</span><span>(</span><span>)</span><span>)</span><span>;</span>
        remoteControl2<span>.</span><span>on</span><span>(</span><span>)</span><span>;</span>
        remoteControl2<span>.</span><span>off</span><span>(</span><span>)</span><span>;</span>
        remoteControl2<span>.</span><span>tuneChannel</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="分析" tabindex="-1"> 分析</h2>
<h3 id="优点" tabindex="-1"> 优点</h3>
<ul>
<li>分离抽象接口及其实现部分。</li>
<li>桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。</li>
<li>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</li>
<li>实现细节对客户透明，可以对用户隐藏实现细节。</li>
</ul>
<h3 id="缺点" tabindex="-1"> 缺点</h3>
<ul>
<li>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</li>
<li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。</li>
</ul>
<h3 id="适用环境" tabindex="-1"> 适用环境</h3>
<ul>
<li>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li>
<li>抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。</li>
<li>一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</li>
<li>虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。</li>
<li>对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</li>
</ul>
<h2 id="应用" tabindex="-1"> 应用</h2>
<h3 id="开发场景" tabindex="-1"> 开发场景</h3>
<ul>
<li>Java语言通过Java虚拟机实现了平台的无关性</li>
</ul>
<h3 id="jdk" tabindex="-1"> JDK</h3>
<ul>
<li>AWT (It provides an abstraction layer which maps onto the native OS the windowing support.)</li>
<li>JDBC：使用JDBC驱动程序的应用系统就是抽象角色，而所使用的数据库是实现角色。一个JDBC驱动程序可以动态地将一个特定类型的数据库与一个Java应用程序绑定在一起，从而实现抽象角色与实现角色的动态耦合。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>模板方法模式</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">模板方法模式</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="模板方法-template-method" tabindex="-1"> 模板方法（Template Method）</h1>
<h2 id="介绍" tabindex="-1"> 介绍</h2>
<h3 id="定义" tabindex="-1"> 定义</h3>
<p>定义算法框架，并将一些步骤的实现延迟到子类。</p>
<p>通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。</p>
<h3 id="类图" tabindex="-1"> 类图</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac6a794b-68c0-486c-902f-8d988eee5766.png"/> </div><br>
<h3 id="角色划分" tabindex="-1"> 角色划分</h3>
<ul>
<li>AbstractClass：实现一个模板方法，定义了算法的骨架，具体子类将重定义PrimitiveOperation以实现一个算法的步骤。AbstractClass其实就是一个抽象模板，定义并实现了一个模板方法。这个模板方法一般是一个具体的方法。它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。</li>
<li>ConcreteClasses：实现PrimitiveOperation以完成算法与特定子类相关的步骤。ConcreteClass实现父类所定义的一个或多个抽象方法。每一个AbstractClass都可以有任意多个ConcreteClass与之对应，而每一个ConcreteClass都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。</li>
</ul>
<h2 id="实现" tabindex="-1"> 实现</h2>
<p>冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/11236498-1417-46ce-a1b0-e10054256955.png"/> </div><br>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>CaffeineBeverage</span> <span>{</span>

    <span>final</span> <span>void</span> <span>prepareRecipe</span><span>(</span><span>)</span> <span>{</span>
        <span>boilWater</span><span>(</span><span>)</span><span>;</span>
        <span>brew</span><span>(</span><span>)</span><span>;</span>
        <span>pourInCup</span><span>(</span><span>)</span><span>;</span>
        <span>addCondiments</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>abstract</span> <span>void</span> <span>brew</span><span>(</span><span>)</span><span>;</span>

    <span>abstract</span> <span>void</span> <span>addCondiments</span><span>(</span><span>)</span><span>;</span>

    <span>void</span> <span>boilWater</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"boilWater"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>void</span> <span>pourInCup</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"pourInCup"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Coffee</span> <span>extends</span> <span>CaffeineBeverage</span> <span>{</span>
    <span>@Override</span>
    <span>void</span> <span>brew</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Coffee.brew"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>void</span> <span>addCondiments</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Coffee.addCondiments"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Tea</span> <span>extends</span> <span>CaffeineBeverage</span> <span>{</span>
    <span>@Override</span>
    <span>void</span> <span>brew</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Tea.brew"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>void</span> <span>addCondiments</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Tea.addCondiments"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>CaffeineBeverage</span> caffeineBeverage <span>=</span> <span>new</span> <span>Coffee</span><span>(</span><span>)</span><span>;</span>
        caffeineBeverage<span>.</span><span>prepareRecipe</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"-----------"</span><span>)</span><span>;</span>
        caffeineBeverage <span>=</span> <span>new</span> <span>Tea</span><span>(</span><span>)</span><span>;</span>
        caffeineBeverage<span>.</span><span>prepareRecipe</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code>boilWater
Coffee.brew
pourInCup
Coffee.addCondiments
-----------
boilWater
Tea.brew
pourInCup
Tea.addCondiments
</code></pre></div><h2 id="分析" tabindex="-1"> 分析</h2>
<h3 id="优点" tabindex="-1"> 优点</h3>
<ul>
<li>模板方法模式通过把不变的行为搬移到父类，去除了子类中的重复代码。</li>
<li>子类实现算法的某些细节，有助于算法的扩展。</li>
<li>通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。</li>
</ul>
<h3 id="缺点" tabindex="-1"> 缺点</h3>
<p>按照设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类负责完成具体的事务属性和方法，但是模板方式正好相反，子类执行的结果影响了父类的结果，会增加代码阅读的难度。</p>
<h3 id="适用场景" tabindex="-1"> 适用场景</h3>
<ul>
<li>多个子类有共有的方法，并且逻辑基本相同。</li>
<li>重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。</li>
<li>重构时，模板方法是一个经常使用的方法，把相同的代码抽取到父类中，然后通过构造函数约束其行为。</li>
</ul>
<h2 id="应用" tabindex="-1"> 应用</h2>
<h3 id="开发场景" tabindex="-1"> 开发场景</h3>
<ul>
<li>数据库访问的封装</li>
<li>Junit单元测试</li>
<li>servlet中关于doGet/doPost方法调用</li>
<li>Hibernate中模板程序</li>
<li>Spring中JDBCTemplate、HibernateTemplate等</li>
</ul>
<h3 id="jdk" tabindex="-1"> JDK</h3>
<ul>
<li>java.util.Collections#sort()</li>
<li>java.io.InputStream#skip()</li>
<li>java.io.InputStream#read()</li>
<li>java.util.AbstractList#indexOf()</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>状态模式</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">状态模式</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="状态-state" tabindex="-1"> 状态（State）</h1>
<h3 id="定义" tabindex="-1"> 定义</h3>
<p>状态模式(State Pattern) ：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)</p>
<p><strong>模式动机</strong><br>
一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(stateful)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。</p>
<h3 id="类图" tabindex="-1"> 类图</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/79df886f-fdc3-4020-a07f-c991bb58e0d8.png"/> </div><br>
<h3 id="角色划分" tabindex="-1"> 角色划分</h3>
<ul>
<li>Context: 环境类</li>
<li>State: 抽象状态类</li>
<li>ConcreteState: 具体状态类</li>
</ul>
<h2 id="实现" tabindex="-1"> 实现</h2>
<p>糖果销售机有多种状态，每种状态下销售机有不同的行为，状态可以发生转移，使得销售机的行为也发生改变。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/396be981-3f2c-4fd9-8101-dbf9c841504b.jpg" width="600"/> </div><br>
<div><pre><code><span>public</span> <span>interface</span> <span>State</span> <span>{</span>
    <span>/**
     * 投入 25 分钱
     */</span>
    <span>void</span> <span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
    <span>/**
     * 退回 25 分钱
     */</span>
    <span>void</span> <span>ejectQuarter</span><span>(</span><span>)</span><span>;</span>
    <span>/**
     * 转动曲柄
     */</span>
    <span>void</span> <span>turnCrank</span><span>(</span><span>)</span><span>;</span>
    <span>/**
     * 发放糖果
     */</span>
    <span>void</span> <span>dispense</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>HasQuarterState</span> <span>implements</span> <span>State</span> <span>{</span>

    <span>private</span> <span>GumballMachine</span> gumballMachine<span>;</span>

    <span>public</span> <span>HasQuarterState</span><span>(</span><span>GumballMachine</span> gumballMachine<span>)</span> <span>{</span>
        <span>this</span><span>.</span>gumballMachine <span>=</span> gumballMachine<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>insertQuarter</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You can't insert another quarter"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>ejectQuarter</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Quarter returned"</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>setState</span><span>(</span>gumballMachine<span>.</span><span>getNoQuarterState</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>turnCrank</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You turned..."</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>setState</span><span>(</span>gumballMachine<span>.</span><span>getSoldState</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>dispense</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"No gumball dispensed"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>NoQuarterState</span> <span>implements</span> <span>State</span> <span>{</span>

    <span>GumballMachine</span> gumballMachine<span>;</span>

    <span>public</span> <span>NoQuarterState</span><span>(</span><span>GumballMachine</span> gumballMachine<span>)</span> <span>{</span>
        <span>this</span><span>.</span>gumballMachine <span>=</span> gumballMachine<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>insertQuarter</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You insert a quarter"</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>setState</span><span>(</span>gumballMachine<span>.</span><span>getHasQuarterState</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>ejectQuarter</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You haven't insert a quarter"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>turnCrank</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You turned, but there's no quarter"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>dispense</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You need to pay first"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>SoldOutState</span> <span>implements</span> <span>State</span> <span>{</span>

    <span>GumballMachine</span> gumballMachine<span>;</span>

    <span>public</span> <span>SoldOutState</span><span>(</span><span>GumballMachine</span> gumballMachine<span>)</span> <span>{</span>
        <span>this</span><span>.</span>gumballMachine <span>=</span> gumballMachine<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>insertQuarter</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You can't insert a quarter, the machine is sold out"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>ejectQuarter</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You can't eject, you haven't inserted a quarter yet"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>turnCrank</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You turned, but there are no gumballs"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>dispense</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"No gumball dispensed"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>SoldState</span> <span>implements</span> <span>State</span> <span>{</span>

    <span>GumballMachine</span> gumballMachine<span>;</span>

    <span>public</span> <span>SoldState</span><span>(</span><span>GumballMachine</span> gumballMachine<span>)</span> <span>{</span>
        <span>this</span><span>.</span>gumballMachine <span>=</span> gumballMachine<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>insertQuarter</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Please wait, we're already giving you a gumball"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>ejectQuarter</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Sorry, you already turned the crank"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>turnCrank</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Turning twice doesn't get you another gumball!"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>dispense</span><span>(</span><span>)</span> <span>{</span>
        gumballMachine<span>.</span><span>releaseBall</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>gumballMachine<span>.</span><span>getCount</span><span>(</span><span>)</span> <span>></span> <span>0</span><span>)</span> <span>{</span>
            gumballMachine<span>.</span><span>setState</span><span>(</span>gumballMachine<span>.</span><span>getNoQuarterState</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Oops, out of gumballs"</span><span>)</span><span>;</span>
            gumballMachine<span>.</span><span>setState</span><span>(</span>gumballMachine<span>.</span><span>getSoldOutState</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>GumballMachine</span> <span>{</span>

    <span>private</span> <span>State</span> soldOutState<span>;</span>
    <span>private</span> <span>State</span> noQuarterState<span>;</span>
    <span>private</span> <span>State</span> hasQuarterState<span>;</span>
    <span>private</span> <span>State</span> soldState<span>;</span>

    <span>private</span> <span>State</span> state<span>;</span>
    <span>private</span> <span>int</span> count <span>=</span> <span>0</span><span>;</span>

    <span>public</span> <span>GumballMachine</span><span>(</span><span>int</span> numberGumballs<span>)</span> <span>{</span>
        count <span>=</span> numberGumballs<span>;</span>
        soldOutState <span>=</span> <span>new</span> <span>SoldOutState</span><span>(</span><span>this</span><span>)</span><span>;</span>
        noQuarterState <span>=</span> <span>new</span> <span>NoQuarterState</span><span>(</span><span>this</span><span>)</span><span>;</span>
        hasQuarterState <span>=</span> <span>new</span> <span>HasQuarterState</span><span>(</span><span>this</span><span>)</span><span>;</span>
        soldState <span>=</span> <span>new</span> <span>SoldState</span><span>(</span><span>this</span><span>)</span><span>;</span>

        <span>if</span> <span>(</span>numberGumballs <span>></span> <span>0</span><span>)</span> <span>{</span>
            state <span>=</span> noQuarterState<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            state <span>=</span> soldOutState<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>insertQuarter</span><span>(</span><span>)</span> <span>{</span>
        state<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>ejectQuarter</span><span>(</span><span>)</span> <span>{</span>
        state<span>.</span><span>ejectQuarter</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>turnCrank</span><span>(</span><span>)</span> <span>{</span>
        state<span>.</span><span>turnCrank</span><span>(</span><span>)</span><span>;</span>
        state<span>.</span><span>dispense</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setState</span><span>(</span><span>State</span> state<span>)</span> <span>{</span>
        <span>this</span><span>.</span>state <span>=</span> state<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>releaseBall</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"A gumball comes rolling out the slot..."</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>count <span>!=</span> <span>0</span><span>)</span> <span>{</span>
            count <span>-=</span> <span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>State</span> <span>getSoldOutState</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> soldOutState<span>;</span>
    <span>}</span>

    <span>public</span> <span>State</span> <span>getNoQuarterState</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> noQuarterState<span>;</span>
    <span>}</span>

    <span>public</span> <span>State</span> <span>getHasQuarterState</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> hasQuarterState<span>;</span>
    <span>}</span>

    <span>public</span> <span>State</span> <span>getSoldState</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> soldState<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getCount</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> count<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>GumballMachine</span> gumballMachine <span>=</span> <span>new</span> <span>GumballMachine</span><span>(</span><span>5</span><span>)</span><span>;</span>

        gumballMachine<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>turnCrank</span><span>(</span><span>)</span><span>;</span>

        gumballMachine<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>ejectQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>turnCrank</span><span>(</span><span>)</span><span>;</span>

        gumballMachine<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>turnCrank</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>turnCrank</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>ejectQuarter</span><span>(</span><span>)</span><span>;</span>

        gumballMachine<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>turnCrank</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>turnCrank</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>turnCrank</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><div><pre><code>You insert a quarter
You turned...
A gumball comes rolling out the slot...
You insert a quarter
Quarter returned
You turned, but there's no quarter
You need to pay first
You insert a quarter
You turned...
A gumball comes rolling out the slot...
You insert a quarter
You turned...
A gumball comes rolling out the slot...
You haven't insert a quarter
You insert a quarter
You can't insert another quarter
You turned...
A gumball comes rolling out the slot...
You insert a quarter
You turned...
A gumball comes rolling out the slot...
Oops, out of gumballs
You can't insert a quarter, the machine is sold out
You turned, but there are no gumballs
No gumball dispensed
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h2 id="分析" tabindex="-1"> 分析</h2>
<ul>
<li>状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。</li>
<li>状态模式的关键是引入了一个抽象类来专门表示对象的状态，这个类我们叫做抽象状态类，而对象的每一种具体状态类都继承了该类，并在不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换。</li>
</ul>
<p>在状态模式结构中需要理解环境类与抽象状态类的作用：</p>
<ul>
<li>环境类实际上就是拥有状态的对象，环境类有时候可以充当状态管理器(State Manager)的角色，可以在环境类中对状态进行切换操作。</li>
<li>抽象状态类可以是抽象类，也可以是接口，不同状态类就是继承这个父类的不同子类，状态类的产生是由于环境类存在多个状态，同时还满足两个条件： 这些状态经常需要切换，在不同的状态下对象的行为不同。因此可以将不同对象下的行为单独提取出来封装在具体的状态类中，使得环境类对象在其内部状态改变时可以改变它的行为，对象看起来似乎修改了它的类，而实际上是由于切换到不同的具体状态类实现的。由于环境类可以设置为任一具体状态类，因此它针对抽象状态类进行编程，在程序运行时可以将任一具体状态类的对象设置到环境类中，从而使得环境类可以改变内部状态，并且改变行为。</li>
</ul>
<h3 id="优点" tabindex="-1"> 优点</h3>
<ul>
<li>封装了转换规则。</li>
<li>枚举可能的状态，在枚举状态之前需要确定状态种类。</li>
<li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li>
<li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</li>
<li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li>
</ul>
<h3 id="缺点" tabindex="-1"> 缺点</h3>
<ul>
<li>状态模式的使用必然会增加系统类和对象的个数。</li>
<li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li>
<li>状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</li>
</ul>
<h3 id="适用环境" tabindex="-1"> 适用环境</h3>
<ul>
<li>对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。</li>
<li>代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。</li>
</ul>
<h2 id="应用" tabindex="-1"> 应用</h2>
<h3 id="开发场景" tabindex="-1"> 开发场景</h3>
<ul>
<li>银行系统中账号状态的管理</li>
<li>OA系统中公文状态的管理</li>
<li>酒店系统中，房间状态的管理</li>
<li>线程对象各状态之间的切换</li>
</ul>
<h3 id="模式扩展" tabindex="-1"> 模式扩展</h3>
<p><strong>共享状态</strong>：在有些情况下多个环境对象需要共享同一个状态，如果希望在系统中实现多个环境对象实例共享一个或多个状态对象，那么需要将这些状态对象定义为环境的静态成员对象</p>
<p><strong>简单状态模式与可切换状态的状态模式</strong></p>
<ul>
<li>简单状态模式：简单状态模式是指状态都相互独立，状态之间无须进行转换的状态模式，这是最简单的一种状态模式。对于这种状态模式，每个状态类都封装与状态相关的操作，而无须关心状态的切换，可以在客户端直接实例化状态类，然后将状态对象设置到环境类中。如果是这种简单的状态模式，它遵循“开闭原则”，在客户端可以针对抽象状态类进行编程，而将具体状态类写到配置文件中，同时增加新的状态类对原有系统也不造成任何影响。</li>
<li>可切换状态的状态模式：大多数的状态模式都是可以切换状态的状态模式，在实现状态切换时，在具体状态类内部需要调用环境类Context的setState()方法进行状态的转换操作，在具体状态类中可以调用到环境类的方法，因此状态类与环境类之间通常还存在关联关系或者依赖关系。通过在状态类中引用环境类的对象来回调环境类的setState()方法实现状态的切换。在这种可以切换状态的状态模式中，增加新的状态类可能需要修改其他某些状态类甚至环境类的源代码，否则系统无法切换到新增状态。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>设计模式目录</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%9B%AE%E5%BD%95.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%9B%AE%E5%BD%95.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">设计模式目录</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="一、前言" tabindex="-1"> 一、前言</h1>
<p>设计模式是解决问题的方案，学习现有的设计模式可以做到经验复用。拥有设计模式词汇，在沟通时就能用更少的词汇来讨论，并且不需要了解底层细节。</p>
<h1 id="二、创建型" tabindex="-1"> 二、创建型</h1>
<ul>
<li><a href="/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B.html">单例模式</a></li>
<li><a href="/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html">工厂模式</a></li>
<li><a href="/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.html">建造者模式</a></li>
<li><a href="/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html">原型模式</a></li>
</ul>
<h1 id="三、结构型" tabindex="-1"> 三、结构型</h1>
<ul>
<li><a href="/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8.html">适配器模式</a></li>
<li><a href="/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5.html">桥接模式</a></li>
<li><a href="/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88.html">组合模式</a></li>
<li><a href="/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0.html">装饰模式</a></li>
<li><a href="/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82.html">外观模式</a></li>
<li><a href="/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83.html">享元模式</a></li>
<li><a href="/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86.html">代理模式</a></li>
</ul>
<h1 id="四、行为型" tabindex="-1"> 四、行为型</h1>
<ul>
<li><a href="/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE.html">责任链模式</a></li>
<li><a href="/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4.html">命令模式</a></li>
<li><a href="/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85.html">观察者模式</a></li>
<li><a href="/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85.html">中介者模式</a></li>
<li><a href="/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81.html">状态模式</a></li>
<li><a href="/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5.html">策略模式</a></li>
<li><a href="/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.html">模板方法模式</a></li>
<li><a href="/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8.html">迭代器模式</a></li>
<li><a href="/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8.html">解释器模式</a></li>
<li><a href="/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85.html">访问者模式</a></li>
<li><a href="/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95.html">备忘录模式</a></li>
<li><a href="/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A9%BA%E5%AF%B9%E8%B1%A1.html">空对象模式</a></li>
</ul>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li>弗里曼. Head First 设计模式 [M]. 中国电力出版社, 2007.</li>
<li>Gamma E. 设计模式: 可复用面向对象软件的基础 [M]. 机械工业出版社, 2007.</li>
<li>Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.</li>
<li><a href="http://www.oodesign.com/" target="_blank" rel="noopener noreferrer">Design Patterns</a></li>
<li><a href="http://java-design-patterns.com/" target="_blank" rel="noopener noreferrer">Design patterns implemented in Java</a></li>
<li><a href="http://www.programering.com/a/MTNxAzMwATY.html" target="_blank" rel="noopener noreferrer">The breakdown of design patterns in JDK</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>空对象模式</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A9%BA%E5%AF%B9%E8%B1%A1.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A9%BA%E5%AF%B9%E8%B1%A1.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">空对象模式</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="空对象-null" tabindex="-1"> 空对象（Null）</h1>
<h3 id="定义" tabindex="-1"> 定义</h3>
<p>使用什么都不做的空对象来代替 NULL。</p>
<p>一个方法返回 NULL，意味着方法的调用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。</p>
<h3 id="类图" tabindex="-1"> 类图</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/22870bbe-898f-4c17-a31a-d7c5ee5d1c10.png"/> </div><br>
<h2 id="实现" tabindex="-1"> 实现</h2>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>AbstractOperation</span> <span>{</span>
    <span>abstract</span> <span>void</span> <span>request</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>RealOperation</span> <span>extends</span> <span>AbstractOperation</span> <span>{</span>
    <span>@Override</span>
    <span>void</span> <span>request</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"do something"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>NullOperation</span> <span>extends</span> <span>AbstractOperation</span><span>{</span>
    <span>@Override</span>
    <span>void</span> <span>request</span><span>(</span><span>)</span> <span>{</span>
        <span>// do nothing</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>AbstractOperation</span> abstractOperation <span>=</span> <span>func</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>
        abstractOperation<span>.</span><span>request</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>AbstractOperation</span> <span>func</span><span>(</span><span>int</span> para<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>para <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>NullOperation</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>new</span> <span>RealOperation</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="分析" tabindex="-1"> 分析</h2>
<h3 id="优点" tabindex="-1"> 优点</h3>
<ul>
<li>可以加强系统的稳固性，能有有效地防止空指针报错对整个系统的影响，使系统更加稳定。</li>
<li>能够实现对空对象情况的定制化的控制，能够掌握处理空对象的主动权。</li>
<li>并不依靠Client来保证整个系统的稳定运行。</li>
<li>通过isNull对==null的替换，显得更加优雅，更加易懂。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>策略模式</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">策略模式</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="策略-strategy" tabindex="-1"> 策略（Strategy）</h1>
<h2 id="介绍" tabindex="-1"> 介绍</h2>
<h3 id="定义" tabindex="-1"> 定义</h3>
<p>定义一系列算法，封装每个算法，并使它们可以互换。</p>
<p>策略模式可以让算法独立于使用它的客户端。</p>
<h3 id="类图" tabindex="-1"> 类图</h3>
<ul>
<li>Strategy 接口定义了一个算法族，它们都实现了  behavior() 方法。</li>
<li>Context 是使用到该算法族的类，其中的 doSomething() 方法会调用 behavior()，setStrategy(Strategy) 方法可以动态地改变 strategy 对象，也就是说能动态地改变 Context 所使用的算法。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cd1be8c2-755a-4a66-ad92-2e30f8f47922.png"/> </div><br>
<h3 id="角色划分" tabindex="-1"> 角色划分</h3>
<ul>
<li>Context: 环境类</li>
<li>Strategy: 抽象策略类</li>
<li>ConcreteStrategy: 具体策略类</li>
</ul>
<h2 id="实现" tabindex="-1"> 实现</h2>
<h3 id="典型实现" tabindex="-1"> 典型实现</h3>
<p>设计一个鸭子，它可以动态地改变叫声。这里的算法族是鸭子的叫声行为。</p>
<div><pre><code><span>public</span> <span>interface</span> <span>QuackBehavior</span> <span>{</span>
    <span>void</span> <span>quack</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Quack</span> <span>implements</span> <span>QuackBehavior</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>quack</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"quack!"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Squeak</span> <span>implements</span> <span>QuackBehavior</span><span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>quack</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"squeak!"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Duck</span> <span>{</span>

    <span>private</span> <span>QuackBehavior</span> quackBehavior<span>;</span>

    <span>public</span> <span>void</span> <span>performQuack</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>quackBehavior <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            quackBehavior<span>.</span><span>quack</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setQuackBehavior</span><span>(</span><span>QuackBehavior</span> quackBehavior<span>)</span> <span>{</span>
        <span>this</span><span>.</span>quackBehavior <span>=</span> quackBehavior<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Duck</span> duck <span>=</span> <span>new</span> <span>Duck</span><span>(</span><span>)</span><span>;</span>
        duck<span>.</span><span>setQuackBehavior</span><span>(</span><span>new</span> <span>Squeak</span><span>(</span><span>)</span><span>)</span><span>;</span>
        duck<span>.</span><span>performQuack</span><span>(</span><span>)</span><span>;</span>
        duck<span>.</span><span>setQuackBehavior</span><span>(</span><span>new</span> <span>Quack</span><span>(</span><span>)</span><span>)</span><span>;</span>
        duck<span>.</span><span>performQuack</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code>squeak!
quack!
</code></pre></div><h3 id="增强策略模式实现" tabindex="-1"> 增强策略模式实现</h3>
<p>客户端需要显示决定具体使用何种策略，并且一旦需要换用其它策略，需要修改客户端的代码。解决这个问题，一个比较好的方式是使用简单工厂，使得客户端都不需要知道策略类的实例化过程，甚至都不需要具体哪种策略被使用。</p>
<div><pre><code><span>public</span> <span>class</span> <span>SimpleFactoryContext</span> <span>{</span>

  <span>private</span> <span>static</span> <span>final</span> <span>Logger</span> LOG <span>=</span> <span>LoggerFactory</span><span>.</span><span>getLogger</span><span>(</span><span>SimpleFactoryContext</span><span>.</span><span>class</span><span>)</span><span>;</span>
  <span>private</span> <span>static</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Class</span><span>></span></span> allStrategies<span>;</span>

  <span>static</span> <span>{</span>
    <span>Reflections</span> reflections <span>=</span> <span>new</span> <span>Reflections</span><span>(</span><span>"com.jasongj.strategy"</span><span>)</span><span>;</span>
    <span>Set</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> annotatedClasses <span>=</span>
        reflections<span>.</span><span>getTypesAnnotatedWith</span><span>(</span><span><span>com<span>.</span>jasongj<span>.</span>annotation<span>.</span></span>Strategy</span><span>.</span><span>class</span><span>)</span><span>;</span>
    allStrategies <span>=</span> <span>new</span> <span>ConcurrentHashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Class</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> classObject <span>:</span> annotatedClasses<span>)</span> <span>{</span>
      <span><span>com<span>.</span>jasongj<span>.</span>annotation<span>.</span></span>Strategy</span> strategy <span>=</span> <span>(</span><span><span>com<span>.</span>jasongj<span>.</span>annotation<span>.</span></span>Strategy</span><span>)</span> classObject
          <span>.</span><span>getAnnotation</span><span>(</span><span><span>com<span>.</span>jasongj<span>.</span>annotation<span>.</span></span>Strategy</span><span>.</span><span>class</span><span>)</span><span>;</span>
      allStrategies<span>.</span><span>put</span><span>(</span>strategy<span>.</span><span>name</span><span>(</span><span>)</span><span>,</span> classObject<span>)</span><span>;</span>
    <span>}</span>
    allStrategies <span>=</span> <span>Collections</span><span>.</span><span>unmodifiableMap</span><span>(</span>allStrategies<span>)</span><span>;</span>
  <span>}</span>

  <span>private</span> <span>Strategy</span> strategy<span>;</span>

  <span>public</span> <span>SimpleFactoryContext</span><span>(</span><span>)</span> <span>{</span>
    <span>String</span> name <span>=</span> <span>null</span><span>;</span>
    <span>try</span> <span>{</span>
      <span>XMLConfiguration</span> config <span>=</span> <span>new</span> <span>XMLConfiguration</span><span>(</span><span>"strategy.xml"</span><span>)</span><span>;</span>
      name <span>=</span> config<span>.</span><span>getString</span><span>(</span><span>"strategy.name"</span><span>)</span><span>;</span>
      LOG<span>.</span><span>info</span><span>(</span><span>"strategy name is {}"</span><span>,</span> name<span>)</span><span>;</span>
    <span>}</span> <span>catch</span> <span>(</span><span>ConfigurationException</span> ex<span>)</span> <span>{</span>
      LOG<span>.</span><span>error</span><span>(</span><span>"Parsing xml configuration file failed"</span><span>,</span> ex<span>)</span><span>;</span>
    <span>}</span>

    <span>if</span> <span>(</span>allStrategies<span>.</span><span>containsKey</span><span>(</span>name<span>)</span><span>)</span> <span>{</span>
      LOG<span>.</span><span>info</span><span>(</span><span>"Created strategy name is {}"</span><span>,</span> name<span>)</span><span>;</span>
      <span>try</span> <span>{</span>
        strategy <span>=</span> <span>(</span><span>Strategy</span><span>)</span> allStrategies<span>.</span><span>get</span><span>(</span>name<span>)</span><span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>
      <span>}</span> <span>catch</span> <span>(</span><span>InstantiationException</span> <span>|</span> <span>IllegalAccessException</span> ex<span>)</span> <span>{</span>
        LOG<span>.</span><span>error</span><span>(</span><span>"Instantiate Strategy failed"</span><span>,</span> ex<span>)</span><span>;</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
      LOG<span>.</span><span>error</span><span>(</span><span>"Specified Strategy name {} does not exist"</span><span>,</span> name<span>)</span><span>;</span>
    <span>}</span>

  <span>}</span>

  <span>public</span> <span>void</span> <span>action</span><span>(</span><span>String</span> input<span>)</span> <span>{</span>
    strategy<span>.</span><span>strategy</span><span>(</span>input<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><p>上面的实现可以看出，虽然并没有单独创建一个简单工厂类，但它已经融入了简单工厂模式的设计思想和实现方法。</p>
<p>客户端调用</p>
<div><pre><code><span>public</span> <span>class</span> <span>SimpleFactoryClient</span> <span>{</span>

  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>SimpleFactoryContext</span> context <span>=</span> <span>new</span> <span>SimpleFactoryContext</span><span>(</span><span>)</span><span>;</span>
    context<span>.</span><span>action</span><span>(</span><span>"Hellow, world"</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre></div><h2 id="分析" tabindex="-1"> 分析</h2>
<ul>
<li>策略模式是一个比较容易理解和使用的设计模式，策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。</li>
<li>在策略模式中，应当由客户端自己决定在什么情况下使用什么具体策略角色。</li>
<li>策略模式仅仅封装算法，提供新算法插入到已有系统中，以及老算法从系统中“退休”的方便，策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定。这在一定程度上提高了系统的灵活性，但是客户端需要理解所有具体策略类之间的区别，以便选择合适的算法，这也是策略模式的缺点之一，在一定程度上增加了客户端的使用难度。</li>
</ul>
<h3 id="优点" tabindex="-1"> 优点</h3>
<ul>
<li>策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。</li>
<li>策略模式提供了管理相关的算法族的办法。</li>
<li>策略模式提供了可以替换继承关系的办法。</li>
<li>使用策略模式可以避免使用多重条件转移语句。</li>
<li>结合简单工厂模式和Annotation，策略模式可以方便的在不修改客户端代码的前提下切换算法（策略）</li>
</ul>
<h3 id="缺点" tabindex="-1"> 缺点</h3>
<ul>
<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li>
<li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</li>
</ul>
<h3 id="oop原则" tabindex="-1"> OOP原则</h3>
<p><strong>已遵循的OOP原则</strong></p>
<ul>
<li>依赖倒置原则</li>
<li>迪米特法则</li>
<li>里氏替换原则</li>
<li>接口隔离原则</li>
<li>单一职责原则</li>
<li>开闭原则</li>
</ul>
<p><strong>未遵循的OOP原则</strong></p>
<ul>
<li>NA</li>
</ul>
<h3 id="适用环境" tabindex="-1"> 适用环境</h3>
<ul>
<li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li>
<li>一个系统需要动态地在几种算法中选择一种。</li>
<li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li>
<li>不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。</li>
</ul>
<h3 id="与状态模式的比较" tabindex="-1"> 与状态模式的比较</h3>
<p>状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。</p>
<p>状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。</p>
<h2 id="应用" tabindex="-1"> 应用</h2>
<h3 id="模式扩展" tabindex="-1"> 模式扩展</h3>
<p><strong>策略模式与状态模式</strong></p>
<ul>
<li>可以通过环境类状态的个数来决定是使用策略模式还是状态模式。</li>
<li>策略模式的环境类自己选择一个具体策略类，具体策略类无须关心环境类；而状态模式的环境类由于外在因素需要放进一个具体状态中，以便通过其方法实现状态的切换，因此环境类和状态类之间存在一种双向的关联关系。</li>
<li>使用策略模式时，客户端需要知道所选的具体策略是哪一个，而使用状态模式时，客户端无须关心具体状态，环境类的状态会根据用户的操作自动转换。</li>
<li>如果系统中某个类的对象存在多种状态，不同状态下行为有差异，而且这些状态之间可以发生转换时使用状态模式；如果系统中某个类的某一行为存在多种实现方式，而且这些实现方式可以互换时使用策略模式。</li>
</ul>
<h3 id="开发场景" tabindex="-1"> 开发场景</h3>
<ul>
<li>JAVASE中GUI编程中，布局管理</li>
<li>Spring框架中，Resource接口，资源访问策略</li>
<li>javax.servlet.http.HttpServlet#service()</li>
</ul>
<h3 id="jdk" tabindex="-1"> JDK</h3>
<ul>
<li>java.util.Comparator#compare()</li>
<li>javax.servlet.http.HttpServlet</li>
<li>javax.servlet.Filter#doFilter()</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>组合模式</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">组合模式</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="组合-composite" tabindex="-1"> 组合（Composite）</h1>
<h2 id="介绍" tabindex="-1"> 介绍</h2>
<h3 id="定义" tabindex="-1"> 定义</h3>
<p>将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。</p>
<p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<h3 id="类图" tabindex="-1"> 类图</h3>
<p>组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。</p>
<p>组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2b8bfd57-b4d1-4a75-bfb0-bcf1fba4014a.png"/> </div><br>
<h3 id="角色划分" tabindex="-1"> 角色划分</h3>
<ul>
<li>抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。</li>
<li>树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。</li>
<li>树枝构件（Composite）角色：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。</li>
</ul>
<h2 id="实现" tabindex="-1"> 实现</h2>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>Component</span> <span>{</span>
    <span>protected</span> <span>String</span> name<span>;</span>

    <span>public</span> <span>Component</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>print</span><span>(</span><span>)</span> <span>{</span>
        <span>print</span><span>(</span><span>0</span><span>)</span><span>;</span>
    <span>}</span>

    <span>abstract</span> <span>void</span> <span>print</span><span>(</span><span>int</span> level<span>)</span><span>;</span>

    <span>abstract</span> <span>public</span> <span>void</span> <span>add</span><span>(</span><span>Component</span> component<span>)</span><span>;</span>

    <span>abstract</span> <span>public</span> <span>void</span> <span>remove</span><span>(</span><span>Component</span> component<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Composite</span> <span>extends</span> <span>Component</span> <span>{</span>

    <span>private</span> <span>List</span><span><span>&lt;</span><span>Component</span><span>></span></span> child<span>;</span>

    <span>public</span> <span>Composite</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>super</span><span>(</span>name<span>)</span><span>;</span>
        child <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>void</span> <span>print</span><span>(</span><span>int</span> level<span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> level<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"--"</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Composite:"</span> <span>+</span> name<span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>Component</span> component <span>:</span> child<span>)</span> <span>{</span>
            component<span>.</span><span>print</span><span>(</span>level <span>+</span> <span>1</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>add</span><span>(</span><span>Component</span> component<span>)</span> <span>{</span>
        child<span>.</span><span>add</span><span>(</span>component<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>remove</span><span>(</span><span>Component</span> component<span>)</span> <span>{</span>
        child<span>.</span><span>remove</span><span>(</span>component<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Leaf</span> <span>extends</span> <span>Component</span> <span>{</span>
    <span>public</span> <span>Leaf</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>super</span><span>(</span>name<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>void</span> <span>print</span><span>(</span><span>int</span> level<span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> level<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"--"</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"left:"</span> <span>+</span> name<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>add</span><span>(</span><span>Component</span> component<span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>UnsupportedOperationException</span><span>(</span><span>)</span><span>;</span> <span>// 牺牲透明性换取单一职责原则，这样就不用考虑是叶子节点还是组合节点</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>remove</span><span>(</span><span>Component</span> component<span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>UnsupportedOperationException</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Composite</span> root <span>=</span> <span>new</span> <span>Composite</span><span>(</span><span>"root"</span><span>)</span><span>;</span>
        <span>Component</span> node1 <span>=</span> <span>new</span> <span>Leaf</span><span>(</span><span>"1"</span><span>)</span><span>;</span>
        <span>Component</span> node2 <span>=</span> <span>new</span> <span>Composite</span><span>(</span><span>"2"</span><span>)</span><span>;</span>
        <span>Component</span> node3 <span>=</span> <span>new</span> <span>Leaf</span><span>(</span><span>"3"</span><span>)</span><span>;</span>
        root<span>.</span><span>add</span><span>(</span>node1<span>)</span><span>;</span>
        root<span>.</span><span>add</span><span>(</span>node2<span>)</span><span>;</span>
        root<span>.</span><span>add</span><span>(</span>node3<span>)</span><span>;</span>
        <span>Component</span> node21 <span>=</span> <span>new</span> <span>Leaf</span><span>(</span><span>"21"</span><span>)</span><span>;</span>
        <span>Component</span> node22 <span>=</span> <span>new</span> <span>Composite</span><span>(</span><span>"22"</span><span>)</span><span>;</span>
        node2<span>.</span><span>add</span><span>(</span>node21<span>)</span><span>;</span>
        node2<span>.</span><span>add</span><span>(</span>node22<span>)</span><span>;</span>
        <span>Component</span> node221 <span>=</span> <span>new</span> <span>Leaf</span><span>(</span><span>"221"</span><span>)</span><span>;</span>
        node22<span>.</span><span>add</span><span>(</span>node221<span>)</span><span>;</span>
        root<span>.</span><span>print</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><div><pre><code>Composite:root
--left:1
--Composite:2
----left:21
----Composite:22
------left:221
--left:3
</code></pre></div><h2 id="分析" tabindex="-1"> 分析</h2>
<h3 id="优点" tabindex="-1"> 优点</h3>
<ul>
<li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</li>
<li>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</li>
</ul>
<h3 id="缺点" tabindex="-1"> 缺点</h3>
<ul>
<li>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</li>
<li>不容易限制容器中的构件；</li>
<li>不容易用继承的方法来增加构件的新功能；</li>
</ul>
<h3 id="适用场景" tabindex="-1"> 适用场景</h3>
<ul>
<li>在需要表示一个对象整体与部分的层次结构的场合。</li>
<li>要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合</li>
</ul>
<h2 id="应用" tabindex="-1"> 应用</h2>
<h3 id="开发场景" tabindex="-1"> 开发场景</h3>
<ul>
<li>操作系统的资源管理器</li>
<li>GUI中的容器层次图</li>
<li>XML文件解析 - OA系统中，组织结构的处理</li>
<li>Junit单元测试框架</li>
<li>底层设计就是典型的组合模式，TestCase(叶子)、TestUnite(容器) 、Test接口(抽象)</li>
</ul>
<h3 id="jdk" tabindex="-1"> JDK</h3>
<ul>
<li>javax.swing.JComponent#add(Component)</li>
<li>java.awt.Container#add(Component)</li>
<li>java.util.Map#putAll(Map)</li>
<li>java.util.List#addAll(Collection)</li>
<li>java.util.Set#addAll(Collection)</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>装饰模式</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">装饰模式</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="装饰-decorator" tabindex="-1"> 装饰（Decorator）</h1>
<h2 id="介绍" tabindex="-1"> 介绍</h2>
<h3 id="定义" tabindex="-1"> 定义</h3>
<p>为对象动态添加功能。</p>
<p>装饰（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式</p>
<h3 id="类图" tabindex="-1"> 类图</h3>
<p>装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component），具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6b833bc2-517a-4270-8a5e-0a5f6df8cd96.png"/> </div><br>
<h3 id="角色划分" tabindex="-1"> 角色划分</h3>
<ul>
<li>Component（被装饰对象的基类）：定义一个对象接口，可以给这些对象动态地添加职责。</li>
<li>ConcreteComponent（具体被装饰对象）：定义一个对象，可以给这个对象添加一些职责。</li>
<li>Decorator（装饰者抽象类）：维持一个指向Component实例的引用，并定义一个与Component接口一致的接口。</li>
<li>ConcreteDecorator（具体装饰者）：具体的装饰对象，给内部持有的具体被装饰对象，增加具体的职责。</li>
</ul>
<h2 id="实现" tabindex="-1"> 实现</h2>
<p>设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。</p>
<p>下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c9cfd600-bc91-4f3a-9f99-b42f88a5bb24.jpg" width="600"/> </div><br>
<p>Component</p>
<div><pre><code><span>public</span> <span>interface</span> <span>Beverage</span> <span>{</span>
    <span>double</span> <span>cost</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><p>ConcreteComponent</p>
<div><pre><code><span>public</span> <span>class</span> <span>DarkRoast</span> <span>implements</span> <span>Beverage</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>double</span> <span>cost</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>HouseBlend</span> <span>implements</span> <span>Beverage</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>double</span> <span>cost</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><p>Decorator</p>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>CondimentDecorator</span> <span>implements</span> <span>Beverage</span> <span>{</span>
    <span>protected</span> <span>Beverage</span> beverage<span>;</span>
<span>}</span>
</code></pre></div><p>ConcreteDecorator</p>
<div><pre><code><span>public</span> <span>class</span> <span>Milk</span> <span>extends</span> <span>CondimentDecorator</span> <span>{</span>

    <span>public</span> <span>Milk</span><span>(</span><span>Beverage</span> beverage<span>)</span> <span>{</span>
        <span>this</span><span>.</span>beverage <span>=</span> beverage<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>double</span> <span>cost</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>1</span> <span>+</span> beverage<span>.</span><span>cost</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Mocha</span> <span>extends</span> <span>CondimentDecorator</span> <span>{</span>

    <span>public</span> <span>Mocha</span><span>(</span><span>Beverage</span> beverage<span>)</span> <span>{</span>
        <span>this</span><span>.</span>beverage <span>=</span> beverage<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>double</span> <span>cost</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>1</span> <span>+</span> beverage<span>.</span><span>cost</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Beverage</span> beverage <span>=</span> <span>new</span> <span>HouseBlend</span><span>(</span><span>)</span><span>;</span>
        beverage <span>=</span> <span>new</span> <span>Mocha</span><span>(</span>beverage<span>)</span><span>;</span>
        beverage <span>=</span> <span>new</span> <span>Milk</span><span>(</span>beverage<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>beverage<span>.</span><span>cost</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code>3.0
</code></pre></div><h2 id="分析" tabindex="-1"> 分析</h2>
<h3 id="设计原则" tabindex="-1"> 设计原则</h3>
<p>类应该对扩展开放，对修改关闭：也就是添加新功能时不需要修改代码。饮料可以动态添加新的配料，而不需要去修改饮料的代码。</p>
<p>不可能把所有的类设计成都满足这一原则，应当把该原则应用于最有可能发生改变的地方。</p>
<h3 id="优点" tabindex="-1"> 优点</h3>
<ul>
<li>扩展对象功能，比继承灵活，不会导致类个数急剧增加</li>
<li>可以对一个对象进行多次装饰，创造出不同行为的组合，得到功能更加强大的对象</li>
<li>具体构建类和具体装饰类可以独立变化，用户可以根据需要自己增加新的具体构件子类和具体装饰子类。 缺点</li>
</ul>
<h3 id="缺点" tabindex="-1"> 缺点</h3>
<ul>
<li>产生很多小对象。大量小对象占据内存，一定程度上影响性能。</li>
<li>装饰模式易于出错，调试排查比较麻烦。</li>
<li>装饰模式增加了许多子类，如果过度使用会使程序变得很复杂</li>
</ul>
<h3 id="适用环境" tabindex="-1"> 适用环境</h3>
<ol>
<li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li>
<li>处理那些可以撤消的职责。</li>
<li>当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的 子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</li>
</ol>
<h3 id="和桥接模式的区别" tabindex="-1"> 和桥接模式的区别</h3>
<ul>
<li>两个模式都是为了解决过多子类对象问题。但他们的诱因不一样。桥模式是对象自身现有机制沿着多个维度变化，是既有部分不稳定。装饰模式是为了增加新的功能。</li>
</ul>
<h3 id="要点" tabindex="-1"> 要点</h3>
<ol>
<li>继承属于扩展形式之一，但不见得是达到弹性设计的最佳方案。</li>
<li>在我们的设计中，应该允许行为可以被扩展，而不须修改现有的代码。</li>
<li>组合和委托可用于在运行时动态地加上新的行为。</li>
<li>除了继承，装饰者模式也可以让我们扩展行为。</li>
<li>装饰者模式意味着一群装饰者类， 这些类用来包装具体组件。</li>
<li>装饰者类反映出被装饰的组件类型（实际上，他们具有相同的类型，都经过接口或继承实现）。</li>
<li>装饰者可以在被装饰者的行为前面与/或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的。</li>
<li>你可以有无数个装饰者包装一个组件。</li>
<li>装饰者一般对组建的客户是透明的，除非客户程序依赖于组件的具体类型。</li>
</ol>
<h2 id="应用" tabindex="-1"> 应用</h2>
<h3 id="开发场景" tabindex="-1"> 开发场景</h3>
<ul>
<li>IO中输入流和输出流的设计</li>
<li>Swing包中图形界面构件功能</li>
<li>Servlet API 中提供了一个request对象的Decorator设计模式的默认实现类HttpServletRequestWrapper，</li>
<li>HttpServletRequestWrapper 类，增强了request对象的功能。</li>
<li>Struts2中，request，response,session对象的处理</li>
</ul>
<h3 id="jdk" tabindex="-1"> JDK</h3>
<ul>
<li>java.io.BufferedInputStream(InputStream)</li>
<li>java.io.DataInputStream(InputStream)</li>
<li>java.io.BufferedOutputStream(OutputStream)</li>
<li>java.util.zip.ZipOutputStream(OutputStream)</li>
<li>java.util.Collections#checked<a href="">List|Map|Set|SortedSet|SortedMap</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>观察者模式</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">观察者模式</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="观察者-observer" tabindex="-1"> 观察者（Observer）</h1>
<h2 id="介绍" tabindex="-1"> 介绍</h2>
<h3 id="定义" tabindex="-1"> 定义</h3>
<p>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p>
<p><strong>模式动机</strong></p>
<p>建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。</p>
<p>主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7a3c6a30-c735-4edb-8115-337288a4f0f2.jpg" width="600"/> </div><br>
<h3 id="类图" tabindex="-1"> 类图</h3>
<p>主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。</p>
<p>观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a8c8f894-a712-447c-9906-5caef6a016e3.png"/> </div><br>
<h3 id="角色划分" tabindex="-1"> 角色划分</h3>
<ul>
<li>Subject: 目标</li>
<li>ConcreteSubject: 具体目标</li>
<li>Observer: 观察者</li>
<li>ConcreteObserver: 具体观察者</li>
</ul>
<h2 id="实现" tabindex="-1"> 实现</h2>
<p>天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1df9732-86ce-4d69-9f06-fba1db7b3b5a.jpg"/> </div><br>
<div><pre><code><span>public</span> <span>interface</span> <span>Subject</span> <span>{</span>
    <span>void</span> <span>registerObserver</span><span>(</span><span>Observer</span> o<span>)</span><span>;</span>

    <span>void</span> <span>removeObserver</span><span>(</span><span>Observer</span> o<span>)</span><span>;</span>

    <span>void</span> <span>notifyObserver</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>WeatherData</span> <span>implements</span> <span>Subject</span> <span>{</span>
    <span>private</span> <span>List</span><span><span>&lt;</span><span>Observer</span><span>></span></span> observers<span>;</span>
    <span>private</span> <span>float</span> temperature<span>;</span>
    <span>private</span> <span>float</span> humidity<span>;</span>
    <span>private</span> <span>float</span> pressure<span>;</span>

    <span>public</span> <span>WeatherData</span><span>(</span><span>)</span> <span>{</span>
        observers <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setMeasurements</span><span>(</span><span>float</span> temperature<span>,</span> <span>float</span> humidity<span>,</span> <span>float</span> pressure<span>)</span> <span>{</span>
        <span>this</span><span>.</span>temperature <span>=</span> temperature<span>;</span>
        <span>this</span><span>.</span>humidity <span>=</span> humidity<span>;</span>
        <span>this</span><span>.</span>pressure <span>=</span> pressure<span>;</span>
        <span>notifyObserver</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>registerObserver</span><span>(</span><span>Observer</span> o<span>)</span> <span>{</span>
        observers<span>.</span><span>add</span><span>(</span>o<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>removeObserver</span><span>(</span><span>Observer</span> o<span>)</span> <span>{</span>
        <span>int</span> i <span>=</span> observers<span>.</span><span>indexOf</span><span>(</span>o<span>)</span><span>;</span>
        <span>if</span> <span>(</span>i <span>>=</span> <span>0</span><span>)</span> <span>{</span>
            observers<span>.</span><span>remove</span><span>(</span>i<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>notifyObserver</span><span>(</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>Observer</span> o <span>:</span> observers<span>)</span> <span>{</span>
            o<span>.</span><span>update</span><span>(</span>temperature<span>,</span> humidity<span>,</span> pressure<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><div><pre><code><span>public</span> <span>interface</span> <span>Observer</span> <span>{</span>
    <span>void</span> <span>update</span><span>(</span><span>float</span> temp<span>,</span> <span>float</span> humidity<span>,</span> <span>float</span> pressure<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>StatisticsDisplay</span> <span>implements</span> <span>Observer</span> <span>{</span>

    <span>public</span> <span>StatisticsDisplay</span><span>(</span><span>Subject</span> weatherData<span>)</span> <span>{</span>
        weatherData<span>.</span><span>reisterObserver</span><span>(</span><span>this</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>update</span><span>(</span><span>float</span> temp<span>,</span> <span>float</span> humidity<span>,</span> <span>float</span> pressure<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"StatisticsDisplay.update: "</span> <span>+</span> temp <span>+</span> <span>" "</span> <span>+</span> humidity <span>+</span> <span>" "</span> <span>+</span> pressure<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>CurrentConditionsDisplay</span> <span>implements</span> <span>Observer</span> <span>{</span>

    <span>public</span> <span>CurrentConditionsDisplay</span><span>(</span><span>Subject</span> weatherData<span>)</span> <span>{</span>
        weatherData<span>.</span><span>registerObserver</span><span>(</span><span>this</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>update</span><span>(</span><span>float</span> temp<span>,</span> <span>float</span> humidity<span>,</span> <span>float</span> pressure<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"CurrentConditionsDisplay.update: "</span> <span>+</span> temp <span>+</span> <span>" "</span> <span>+</span> humidity <span>+</span> <span>" "</span> <span>+</span> pressure<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>WeatherStation</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>WeatherData</span> weatherData <span>=</span> <span>new</span> <span>WeatherData</span><span>(</span><span>)</span><span>;</span>
        <span>CurrentConditionsDisplay</span> currentConditionsDisplay <span>=</span> <span>new</span> <span>CurrentConditionsDisplay</span><span>(</span>weatherData<span>)</span><span>;</span>
        <span>StatisticsDisplay</span> statisticsDisplay <span>=</span> <span>new</span> <span>StatisticsDisplay</span><span>(</span>weatherData<span>)</span><span>;</span>

        weatherData<span>.</span><span>setMeasurements</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span><span>;</span>
        weatherData<span>.</span><span>setMeasurements</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code>CurrentConditionsDisplay.update: 0.0 0.0 0.0
StatisticsDisplay.update: 0.0 0.0 0.0
CurrentConditionsDisplay.update: 1.0 1.0 1.0
StatisticsDisplay.update: 1.0 1.0 1.0
</code></pre></div><h2 id="分析" tabindex="-1"> 分析</h2>
<ul>
<li>观察者模式描述了如何建立对象与对象之间的依赖关系，如何构造满足这种需求的系统。</li>
<li>这一模式中的关键对象是观察目标和观察者，一个目标可以有任意数目的与之相依赖的观察者，一旦目标的状态发生改变，所有的观察者都将得到通知。</li>
<li>作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步，这种交互也称为发布-订阅(publishsubscribe)。目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通</li>
</ul>
<h3 id="优点" tabindex="-1"> 优点</h3>
<ul>
<li>观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。</li>
<li>观察者模式在观察目标和观察者之间建立一个抽象的耦合。</li>
<li>观察者模式支持广播通信。</li>
<li>观察者模式符合“开闭原则”的要求。</li>
</ul>
<h3 id="缺点" tabindex="-1"> 缺点</h3>
<ul>
<li>如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li>
<li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li>
<li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li>
<li>如果某些观察者的响应方法被阻塞，整个通知过程即被阻塞，其它观察者不能及时被通知</li>
</ul>
<h3 id="oop原则" tabindex="-1"> OOP原则</h3>
<p><strong>已遵循的OOP原则</strong></p>
<ul>
<li>依赖倒置原则</li>
<li>迪米特法则</li>
<li>里氏替换原则</li>
<li>接口隔离原则</li>
<li>单一职责原则</li>
<li>开闭原则</li>
</ul>
<p><strong>未遵循的OOP原则</strong></p>
<ul>
<li>NA</li>
</ul>
<h3 id="适用环境" tabindex="-1"> 适用环境</h3>
<ul>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li>
<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li>
<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li>
</ul>
<h2 id="应用" tabindex="-1"> 应用</h2>
<h3 id="开发场景" tabindex="-1"> 开发场景</h3>
<ul>
<li>聊天室程序的，服务器转发给所有客户端</li>
<li>电子商务网站可以在执行发送操作后给用户多个发送商品打折信息</li>
<li>网络游戏(多人联机对战)场景中，服务器将客户端的状态进行分发</li>
<li>邮件订阅</li>
<li>Servlet中，监听器的实现</li>
<li>Android中，广播机制</li>
<li>JDK的AWT中事件处理模型,基于观察者模式的委派事件模型(Delegation Event Model)
<ul>
<li>事件源—————-目标对象</li>
<li>事件监听器————观察者</li>
</ul>
</li>
</ul>
<h3 id="模式扩展" tabindex="-1"> 模式扩展</h3>
<p>MVC模式是一种架构模式，它包含三个角色：模型(Model)，视图(View)和控制器(Controller)。观察者模式可以用来实现MVC模式，观察者模式中的观察目标就是MVC模式中的模型(Model)，而观察者就是MVC中的视图(View)，控制器(Controller)充当两者之间的中介者(Mediator)。当模型层的数据发生改变时，视图层将自动改变其显示内容。</p>
<h3 id="jdk" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Observer.html" target="_blank" rel="noopener noreferrer">java.util.Observer</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/EventListener.html" target="_blank" rel="noopener noreferrer">java.util.EventListener</a></li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionBindingListener.html" target="_blank" rel="noopener noreferrer">javax.servlet.http.HttpSessionBindingListener</a></li>
<li><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener noreferrer">RxJava</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>解释器模式</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">解释器模式</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="解释器-interpreter" tabindex="-1"> 解释器（Interpreter）</h1>
<h2 id="介绍" tabindex="-1"> 介绍</h2>
<h3 id="定义" tabindex="-1"> 定义</h3>
<p>为语言创建解释器，通常由语言的语法和语法分析来定义。</p>
<p>解释器（Interpreter）模式的定义：给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。</p>
<h3 id="类图" tabindex="-1"> 类图</h3>
<ul>
<li>TerminalExpression：终结符表达式，每个终结符都需要一个 TerminalExpression。</li>
<li>Context：上下文，包含解释器之外的一些全局信息。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2b125bcd-1b36-43be-9b78-d90b076be549.png"/> </div><br>
<h3 id="角色划分" tabindex="-1"> 角色划分</h3>
<ul>
<li>抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。</li>
<li>终结符表达式（Terminal    Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。</li>
<li>非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</li>
<li>环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</li>
<li>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</li>
</ul>
<h2 id="实现" tabindex="-1"> 实现</h2>
<p>以下是一个规则检验器实现，具有 and 和 or 规则，通过规则可以构建一颗解析树，用来检验一个文本是否满足解析树定义的规则。</p>
<p>例如一颗解析树为 D And (A Or (B C))，文本 &quot;D A&quot; 满足该解析树定义的规则。</p>
<p>这里的 Context 指的是 String。</p>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>Expression</span> <span>{</span>
    <span>public</span> <span>abstract</span> <span>boolean</span> <span>interpret</span><span>(</span><span>String</span> str<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>TerminalExpression</span> <span>extends</span> <span>Expression</span> <span>{</span>

    <span>private</span> <span>String</span> literal <span>=</span> <span>null</span><span>;</span>

    <span>public</span> <span>TerminalExpression</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
        literal <span>=</span> str<span>;</span>
    <span>}</span>

    <span>public</span> <span>boolean</span> <span>interpret</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
        <span>StringTokenizer</span> st <span>=</span> <span>new</span> <span>StringTokenizer</span><span>(</span>str<span>)</span><span>;</span>
        <span>while</span> <span>(</span>st<span>.</span><span>hasMoreTokens</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>String</span> test <span>=</span> st<span>.</span><span>nextToken</span><span>(</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>test<span>.</span><span>equals</span><span>(</span>literal<span>)</span><span>)</span> <span>{</span>
                <span>return</span> <span>true</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>AndExpression</span> <span>extends</span> <span>Expression</span> <span>{</span>

    <span>private</span> <span>Expression</span> expression1 <span>=</span> <span>null</span><span>;</span>
    <span>private</span> <span>Expression</span> expression2 <span>=</span> <span>null</span><span>;</span>

    <span>public</span> <span>AndExpression</span><span>(</span><span>Expression</span> expression1<span>,</span> <span>Expression</span> expression2<span>)</span> <span>{</span>
        <span>this</span><span>.</span>expression1 <span>=</span> expression1<span>;</span>
        <span>this</span><span>.</span>expression2 <span>=</span> expression2<span>;</span>
    <span>}</span>

    <span>public</span> <span>boolean</span> <span>interpret</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
        <span>return</span> expression1<span>.</span><span>interpret</span><span>(</span>str<span>)</span> <span>&amp;&amp;</span> expression2<span>.</span><span>interpret</span><span>(</span>str<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>OrExpression</span> <span>extends</span> <span>Expression</span> <span>{</span>
    <span>private</span> <span>Expression</span> expression1 <span>=</span> <span>null</span><span>;</span>
    <span>private</span> <span>Expression</span> expression2 <span>=</span> <span>null</span><span>;</span>

    <span>public</span> <span>OrExpression</span><span>(</span><span>Expression</span> expression1<span>,</span> <span>Expression</span> expression2<span>)</span> <span>{</span>
        <span>this</span><span>.</span>expression1 <span>=</span> expression1<span>;</span>
        <span>this</span><span>.</span>expression2 <span>=</span> expression2<span>;</span>
    <span>}</span>

    <span>public</span> <span>boolean</span> <span>interpret</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
        <span>return</span> expression1<span>.</span><span>interpret</span><span>(</span>str<span>)</span> <span>||</span> expression2<span>.</span><span>interpret</span><span>(</span>str<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>/**
     * 构建解析树
     */</span>
    <span>public</span> <span>static</span> <span>Expression</span> <span>buildInterpreterTree</span><span>(</span><span>)</span> <span>{</span>
        <span>// Literal</span>
        <span>Expression</span> terminal1 <span>=</span> <span>new</span> <span>TerminalExpression</span><span>(</span><span>"A"</span><span>)</span><span>;</span>
        <span>Expression</span> terminal2 <span>=</span> <span>new</span> <span>TerminalExpression</span><span>(</span><span>"B"</span><span>)</span><span>;</span>
        <span>Expression</span> terminal3 <span>=</span> <span>new</span> <span>TerminalExpression</span><span>(</span><span>"C"</span><span>)</span><span>;</span>
        <span>Expression</span> terminal4 <span>=</span> <span>new</span> <span>TerminalExpression</span><span>(</span><span>"D"</span><span>)</span><span>;</span>
        <span>// B C</span>
        <span>Expression</span> alternation1 <span>=</span> <span>new</span> <span>OrExpression</span><span>(</span>terminal2<span>,</span> terminal3<span>)</span><span>;</span>
        <span>// A Or (B C)</span>
        <span>Expression</span> alternation2 <span>=</span> <span>new</span> <span>OrExpression</span><span>(</span>terminal1<span>,</span> alternation1<span>)</span><span>;</span>
        <span>// D And (A Or (B C))</span>
        <span>return</span> <span>new</span> <span>AndExpression</span><span>(</span>terminal4<span>,</span> alternation2<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Expression</span> define <span>=</span> <span>buildInterpreterTree</span><span>(</span><span>)</span><span>;</span>
        <span>String</span> context1 <span>=</span> <span>"D A"</span><span>;</span>
        <span>String</span> context2 <span>=</span> <span>"A B"</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>define<span>.</span><span>interpret</span><span>(</span>context1<span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>define<span>.</span><span>interpret</span><span>(</span>context2<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><div><pre><code>true
false
</code></pre></div><h2 id="分析" tabindex="-1"> 分析</h2>
<h3 id="优点" tabindex="-1"> 优点</h3>
<ul>
<li>扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。</li>
<li>容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。</li>
</ul>
<h3 id="缺点" tabindex="-1"> 缺点</h3>
<ul>
<li>执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。</li>
<li>会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。</li>
<li>可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。</li>
</ul>
<h3 id="适用场景" tabindex="-1"> 适用场景</h3>
<ul>
<li>当语言的文法较为简单，且执行效率不是关键问题时。</li>
<li>当问题重复出现，且可以用一种简单的语言来进行表达时。</li>
<li>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候，如 XML 文档解释。</li>
</ul>
<p><strong>注意</strong>：解释器模式在实际的软件开发中使用比较少，因为它会引起效率、性能以及维护等问题。</p>
<h2 id="应用" tabindex="-1"> 应用</h2>
<h3 id="开发场景" tabindex="-1"> 开发场景</h3>
<ul>
<li>EL表达式式的处理</li>
<li>正则表达式解释器</li>
<li>SQL语法的解释器</li>
<li>数学表达式解析器
<ul>
<li>如现成的工具包:Math Expression String Parser、Expression4J等。</li>
</ul>
</li>
</ul>
<h3 id="jdk" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html" target="_blank" rel="noopener noreferrer">java.util.Pattern</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/text/Normalizer.html" target="_blank" rel="noopener noreferrer">java.text.Normalizer</a></li>
<li>All subclasses of <a href="http://docs.oracle.com/javase/8/docs/api/java/text/Format.html" target="_blank" rel="noopener noreferrer">java.text.Format</a></li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/el/ELResolver.html" target="_blank" rel="noopener noreferrer">javax.el.ELResolver</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>访问者模式</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">访问者模式</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="访问者-visitor" tabindex="-1"> 访问者（Visitor）</h1>
<h2 id="介绍" tabindex="-1"> 介绍</h2>
<h3 id="定义" tabindex="-1"> 定义</h3>
<p>为一个对象结构（比如组合结构）增加新能力。</p>
<p>访问者（Visitor）模式的定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。</p>
<h3 id="类图" tabindex="-1"> 类图</h3>
<ul>
<li>Visitor：访问者，为每一个 ConcreteElement 声明一个 visit 操作</li>
<li>ConcreteVisitor：具体访问者，存储遍历过程中的累计结果</li>
<li>ObjectStructure：对象结构，可以是组合结构，或者是一个集合。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/79c6f036-bde6-4393-85a3-ef36a0327bd2.png"/> </div><br>
<h3 id="角色划分" tabindex="-1"> 角色划分</h3>
<ul>
<li>抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。</li>
<li>具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。</li>
<li>抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。</li>
<li>具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。</li>
<li>对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。</li>
</ul>
<h2 id="实现" tabindex="-1"> 实现</h2>
<p>访问者（Visitor）模式实现的关键是如何将作用于元素的操作分离出来封装成独立的类</p>
<div><pre><code><span>public</span> <span>interface</span> <span>Element</span> <span>{</span>
    <span>void</span> <span>accept</span><span>(</span><span>Visitor</span> visitor<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>class</span> <span>CustomerGroup</span> <span>{</span>

    <span>private</span> <span>List</span><span><span>&lt;</span><span>Customer</span><span>></span></span> customers <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

    <span>void</span> <span>accept</span><span>(</span><span>Visitor</span> visitor<span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>Customer</span> customer <span>:</span> customers<span>)</span> <span>{</span>
            customer<span>.</span><span>accept</span><span>(</span>visitor<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>void</span> <span>addCustomer</span><span>(</span><span>Customer</span> customer<span>)</span> <span>{</span>
        customers<span>.</span><span>add</span><span>(</span>customer<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Customer</span> <span>implements</span> <span>Element</span> <span>{</span>

    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>List</span><span><span>&lt;</span><span>Order</span><span>></span></span> orders <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

    <span>Customer</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>void</span> <span>addOrder</span><span>(</span><span>Order</span> order<span>)</span> <span>{</span>
        orders<span>.</span><span>add</span><span>(</span>order<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>accept</span><span>(</span><span>Visitor</span> visitor<span>)</span> <span>{</span>
        visitor<span>.</span><span>visit</span><span>(</span><span>this</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>Order</span> order <span>:</span> orders<span>)</span> <span>{</span>
            order<span>.</span><span>accept</span><span>(</span>visitor<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Order</span> <span>implements</span> <span>Element</span> <span>{</span>

    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>List</span><span><span>&lt;</span><span>Item</span><span>></span></span> items <span>=</span> <span>new</span> <span>ArrayList</span><span>(</span><span>)</span><span>;</span>

    <span>Order</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>Order</span><span>(</span><span>String</span> name<span>,</span> <span>String</span> itemName<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>this</span><span>.</span><span>addItem</span><span>(</span><span>new</span> <span>Item</span><span>(</span>itemName<span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>void</span> <span>addItem</span><span>(</span><span>Item</span> item<span>)</span> <span>{</span>
        items<span>.</span><span>add</span><span>(</span>item<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>accept</span><span>(</span><span>Visitor</span> visitor<span>)</span> <span>{</span>
        visitor<span>.</span><span>visit</span><span>(</span><span>this</span><span>)</span><span>;</span>

        <span>for</span> <span>(</span><span>Item</span> item <span>:</span> items<span>)</span> <span>{</span>
            item<span>.</span><span>accept</span><span>(</span>visitor<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Item</span> <span>implements</span> <span>Element</span> <span>{</span>

    <span>private</span> <span>String</span> name<span>;</span>

    <span>Item</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>accept</span><span>(</span><span>Visitor</span> visitor<span>)</span> <span>{</span>
        visitor<span>.</span><span>visit</span><span>(</span><span>this</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><div><pre><code><span>public</span> <span>interface</span> <span>Visitor</span> <span>{</span>
    <span>void</span> <span>visit</span><span>(</span><span>Customer</span> customer<span>)</span><span>;</span>

    <span>void</span> <span>visit</span><span>(</span><span>Order</span> order<span>)</span><span>;</span>

    <span>void</span> <span>visit</span><span>(</span><span>Item</span> item<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>GeneralReport</span> <span>implements</span> <span>Visitor</span> <span>{</span>

    <span>private</span> <span>int</span> customersNo<span>;</span>
    <span>private</span> <span>int</span> ordersNo<span>;</span>
    <span>private</span> <span>int</span> itemsNo<span>;</span>

    <span>public</span> <span>void</span> <span>visit</span><span>(</span><span>Customer</span> customer<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>customer<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        customersNo<span>++</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>visit</span><span>(</span><span>Order</span> order<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>order<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        ordersNo<span>++</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>visit</span><span>(</span><span>Item</span> item<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>item<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        itemsNo<span>++</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>displayResults</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Number of customers: "</span> <span>+</span> customersNo<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Number of orders:    "</span> <span>+</span> ordersNo<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Number of items:     "</span> <span>+</span> itemsNo<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Customer</span> customer1 <span>=</span> <span>new</span> <span>Customer</span><span>(</span><span>"customer1"</span><span>)</span><span>;</span>
        customer1<span>.</span><span>addOrder</span><span>(</span><span>new</span> <span>Order</span><span>(</span><span>"order1"</span><span>,</span> <span>"item1"</span><span>)</span><span>)</span><span>;</span>
        customer1<span>.</span><span>addOrder</span><span>(</span><span>new</span> <span>Order</span><span>(</span><span>"order2"</span><span>,</span> <span>"item1"</span><span>)</span><span>)</span><span>;</span>
        customer1<span>.</span><span>addOrder</span><span>(</span><span>new</span> <span>Order</span><span>(</span><span>"order3"</span><span>,</span> <span>"item1"</span><span>)</span><span>)</span><span>;</span>

        <span>Order</span> order <span>=</span> <span>new</span> <span>Order</span><span>(</span><span>"order_a"</span><span>)</span><span>;</span>
        order<span>.</span><span>addItem</span><span>(</span><span>new</span> <span>Item</span><span>(</span><span>"item_a1"</span><span>)</span><span>)</span><span>;</span>
        order<span>.</span><span>addItem</span><span>(</span><span>new</span> <span>Item</span><span>(</span><span>"item_a2"</span><span>)</span><span>)</span><span>;</span>
        order<span>.</span><span>addItem</span><span>(</span><span>new</span> <span>Item</span><span>(</span><span>"item_a3"</span><span>)</span><span>)</span><span>;</span>
        <span>Customer</span> customer2 <span>=</span> <span>new</span> <span>Customer</span><span>(</span><span>"customer2"</span><span>)</span><span>;</span>
        customer2<span>.</span><span>addOrder</span><span>(</span>order<span>)</span><span>;</span>

        <span>CustomerGroup</span> customers <span>=</span> <span>new</span> <span>CustomerGroup</span><span>(</span><span>)</span><span>;</span>
        customers<span>.</span><span>addCustomer</span><span>(</span>customer1<span>)</span><span>;</span>
        customers<span>.</span><span>addCustomer</span><span>(</span>customer2<span>)</span><span>;</span>

        <span>GeneralReport</span> visitor <span>=</span> <span>new</span> <span>GeneralReport</span><span>(</span><span>)</span><span>;</span>
        customers<span>.</span><span>accept</span><span>(</span>visitor<span>)</span><span>;</span>
        visitor<span>.</span><span>displayResults</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><div><pre><code>customer1
order1
item1
order2
item1
order3
item1
customer2
order_a
item_a1
item_a2
item_a3
Number of customers: 2
Number of orders:    4
Number of items:     6
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="分析" tabindex="-1"> 分析</h2>
<h3 id="优点" tabindex="-1"> 优点</h3>
<ul>
<li>扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</li>
<li>复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。</li>
<li>灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。</li>
<li>符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。</li>
</ul>
<h3 id="缺点" tabindex="-1"> 缺点</h3>
<ul>
<li>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。</li>
<li>破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。</li>
<li>违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。</li>
</ul>
<h3 id="适用场景" tabindex="-1"> 适用场景</h3>
<ul>
<li>对象结构相对稳定，但其操作算法经常变化的程序。</li>
<li>对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。</li>
<li>对象结构包含很多类型的对象，希望对这些对象实施一些依赖于其具体类型的操作。</li>
</ul>
<h2 id="应用" tabindex="-1"> 应用</h2>
<h3 id="模式扩展" tabindex="-1"> 模式扩展</h3>
<p>访问者（Visitor）模式是使用频率较高的一种设计模式，它常常同以下两种设计模式联用</p>
<ul>
<li>与“迭代器模式”联用。因为访问者模式中的“对象结构”是一个包含元素角色的容器，当访问者遍历容器中的所有元素时，常常要用迭代器。</li>
<li>同“组合模式”联用。因为访问者（Visitor）模式中的“元素对象”可能是叶子对象或者是容器对象，如果元素对象包含容器对象，就必须用到组合模式</li>
</ul>
<div align="center">
<p><img src="@source/assets/cs-note/oop-pattern/访问者-组合模式.gif" alt="" loading="lazy"></p>
</div>
<h3 id="开发场景" tabindex="-1"> 开发场景</h3>
<ul>
<li>XML文档解析器设计</li>
<li>编译器的设计</li>
<li>复杂集合对象的处理</li>
</ul>
<h3 id="jdk" tabindex="-1"> JDK</h3>
<ul>
<li>javax.lang.model.element.Element and javax.lang.model.element.ElementVisitor</li>
<li>javax.lang.model.type.TypeMirror and javax.lang.model.type.TypeVisitor</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>责任链模式</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">责任链模式</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="责任链-chain-of-responsibility" tabindex="-1"> 责任链（Chain Of Responsibility）</h1>
<h2 id="介绍" tabindex="-1"> 介绍</h2>
<h3 id="定义" tabindex="-1"> 定义</h3>
<p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。</p>
<h3 id="类图" tabindex="-1"> 类图</h3>
<ul>
<li>Handler：定义处理请求的接口，并且实现后继链（successor）</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ca9f23bf-55a4-47b2-9534-a28e35397988.png"/> </div><br>
<h3 id="角色划分" tabindex="-1"> 角色划分</h3>
<ul>
<li>抽象处理者角色(Handler)：定义出一个处理请求的接口。如果需要，接口可以定义出一个方法以设定和返回对下家的引用。这个角色通常由一个Java抽象类或者Java接口实现。</li>
<li>具体处理者角色(ConcreteHandler)：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，</li>
</ul>
<h3 id="实现" tabindex="-1"> 实现</h3>
<p>抽象处理角色</p>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>Handler</span> <span>{</span>

    <span>protected</span> <span>Handler</span> successor<span>;</span>


    <span>public</span> <span>Handler</span><span>(</span><span>Handler</span> successor<span>)</span> <span>{</span>
        <span>this</span><span>.</span>successor <span>=</span> successor<span>;</span>
    <span>}</span>


    <span>protected</span> <span>abstract</span> <span>void</span> <span>handleRequest</span><span>(</span><span>Request</span> request<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>具体处理角色</p>
<div><pre><code><span>public</span> <span>class</span> <span>ConcreteHandler1</span> <span>extends</span> <span>Handler</span> <span>{</span>

    <span>public</span> <span>ConcreteHandler1</span><span>(</span><span>Handler</span> successor<span>)</span> <span>{</span>
        <span>super</span><span>(</span>successor<span>)</span><span>;</span>
    <span>}</span>


    <span>@Override</span>
    <span>protected</span> <span>void</span> <span>handleRequest</span><span>(</span><span>Request</span> request<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>request<span>.</span><span>getType</span><span>(</span><span>)</span> <span>==</span> <span>RequestType</span><span>.</span>TYPE1<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>request<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>" is handle by ConcreteHandler1"</span><span>)</span><span>;</span>
            <span>return</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>successor <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            successor<span>.</span><span>handleRequest</span><span>(</span>request<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteHandler2</span> <span>extends</span> <span>Handler</span> <span>{</span>

    <span>public</span> <span>ConcreteHandler2</span><span>(</span><span>Handler</span> successor<span>)</span> <span>{</span>
        <span>super</span><span>(</span>successor<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>protected</span> <span>void</span> <span>handleRequest</span><span>(</span><span>Request</span> request<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>request<span>.</span><span>getType</span><span>(</span><span>)</span> <span>==</span> <span>RequestType</span><span>.</span>TYPE2<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>request<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>" is handle by ConcreteHandler2"</span><span>)</span><span>;</span>
            <span>return</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>successor <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            successor<span>.</span><span>handleRequest</span><span>(</span>request<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Request</span> <span>{</span>

    <span>private</span> <span>RequestType</span> type<span>;</span>
    <span>private</span> <span>String</span> name<span>;</span>

    <span>public</span> <span>Request</span><span>(</span><span>RequestType</span> type<span>,</span> <span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>type <span>=</span> type<span>;</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>RequestType</span> <span>getType</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> type<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><div><pre><code><span>public</span> <span>enum</span> <span>RequestType</span> <span>{</span>
    TYPE1<span>,</span> TYPE2
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>

        <span>Handler</span> handler1 <span>=</span> <span>new</span> <span>ConcreteHandler1</span><span>(</span><span>null</span><span>)</span><span>;</span>
        <span>Handler</span> handler2 <span>=</span> <span>new</span> <span>ConcreteHandler2</span><span>(</span>handler1<span>)</span><span>;</span>

        <span>Request</span> request1 <span>=</span> <span>new</span> <span>Request</span><span>(</span><span>RequestType</span><span>.</span>TYPE1<span>,</span> <span>"request1"</span><span>)</span><span>;</span>
        handler2<span>.</span><span>handleRequest</span><span>(</span>request1<span>)</span><span>;</span>

        <span>Request</span> request2 <span>=</span> <span>new</span> <span>Request</span><span>(</span><span>RequestType</span><span>.</span>TYPE2<span>,</span> <span>"request2"</span><span>)</span><span>;</span>
        handler2<span>.</span><span>handleRequest</span><span>(</span>request2<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code>request1 is handle by ConcreteHandler1
request2 is handle by ConcreteHandler2
</code></pre></div><h2 id="分析" tabindex="-1"> 分析</h2>
<p><strong>职责链灵活性</strong></p>
<ul>
<li>改变内部的传递规则</li>
<li>可以从职责链任何一关开始</li>
<li>用与不用的区别：不用职责链的结构，我们需要和公司中的每一个层级都发生耦合关系</li>
</ul>
<p><strong>纯的与不纯的责任链模式</strong></p>
<p>一个纯的责任链模式要求一个具体的处理者对象只能在两个行为中选择一个：一是承担责任，而是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又把责任向下传的情况。</p>
<p>在一个纯的责任链模式里面，一个请求必须被某一个处理者对象所接收；在一个不纯的责任链模式里面，一个请求可以最终不被任何接收端对象所接收。</p>
<h2 id="应用" tabindex="-1"> 应用</h2>
<h3 id="开发场景" tabindex="-1"> 开发场景</h3>
<ul>
<li>Java中，异常机制就是一种责任链模式。一个try可以对应多个catch，当第一个catch不匹配类型，则自动跳到第二个catch.</li>
<li>Javascript语言中，事件的冒泡和捕获机制。Java语言中，事件的处理采用责任链模式。</li>
<li>Servlet开发中，过滤器的链式处理</li>
<li>Struts2中，拦截器的调用也是典型的责任链模式</li>
<li>dubbo中的filter</li>
<li>mybatis中的plugin</li>
</ul>
<h3 id="jdk" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/logging/Logger.html#log%28java.util.logging.Level,%20java.lang.String%29" target="_blank" rel="noopener noreferrer">java.util.logging.Logger#log()</a></li>
<li><a href="https://commons.apache.org/proper/commons-chain/index.html" target="_blank" rel="noopener noreferrer">Apache Commons Chain</a></li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/Filter.html#doFilter-javax.servlet.ServletRequest-javax.servlet.ServletResponse-javax.servlet.FilterChain-" target="_blank" rel="noopener noreferrer">javax.servlet.Filter#doFilter()</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>迭代器模式</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">迭代器模式</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="迭代器-iterator" tabindex="-1"> 迭代器（Iterator）</h1>
<h2 id="介绍" tabindex="-1"> 介绍</h2>
<h3 id="定义" tabindex="-1"> 定义</h3>
<p>提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。</p>
<p>迭代器模式是通过将聚合对象的遍历行为分离出来，抽象成迭代器类来实现的，其目的是在不暴露聚合对象的内部结构的情况下，让外部代码透明地访问聚合的内部数据。</p>
<h3 id="类图" tabindex="-1"> 类图</h3>
<ul>
<li>Aggregate 是聚合类，其中 createIterator() 方法可以产生一个 Iterator；</li>
<li>Iterator 主要定义了 hasNext() 和 next() 方法。</li>
<li>Client 组合了 Aggregate，为了迭代遍历 Aggregate，也需要组合 Iterator。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/89292ae1-5f13-44dc-b508-3f035e80bf89.png"/> </div><br>
<h3 id="角色划分" tabindex="-1"> 角色划分</h3>
<ul>
<li>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。</li>
<li>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</li>
<li>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。</li>
<li>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</li>
</ul>
<h2 id="实现" tabindex="-1"> 实现</h2>
<div><pre><code><span>public</span> <span>interface</span> <span>Aggregate</span> <span>{</span>
    <span>Iterator</span> <span>createIterator</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteAggregate</span> <span>implements</span> <span>Aggregate</span> <span>{</span>

    <span>private</span> <span>Integer</span><span>[</span><span>]</span> items<span>;</span>

    <span>public</span> <span>ConcreteAggregate</span><span>(</span><span>)</span> <span>{</span>
        items <span>=</span> <span>new</span> <span>Integer</span><span>[</span><span>10</span><span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> items<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            items<span>[</span>i<span>]</span> <span>=</span> i<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>Iterator</span> <span>createIterator</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ConcreteIterator</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span>items<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><div><pre><code><span>public</span> <span>interface</span> <span>Iterator</span><span><span>&lt;</span><span>Item</span><span>></span></span> <span>{</span>

    <span>Item</span> <span>next</span><span>(</span><span>)</span><span>;</span>

    <span>boolean</span> <span>hasNext</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteIterator</span><span><span>&lt;</span><span>Item</span><span>></span></span> <span>implements</span> <span>Iterator</span> <span>{</span>

    <span>private</span> <span>Item</span><span>[</span><span>]</span> items<span>;</span>
    <span>private</span> <span>int</span> position <span>=</span> <span>0</span><span>;</span>

    <span>public</span> <span>ConcreteIterator</span><span>(</span><span>Item</span><span>[</span><span>]</span> items<span>)</span> <span>{</span>
        <span>this</span><span>.</span>items <span>=</span> items<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>Object</span> <span>next</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> items<span>[</span>position<span>++</span><span>]</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>boolean</span> <span>hasNext</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> position <span>&lt;</span> items<span>.</span>length<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Aggregate</span> aggregate <span>=</span> <span>new</span> <span>ConcreteAggregate</span><span>(</span><span>)</span><span>;</span>
        <span>Iterator</span><span><span>&lt;</span><span>Integer</span><span>></span></span> iterator <span>=</span> aggregate<span>.</span><span>createIterator</span><span>(</span><span>)</span><span>;</span>
        <span>while</span> <span>(</span>iterator<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="分析" tabindex="-1"> 分析</h2>
<h3 id="优点" tabindex="-1"> 优点</h3>
<ul>
<li>访问一个聚合对象的内容而无须暴露它的内部表示。</li>
<li>遍历任务交由迭代器完成，这简化了聚合类。</li>
<li>它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。</li>
<li>增加新的聚合类和迭代器类都很方便，无须修改原有代码。</li>
<li>封装性良好，为遍历不同的聚合结构提供一个统一的接口。</li>
</ul>
<h3 id="缺点" tabindex="-1"> 缺点</h3>
<p>增加了类的个数，这在一定程度上增加了系统的复杂性</p>
<h3 id="适用场景" tabindex="-1"> 适用场景</h3>
<ul>
<li>当需要为聚合对象提供多种遍历方式时。</li>
<li>当需要为遍历不同的聚合结构提供一个统一的接口时。</li>
<li>当访问一个聚合对象的内容而无须暴露其内部细节的表示时。</li>
</ul>
<h2 id="应用" tabindex="-1"> 应用</h2>
<h3 id="模式扩展" tabindex="-1"> 模式扩展</h3>
<p>迭代器模式常常与组合模式结合起来使用，在对组合模式中的容器构件进行访问时，经常将迭代器潜藏在组合模式的容器构成类中。当然，也可以构造一个外部迭代器来对容器构件进行访问</p>
<div align="center">
<p><img src="@source/assets/cs-note/oop-pattern/迭代器-组合模式.gif" alt="" loading="lazy"></p>
</div>
<h3 id="开发场景" tabindex="-1"> 开发场景</h3>
<ul>
<li>JDK内置的迭代器(List/Set)</li>
</ul>
<h3 id="jdk" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html" target="_blank" rel="noopener noreferrer">java.util.Iterator</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html" target="_blank" rel="noopener noreferrer">java.util.Enumeration</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>适配器模式</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">适配器模式</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="适配器-adapter" tabindex="-1"> 适配器（Adapter）</h1>
<h2 id="介绍" tabindex="-1"> 介绍</h2>
<h3 id="定义" tabindex="-1"> 定义</h3>
<p>把一个类接口转换成另一个用户需要的接口。</p>
<p>适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3d5b828e-5c4d-48d8-a440-281e4a8e1c92.png"/> </div><br>
<p>以下情况比较适合使用 Adapter 模式：</p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-adapter-pattern/index.html" target="_blank" rel="noopener noreferrer">适配器模式原理及实例介绍-IBM</a></p>
<h3 id="类图" tabindex="-1"> 类图</h3>
<div align="center"> 
<p><img src="@source/assets/cs-note/oop-pattern/适配器.png" alt="" loading="lazy"></p>
</div>
<h3 id="角色划分" tabindex="-1"> 角色划分</h3>
<ul>
<li>被适配者 Adaptee，</li>
<li>适配器 Adapter</li>
<li>目标对象 Target：其中两个现存的想要组合到一起的类分别是被适配者 Adaptee 和目标对象 Target 角色</li>
</ul>
<h2 id="实现" tabindex="-1"> 实现</h2>
<p>客户端使用的接口,与业务相关</p>
<div><pre><code><span>public</span> <span>interface</span> <span>Target</span> <span>{</span>
    <span>//客户端请求处理的方法</span>
    <span>public</span> <span>void</span> <span>request</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><p>被适配的对象,已经存在的接口,这个接口需要配置</p>
<div><pre><code><span>public</span> <span>class</span> <span>Adaptee</span> <span>{</span>
    <span>public</span> <span>void</span> <span>specificRequest</span><span>(</span><span>)</span><span>{</span>
        <span>//业务代码</span>
    <span>}</span>
<span>}</span>
</code></pre></div><p>适配器实现</p>
<div><pre><code><span>public</span> <span>class</span> <span>Adapter</span> <span>implements</span> <span>Target</span> <span>{</span>
    <span>//持有需要被适配的接口对象</span>
    <span>private</span> <span>Adaptee</span> adaptee<span>;</span>
    <span>//构造方法，传入需要被适配的对象</span>
    <span>public</span> <span>Adapter</span><span>(</span><span>Adaptee</span> adaptee<span>)</span> <span>{</span>
        <span>this</span><span>.</span>adaptee <span>=</span> adaptee<span>;</span>
    <span>}</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>request</span><span>(</span><span>)</span> <span>{</span>
        <span>// TODO Auto-generated method stub</span>
        adaptee<span>.</span><span>specificRequest</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>使用适配器的客户端</p>
<div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>
        <span>//创建需要被适配的对象</span>
        <span>Adaptee</span> adaptee <span>=</span> <span>new</span> <span>Adaptee</span><span>(</span><span>)</span><span>;</span>
        <span>//创建客户端需要调用的接口对象</span>
        <span>Target</span> target <span>=</span> <span>new</span> <span>Adapter</span><span>(</span>adaptee<span>)</span><span>;</span>
        <span>//请求处理</span>
        target<span>.</span><span>request</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>鸭子（Duck）和火鸡（Turkey）拥有不同的叫声，Duck 的叫声调用 quack() 方法，而 Turkey 调用 gobble() 方法。</p>
<p>要求将 Turkey 的 gobble() 方法适配成 Duck 的 quack() 方法，从而让火鸡冒充鸭子！</p>
<div><pre><code><span>public</span> <span>interface</span> <span>Duck</span> <span>{</span>
    <span>void</span> <span>quack</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>interface</span> <span>Turkey</span> <span>{</span>
    <span>void</span> <span>gobble</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>WildTurkey</span> <span>implements</span> <span>Turkey</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>gobble</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"gobble!"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>TurkeyAdapter</span> <span>implements</span> <span>Duck</span> <span>{</span>
    <span>Turkey</span> turkey<span>;</span>

    <span>public</span> <span>TurkeyAdapter</span><span>(</span><span>Turkey</span> turkey<span>)</span> <span>{</span>
        <span>this</span><span>.</span>turkey <span>=</span> turkey<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>quack</span><span>(</span><span>)</span> <span>{</span>
        turkey<span>.</span><span>gobble</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Turkey</span> turkey <span>=</span> <span>new</span> <span>WildTurkey</span><span>(</span><span>)</span><span>;</span>
        <span>Duck</span> duck <span>=</span> <span>new</span> <span>TurkeyAdapter</span><span>(</span>turkey<span>)</span><span>;</span>
        duck<span>.</span><span>quack</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><h2 id="分析" tabindex="-1"> 分析</h2>
<h3 id="优点" tabindex="-1"> 优点</h3>
<ul>
<li>客户端通过适配器可以透明地调用目标接口。</li>
<li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li>
<li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li>
</ul>
<h3 id="缺点" tabindex="-1"> 缺点</h3>
<p>对类适配器来说，更换适配器的实现过程比较复杂。</p>
<h3 id="适用场景" tabindex="-1"> 适用场景</h3>
<ul>
<li>想使用一个已经存在的类，而它的接口不符合你的需求；</li>
<li>想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作；</li>
<li>想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口，对象适配器可以适配它的父亲接口。</li>
</ul>
<h2 id="应用" tabindex="-1"> 应用</h2>
<h3 id="开发场景" tabindex="-1"> 开发场景</h3>
<p>JDK中使用适配器模式的类</p>
<ul>
<li>java.util.Arrays#asList()</li>
<li>java.io.InputStreamReader(InputStream)</li>
<li>java.io.OutputStreamWriter(OutputStream)</li>
</ul>
<p>Spring 中使用适配器模式的典型应用</p>
<ul>
<li>在 Spring 的 AOP 里通过使用的 Advice（通知）来增强被代理类的功能。</li>
</ul>
<h3 id="jdk" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList%28T...%29" target="_blank" rel="noopener noreferrer">java.util.Arrays#asList()</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#list-java.util.Enumeration-" target="_blank" rel="noopener noreferrer">java.util.Collections#list()</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#enumeration-java.util.Collection-" target="_blank" rel="noopener noreferrer">java.util.Collections#enumeration()</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/adapters/XmlAdapter.html#marshal-BoundType-" target="_blank" rel="noopener noreferrer">javax.xml.bind.annotation.adapters.XMLAdapter</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>计算机操作系统-内存管理</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">计算机操作系统-内存管理</source>
      <category>计算机基础</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
<li></li>
</ul>

<h1 id="虚拟内存" tabindex="-1"> 虚拟内存</h1>
<p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p>
<p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p>
<p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7b281b1e-0595-402b-ae35-8c91084c33c1.png"/> </div>
<h1 id="分页系统地址映射" tabindex="-1"> 分页系统地址映射</h1>
<p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p>
<p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p>
<p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" width="500"/> </div>
<h1 id="页面置换算法" tabindex="-1"> 页面置换算法</h1>
<p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p>
<p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p>
<p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p>
<h2 id="_1-最佳" tabindex="-1"> 1. 最佳</h2>
<blockquote>
<p>OPT, Optimal replacement algorithm</p>
</blockquote>
<p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p>
<p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p>
<p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p>
<div><pre><code>7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1
</code></pre></div><p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p>
<h2 id="_2-最近最久未使用" tabindex="-1"> 2. 最近最久未使用</h2>
<blockquote>
<p>LRU, Least Recently Used</p>
</blockquote>
<p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p>
<p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p>
<p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p>
<div><pre><code>4，7，0，7，1，0，1，2，1，2，6
</code></pre></div><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eb859228-c0f2-4bce-910d-d9f76929352b.png"/> </div>
<h2 id="_3-最近未使用" tabindex="-1"> 3. 最近未使用</h2>
<blockquote>
<p>NRU, Not Recently Used</p>
</blockquote>
<p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：</p>
<ul>
<li>R=0，M=0</li>
<li>R=0，M=1</li>
<li>R=1，M=0</li>
<li>R=1，M=1</li>
</ul>
<p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p>
<p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p>
<h2 id="_4-先进先出" tabindex="-1"> 4. 先进先出</h2>
<blockquote>
<p>FIFO, First In First Out</p>
</blockquote>
<p>选择换出的页面是最先进入的页面。</p>
<p>该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。</p>
<h2 id="_5-第二次机会算法" tabindex="-1"> 5. 第二次机会算法</h2>
<p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p>
<p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ecf8ad5d-5403-48b9-b6e7-f2e20ffe8fca.png"/> </div>
<h2 id="_6-时钟" tabindex="-1"> 6. 时钟</h2>
<blockquote>
<p>Clock</p>
</blockquote>
<p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5f5ef0b6-98ea-497c-a007-f6c55288eab1.png"/> </div>
<h1 id="分段" tabindex="-1"> 分段</h1>
<p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p>
<p>下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/22de0538-7c6e-4365-bd3b-8ce3c5900216.png"/> </div>
<p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e0900bb2-220a-43b7-9aa9-1d5cd55ff56e.png"/> </div>
<h1 id="段页式" tabindex="-1"> 段页式</h1>
<p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p>
<h1 id="分页与分段的比较" tabindex="-1"> 分页与分段的比较</h1>
<ul>
<li>
<p>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</p>
</li>
<li>
<p>地址空间的维度：分页是一维地址空间，分段是二维的。</p>
</li>
<li>
<p>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</p>
</li>
<li>
<p>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>计算机操作系统-概述</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">计算机操作系统-概述</source>
      <category>计算机基础</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>

<h1 id="基本特征" tabindex="-1"> 基本特征</h1>
<h2 id="_1-并发" tabindex="-1"> 1. 并发</h2>
<p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</p>
<p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p>
<p>操作系统通过引入进程和线程，使得程序能够并发运行。</p>
<h2 id="_2-共享" tabindex="-1"> 2. 共享</h2>
<p>共享是指系统中的资源可以被多个并发进程共同使用。</p>
<p>有两种共享方式：互斥共享和同时共享。</p>
<p>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</p>
<h2 id="_3-虚拟" tabindex="-1"> 3. 虚拟</h2>
<p>虚拟技术把一个物理实体转换为多个逻辑实体。</p>
<p>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</p>
<p>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p>
<p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p>
<h2 id="_4-异步" tabindex="-1"> 4. 异步</h2>
<p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p>
<h1 id="基本功能" tabindex="-1"> 基本功能</h1>
<h2 id="_1-进程管理" tabindex="-1"> 1. 进程管理</h2>
<p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p>
<h2 id="_2-内存管理" tabindex="-1"> 2. 内存管理</h2>
<p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p>
<h2 id="_3-文件管理" tabindex="-1"> 3. 文件管理</h2>
<p>文件存储空间的管理、目录管理、文件读写管理和保护等。</p>
<h2 id="_4-设备管理" tabindex="-1"> 4. 设备管理</h2>
<p>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</p>
<p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p>
<h1 id="系统调用" tabindex="-1"> 系统调用</h1>
<p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/tGPV0.png" width="600"/> </div>
<p>Linux 的系统调用主要有以下这些：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Task</th>
<th>Commands</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">进程控制</td>
<td>fork(); exit(); wait();</td>
</tr>
<tr>
<td style="text-align:center">进程通信</td>
<td>pipe(); shmget(); mmap();</td>
</tr>
<tr>
<td style="text-align:center">文件操作</td>
<td>open(); read(); write();</td>
</tr>
<tr>
<td style="text-align:center">设备操作</td>
<td>ioctl(); read(); write();</td>
</tr>
<tr>
<td style="text-align:center">信息维护</td>
<td>getpid(); alarm(); sleep();</td>
</tr>
<tr>
<td style="text-align:center">安全</td>
<td>chmod(); umask(); chown();</td>
</tr>
</tbody>
</table>
<h1 id="大内核和微内核" tabindex="-1"> 大内核和微内核</h1>
<h2 id="_1-大内核" tabindex="-1"> 1. 大内核</h2>
<p>大内核是将操作系统功能作为一个紧密结合的整体放到内核。</p>
<p>由于各模块共享信息，因此有很高的性能。</p>
<h2 id="_2-微内核" tabindex="-1"> 2. 微内核</h2>
<p>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。</p>
<p>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。</p>
<p>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2_14_microkernelArchitecture.jpg"/> </div>
<h1 id="中断分类" tabindex="-1"> 中断分类</h1>
<h2 id="_1-外中断" tabindex="-1"> 1. 外中断</h2>
<p>由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p>
<h2 id="_2-异常" tabindex="-1"> 2. 异常</h2>
<p>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p>
<h2 id="_3-陷入" tabindex="-1"> 3. 陷入</h2>
<p>在用户程序中使用系统调用。</p>
]]></content:encoded>
    </item>
    <item>
      <title>计算机操作系统-死锁</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">计算机操作系统-死锁</source>
      <category>计算机基础</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>

<h1 id="必要条件" tabindex="-1"> 必要条件</h1>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c037c901-7eae-4e31-a1e4-9d41329e5c3e.png"/> </div>
<ul>
<li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li>
<li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li>
<li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li>
<li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li>
</ul>
<h1 id="处理方法" tabindex="-1"> 处理方法</h1>
<p>主要有以下四种方法：</p>
<ul>
<li>鸵鸟策略</li>
<li>死锁检测与死锁恢复</li>
<li>死锁预防</li>
<li>死锁避免</li>
</ul>
<h1 id="鸵鸟策略" tabindex="-1"> 鸵鸟策略</h1>
<p>把头埋在沙子里，假装根本没发生问题。</p>
<p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p>
<p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p>
<p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
<h1 id="死锁检测与死锁恢复" tabindex="-1"> 死锁检测与死锁恢复</h1>
<p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p>
<h2 id="_1-每种类型一个资源的死锁检测" tabindex="-1"> 1. 每种类型一个资源的死锁检测</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1fa0453-a4b0-4eae-a352-48acca8fff74.png"/> </div>
<p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p>
<p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p>
<p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p>
<h2 id="_2-每种类型多个资源的死锁检测" tabindex="-1"> 2. 每种类型多个资源的死锁检测</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png"/> </div>
<p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p>
<ul>
<li>E 向量：资源总量</li>
<li>A 向量：资源剩余量</li>
<li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li>
<li>R 矩阵：每个进程请求的资源数量</li>
</ul>
<p>进程 P<sub>1</sub> 和 P<sub>2</sub> 所请求的资源都得不到满足，只有进程 P<sub>3</sub> 可以，让 P<sub>3</sub> 执行，之后释放 P<sub>3</sub> 拥有的资源，此时 A = (2 2 2 0)。P<sub>2</sub> 可以执行，执行后释放 P<sub>2</sub> 拥有的资源，A = (4 2 2 1) 。P<sub>1</sub> 也可以执行。所有进程都可以顺利执行，没有死锁。</p>
<p>算法总结如下：</p>
<p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p>
<ol>
<li>寻找一个没有标记的进程 P<sub>i</sub>，它所请求的资源小于等于 A。</li>
<li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li>
<li>如果没有这样一个进程，算法终止。</li>
</ol>
<h2 id="_3-死锁恢复" tabindex="-1"> 3. 死锁恢复</h2>
<ul>
<li>利用抢占恢复</li>
<li>利用回滚恢复</li>
<li>通过杀死进程恢复</li>
</ul>
<h1 id="死锁预防" tabindex="-1"> 死锁预防</h1>
<p>在程序运行之前预防发生死锁。</p>
<h2 id="_1-破坏互斥条件" tabindex="-1"> 1. 破坏互斥条件</h2>
<p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p>
<h2 id="_2-破坏占有和等待条件" tabindex="-1"> 2. 破坏占有和等待条件</h2>
<p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p>
<h2 id="_3-破坏不可抢占条件" tabindex="-1"> 3. 破坏不可抢占条件</h2>
<h2 id="_4-破坏环路等待" tabindex="-1"> 4. 破坏环路等待</h2>
<p>给资源统一编号，进程只能按编号顺序来请求资源。</p>
<h1 id="死锁避免" tabindex="-1"> 死锁避免</h1>
<p>在程序运行时避免发生死锁。</p>
<h2 id="_1-安全状态" tabindex="-1"> 1. 安全状态</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ed523051-608f-4c3f-b343-383e2d194470.png"/> </div>
<p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p>
<p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p>
<p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p>
<h2 id="_2-单个资源的银行家算法" tabindex="-1"> 2. 单个资源的银行家算法</h2>
<p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png"/> </div>
<p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p>
<h2 id="_3-多个资源的银行家算法" tabindex="-1"> 3. 多个资源的银行家算法</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png"/> </div>
<p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p>
<p>检查一个状态是否安全的算法如下：</p>
<ul>
<li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li>
<li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li>
<li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li>
</ul>
<p>如果一个状态不是安全的，需要拒绝进入这个状态。</p>
]]></content:encoded>
    </item>
    <item>
      <title>计算机操作系统-目录</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%9B%AE%E5%BD%95.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%9B%AE%E5%BD%95.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">计算机操作系统-目录</source>
      <category>计算机基础</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="目录" tabindex="-1"> 目录</h1>
<ul>
<li><a href="/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.html">概述</a></li>
<li><a href="/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html">进程管理</a></li>
<li><a href="/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81.html">死锁</a></li>
<li><a href="/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">内存管理</a></li>
<li><a href="/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.html">设备管理</a></li>
<li><a href="/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5.html">链接</a></li>
</ul>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li>Tanenbaum A S, Bos H. Modern operating systems[M]. Prentice Hall Press, 2014.</li>
<li>汤子瀛, 哲凤屏, 汤小丹. 计算机操作系统[M]. 西安电子科技大学出版社, 2001.</li>
<li>Bryant, R. E., &amp; O’Hallaron, D. R. (2004). 深入理解计算机系统.</li>
<li>史蒂文斯. UNIX 环境高级编程 [M]. 人民邮电出版社, 2014.</li>
<li><a href="https://applied-programming.github.io/Operating-Systems-Notes/" target="_blank" rel="noopener noreferrer">Operating System Notes</a></li>
<li><a href="https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/2_Structures.html" target="_blank" rel="noopener noreferrer">Operating-System Structures</a></li>
<li><a href="http://cse.csusb.edu/tongyu/courses/cs460/notes/process.php" target="_blank" rel="noopener noreferrer">Processes</a></li>
<li><a href="https://www.slideshare.net/rkolahalam/inter-process-communication-presentation1" target="_blank" rel="noopener noreferrer">Inter Process Communication Presentation[1]</a></li>
<li><a href="https://blogs.cisco.com/datacenter/decoding-ucs-invicta-part-1" target="_blank" rel="noopener noreferrer">Decoding UCS Invicta – Part 1</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>计算机操作系统-设备管理</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">计算机操作系统-设备管理</source>
      <category>计算机基础</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>

<h1 id="磁盘结构" tabindex="-1"> 磁盘结构</h1>
<ul>
<li>盘面（Platter）：一个磁盘有多个盘面；</li>
<li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li>
<li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li>
<li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li>
<li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li>
<li>主轴（Spindle）：使整个盘面转动。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/014fbc4d-d873-4a12-b160-867ddaed9807.jpg"/> </div>
<h1 id="磁盘调度算法" tabindex="-1"> 磁盘调度算法</h1>
<p>读写一个磁盘块的时间的影响因素有：</p>
<ul>
<li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li>
<li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li>
<li>实际的数据传输时间</li>
</ul>
<p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
<h2 id="_1-先来先服务" tabindex="-1"> 1. 先来先服务</h2>
<blockquote>
<p>FCFS, First Come First Served</p>
</blockquote>
<p>按照磁盘请求的顺序进行调度。</p>
<p>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p>
<h2 id="_2-最短寻道时间优先" tabindex="-1"> 2. 最短寻道时间优先</h2>
<blockquote>
<p>SSTF, Shortest Seek Time First</p>
</blockquote>
<p>优先调度与当前磁头所在磁道距离最近的磁道。</p>
<p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4e2485e4-34bd-4967-9f02-0c093b797aaa.png"/> </div>
<h2 id="_3-电梯算法" tabindex="-1"> 3. 电梯算法</h2>
<blockquote>
<p>SCAN</p>
</blockquote>
<p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p>
<p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p>
<p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/271ce08f-c124-475f-b490-be44fedc6d2e.png"/> </div>
]]></content:encoded>
    </item>
    <item>
      <title>计算机操作系统-进程管理</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">计算机操作系统-进程管理</source>
      <category>计算机基础</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>

<h1 id="进程与线程" tabindex="-1"> 进程与线程</h1>
<h2 id="_1-进程" tabindex="-1"> 1. 进程</h2>
<p>进程是资源分配的基本单位。</p>
<p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p>
<p>下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a6ac2b08-3861-4e85-baa8-382287bfee9f.png"/> </div>
<h2 id="_2-线程" tabindex="-1"> 2. 线程</h2>
<p>线程是独立调度的基本单位。</p>
<p>一个进程中可以有多个线程，它们共享进程资源。</p>
<p>QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3cd630ea-017c-488d-ad1d-732b4efeddf5.png"/> </div>
<h2 id="_3-区别" tabindex="-1"> 3. 区别</h2>
<p>Ⅰ 拥有资源</p>
<p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p>
<p>Ⅱ 调度</p>
<p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p>
<p>Ⅲ 系统开销</p>
<p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p>
<p>Ⅳ 通信方面</p>
<p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</p>
<p>V 上下文切换</p>
<p>进程切换与线程切换的一个最主要区别就在于进程切换涉及到虚拟地址空间的切换而线程切换则不会。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。</p>
<p>当进程切换后页表也要进行切换，页表切换后TLB就失效了，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换快。</p>
<h1 id="进程状态的切换" tabindex="-1"> 进程状态的切换</h1>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ProcessState.png" width="500"/> </div>
<ul>
<li>就绪状态（ready）：等待被调度</li>
<li>运行状态（running）</li>
<li>阻塞状态（waiting）：等待资源</li>
</ul>
<p>应该注意以下内容：</p>
<ul>
<li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li>
<li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li>
</ul>
<h1 id="进程切换" tabindex="-1"> 进程切换</h1>
<p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>
<p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p>
<ol>
<li>保存处理机上下文，包括程序计数器和其他寄存器。</li>
<li>更新PCB信息。</li>
<li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li>
<li>选择另一个进程执行，并更新其PCB。</li>
<li>更新内存管理的数据结构。</li>
<li>恢复处理机上下文。</li>
</ol>
<h2 id="用户空间-内核空间" tabindex="-1"> 用户空间 内核空间</h2>
<p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p>
<h1 id="进程调度算法" tabindex="-1"> 进程调度算法</h1>
<p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p>
<h2 id="_1-批处理系统" tabindex="-1"> 1. 批处理系统</h2>
<p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p>
<p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong></p>
<p>非抢占式的调度算法，按照请求的顺序进行调度。</p>
<p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
<p><strong>1.2 短作业优先 shortest job first（SJF）</strong></p>
<p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p>
<p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
<p><strong>1.3 最短剩余时间优先 shortest remaining time next（SRTN）</strong></p>
<p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
<h2 id="_2-交互式系统" tabindex="-1"> 2. 交互式系统</h2>
<p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p>
<p><strong>2.1 时间片轮转</strong></p>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>
<ul>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li>
<li>而如果时间片过长，那么实时性就不能得到保证。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8c662999-c16c-481c-9f40-1fdba5bc9167.png"/> </div>
<p><strong>2.2 优先级调度</strong></p>
<p>为每个进程分配一个优先级，按优先级进行调度。</p>
<p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<p><strong>2.3 多级反馈队列</strong></p>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p>
<p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>
<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/042cf928-3c8e-4815-ae9c-f2780202c68f.png"/> </div>
<h2 id="_3-实时系统" tabindex="-1"> 3. 实时系统</h2>
<p>实时系统要求一个请求在一个确定时间内得到响应。</p>
<p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>
<h1 id="进程同步" tabindex="-1"> 进程同步</h1>
<h2 id="_1-临界区" tabindex="-1"> 1. 临界区</h2>
<p>对临界资源进行访问的那段代码称为临界区。</p>
<p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p>
<div><pre><code>// entry section
// critical section;
// exit section
</code></pre></div><h2 id="_2-同步与互斥" tabindex="-1"> 2. 同步与互斥</h2>
<ul>
<li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li>
<li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li>
</ul>
<h2 id="_3-信号量" tabindex="-1"> 3. 信号量</h2>
<p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
<ul>
<li><strong>down</strong>  : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li>
<li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>
</ul>
<p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p>
<p>如果信号量的取值只能为 0 或者 1，那么就成为了  <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p>
<div><pre><code><span>typedef</span> <span>int</span> semaphore<span>;</span>
semaphore mutex <span>=</span> <span>1</span><span>;</span>
<span>void</span> <span>P1</span><span>(</span><span>)</span> <span>{</span>
    <span>down</span><span>(</span><span>&amp;</span>mutex<span>)</span><span>;</span>
    <span>// 临界区</span>
    <span>up</span><span>(</span><span>&amp;</span>mutex<span>)</span><span>;</span>
<span>}</span>

<span>void</span> <span>P2</span><span>(</span><span>)</span> <span>{</span>
    <span>down</span><span>(</span><span>&amp;</span>mutex<span>)</span><span>;</span>
    <span>// 临界区</span>
    <span>up</span><span>(</span><span>&amp;</span>mutex<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><strong>使用信号量实现生产者-消费者问题</strong></p>
<p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p>
<p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p>
<p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p>
<p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p>
<div><pre><code><span><span>#</span><span>define</span> <span>N</span> <span><span>100</span></span></span>
<span>typedef</span> <span>int</span> semaphore<span>;</span>
semaphore mutex <span>=</span> <span>1</span><span>;</span>
semaphore empty <span>=</span> N<span>;</span>
semaphore full <span>=</span> <span>0</span><span>;</span>

<span>void</span> <span>producer</span><span>(</span><span>)</span> <span>{</span>
    <span>while</span><span>(</span>TRUE<span>)</span> <span>{</span>
        <span>int</span> item <span>=</span> <span>produce_item</span><span>(</span><span>)</span><span>;</span>
        <span>down</span><span>(</span><span>&amp;</span>empty<span>)</span><span>;</span>
        <span>down</span><span>(</span><span>&amp;</span>mutex<span>)</span><span>;</span>
        <span>insert_item</span><span>(</span>item<span>)</span><span>;</span>
        <span>up</span><span>(</span><span>&amp;</span>mutex<span>)</span><span>;</span>
        <span>up</span><span>(</span><span>&amp;</span>full<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>void</span> <span>consumer</span><span>(</span><span>)</span> <span>{</span>
    <span>while</span><span>(</span>TRUE<span>)</span> <span>{</span>
        <span>down</span><span>(</span><span>&amp;</span>full<span>)</span><span>;</span>
        <span>down</span><span>(</span><span>&amp;</span>mutex<span>)</span><span>;</span>
        <span>int</span> item <span>=</span> <span>remove_item</span><span>(</span><span>)</span><span>;</span>
        <span>consume_item</span><span>(</span>item<span>)</span><span>;</span>
        <span>up</span><span>(</span><span>&amp;</span>mutex<span>)</span><span>;</span>
        <span>up</span><span>(</span><span>&amp;</span>empty<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id="_4-管程" tabindex="-1"> 4. 管程</h2>
<p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p>
<p>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</p>
<div><pre><code>monitor ProducerConsumer
    integer i<span>;</span>
    condition c<span>;</span>

    <span>procedure</span> insert<span>(</span><span>)</span><span>;</span>
    <span>begin</span>
        <span>// ...</span>
    <span>end</span><span>;</span>

    <span>procedure</span> remove<span>(</span><span>)</span><span>;</span>
    <span>begin</span>
        <span>// ...</span>
    <span>end</span><span>;</span>
<span>end</span> monitor<span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p>
<p>管程引入了  <strong>条件变量</strong>  以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p>
<p><strong>使用管程实现生产者-消费者问题</strong></p>
<div><pre><code><span>// 管程</span>
monitor ProducerConsumer
    condition full<span>,</span> empty<span>;</span>
    integer count <span>:=</span> <span>0</span><span>;</span>
    condition c<span>;</span>

    <span>procedure</span> insert<span>(</span>item<span>:</span> integer<span>)</span><span>;</span>
    <span>begin</span>
        <span>if</span> count <span>=</span> N <span>then</span> wait<span>(</span>full<span>)</span><span>;</span>
        insert_item<span>(</span>item<span>)</span><span>;</span>
        count <span>:=</span> count <span>+</span> <span>1</span><span>;</span>
        <span>if</span> count <span>=</span> <span>1</span> <span>then</span> signal<span>(</span>empty<span>)</span><span>;</span>
    <span>end</span><span>;</span>

    <span>function</span> remove<span>:</span> integer<span>;</span>
    <span>begin</span>
        <span>if</span> count <span>=</span> <span>0</span> <span>then</span> wait<span>(</span>empty<span>)</span><span>;</span>
        remove <span>=</span> remove_item<span>;</span>
        count <span>:=</span> count <span>-</span> <span>1</span><span>;</span>
        <span>if</span> count <span>=</span> N <span>-</span><span>1</span> <span>then</span> signal<span>(</span>full<span>)</span><span>;</span>
    <span>end</span><span>;</span>
<span>end</span> monitor<span>;</span>

<span>// 生产者客户端</span>
<span>procedure</span> producer
<span>begin</span>
    <span>while</span> <span>true</span> <span>do</span>
    <span>begin</span>
        item <span>=</span> produce_item<span>;</span>
        ProducerConsumer<span>.</span>insert<span>(</span>item<span>)</span><span>;</span>
    <span>end</span>
<span>end</span><span>;</span>

<span>// 消费者客户端</span>
<span>procedure</span> consumer
<span>begin</span>
    <span>while</span> <span>true</span> <span>do</span>
    <span>begin</span>
        item <span>=</span> ProducerConsumer<span>.</span>remove<span>;</span>
        consume_item<span>(</span>item<span>)</span><span>;</span>
    <span>end</span>
<span>end</span><span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h1 id="经典同步问题" tabindex="-1"> 经典同步问题</h1>
<p>生产者和消费者问题前面已经讨论过了。</p>
<h2 id="_1-读者-写者问题" tabindex="-1"> 1. 读者-写者问题</h2>
<p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p>
<p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p>
<div><pre><code><span>typedef</span> <span>int</span> semaphore<span>;</span>
semaphore count_mutex <span>=</span> <span>1</span><span>;</span>
semaphore data_mutex <span>=</span> <span>1</span><span>;</span>
<span>int</span> count <span>=</span> <span>0</span><span>;</span>

<span>void</span> <span>reader</span><span>(</span><span>)</span> <span>{</span>
    <span>while</span><span>(</span>TRUE<span>)</span> <span>{</span>
        <span>down</span><span>(</span><span>&amp;</span>count_mutex<span>)</span><span>;</span>
        count<span>++</span><span>;</span>
        <span>if</span><span>(</span>count <span>==</span> <span>1</span><span>)</span> <span>down</span><span>(</span><span>&amp;</span>data_mutex<span>)</span><span>;</span> <span>// 第一个读者需要对数据进行加锁，防止写进程访问</span>
        <span>up</span><span>(</span><span>&amp;</span>count_mutex<span>)</span><span>;</span>
        <span>read</span><span>(</span><span>)</span><span>;</span>
        <span>down</span><span>(</span><span>&amp;</span>count_mutex<span>)</span><span>;</span>
        count<span>--</span><span>;</span>
        <span>if</span><span>(</span>count <span>==</span> <span>0</span><span>)</span> <span>up</span><span>(</span><span>&amp;</span>data_mutex<span>)</span><span>;</span>
        <span>up</span><span>(</span><span>&amp;</span>count_mutex<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>void</span> <span>writer</span><span>(</span><span>)</span> <span>{</span>
    <span>while</span><span>(</span>TRUE<span>)</span> <span>{</span>
        <span>down</span><span>(</span><span>&amp;</span>data_mutex<span>)</span><span>;</span>
        <span>write</span><span>(</span><span>)</span><span>;</span>
        <span>up</span><span>(</span><span>&amp;</span>data_mutex<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>以下内容由 <a href="https://github.com/yugandharbandi" target="_blank" rel="noopener noreferrer">@Bandi Yugandhar</a> 提供。</p>
<p>The first case may result Writer to starve. This case favous Writers i.e no writer, once added to the queue, shall be kept waiting longer than absolutely necessary(only when there are readers that entered the queue before the writer).</p>
<div><pre><code>int readcount, writecount;                   //(initial value = 0)
semaphore rmutex, wmutex, readLock, resource; //(initial value = 1)

//READER
void reader() {
&lt;ENTRY Section&gt;
 down(&amp;readLock);                 //  reader is trying to enter
 down(&amp;rmutex);                  //   lock to increase readcount
  readcount++;                 
  if (readcount == 1)          
   down(&amp;resource);              //if you are the first reader then lock  the resource
 up(&amp;rmutex);                  //release  for other readers
 up(&amp;readLock);                 //Done with trying to access the resource

&lt;CRITICAL Section&gt;
//reading is performed

&lt;EXIT Section&gt;
 down(&amp;rmutex);                  //reserve exit section - avoids race condition with readers
 readcount--;                       //indicate you're leaving
  if (readcount == 0)          //checks if you are last reader leaving
   up(&amp;resource);              //if last, you must release the locked resource
 up(&amp;rmutex);                  //release exit section for other readers
}

//WRITER
void writer() {
  &lt;ENTRY Section&gt;
  down(&amp;wmutex);                  //reserve entry section for writers - avoids race conditions
  writecount++;                //report yourself as a writer entering
  if (writecount == 1)         //checks if you're first writer
   down(&amp;readLock);               //if you're first, then you must lock the readers out. Prevent them from trying to enter CS
  up(&amp;wmutex);                  //release entry section

&lt;CRITICAL Section&gt;
 down(&amp;resource);                //reserve the resource for yourself - prevents other writers from simultaneously editing the shared resource
  //writing is performed
 up(&amp;resource);                //release file

&lt;EXIT Section&gt;
  down(&amp;wmutex);                  //reserve exit section
  writecount--;                //indicate you're leaving
  if (writecount == 0)         //checks if you're the last writer
   up(&amp;readLock);               //if you're last writer, you must unlock the readers. Allows them to try enter CS for reading
  up(&amp;wmutex);                  //release exit section
}
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>We can observe that every reader is forced to acquire ReadLock. On the otherhand, writers doesn’t need to lock individually. Once the first writer locks the ReadLock, it will be released only when there is no writer left in the queue.</p>
<p>From the both cases we observed that either reader or writer has to starve. Below solutionadds the constraint that no thread shall be allowed to starve; that is, the operation of obtaining a lock on the shared data will always terminate in a bounded amount of time.</p>
<div><pre><code>int readCount;                  // init to 0; number of readers currently accessing resource

// all semaphores initialised to 1
Semaphore resourceAccess;       // controls access (read/write) to the resource
Semaphore readCountAccess;      // for syncing changes to shared variable readCount
Semaphore serviceQueue;         // FAIRNESS: preserves ordering of requests (signaling must be FIFO)

void writer()
{ 
    down(&amp;serviceQueue);           // wait in line to be servicexs
    // &lt;ENTER&gt;
    down(&amp;resourceAccess);         // request exclusive access to resource
    // &lt;/ENTER&gt;
    up(&amp;serviceQueue);           // let next in line be serviced

    // &lt;WRITE&gt;
    writeResource();            // writing is performed
    // &lt;/WRITE&gt;

    // &lt;EXIT&gt;
    up(&amp;resourceAccess);         // release resource access for next reader/writer
    // &lt;/EXIT&gt;
}

void reader()
{ 
    down(&amp;serviceQueue);           // wait in line to be serviced
    down(&amp;readCountAccess);        // request exclusive access to readCount
    // &lt;ENTER&gt;
    if (readCount == 0)         // if there are no readers already reading:
        down(&amp;resourceAccess);     // request resource access for readers (writers blocked)
    readCount++;                // update count of active readers
    // &lt;/ENTER&gt;
    up(&amp;serviceQueue);           // let next in line be serviced
    up(&amp;readCountAccess);        // release access to readCount

    // &lt;READ&gt;
    readResource();             // reading is performed
    // &lt;/READ&gt;

    down(&amp;readCountAccess);        // request exclusive access to readCount
    // &lt;EXIT&gt;
    readCount--;                // update count of active readers
    if (readCount == 0)         // if there are no readers left:
        up(&amp;resourceAccess);     // release resource access for all
    // &lt;/EXIT&gt;
    up(&amp;readCountAccess);        // release access to readCount
}

</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><h2 id="_2-哲学家进餐问题" tabindex="-1"> 2. 哲学家进餐问题</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a9077f06-7584-4f2b-8c20-3a8e46928820.jpg"/> </div>
<p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p>
<p>下面是一种错误的解法，考虑到如果所有哲学家同时拿起左手边的筷子，那么就无法拿起右手边的筷子，造成死锁。</p>
<div><pre><code><span><span>#</span><span>define</span> <span>N</span> <span><span>5</span></span></span>

<span>void</span> <span>philosopher</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>
    <span>while</span><span>(</span>TRUE<span>)</span> <span>{</span>
        <span>think</span><span>(</span><span>)</span><span>;</span>
        <span>take</span><span>(</span>i<span>)</span><span>;</span>       <span>// 拿起左边的筷子</span>
        <span>take</span><span>(</span><span>(</span>i<span>+</span><span>1</span><span>)</span><span>%</span>N<span>)</span><span>;</span> <span>// 拿起右边的筷子</span>
        <span>eat</span><span>(</span><span>)</span><span>;</span>
        <span>put</span><span>(</span>i<span>)</span><span>;</span>
        <span>put</span><span>(</span><span>(</span>i<span>+</span><span>1</span><span>)</span><span>%</span>N<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>为了防止死锁的发生，可以设置两个条件：</p>
<ul>
<li>必须同时拿起左右两根筷子；</li>
<li>只有在两个邻居都没有进餐的情况下才允许进餐。</li>
</ul>
<div><pre><code><span><span>#</span><span>define</span> <span>N</span> <span><span>5</span></span></span>
<span><span>#</span><span>define</span> <span>LEFT</span> <span><span>(</span>i <span>+</span> N <span>-</span> <span>1</span><span>)</span> <span>%</span> N </span><span>// 左邻居</span></span>
<span><span>#</span><span>define</span> <span>RIGHT</span> <span><span>(</span>i <span>+</span> <span>1</span><span>)</span> <span>%</span> N    </span><span>// 右邻居</span></span>
<span><span>#</span><span>define</span> <span>THINKING</span> <span><span>0</span></span></span>
<span><span>#</span><span>define</span> <span>HUNGRY</span>   <span><span>1</span></span></span>
<span><span>#</span><span>define</span> <span>EATING</span>   <span><span>2</span></span></span>
<span>typedef</span> <span>int</span> semaphore<span>;</span>
<span>int</span> state<span>[</span>N<span>]</span><span>;</span>                <span>// 跟踪每个哲学家的状态</span>
semaphore mutex <span>=</span> <span>1</span><span>;</span>         <span>// 临界区的互斥</span>
semaphore s<span>[</span>N<span>]</span><span>;</span>              <span>// 每个哲学家一个信号量</span>

<span>void</span> <span>philosopher</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>
    <span>while</span><span>(</span>TRUE<span>)</span> <span>{</span>
        <span>think</span><span>(</span><span>)</span><span>;</span>
        <span>take_two</span><span>(</span>i<span>)</span><span>;</span>
        <span>eat</span><span>(</span><span>)</span><span>;</span>
        <span>put_two</span><span>(</span>i<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>void</span> <span>take_two</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>
    <span>down</span><span>(</span><span>&amp;</span>mutex<span>)</span><span>;</span>
    state<span>[</span>i<span>]</span> <span>=</span> HUNGRY<span>;</span>
    <span>test</span><span>(</span>i<span>)</span><span>;</span>
    <span>up</span><span>(</span><span>&amp;</span>mutex<span>)</span><span>;</span>
    <span>down</span><span>(</span><span>&amp;</span>s<span>[</span>i<span>]</span><span>)</span><span>;</span>
<span>}</span>

<span>void</span> <span>put_two</span><span>(</span>i<span>)</span> <span>{</span>
    <span>down</span><span>(</span><span>&amp;</span>mutex<span>)</span><span>;</span>
    state<span>[</span>i<span>]</span> <span>=</span> THINKING<span>;</span>
    <span>test</span><span>(</span>LEFT<span>)</span><span>;</span>
    <span>test</span><span>(</span>RIGHT<span>)</span><span>;</span>
    <span>up</span><span>(</span><span>&amp;</span>mutex<span>)</span><span>;</span>
<span>}</span>

<span>void</span> <span>test</span><span>(</span>i<span>)</span> <span>{</span>         <span>// 尝试拿起两把筷子</span>
    <span>if</span><span>(</span>state<span>[</span>i<span>]</span> <span>==</span> HUNGRY <span>&amp;&amp;</span> state<span>[</span>LEFT<span>]</span> <span>!=</span> EATING <span>&amp;&amp;</span> state<span>[</span>RIGHT<span>]</span> <span>!=</span>EATING<span>)</span> <span>{</span>
        state<span>[</span>i<span>]</span> <span>=</span> EATING<span>;</span>
        <span>up</span><span>(</span><span>&amp;</span>s<span>[</span>i<span>]</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h1 id="进程通信" tabindex="-1"> 进程通信</h1>
<p>进程同步与进程通信很容易混淆，它们的区别在于：</p>
<ul>
<li>进程同步：控制多个进程按一定顺序执行；</li>
<li>进程通信：进程间传输信息。</li>
</ul>
<p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p>
<h2 id="_1-管道" tabindex="-1"> 1. 管道</h2>
<p>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。</p>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;unistd.h></span></span>
<span>int</span> <span>pipe</span><span>(</span><span>int</span> fd<span>[</span><span>2</span><span>]</span><span>)</span><span>;</span>
</code></pre></div><p>它具有以下限制：</p>
<ul>
<li>只支持半双工通信（单向交替传输）；</li>
<li>只能在父子进程或者兄弟进程中使用。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png"/> </div>
<h2 id="_2-fifo" tabindex="-1"> 2. FIFO</h2>
<p>也称为命名管道，去除了管道只能在父子进程中使用的限制。</p>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;sys/stat.h></span></span>
<span>int</span> <span>mkfifo</span><span>(</span><span>const</span> <span>char</span> <span>*</span>path<span>,</span> <span>mode_t</span> mode<span>)</span><span>;</span>
<span>int</span> <span>mkfifoat</span><span>(</span><span>int</span> fd<span>,</span> <span>const</span> <span>char</span> <span>*</span>path<span>,</span> <span>mode_t</span> mode<span>)</span><span>;</span>
</code></pre></div><p>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png"/> </div>
<h2 id="_3-信号" tabindex="-1"> 3. 信号</h2>
<p>软中断信号（signal，又简称为信号）用来通知进程发生了异步事件。在软件层次上是对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。进程之间可以互相通过系统调用kill发送软中断信号。内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。</p>
<p>与硬件中断类似——异步模式。但信号是软件层面上实现的中断，早期常被称为“软中断”。</p>
<p>内核处理一个进程收到的信号的时机是在一个进程从内核态返回用户态时。所以，当一个进程在内核态下运行时，软中断信号并不立即起作用，要等到将返回用户态时才处理。进程只有处理完信号才会返回用户态，进程在用户态下不会有未处理完的信号。</p>
<p>Linux内核的进程控制块PCB中包含了信号相关信息，主要指的是阻塞信号集和未决信号集。</p>
<p>阻塞信号集（信号屏蔽字）：将某些信号加入集合，对他们设置屏蔽，当屏蔽某信号后收到该信号，将会被阻塞，直到解除屏蔽后被唤醒</p>
<p>未决信号集：</p>
<ol>
<li>信号产生，未决信号集中描述该信号的位立刻翻转为1，表信号处于未决状态。当信号被处理对应位翻转回为0。这一时刻往往非常短暂。</li>
<li>信号产生后由于某些原因(主要是阻塞)不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。</li>
</ol>
<h2 id="_4-消息队列" tabindex="-1"> 4. 消息队列</h2>
<p>相比于 FIFO，消息队列具有以下优点：</p>
<ul>
<li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li>
<li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li>
<li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li>
</ul>
<h2 id="_5-信号量" tabindex="-1"> 5. 信号量</h2>
<p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p>
<h2 id="_6-共享存储" tabindex="-1"> 6. 共享存储</h2>
<p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p>
<p>需要使用信号量用来同步对共享存储的访问。</p>
<p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</p>
<h2 id="_7-套接字" tabindex="-1"> 7. 套接字</h2>
<p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p>
]]></content:encoded>
    </item>
    <item>
      <title>计算机操作系统-链接</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">计算机操作系统-链接</source>
      <category>计算机基础</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<h1 id="编译系统" tabindex="-1"> 编译系统</h1>
<p>以下是一个 hello.c 程序：</p>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>

<span>int</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
    <span>printf</span><span>(</span><span>"hello, world\n"</span><span>)</span><span>;</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div><p>在 Unix 系统上，由编译器把源文件转换为目标文件。</p>
<div><pre><code>gcc -o hello hello.c
</code></pre></div><p>这个过程大致如下：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b396d726-b75f-4a32-89a2-03a7b6e19f6f.jpg" width="800"/> </div>
<ul>
<li>预处理阶段：处理以 # 开头的预处理命令；</li>
<li>编译阶段：翻译成汇编文件；</li>
<li>汇编阶段：将汇编文件翻译成可重定位目标文件；</li>
<li>链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。</li>
</ul>
<h1 id="静态链接" tabindex="-1"> 静态链接</h1>
<p>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p>
<ul>
<li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li>
<li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/47d98583-8bb0-45cc-812d-47eefa0a4a40.jpg"/> </div>
<h1 id="目标文件" tabindex="-1"> 目标文件</h1>
<ul>
<li>可执行目标文件：可以直接在内存中执行；</li>
<li>可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；</li>
<li>共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；</li>
</ul>
<h1 id="动态链接" tabindex="-1"> 动态链接</h1>
<p>静态库有以下两个问题：</p>
<ul>
<li>当静态库更新时那么整个程序都要重新进行链接；</li>
<li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li>
</ul>
<p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p>
<ul>
<li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li>
<li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/76dc7769-1aac-4888-9bea-064f1caa8e77.jpg"/> </div>
]]></content:encoded>
    </item>
    <item>
      <title>LeetCode数据库题解</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%95%B0%E6%8D%AE%E5%BA%93/Leetcode-Database%E9%A2%98%E8%A7%A3.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%95%B0%E6%8D%AE%E5%BA%93/Leetcode-Database%E9%A2%98%E8%A7%A3.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">LeetCode数据库题解</source>
      <category>数据库</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>

<h1 id="_595-big-countries" tabindex="-1"> 595. Big Countries</h1>
<p>https://leetcode.com/problems/big-countries/description/</p>
<h2 id="description" tabindex="-1"> Description</h2>
<div><pre><code>+-----------------+------------+------------+--------------+---------------+
| name            | continent  | area       | population   | gdp           |
+-----------------+------------+------------+--------------+---------------+
| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |
| Albania         | Europe     | 28748      | 2831741      | 12960000      |
| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |
| Andorra         | Europe     | 468        | 78115        | 3712000       |
| Angola          | Africa     | 1246700    | 20609294     | 100990000     |
+-----------------+------------+------------+--------------+---------------+
</code></pre></div><p>查找面积超过 3,000,000 或者人口数超过 25,000,000 的国家。</p>
<div><pre><code>+--------------+-------------+--------------+
| name         | population  | area         |
+--------------+-------------+--------------+
| Afghanistan  | 25500100    | 652230       |
| Algeria      | 37100000    | 2381741      |
+--------------+-------------+--------------+
</code></pre></div><h2 id="sql-schema" tabindex="-1"> SQL Schema</h2>
<p>SQL Schema 用于在本地环境下创建表结构并导入数据，从而方便在本地环境解答。</p>
<div><pre><code><span>DROP</span> <span>TABLE</span>
<span>IF</span>
    <span>EXISTS</span> World<span>;</span>
<span>CREATE</span> <span>TABLE</span> World <span>(</span> NAME <span>VARCHAR</span> <span>(</span> <span>255</span> <span>)</span><span>,</span> continent <span>VARCHAR</span> <span>(</span> <span>255</span> <span>)</span><span>,</span> area <span>INT</span><span>,</span> population <span>INT</span><span>,</span> gdp <span>INT</span> <span>)</span><span>;</span>
<span>INSERT</span> <span>INTO</span> World <span>(</span> NAME<span>,</span> continent<span>,</span> area<span>,</span> population<span>,</span> gdp <span>)</span>
<span>VALUES</span>
    <span>(</span> <span>'Afghanistan'</span><span>,</span> <span>'Asia'</span><span>,</span> <span>'652230'</span><span>,</span> <span>'25500100'</span><span>,</span> <span>'203430000'</span> <span>)</span><span>,</span>
    <span>(</span> <span>'Albania'</span><span>,</span> <span>'Europe'</span><span>,</span> <span>'28748'</span><span>,</span> <span>'2831741'</span><span>,</span> <span>'129600000'</span> <span>)</span><span>,</span>
    <span>(</span> <span>'Algeria'</span><span>,</span> <span>'Africa'</span><span>,</span> <span>'2381741'</span><span>,</span> <span>'37100000'</span><span>,</span> <span>'1886810000'</span> <span>)</span><span>,</span>
    <span>(</span> <span>'Andorra'</span><span>,</span> <span>'Europe'</span><span>,</span> <span>'468'</span><span>,</span> <span>'78115'</span><span>,</span> <span>'37120000'</span> <span>)</span><span>,</span>
    <span>(</span> <span>'Angola'</span><span>,</span> <span>'Africa'</span><span>,</span> <span>'1246700'</span><span>,</span> <span>'20609294'</span><span>,</span> <span>'1009900000'</span> <span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="solution" tabindex="-1"> Solution</h2>
<div><pre><code><span>SELECT</span> name<span>,</span>
    population<span>,</span>
    area
<span>FROM</span>
    World
<span>WHERE</span>
    area <span>></span> <span>3000000</span>
    <span>OR</span> population <span>></span> <span>25000000</span><span>;</span>
</code></pre></div><h1 id="_627-swap-salary" tabindex="-1"> 627. Swap Salary</h1>
<p>https://leetcode.com/problems/swap-salary/description/</p>
<h2 id="description-1" tabindex="-1"> Description</h2>
<div><pre><code>| id  | name | sex | salary |
| --- | ---- | --- | ------ |
| 1   | A    | m   | 2500   |
| 2   | B    | f   | 1500   |
| 3   | C    | m   | 5500   |
| 4   | D    | f   | 500    |
</code></pre></div><p>只用一个 SQL 查询，将 sex 字段反转。</p>
<div><pre><code>| id  | name | sex | salary |
| --- | ---- | --- | ------ |
| 1   | A    | f   | 2500   |
| 2   | B    | m   | 1500   |
| 3   | C    | f   | 5500   |
| 4   | D    | m   | 500    |
</code></pre></div><h2 id="sql-schema-1" tabindex="-1"> SQL Schema</h2>
<div><pre><code><span>DROP</span> <span>TABLE</span>
<span>IF</span>
    <span>EXISTS</span> salary<span>;</span>
<span>CREATE</span> <span>TABLE</span> salary <span>(</span> id <span>INT</span><span>,</span> NAME <span>VARCHAR</span> <span>(</span> <span>100</span> <span>)</span><span>,</span> sex <span>CHAR</span> <span>(</span> <span>1</span> <span>)</span><span>,</span> salary <span>INT</span> <span>)</span><span>;</span>
<span>INSERT</span> <span>INTO</span> salary <span>(</span> id<span>,</span> NAME<span>,</span> sex<span>,</span> salary <span>)</span>
<span>VALUES</span>
    <span>(</span> <span>'1'</span><span>,</span> <span>'A'</span><span>,</span> <span>'m'</span><span>,</span> <span>'2500'</span> <span>)</span><span>,</span>
    <span>(</span> <span>'2'</span><span>,</span> <span>'B'</span><span>,</span> <span>'f'</span><span>,</span> <span>'1500'</span> <span>)</span><span>,</span>
    <span>(</span> <span>'3'</span><span>,</span> <span>'C'</span><span>,</span> <span>'m'</span><span>,</span> <span>'5500'</span> <span>)</span><span>,</span>
    <span>(</span> <span>'4'</span><span>,</span> <span>'D'</span><span>,</span> <span>'f'</span><span>,</span> <span>'500'</span> <span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="solution-1" tabindex="-1"> Solution</h2>
<p>使用异或操作，两个相等的数异或的结果为 0，而 0 与任何一个数异或的结果为这个数。</p>
<div><pre><code>'f' ^ 'm' ^ 'f' = 'm'
'm' ^ 'm' ^ 'f' = 'f'
</code></pre></div><div><pre><code><span>UPDATE</span> salary
<span>SET</span> sex <span>=</span> <span>CHAR</span> <span>(</span> ASCII<span>(</span>sex<span>)</span> <span>^</span> ASCII<span>(</span> <span>'m'</span> <span>)</span> <span>^</span> ASCII<span>(</span> <span>'f'</span> <span>)</span> <span>)</span><span>;</span>
</code></pre></div><h1 id="_620-not-boring-movies" tabindex="-1"> 620. Not Boring Movies</h1>
<p>https://leetcode.com/problems/not-boring-movies/description/</p>
<h2 id="description-2" tabindex="-1"> Description</h2>
<div><pre><code>+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   1     | War       |   great 3D   |   8.9     |
|   2     | Science   |   fiction    |   8.5     |
|   3     | irish     |   boring     |   6.2     |
|   4     | Ice song  |   Fantacy    |   8.6     |
|   5     | House card|   Interesting|   9.1     |
+---------+-----------+--------------+-----------+
</code></pre></div><p>查找 id 为奇数，并且 description 不是 boring 的电影，按 rating 降序。</p>
<div><pre><code>+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   5     | House card|   Interesting|   9.1     |
|   1     | War       |   great 3D   |   8.9     |
+---------+-----------+--------------+-----------+
</code></pre></div><h2 id="sql-schema-2" tabindex="-1"> SQL Schema</h2>
<div><pre><code><span>DROP</span> <span>TABLE</span>
<span>IF</span>
    <span>EXISTS</span> cinema<span>;</span>
<span>CREATE</span> <span>TABLE</span> cinema <span>(</span> id <span>INT</span><span>,</span> movie <span>VARCHAR</span> <span>(</span> <span>255</span> <span>)</span><span>,</span> description <span>VARCHAR</span> <span>(</span> <span>255</span> <span>)</span><span>,</span> rating <span>FLOAT</span> <span>(</span> <span>2</span><span>,</span> <span>1</span> <span>)</span> <span>)</span><span>;</span>
<span>INSERT</span> <span>INTO</span> cinema <span>(</span> id<span>,</span> movie<span>,</span> description<span>,</span> rating <span>)</span>
<span>VALUES</span>
    <span>(</span> <span>1</span><span>,</span> <span>'War'</span><span>,</span> <span>'great 3D'</span><span>,</span> <span>8.9</span> <span>)</span><span>,</span>
    <span>(</span> <span>2</span><span>,</span> <span>'Science'</span><span>,</span> <span>'fiction'</span><span>,</span> <span>8.5</span> <span>)</span><span>,</span>
    <span>(</span> <span>3</span><span>,</span> <span>'irish'</span><span>,</span> <span>'boring'</span><span>,</span> <span>6.2</span> <span>)</span><span>,</span>
    <span>(</span> <span>4</span><span>,</span> <span>'Ice song'</span><span>,</span> <span>'Fantacy'</span><span>,</span> <span>8.6</span> <span>)</span><span>,</span>
    <span>(</span> <span>5</span><span>,</span> <span>'House card'</span><span>,</span> <span>'Interesting'</span><span>,</span> <span>9.1</span> <span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="solution-2" tabindex="-1"> Solution</h2>
<div><pre><code><span>SELECT</span>
    <span>*</span>
<span>FROM</span>
    cinema
<span>WHERE</span>
    id <span>%</span> <span>2</span> <span>=</span> <span>1</span>
    <span>AND</span> description <span>!=</span> <span>'boring'</span>
<span>ORDER</span> <span>BY</span>
    rating <span>DESC</span><span>;</span>
</code></pre></div><h1 id="_596-classes-more-than-5-students" tabindex="-1"> 596. Classes More Than 5 Students</h1>
<p>https://leetcode.com/problems/classes-more-than-5-students/description/</p>
<h2 id="description-3" tabindex="-1"> Description</h2>
<div><pre><code>+---------+------------+
| student | class      |
+---------+------------+
| A       | Math       |
| B       | English    |
| C       | Math       |
| D       | Biology    |
| E       | Math       |
| F       | Computer   |
| G       | Math       |
| H       | Math       |
| I       | Math       |
+---------+------------+
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>查找有五名及以上 student 的 class。</p>
<div><pre><code>+---------+
| class   |
+---------+
| Math    |
+---------+
</code></pre></div><h2 id="sql-schema-3" tabindex="-1"> SQL Schema</h2>
<div><pre><code><span>DROP</span> <span>TABLE</span>
<span>IF</span>
    <span>EXISTS</span> courses<span>;</span>
<span>CREATE</span> <span>TABLE</span> courses <span>(</span> student <span>VARCHAR</span> <span>(</span> <span>255</span> <span>)</span><span>,</span> class <span>VARCHAR</span> <span>(</span> <span>255</span> <span>)</span> <span>)</span><span>;</span>
<span>INSERT</span> <span>INTO</span> courses <span>(</span> student<span>,</span> class <span>)</span>
<span>VALUES</span>
    <span>(</span> <span>'A'</span><span>,</span> <span>'Math'</span> <span>)</span><span>,</span>
    <span>(</span> <span>'B'</span><span>,</span> <span>'English'</span> <span>)</span><span>,</span>
    <span>(</span> <span>'C'</span><span>,</span> <span>'Math'</span> <span>)</span><span>,</span>
    <span>(</span> <span>'D'</span><span>,</span> <span>'Biology'</span> <span>)</span><span>,</span>
    <span>(</span> <span>'E'</span><span>,</span> <span>'Math'</span> <span>)</span><span>,</span>
    <span>(</span> <span>'F'</span><span>,</span> <span>'Computer'</span> <span>)</span><span>,</span>
    <span>(</span> <span>'G'</span><span>,</span> <span>'Math'</span> <span>)</span><span>,</span>
    <span>(</span> <span>'H'</span><span>,</span> <span>'Math'</span> <span>)</span><span>,</span>
    <span>(</span> <span>'I'</span><span>,</span> <span>'Math'</span> <span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="solution-3" tabindex="-1"> Solution</h2>
<p>对 class 列进行分组之后，再使用 count 汇总函数统计数量，统计之后使用 having 进行过滤。</p>
<div><pre><code><span>SELECT</span>
    class
<span>FROM</span>
    courses
<span>GROUP</span> <span>BY</span>
    class
<span>HAVING</span>
    <span>count</span><span>(</span> <span>DISTINCT</span> student <span>)</span> <span>>=</span> <span>5</span><span>;</span>
</code></pre></div><h1 id="_182-duplicate-emails" tabindex="-1"> 182. Duplicate Emails</h1>
<p>https://leetcode.com/problems/duplicate-emails/description/</p>
<h2 id="description-4" tabindex="-1"> Description</h2>
<p>邮件地址表：</p>
<div><pre><code>+----+---------+
| Id | Email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+
</code></pre></div><p>查找重复的邮件地址：</p>
<div><pre><code>+---------+
| Email   |
+---------+
| a@b.com |
+---------+
</code></pre></div><h2 id="sql-schema-4" tabindex="-1"> SQL Schema</h2>
<div><pre><code><span>DROP</span> <span>TABLE</span>
<span>IF</span>
    <span>EXISTS</span> Person<span>;</span>
<span>CREATE</span> <span>TABLE</span> Person <span>(</span> Id <span>INT</span><span>,</span> Email <span>VARCHAR</span> <span>(</span> <span>255</span> <span>)</span> <span>)</span><span>;</span>
<span>INSERT</span> <span>INTO</span> Person <span>(</span> Id<span>,</span> Email <span>)</span>
<span>VALUES</span>
    <span>(</span> <span>1</span><span>,</span> <span>'a@b.com'</span> <span>)</span><span>,</span>
    <span>(</span> <span>2</span><span>,</span> <span>'c@d.com'</span> <span>)</span><span>,</span>
    <span>(</span> <span>3</span><span>,</span> <span>'a@b.com'</span> <span>)</span><span>;</span>
</code></pre></div><h2 id="solution-4" tabindex="-1"> Solution</h2>
<p>对 Email 进行分组，如果相同 Email 的数量大于等于 2，则表示该 Email 重复。</p>
<div><pre><code><span>SELECT</span>
    Email
<span>FROM</span>
    Person
<span>GROUP</span> <span>BY</span>
    Email
<span>HAVING</span>
    <span>COUNT</span><span>(</span> <span>*</span> <span>)</span> <span>>=</span> <span>2</span><span>;</span>
</code></pre></div><h1 id="_196-delete-duplicate-emails" tabindex="-1"> 196. Delete Duplicate Emails</h1>
<p>https://leetcode.com/problems/delete-duplicate-emails/description/</p>
<h2 id="description-5" tabindex="-1"> Description</h2>
<p>邮件地址表：</p>
<div><pre><code>+----+---------+
| Id | Email   |
+----+---------+
| 1  | john@example.com |
| 2  | bob@example.com |
| 3  | john@example.com |
+----+---------+
</code></pre></div><p>删除重复的邮件地址：</p>
<div><pre><code>+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
+----+------------------+
</code></pre></div><h2 id="sql-schema-5" tabindex="-1"> SQL Schema</h2>
<p>与 182 相同。</p>
<h2 id="solution-5" tabindex="-1"> Solution</h2>
<p>只保留相同 Email 中 Id 最小的那一个，然后删除其它的。</p>
<p>连接：</p>
<div><pre><code><span>DELETE</span> p1
<span>FROM</span>
    Person p1<span>,</span>
    Person p2
<span>WHERE</span>
    p1<span>.</span>Email <span>=</span> p2<span>.</span>Email
    <span>AND</span> p1<span>.</span>Id <span>></span> p2<span>.</span>Id
</code></pre></div><p>子查询：</p>
<div><pre><code><span>DELETE</span>
<span>FROM</span>
    Person
<span>WHERE</span>
    id <span>NOT</span> <span>IN</span> <span>(</span> <span>SELECT</span> id <span>FROM</span> <span>(</span> <span>SELECT</span> <span>min</span><span>(</span> id <span>)</span> <span>AS</span> id <span>FROM</span> Person <span>GROUP</span> <span>BY</span> email <span>)</span> <span>AS</span> m <span>)</span><span>;</span>
</code></pre></div><p>应该注意的是上述解法额外嵌套了一个 SELECT 语句，如果不这么做，会出现错误：You can't specify target table 'Person' for update in FROM clause。以下演示了这种错误解法。</p>
<div><pre><code><span>DELETE</span>
<span>FROM</span>
    Person
<span>WHERE</span>
    id <span>NOT</span> <span>IN</span> <span>(</span> <span>SELECT</span> <span>min</span><span>(</span> id <span>)</span> <span>AS</span> id <span>FROM</span> Person <span>GROUP</span> <span>BY</span> email <span>)</span><span>;</span>
</code></pre></div><p>参考：<a href="https://stackoverflow.com/questions/45494/mysql-error-1093-cant-specify-target-table-for-update-in-from-clause" target="_blank" rel="noopener noreferrer">pMySQL Error 1093 - Can't specify target table for update in FROM clause</a></p>
<h1 id="_175-combine-two-tables" tabindex="-1"> 175. Combine Two Tables</h1>
<p>https://leetcode.com/problems/combine-two-tables/description/</p>
<h2 id="description-6" tabindex="-1"> Description</h2>
<p>Person 表：</p>
<div><pre><code>+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| PersonId    | int     |
| FirstName   | varchar |
| LastName    | varchar |
+-------------+---------+
PersonId is the primary key column for this table.
</code></pre></div><p>Address 表：</p>
<div><pre><code>+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| AddressId   | int     |
| PersonId    | int     |
| City        | varchar |
| State       | varchar |
+-------------+---------+
AddressId is the primary key column for this table.
</code></pre></div><p>查找 FirstName, LastName, City, State 数据，而不管一个用户有没有填地址信息。</p>
<h2 id="sql-schema-6" tabindex="-1"> SQL Schema</h2>
<div><pre><code><span>DROP</span> <span>TABLE</span>
<span>IF</span>
    <span>EXISTS</span> Person<span>;</span>
<span>CREATE</span> <span>TABLE</span> Person <span>(</span> PersonId <span>INT</span><span>,</span> FirstName <span>VARCHAR</span> <span>(</span> <span>255</span> <span>)</span><span>,</span> LastName <span>VARCHAR</span> <span>(</span> <span>255</span> <span>)</span> <span>)</span><span>;</span>
<span>DROP</span> <span>TABLE</span>
<span>IF</span>
    <span>EXISTS</span> Address<span>;</span>
<span>CREATE</span> <span>TABLE</span> Address <span>(</span> AddressId <span>INT</span><span>,</span> PersonId <span>INT</span><span>,</span> City <span>VARCHAR</span> <span>(</span> <span>255</span> <span>)</span><span>,</span> State <span>VARCHAR</span> <span>(</span> <span>255</span> <span>)</span> <span>)</span><span>;</span>
<span>INSERT</span> <span>INTO</span> Person <span>(</span> PersonId<span>,</span> LastName<span>,</span> FirstName <span>)</span>
<span>VALUES</span>
    <span>(</span> <span>1</span><span>,</span> <span>'Wang'</span><span>,</span> <span>'Allen'</span> <span>)</span><span>;</span>
<span>INSERT</span> <span>INTO</span> Address <span>(</span> AddressId<span>,</span> PersonId<span>,</span> City<span>,</span> State <span>)</span>
<span>VALUES</span>
    <span>(</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>'New York City'</span><span>,</span> <span>'New York'</span> <span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="solution-6" tabindex="-1"> Solution</h2>
<p>涉及到 Person 和 Address 两个表，在对这两个表执行连接操作时，因为要保留 Person 表中的信息，即使在 Address 表中没有关联的信息也要保留。此时可以用左外连接，将 Person 表放在 LEFT JOIN 的左边。</p>
<div><pre><code><span>SELECT</span>
    FirstName<span>,</span>
    LastName<span>,</span>
    City<span>,</span>
    State
<span>FROM</span>
    Person P
    <span>LEFT</span> <span>JOIN</span> Address A
    <span>ON</span> P<span>.</span>PersonId <span>=</span> A<span>.</span>PersonId<span>;</span>
</code></pre></div><h1 id="_181-employees-earning-more-than-their-managers" tabindex="-1"> 181. Employees Earning More Than Their Managers</h1>
<p>https://leetcode.com/problems/employees-earning-more-than-their-managers/description/</p>
<h2 id="description-7" tabindex="-1"> Description</h2>
<p>Employee 表：</p>
<div><pre><code>+----+-------+--------+-----------+
| Id | Name  | Salary | ManagerId |
+----+-------+--------+-----------+
| 1  | Joe   | 70000  | 3         |
| 2  | Henry | 80000  | 4         |
| 3  | Sam   | 60000  | NULL      |
| 4  | Max   | 90000  | NULL      |
+----+-------+--------+-----------+
</code></pre></div><p>查找薪资大于其经理薪资的员工信息。</p>
<h2 id="sql-schema-7" tabindex="-1"> SQL Schema</h2>
<div><pre><code><span>DROP</span> <span>TABLE</span>
<span>IF</span>
    <span>EXISTS</span> Employee<span>;</span>
<span>CREATE</span> <span>TABLE</span> Employee <span>(</span> Id <span>INT</span><span>,</span> NAME <span>VARCHAR</span> <span>(</span> <span>255</span> <span>)</span><span>,</span> Salary <span>INT</span><span>,</span> ManagerId <span>INT</span> <span>)</span><span>;</span>
<span>INSERT</span> <span>INTO</span> Employee <span>(</span> Id<span>,</span> NAME<span>,</span> Salary<span>,</span> ManagerId <span>)</span>
<span>VALUES</span>
    <span>(</span> <span>1</span><span>,</span> <span>'Joe'</span><span>,</span> <span>70000</span><span>,</span> <span>3</span> <span>)</span><span>,</span>
    <span>(</span> <span>2</span><span>,</span> <span>'Henry'</span><span>,</span> <span>80000</span><span>,</span> <span>4</span> <span>)</span><span>,</span>
    <span>(</span> <span>3</span><span>,</span> <span>'Sam'</span><span>,</span> <span>60000</span><span>,</span> <span>NULL</span> <span>)</span><span>,</span>
    <span>(</span> <span>4</span><span>,</span> <span>'Max'</span><span>,</span> <span>90000</span><span>,</span> <span>NULL</span> <span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="solution-7" tabindex="-1"> Solution</h2>
<div><pre><code><span>SELECT</span>
    E1<span>.</span>NAME <span>AS</span> Employee
<span>FROM</span>
    Employee E1
    <span>INNER</span> <span>JOIN</span> Employee E2
    <span>ON</span> E1<span>.</span>ManagerId <span>=</span> E2<span>.</span>Id
    <span>AND</span> E1<span>.</span>Salary <span>></span> E2<span>.</span>Salary<span>;</span>
</code></pre></div><h1 id="_183-customers-who-never-order" tabindex="-1"> 183. Customers Who Never Order</h1>
<p>https://leetcode.com/problems/customers-who-never-order/description/</p>
<h2 id="description-8" tabindex="-1"> Description</h2>
<p>Customers 表：</p>
<div><pre><code>+----+-------+
| Id | Name  |
+----+-------+
| 1  | Joe   |
| 2  | Henry |
| 3  | Sam   |
| 4  | Max   |
+----+-------+
</code></pre></div><p>Orders 表：</p>
<div><pre><code>+----+------------+
| Id | CustomerId |
+----+------------+
| 1  | 3          |
| 2  | 1          |
+----+------------+
</code></pre></div><p>查找没有订单的顾客信息：</p>
<div><pre><code>+-----------+
| Customers |
+-----------+
| Henry     |
| Max       |
+-----------+
</code></pre></div><h2 id="sql-schema-8" tabindex="-1"> SQL Schema</h2>
<div><pre><code><span>DROP</span> <span>TABLE</span>
<span>IF</span>
    <span>EXISTS</span> Customers<span>;</span>
<span>CREATE</span> <span>TABLE</span> Customers <span>(</span> Id <span>INT</span><span>,</span> NAME <span>VARCHAR</span> <span>(</span> <span>255</span> <span>)</span> <span>)</span><span>;</span>
<span>DROP</span> <span>TABLE</span>
<span>IF</span>
    <span>EXISTS</span> Orders<span>;</span>
<span>CREATE</span> <span>TABLE</span> Orders <span>(</span> Id <span>INT</span><span>,</span> CustomerId <span>INT</span> <span>)</span><span>;</span>
<span>INSERT</span> <span>INTO</span> Customers <span>(</span> Id<span>,</span> NAME <span>)</span>
<span>VALUES</span>
    <span>(</span> <span>1</span><span>,</span> <span>'Joe'</span> <span>)</span><span>,</span>
    <span>(</span> <span>2</span><span>,</span> <span>'Henry'</span> <span>)</span><span>,</span>
    <span>(</span> <span>3</span><span>,</span> <span>'Sam'</span> <span>)</span><span>,</span>
    <span>(</span> <span>4</span><span>,</span> <span>'Max'</span> <span>)</span><span>;</span>
<span>INSERT</span> <span>INTO</span> Orders <span>(</span> Id<span>,</span> CustomerId <span>)</span>
<span>VALUES</span>
    <span>(</span> <span>1</span><span>,</span> <span>3</span> <span>)</span><span>,</span>
    <span>(</span> <span>2</span><span>,</span> <span>1</span> <span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id="solution-8" tabindex="-1"> Solution</h2>
<p>左外链接</p>
<div><pre><code><span>SELECT</span>
    C<span>.</span>Name <span>AS</span> Customers
<span>FROM</span>
    Customers C
    <span>LEFT</span> <span>JOIN</span> Orders O
    <span>ON</span> C<span>.</span>Id <span>=</span> O<span>.</span>CustomerId
<span>WHERE</span>
    O<span>.</span>CustomerId <span>IS</span> <span>NULL</span><span>;</span>
</code></pre></div><p>子查询</p>
<div><pre><code><span>SELECT</span>
    Name <span>AS</span> Customers
<span>FROM</span>
    Customers
<span>WHERE</span>
    Id <span>NOT</span> <span>IN</span> <span>(</span> <span>SELECT</span> CustomerId <span>FROM</span> Orders <span>)</span><span>;</span>
</code></pre></div><h1 id="_184-department-highest-salary" tabindex="-1"> 184. Department Highest Salary</h1>
<p>https://leetcode.com/problems/department-highest-salary/description/</p>
<h2 id="description-9" tabindex="-1"> Description</h2>
<p>Employee 表：</p>
<div><pre><code>+----+-------+--------+--------------+
| Id | Name  | Salary | DepartmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 70000  | 1            |
| 2  | Henry | 80000  | 2            |
| 3  | Sam   | 60000  | 2            |
| 4  | Max   | 90000  | 1            |
+----+-------+--------+--------------+
</code></pre></div><p>Department 表：</p>
<div><pre><code>+----+----------+
| Id | Name     |
+----+----------+
| 1  | IT       |
| 2  | Sales    |
+----+----------+
</code></pre></div><p>查找一个 Department 中收入最高者的信息：</p>
<div><pre><code>+------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Max      | 90000  |
| Sales      | Henry    | 80000  |
+------------+----------+--------+
</code></pre></div><h2 id="sql-schema-9" tabindex="-1"> SQL Schema</h2>
<div><pre><code><span>DROP</span> <span>TABLE</span> <span>IF</span> <span>EXISTS</span> Employee<span>;</span>
<span>CREATE</span> <span>TABLE</span> Employee <span>(</span> Id <span>INT</span><span>,</span> NAME <span>VARCHAR</span> <span>(</span> <span>255</span> <span>)</span><span>,</span> Salary <span>INT</span><span>,</span> DepartmentId <span>INT</span> <span>)</span><span>;</span>
<span>DROP</span> <span>TABLE</span> <span>IF</span> <span>EXISTS</span> Department<span>;</span>
<span>CREATE</span> <span>TABLE</span> Department <span>(</span> Id <span>INT</span><span>,</span> NAME <span>VARCHAR</span> <span>(</span> <span>255</span> <span>)</span> <span>)</span><span>;</span>
<span>INSERT</span> <span>INTO</span> Employee <span>(</span> Id<span>,</span> NAME<span>,</span> Salary<span>,</span> DepartmentId <span>)</span>
<span>VALUES</span>
    <span>(</span> <span>1</span><span>,</span> <span>'Joe'</span><span>,</span> <span>70000</span><span>,</span> <span>1</span> <span>)</span><span>,</span>
    <span>(</span> <span>2</span><span>,</span> <span>'Henry'</span><span>,</span> <span>80000</span><span>,</span> <span>2</span> <span>)</span><span>,</span>
    <span>(</span> <span>3</span><span>,</span> <span>'Sam'</span><span>,</span> <span>60000</span><span>,</span> <span>2</span> <span>)</span><span>,</span>
    <span>(</span> <span>4</span><span>,</span> <span>'Max'</span><span>,</span> <span>90000</span><span>,</span> <span>1</span> <span>)</span><span>;</span>
<span>INSERT</span> <span>INTO</span> Department <span>(</span> Id<span>,</span> NAME <span>)</span>
<span>VALUES</span>
    <span>(</span> <span>1</span><span>,</span> <span>'IT'</span> <span>)</span><span>,</span>
    <span>(</span> <span>2</span><span>,</span> <span>'Sales'</span> <span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="solution-9" tabindex="-1"> Solution</h2>
<p>创建一个临时表，包含了部门员工的最大薪资。可以对部门进行分组，然后使用 MAX() 汇总函数取得最大薪资。</p>
<p>之后使用连接找到一个部门中薪资等于临时表中最大薪资的员工。</p>
<div><pre><code><span>SELECT</span>
    D<span>.</span>NAME Department<span>,</span>
    E<span>.</span>NAME Employee<span>,</span>
    E<span>.</span>Salary
<span>FROM</span>
    Employee E<span>,</span>
    Department D<span>,</span>
    <span>(</span> <span>SELECT</span> DepartmentId<span>,</span> <span>MAX</span><span>(</span> Salary <span>)</span> Salary <span>FROM</span> Employee <span>GROUP</span> <span>BY</span> DepartmentId <span>)</span> M
<span>WHERE</span>
    E<span>.</span>DepartmentId <span>=</span> D<span>.</span>Id
    <span>AND</span> E<span>.</span>DepartmentId <span>=</span> M<span>.</span>DepartmentId
    <span>AND</span> E<span>.</span>Salary <span>=</span> M<span>.</span>Salary<span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h1 id="_176-second-highest-salary" tabindex="-1"> 176. Second Highest Salary</h1>
<p>https://leetcode.com/problems/second-highest-salary/description/</p>
<h2 id="description-10" tabindex="-1"> Description</h2>
<div><pre><code>+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
</code></pre></div><p>查找工资第二高的员工。</p>
<div><pre><code>+---------------------+
| SecondHighestSalary |
+---------------------+
| 200                 |
+---------------------+
</code></pre></div><p>没有找到返回 null 而不是不返回数据。</p>
<h2 id="sql-schema-10" tabindex="-1"> SQL Schema</h2>
<div><pre><code><span>DROP</span> <span>TABLE</span>
<span>IF</span>
    <span>EXISTS</span> Employee<span>;</span>
<span>CREATE</span> <span>TABLE</span> Employee <span>(</span> Id <span>INT</span><span>,</span> Salary <span>INT</span> <span>)</span><span>;</span>
<span>INSERT</span> <span>INTO</span> Employee <span>(</span> Id<span>,</span> Salary <span>)</span>
<span>VALUES</span>
    <span>(</span> <span>1</span><span>,</span> <span>100</span> <span>)</span><span>,</span>
    <span>(</span> <span>2</span><span>,</span> <span>200</span> <span>)</span><span>,</span>
    <span>(</span> <span>3</span><span>,</span> <span>300</span> <span>)</span><span>;</span>
</code></pre></div><h2 id="solution-10" tabindex="-1"> Solution</h2>
<p>为了在没有查找到数据时返回 null，需要在查询结果外面再套一层 SELECT。</p>
<div><pre><code><span>SELECT</span>
    <span>(</span> <span>SELECT</span> <span>DISTINCT</span> Salary <span>FROM</span> Employee <span>ORDER</span> <span>BY</span> Salary <span>DESC</span> <span>LIMIT</span> <span>1</span><span>,</span> <span>1</span> <span>)</span> SecondHighestSalary<span>;</span>
</code></pre></div><h1 id="_177-nth-highest-salary" tabindex="-1"> 177. Nth Highest Salary</h1>
<h2 id="description-11" tabindex="-1"> Description</h2>
<p>查找工资第 N 高的员工。</p>
<h2 id="sql-schema-11" tabindex="-1"> SQL Schema</h2>
<p>同 176。</p>
<h2 id="solution-11" tabindex="-1"> Solution</h2>
<div><pre><code><span>CREATE</span> <span>FUNCTION</span> getNthHighestSalary <span>(</span> N <span>INT</span> <span>)</span> <span>RETURNS</span> <span>INT</span> <span>BEGIN</span>

<span>SET</span> N <span>=</span> N <span>-</span> <span>1</span><span>;</span>
<span>RETURN</span> <span>(</span> <span>SELECT</span> <span>(</span> <span>SELECT</span> <span>DISTINCT</span> Salary <span>FROM</span> Employee <span>ORDER</span> <span>BY</span> Salary <span>DESC</span> <span>LIMIT</span> N<span>,</span> <span>1</span> <span>)</span> <span>)</span><span>;</span>

<span>END</span>
</code></pre></div><h1 id="_178-rank-scores" tabindex="-1"> 178. Rank Scores</h1>
<p>https://leetcode.com/problems/rank-scores/description/</p>
<h2 id="description-12" tabindex="-1"> Description</h2>
<p>得分表：</p>
<div><pre><code>+----+-------+
| Id | Score |
+----+-------+
| 1  | 3.50  |
| 2  | 3.65  |
| 3  | 4.00  |
| 4  | 3.85  |
| 5  | 4.00  |
| 6  | 3.65  |
+----+-------+
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>将得分排序，并统计排名。</p>
<div><pre><code>+-------+------+
| Score | Rank |
+-------+------+
| 4.00  | 1    |
| 4.00  | 1    |
| 3.85  | 2    |
| 3.65  | 3    |
| 3.65  | 3    |
| 3.50  | 4    |
+-------+------+
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="sql-schema-12" tabindex="-1"> SQL Schema</h2>
<div><pre><code><span>DROP</span> <span>TABLE</span>
<span>IF</span>
    <span>EXISTS</span> Scores<span>;</span>
<span>CREATE</span> <span>TABLE</span> Scores <span>(</span> Id <span>INT</span><span>,</span> Score <span>DECIMAL</span> <span>(</span> <span>3</span><span>,</span> <span>2</span> <span>)</span> <span>)</span><span>;</span>
<span>INSERT</span> <span>INTO</span> Scores <span>(</span> Id<span>,</span> Score <span>)</span>
<span>VALUES</span>
    <span>(</span> <span>1</span><span>,</span> <span>3.5</span> <span>)</span><span>,</span>
    <span>(</span> <span>2</span><span>,</span> <span>3.65</span> <span>)</span><span>,</span>
    <span>(</span> <span>3</span><span>,</span> <span>4.0</span> <span>)</span><span>,</span>
    <span>(</span> <span>4</span><span>,</span> <span>3.85</span> <span>)</span><span>,</span>
    <span>(</span> <span>5</span><span>,</span> <span>4.0</span> <span>)</span><span>,</span>
    <span>(</span> <span>6</span><span>,</span> <span>3.65</span> <span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="solution-12" tabindex="-1"> Solution</h2>
<p>要统计某个 score 的排名，只要统计大于该 score 的 score 数量，然后加 1。</p>
<table>
<thead>
<tr>
<th style="text-align:center">score</th>
<th style="text-align:center">大于该 score 的 score 数量</th>
<th style="text-align:center">排名</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4.1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">4.2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">4.3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>但是在本题中，相同的 score 只算一个排名：</p>
<table>
<thead>
<tr>
<th style="text-align:center">score</th>
<th style="text-align:center">排名</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4.1</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">4.1</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">4.2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">4.2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">4.3</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">4.3</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>可以按 score 进行分组，将同一个分组中的 score 只当成一个。</p>
<p>但是如果分组字段只有 score 的话，那么相同的 score 最后的结果只会有一个，例如上面的 6 个记录最后只取出 3 个。</p>
<table>
<thead>
<tr>
<th style="text-align:center">score</th>
<th style="text-align:center">排名</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4.1</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">4.2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">4.3</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>所以在分组中需要加入 Id，每个记录显示一个结果。综上，需要使用 score 和 id 两个分组字段。</p>
<p>在下面的实现中，首先将 Scores 表根据 score 字段进行自连接，得到一个新表，然后在新表上对 id 和 score 进行分组。</p>
<div><pre><code><span>SELECT</span>
    S1<span>.</span>score <span>'Score'</span><span>,</span>
    <span>COUNT</span><span>(</span> <span>DISTINCT</span> S2<span>.</span>score <span>)</span> <span>'Rank'</span>
<span>FROM</span>
    Scores S1
    <span>INNER</span> <span>JOIN</span> Scores S2
    <span>ON</span> S1<span>.</span>score <span>&lt;=</span> S2<span>.</span>score
<span>GROUP</span> <span>BY</span>
    S1<span>.</span>id<span>,</span> S1<span>.</span>score
<span>ORDER</span> <span>BY</span>
    S1<span>.</span>score <span>DESC</span><span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h1 id="_180-consecutive-numbers" tabindex="-1"> 180. Consecutive Numbers</h1>
<p>https://leetcode.com/problems/consecutive-numbers/description/</p>
<h2 id="description-13" tabindex="-1"> Description</h2>
<p>数字表：</p>
<div><pre><code>+----+-----+
| Id | Num |
+----+-----+
| 1  |  1  |
| 2  |  1  |
| 3  |  1  |
| 4  |  2  |
| 5  |  1  |
| 6  |  2  |
| 7  |  2  |
+----+-----+
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>查找连续出现三次的数字。</p>
<div><pre><code>+-----------------+
| ConsecutiveNums |
+-----------------+
| 1               |
+-----------------+
</code></pre></div><h2 id="sql-schema-13" tabindex="-1"> SQL Schema</h2>
<div><pre><code><span>DROP</span> <span>TABLE</span>
<span>IF</span>
    <span>EXISTS</span> LOGS<span>;</span>
<span>CREATE</span> <span>TABLE</span> LOGS <span>(</span> Id <span>INT</span><span>,</span> Num <span>INT</span> <span>)</span><span>;</span>
<span>INSERT</span> <span>INTO</span> LOGS <span>(</span> Id<span>,</span> Num <span>)</span>
<span>VALUES</span>
    <span>(</span> <span>1</span><span>,</span> <span>1</span> <span>)</span><span>,</span>
    <span>(</span> <span>2</span><span>,</span> <span>1</span> <span>)</span><span>,</span>
    <span>(</span> <span>3</span><span>,</span> <span>1</span> <span>)</span><span>,</span>
    <span>(</span> <span>4</span><span>,</span> <span>2</span> <span>)</span><span>,</span>
    <span>(</span> <span>5</span><span>,</span> <span>1</span> <span>)</span><span>,</span>
    <span>(</span> <span>6</span><span>,</span> <span>2</span> <span>)</span><span>,</span>
    <span>(</span> <span>7</span><span>,</span> <span>2</span> <span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="solution-13" tabindex="-1"> Solution</h2>
<div><pre><code><span>SELECT</span>
    <span>DISTINCT</span> L1<span>.</span>num ConsecutiveNums
<span>FROM</span>
    Logs L1<span>,</span>
    Logs L2<span>,</span>
    Logs L3
<span>WHERE</span> L1<span>.</span>id <span>=</span> l2<span>.</span>id <span>-</span> <span>1</span>
    <span>AND</span> L2<span>.</span>id <span>=</span> L3<span>.</span>id <span>-</span> <span>1</span>
    <span>AND</span> L1<span>.</span>num <span>=</span> L2<span>.</span>num
    <span>AND</span> l2<span>.</span>num <span>=</span> l3<span>.</span>num<span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h1 id="_626-exchange-seats" tabindex="-1"> 626. Exchange Seats</h1>
<p>https://leetcode.com/problems/exchange-seats/description/</p>
<h2 id="description-14" tabindex="-1"> Description</h2>
<p>seat 表存储着座位对应的学生。</p>
<div><pre><code>+---------+---------+
|    id   | student |
+---------+---------+
|    1    | Abbot   |
|    2    | Doris   |
|    3    | Emerson |
|    4    | Green   |
|    5    | Jeames  |
+---------+---------+
</code></pre></div><p>要求交换相邻座位的两个学生，如果最后一个座位是奇数，那么不交换这个座位上的学生。</p>
<div><pre><code>+---------+---------+
|    id   | student |
+---------+---------+
|    1    | Doris   |
|    2    | Abbot   |
|    3    | Green   |
|    4    | Emerson |
|    5    | Jeames  |
+---------+---------+
</code></pre></div><h2 id="sql-schema-14" tabindex="-1"> SQL Schema</h2>
<div><pre><code><span>DROP</span> <span>TABLE</span>
<span>IF</span>
    <span>EXISTS</span> seat<span>;</span>
<span>CREATE</span> <span>TABLE</span> seat <span>(</span> id <span>INT</span><span>,</span> student <span>VARCHAR</span> <span>(</span> <span>255</span> <span>)</span> <span>)</span><span>;</span>
<span>INSERT</span> <span>INTO</span> seat <span>(</span> id<span>,</span> student <span>)</span>
<span>VALUES</span>
    <span>(</span> <span>'1'</span><span>,</span> <span>'Abbot'</span> <span>)</span><span>,</span>
    <span>(</span> <span>'2'</span><span>,</span> <span>'Doris'</span> <span>)</span><span>,</span>
    <span>(</span> <span>'3'</span><span>,</span> <span>'Emerson'</span> <span>)</span><span>,</span>
    <span>(</span> <span>'4'</span><span>,</span> <span>'Green'</span> <span>)</span><span>,</span>
    <span>(</span> <span>'5'</span><span>,</span> <span>'Jeames'</span> <span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="solution-14" tabindex="-1"> Solution</h2>
<p>使用多个 union。</p>
<div><pre><code><span># 处理偶数 id，让 id 减 1</span>
<span># 例如 2,4,6,... 变成 1,3,5,...</span>
<span>SELECT</span>
    s1<span>.</span>id <span>-</span> <span>1</span> <span>AS</span> id<span>,</span>
    s1<span>.</span>student
<span>FROM</span>
    seat s1
<span>WHERE</span>
    s1<span>.</span>id MOD <span>2</span> <span>=</span> <span>0</span> <span>UNION</span>
<span># 处理奇数 id，让 id 加 1。但是如果最大的 id 为奇数，则不做处理</span>
<span># 例如 1,3,5,... 变成 2,4,6,...</span>
<span>SELECT</span>
    s2<span>.</span>id <span>+</span> <span>1</span> <span>AS</span> id<span>,</span>
    s2<span>.</span>student
<span>FROM</span>
    seat s2
<span>WHERE</span>
    s2<span>.</span>id MOD <span>2</span> <span>=</span> <span>1</span>
    <span>AND</span> s2<span>.</span>id <span>!=</span> <span>(</span> <span>SELECT</span> <span>max</span><span>(</span> s3<span>.</span>id <span>)</span> <span>FROM</span> seat s3 <span>)</span> <span>UNION</span>
<span># 如果最大的 id 为奇数，单独取出这个数</span>
<span>SELECT</span>
    s4<span>.</span>id <span>AS</span> id<span>,</span>
    s4<span>.</span>student
<span>FROM</span>
    seat s4
<span>WHERE</span>
    s4<span>.</span>id MOD <span>2</span> <span>=</span> <span>1</span>
    <span>AND</span> s4<span>.</span>id <span>=</span> <span>(</span> <span>SELECT</span> <span>max</span><span>(</span> s5<span>.</span>id <span>)</span> <span>FROM</span> seat s5 <span>)</span>
<span>ORDER</span> <span>BY</span>
    id<span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>PandoraBoot</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%A1%86%E6%9E%B6/PandoraBoot.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%A1%86%E6%9E%B6/PandoraBoot.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">PandoraBoot</source>
      <category>框架</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="pandora-boot" tabindex="-1"> Pandora Boot</h1>
<p>首先，Pandora Boot 与 Spring Boot 无缝集成，使用 Pandora Boot 的同时也可以充分享受 Spring Boot 的便利；</p>
<p>其次，Pandora Boot 是在 Pandora 的基础之上，发展出的更轻量使用集团中间件的方式；它基于 Pandora 和 Fat Jar 技术，可以直接在 IDE 里启动 Pandora 环境，开发调试等效率都大大提高；</p>
<h2 id="pandora介绍" tabindex="-1"> Pandora介绍</h2>
<p>Pandora是一个轻量级的隔离容器，也就是taobao-hsf.sar，它用来隔离Webapp和中间件的依赖，也用来隔离中间件之间的依赖。</p>
<h3 id="功能" tabindex="-1"> 功能</h3>
<ul>
<li>依赖隔离：能够隔离中间件与应用、中间件与中间件之间的依赖，让其相互之间互不影响</li>
<li>部署隔离：部署和应用分离，中间件升级相对于应用透明</li>
</ul>
<h3 id="用途" tabindex="-1"> 用途</h3>
<ul>
<li>升级：应用方可以在运维系统上轻松选择中间件版本并进行升级，该过程不需要应用方修改应用依赖配置，对应用方透明，能够在短时间做到大规模的中间件客户端升级</li>
<li>束腰：这里提到束腰其实代表着中间件客户端都会以Sar包的形式统一交付，发散不同的团队开发不同的产品，但是到pandora sar包阶段，只会有一个交付的包，这时就能够进行统一的测试，而不用各个团队分开执行，是测试效率的有效保证</li>
</ul>
<blockquote>
<p>束腰，古代建筑学术语。指建筑中的收束部位。 宋 李诫 《营造法式》卷三：“造殿阶基之制……其叠澁每层露棱五寸，束腰露身一尺，用隔身版柱，柱内平面作起突壶门造。”</p>
</blockquote>
<ul>
<li>隔离:由于隔离了中间件对于应用的依赖冲突，对应用升级时应用依赖包的影响基本为0，非常安全</li>
</ul>
<h3 id="架构" tabindex="-1"> 架构</h3>
<p>整个框架由Pipeline、Stage、Service构成。Pipeline表示管道，在管道的每一个环节由Stage完成相应的操作。Pipeline、所有的Stage、Service注册到轻量级的IoC容器，该IoC容器支持Setter注入和单例模式。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-19-16-53-03.png" alt="" loading="lazy"></p>
<p>Pandora启动过程中的几个核心类：</p>
<p>PandoraContainer ：容器入口，启动Pandora容器，创建PipelineContext、ServiceContainer。</p>
<p>ServiceContainer ：IOC容器，管理服务的实例化、装配、依赖注入及生命周期管理等操作。框架服务容器管理Pandora注册的Pipeline、Stage、Service，只能由框架自己进行注册，所有插件在任何阶段都可以通过Context访问到这些服务</p>
<p>PluginModuleFactory：插件工厂，提供插件初始化, 最终通过ClassLoaderService.createModuleClassLoader为每个插件创建一个ModuleClassLoader。</p>
<h3 id="加载机制" tabindex="-1"> 加载机制</h3>
<p>JVM中区分类的方式是判断全限定类名和对应类加载器，如果二者一致，则认为是同一个类。对于jar版本不同的类其全限定类名是一致的，所以只能通过不同的classLoader来实现类隔离。</p>
<p>Pandora 中有 3 种 ClassLoader，其中 2 种是 Pandora 内部构建的 ClassLoader，另外一种是第三方应用的ClassLoader。如下：</p>
<ul>
<li>PandoraClassLoader：Pandora容器启动类加载器，用于加载包括PandoraContainer在内的 %{pandora_sar_path}/lib 下jar包中的类。PandoraClassLoader 就是一个普通的 URLClassLoader，并没有什么特别之处，由于 pandoraClassLoader 和应用的 ClassLoader 并不是同一个 ClassLoader，因此 pandora 容器与第三方应用容器实现了隔离。</li>
<li>ModuleClassLoader：Pandora 中间件的类加载器，用于加载%{pandora_sar_path}/plugins目录下的中间件。在部署每一个中间件的时候，pandora 都会创建一个新的 ModuleClassLoader，因此中间件与中间件之间也是相互隔离的。</li>
<li>bizClassLoader：外部类加载器，可以在构建 PandoraContainer 的时候作为参数从第三方容器中传入，作为类导出/导入交互的类加载器，但这不是必须的。</li>
</ul>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-19-16-57-01.png" alt="" loading="lazy"></p>
<p>通过上图我们可以看出，PandoraClassLoader 实现了 pandora中所有中间件与业务方应用的隔离，在 Pandora 内部利用 ModuleClassLoader 实现了各个中间件之间的隔离，然后 Pandora 会把加载好的隔离的中间件中的类导出到 cachedClasses 中(Pandora 内部维护的一个 Map)，AliTomcat 会利用动态代理或者纯粹是反射去获取 cachedClasses 存放到 SharedClassRepository 中(AliTomcat 内部维护的一个类，用于管理 Pandora 导出的 classes)。业务方应用的类加载器 AliWebappClassLoaderBase 在加载类的时候，并不是严格遵循双亲委派模型，它首先会从 SharedClassRepository 中查找需要加载的类，如果找不到才会去走 tomcat 加载类的流程。因此，Pandora 中的中间件是优先被加载的。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-19-16-59-00.png" alt="" loading="lazy"></p>
]]></content:encoded>
    </item>
    <item>
      <title>1. 求开方</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">1. 求开方</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p><strong>正常实现</strong></p>
<div><pre><code>Input : [1,2,3,4,5]
key : 3
return the index : 2
</code></pre></div><div><pre><code><span>public</span> <span>int</span> <span>binarySearch</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> key<span>)</span> <span>{</span>
    <span>int</span> l <span>=</span> <span>0</span><span>,</span> h <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span>l <span>&lt;=</span> h<span>)</span> <span>{</span>
        <span>int</span> m <span>=</span> l <span>+</span> <span>(</span>h <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
        <span>if</span> <span>(</span>nums<span>[</span>m<span>]</span> <span>==</span> key<span>)</span> <span>{</span>
            <span>return</span> m<span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>nums<span>[</span>m<span>]</span> <span>></span> key<span>)</span> <span>{</span>
            h <span>=</span> m <span>-</span> <span>1</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            l <span>=</span> m <span>+</span> <span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>-</span><span>1</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><strong>时间复杂度</strong></p>
<p>二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。</p>
<p><strong>m 计算</strong></p>
<p>有两种计算中值 m 的方式：</p>
<ul>
<li>m = (l + h) / 2</li>
<li>m = l + (h - l) / 2</li>
</ul>
<p>l + h 可能出现加法溢出，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。所以，最好使用第二种计算法方法。</p>
<p><strong>未成功查找的返回值</strong></p>
<p>循环退出时如果仍然没有查找到 key，那么表示查找失败。可以有两种返回值：</p>
<ul>
<li>-1：以一个错误码表示没有查找到 key</li>
<li>l：将 key 插入到 nums 中的正确位置</li>
</ul>
<p><strong>变种</strong></p>
<p>二分查找可以有很多变种，变种实现要注意边界值的判断。例如在一个有重复元素的数组中查找 key 的最左位置的实现如下：</p>
<div><pre><code><span>public</span> <span>int</span> <span>binarySearch</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> key<span>)</span> <span>{</span>
    <span>int</span> l <span>=</span> <span>0</span><span>,</span> h <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span>l <span>&lt;</span> h<span>)</span> <span>{</span>
        <span>int</span> m <span>=</span> l <span>+</span> <span>(</span>h <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
        <span>if</span> <span>(</span>nums<span>[</span>m<span>]</span> <span>>=</span> key<span>)</span> <span>{</span>
            h <span>=</span> m<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            l <span>=</span> m <span>+</span> <span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> l<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>该实现和正常实现有以下不同：</p>
<ul>
<li>h 的赋值表达式为 h = m</li>
<li>循环条件为 l &lt; h</li>
<li>最后返回 l 而不是 -1</li>
</ul>
<p>在 nums[m] &gt;= key 的情况下，可以推导出最左 key 位于 [l, m] 区间中，这是一个闭区间。h 的赋值表达式为 h = m，因为 m 位置也可能是解。</p>
<p>在 h 的赋值表达式为 h = m 的情况下，如果循环条件为 l &lt;= h，那么会出现循环无法退出的情况，因此循环条件只能是 l &lt; h。以下演示了循环条件为 l &lt;= h 时循环无法退出的情况：</p>
<div><pre><code>nums = {0, 1, 2}, key = 1
l   m   h
0   1   2  nums[m] >= key
0   0   1  nums[m] &lt; key
1   1   1  nums[m] >= key
1   1   1  nums[m] >= key
...
</code></pre></div><p>当循环体退出时，不表示没有查找到 key，因此最后返回的结果不应该为 -1。为了验证有没有查找到，需要在调用端判断一下返回位置上的值和 key 是否相等。</p>
<h1 id="_1-求开方" tabindex="-1"> 1. 求开方</h1>
<p><a href="https://leetcode.com/problems/sqrtx/description/" target="_blank" rel="noopener noreferrer">69. Sqrt(x) (Easy)</a></p>
<div><pre><code>Input: 4
Output: 2

Input: 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since we want to return an integer, the decimal part will be truncated.
</code></pre></div><p>一个数 x 的开方 sqrt 一定在 0 ~ x 之间，并且满足 sqrt == x / sqrt。可以利用二分查找在 0 ~ x 之间查找 sqrt。</p>
<p>对于 x = 8，它的开方是 2.82842...，最后应该返回 2 而不是 3。在循环条件为 l &lt;= h 并且循环退出时，h 总是比 l 小 1，也就是说 h = 2，l = 3，因此最后的返回值应该为 h 而不是 l。</p>
<div><pre><code><span>public</span> <span>int</span> <span>mySqrt</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>x <span>&lt;=</span> <span>1</span><span>)</span> <span>{</span>
        <span>return</span> x<span>;</span>
    <span>}</span>
    <span>int</span> l <span>=</span> <span>1</span><span>,</span> h <span>=</span> x<span>;</span>
    <span>while</span> <span>(</span>l <span>&lt;=</span> h<span>)</span> <span>{</span>
        <span>int</span> mid <span>=</span> l <span>+</span> <span>(</span>h <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
        <span>int</span> sqrt <span>=</span> x <span>/</span> mid<span>;</span>
        <span>if</span> <span>(</span>sqrt <span>==</span> mid<span>)</span> <span>{</span>
            <span>return</span> mid<span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>mid <span>></span> sqrt<span>)</span> <span>{</span>
            h <span>=</span> mid <span>-</span> <span>1</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            l <span>=</span> mid <span>+</span> <span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> h<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h1 id="_2-大于给定元素的最小元素" tabindex="-1"> 2. 大于给定元素的最小元素</h1>
<p><a href="https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/" target="_blank" rel="noopener noreferrer">744. Find Smallest Letter Greater Than Target (Easy)</a></p>
<div><pre><code>Input:
letters = ["c", "f", "j"]
target = "d"
Output: "f"

Input:
letters = ["c", "f", "j"]
target = "k"
Output: "c"
</code></pre></div><p>题目描述：给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符。</p>
<div><pre><code><span>public</span> <span>char</span> <span>nextGreatestLetter</span><span>(</span><span>char</span><span>[</span><span>]</span> letters<span>,</span> <span>char</span> target<span>)</span> <span>{</span>
    <span>int</span> n <span>=</span> letters<span>.</span>length<span>;</span>
    <span>int</span> l <span>=</span> <span>0</span><span>,</span> h <span>=</span> n <span>-</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span>l <span>&lt;=</span> h<span>)</span> <span>{</span>
        <span>int</span> m <span>=</span> l <span>+</span> <span>(</span>h <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
        <span>if</span> <span>(</span>letters<span>[</span>m<span>]</span> <span>&lt;=</span> target<span>)</span> <span>{</span>
            l <span>=</span> m <span>+</span> <span>1</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            h <span>=</span> m <span>-</span> <span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> l <span>&lt;</span> n <span>?</span> letters<span>[</span>l<span>]</span> <span>:</span> letters<span>[</span><span>0</span><span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h1 id="_3-有序数组的-single-element" tabindex="-1"> 3. 有序数组的 Single Element</h1>
<p><a href="https://leetcode.com/problems/single-element-in-a-sorted-array/description/" target="_blank" rel="noopener noreferrer">540. Single Element in a Sorted Array (Medium)</a></p>
<div><pre><code>Input: [1, 1, 2, 3, 3, 4, 4, 8, 8]
Output: 2
</code></pre></div><p>题目描述：一个有序数组只有一个数不出现两次，找出这个数。</p>
<p>要求以 O(logN) 时间复杂度进行求解，因此不能遍历数组并进行异或操作来求解，这么做的时间复杂度为 O(N)。</p>
<p>令 index 为 Single Element 在数组中的位置。在 index 之后，数组中原来存在的成对状态被改变。如果 m 为偶数，并且 m + 1 &lt; index，那么 nums[m] == nums[m + 1]；m + 1 &gt;= index，那么 nums[m] != nums[m + 1]。</p>
<p>从上面的规律可以知道，如果 nums[m] == nums[m + 1]，那么 index 所在的数组位置为 [m + 2, h]，此时令 l = m + 2；如果 nums[m] != nums[m + 1]，那么 index 所在的数组位置为 [l, m]，此时令 h = m。</p>
<p>因为 h 的赋值表达式为 h = m，那么循环条件也就只能使用 l &lt; h 这种形式。</p>
<div><pre><code><span>public</span> <span>int</span> <span>singleNonDuplicate</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>int</span> l <span>=</span> <span>0</span><span>,</span> h <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span>l <span>&lt;</span> h<span>)</span> <span>{</span>
        <span>int</span> m <span>=</span> l <span>+</span> <span>(</span>h <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
        <span>if</span> <span>(</span>m <span>%</span> <span>2</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>
            m<span>--</span><span>;</span>   <span>// 保证 l/h/m 都在偶数位，使得查找区间大小一直都是奇数</span>
        <span>}</span>
        <span>if</span> <span>(</span>nums<span>[</span>m<span>]</span> <span>==</span> nums<span>[</span>m <span>+</span> <span>1</span><span>]</span><span>)</span> <span>{</span>
            l <span>=</span> m <span>+</span> <span>2</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            h <span>=</span> m<span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> nums<span>[</span>l<span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h1 id="_4-第一个错误的版本" tabindex="-1"> 4. 第一个错误的版本</h1>
<p><a href="https://leetcode.com/problems/first-bad-version/description/" target="_blank" rel="noopener noreferrer">278. First Bad Version (Easy)</a></p>
<p>题目描述：给定一个元素 n 代表有 [1, 2, ..., n] 版本，在第 x 位置开始出现错误版本，导致后面的版本都错误。可以调用 isBadVersion(int x) 知道某个版本是否错误，要求找到第一个错误的版本。</p>
<p>如果第 m 个版本出错，则表示第一个错误的版本在 [l, m] 之间，令 h = m；否则第一个错误的版本在 [m + 1, h] 之间，令 l = m + 1。</p>
<p>因为 h 的赋值表达式为 h = m，因此循环条件为 l &lt; h。</p>
<div><pre><code><span>public</span> <span>int</span> <span>firstBadVersion</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>int</span> l <span>=</span> <span>1</span><span>,</span> h <span>=</span> n<span>;</span>
    <span>while</span> <span>(</span>l <span>&lt;</span> h<span>)</span> <span>{</span>
        <span>int</span> mid <span>=</span> l <span>+</span> <span>(</span>h <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
        <span>if</span> <span>(</span><span>isBadVersion</span><span>(</span>mid<span>)</span><span>)</span> <span>{</span>
            h <span>=</span> mid<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            l <span>=</span> mid <span>+</span> <span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> l<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h1 id="_5-旋转数组的最小数字" tabindex="-1"> 5. 旋转数组的最小数字</h1>
<p><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="noopener noreferrer">153. Find Minimum in Rotated Sorted Array (Medium)</a></p>
<div><pre><code>Input: [3,4,5,1,2],
Output: 1
</code></pre></div><div><pre><code><span>public</span> <span>int</span> <span>findMin</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>int</span> l <span>=</span> <span>0</span><span>,</span> h <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span>l <span>&lt;</span> h<span>)</span> <span>{</span>
        <span>int</span> m <span>=</span> l <span>+</span> <span>(</span>h <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
        <span>if</span> <span>(</span>nums<span>[</span>m<span>]</span> <span>&lt;=</span> nums<span>[</span>h<span>]</span><span>)</span> <span>{</span>
            h <span>=</span> m<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            l <span>=</span> m <span>+</span> <span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> nums<span>[</span>l<span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h1 id="_6-查找区间" tabindex="-1"> 6. 查找区间</h1>
<p><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener noreferrer">34. Find First and Last Position of Element in Sorted Array</a></p>
<div><pre><code>Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]

Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
</code></pre></div><div><pre><code><span>public</span> <span>int</span><span>[</span><span>]</span> <span>searchRange</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> target<span>)</span> <span>{</span>
    <span>int</span> first <span>=</span> <span>binarySearch</span><span>(</span>nums<span>,</span> target<span>)</span><span>;</span>
    <span>int</span> last <span>=</span> <span>binarySearch</span><span>(</span>nums<span>,</span> target <span>+</span> <span>1</span><span>)</span> <span>-</span> <span>1</span><span>;</span>
    <span>if</span> <span>(</span>first <span>==</span> nums<span>.</span>length <span>||</span> nums<span>[</span>first<span>]</span> <span>!=</span> target<span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span><span>-</span><span>1</span><span>,</span> <span>-</span><span>1</span><span>}</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>return</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span>first<span>,</span> <span>Math</span><span>.</span><span>max</span><span>(</span>first<span>,</span> last<span>)</span><span>}</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>private</span> <span>int</span> <span>binarySearch</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> target<span>)</span> <span>{</span>
    <span>int</span> l <span>=</span> <span>0</span><span>,</span> h <span>=</span> nums<span>.</span>length<span>;</span> <span>// 注意 h 的初始值</span>
    <span>while</span> <span>(</span>l <span>&lt;</span> h<span>)</span> <span>{</span>
        <span>int</span> m <span>=</span> l <span>+</span> <span>(</span>h <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
        <span>if</span> <span>(</span>nums<span>[</span>m<span>]</span> <span>>=</span> target<span>)</span> <span>{</span>
            h <span>=</span> m<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            l <span>=</span> m <span>+</span> <span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> l<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>1. 统计两个数的二进制表示有多少位不同</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E4%BD%8D%E8%BF%90%E7%AE%97.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E4%BD%8D%E8%BF%90%E7%AE%97.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">1. 统计两个数的二进制表示有多少位不同</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p><strong>基本原理</strong></p>
<p>0s 表示一串 0，1s 表示一串 1。</p>
<div><pre><code>x ^ 0s = x      x &amp; 0s = 0      x | 0s = x
x ^ 1s = ~x     x &amp; 1s = x      x | 1s = 1s
x ^ x = 0       x &amp; x = x       x | x = x
</code></pre></div><ul>
<li>利用 x ^ 1s = ~x 的特点，可以将位级表示翻转；利用 x ^ x = 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数。</li>
<li>利用 x &amp; 0s = 0 和 x &amp; 1s = x 的特点，可以实现掩码操作。一个数 num 与 mask：00111100 进行位与操作，只保留 num 中与 mask 的 1 部分相对应的位。</li>
<li>利用 x | 0s = x 和 x | 1s = 1s 的特点，可以实现设值操作。一个数 num 与 mask：00111100 进行位或操作，将 num 中与 mask 的 1 部分相对应的位都设置为 1。</li>
</ul>
<p>位与运算技巧：</p>
<ul>
<li>n&amp;(n-1) 去除 n 的位级表示中最低的那一位。例如对于二进制表示 10110100，减去 1 得到 10110011，这两个数相与得到 10110000。</li>
<li>n&amp;(-n) 得到 n 的位级表示中最低的那一位。-n 得到 n 的反码加 1，对于二进制表示 10110100，-n 得到 01001100，相与得到 00000100。</li>
<li>n-n&amp;(~n+1) 去除 n 的位级表示中最高的那一位。</li>
</ul>
<p>移位运算：</p>
<ul>
<li>&gt;&gt; n 为算术右移，相当于除以 2<sup>n</sup>；</li>
<li>&gt;&gt;&gt; n 为无符号右移，左边会补上 0。</li>
<li>&lt;&lt; n 为算术左移，相当于乘以 2<sup>n</sup>。</li>
</ul>
<p>** mask 计算**</p>
<p>要获取 111111111，将 0 取反即可，~0。</p>
<p>要得到只有第 i 位为 1 的 mask，将 1 向左移动 i-1 位即可，1&lt;&lt;(i-1) 。例如 1&lt;&lt;4 得到只有第 5 位为 1 的 mask ：00010000。</p>
<p>要得到 1 到 i 位为 1 的 mask，1&lt;&lt;(i+1)-1 即可，例如将 1&lt;&lt;(4+1)-1 = 00010000-1 = 00001111。</p>
<p>要得到 1 到 i 位为 0 的 mask，只需将 1 到 i 位为 1 的 mask 取反，即 ~(1&lt;&lt;(i+1)-1)。</p>
<p><strong>Java 中的位操作</strong></p>
<div><pre><code>static int Integer.bitCount();           // 统计 1 的数量
static int Integer.highestOneBit();      // 获得最高位
static String toBinaryString(int i);     // 转换为二进制表示的字符串
</code></pre></div><h1 id="_1-统计两个数的二进制表示有多少位不同" tabindex="-1"> 1. 统计两个数的二进制表示有多少位不同</h1>
<p><a href="https://leetcode.com/problems/hamming-distance/" target="_blank" rel="noopener noreferrer">461. Hamming Distance (Easy)</a></p>
<div><pre><code>Input: x = 1, y = 4

Output: 2

Explanation:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

The above arrows point to positions where the corresponding bits are different.
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>对两个数进行异或操作，位级表示不同的那一位为 1，统计有多少个 1 即可。</p>
<div><pre><code><span>public</span> <span>int</span> <span>hammingDistance</span><span>(</span><span>int</span> x<span>,</span> <span>int</span> y<span>)</span> <span>{</span>
    <span>int</span> z <span>=</span> x <span>^</span> y<span>;</span>
    <span>int</span> cnt <span>=</span> <span>0</span><span>;</span>
    <span>while</span><span>(</span>z <span>!=</span> <span>0</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>(</span>z <span>&amp;</span> <span>1</span><span>)</span> <span>==</span> <span>1</span><span>)</span> cnt<span>++</span><span>;</span>
        z <span>=</span> z <span>>></span> <span>1</span><span>;</span>
    <span>}</span>
    <span>return</span> cnt<span>;</span>
<span>}</span>
</code></pre></div><p>使用 z&amp;(z-1) 去除 z 位级表示最低的那一位。</p>
<div><pre><code><span>public</span> <span>int</span> <span>hammingDistance</span><span>(</span><span>int</span> x<span>,</span> <span>int</span> y<span>)</span> <span>{</span>
    <span>int</span> z <span>=</span> x <span>^</span> y<span>;</span>
    <span>int</span> cnt <span>=</span> <span>0</span><span>;</span>
    <span>while</span> <span>(</span>z <span>!=</span> <span>0</span><span>)</span> <span>{</span>
        z <span>&amp;=</span> <span>(</span>z <span>-</span> <span>1</span><span>)</span><span>;</span>
        cnt<span>++</span><span>;</span>
    <span>}</span>
    <span>return</span> cnt<span>;</span>
<span>}</span>
</code></pre></div><p>可以使用 Integer.bitcount() 来统计 1 个的个数。</p>
<div><pre><code><span>public</span> <span>int</span> <span>hammingDistance</span><span>(</span><span>int</span> x<span>,</span> <span>int</span> y<span>)</span> <span>{</span>
    <span>return</span> <span>Integer</span><span>.</span><span>bitCount</span><span>(</span>x <span>^</span> y<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h1 id="_2-数组中唯一一个不重复的元素" tabindex="-1"> 2. 数组中唯一一个不重复的元素</h1>
<p><a href="https://leetcode.com/problems/single-number/description/" target="_blank" rel="noopener noreferrer">136. Single Number (Easy)</a></p>
<div><pre><code>Input: [4,1,2,1,2]
Output: 4
</code></pre></div><p>两个相同的数异或的结果为 0，对所有数进行异或操作，最后的结果就是单独出现的那个数。</p>
<div><pre><code><span>public</span> <span>int</span> <span>singleNumber</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>int</span> ret <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> n <span>:</span> nums<span>)</span> ret <span>=</span> ret <span>^</span> n<span>;</span>
    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre></div><h1 id="_3-找出数组中缺失的那个数" tabindex="-1"> 3. 找出数组中缺失的那个数</h1>
<p><a href="https://leetcode.com/problems/missing-number/description/" target="_blank" rel="noopener noreferrer">268. Missing Number (Easy)</a></p>
<div><pre><code>Input: [3,0,1]
Output: 2
</code></pre></div><p>题目描述：数组元素在 0-n 之间，但是有一个数是缺失的，要求找到这个缺失的数。</p>
<div><pre><code><span>public</span> <span>int</span> <span>missingNumber</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>int</span> ret <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        ret <span>=</span> ret <span>^</span> i <span>^</span> nums<span>[</span>i<span>]</span><span>;</span>
    <span>}</span>
    <span>return</span> ret <span>^</span> nums<span>.</span>length<span>;</span>
<span>}</span>
</code></pre></div><h1 id="_4-数组中不重复的两个元素" tabindex="-1"> 4. 数组中不重复的两个元素</h1>
<p><a href="https://leetcode.com/problems/single-number-iii/description/" target="_blank" rel="noopener noreferrer">260. Single Number III (Medium)</a></p>
<p>两个不相等的元素在位级表示上必定会有一位存在不同。</p>
<p>将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果。</p>
<p>diff &amp;= -diff 得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。</p>
<div><pre><code><span>public</span> <span>int</span><span>[</span><span>]</span> <span>singleNumber</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>int</span> diff <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> diff <span>^=</span> num<span>;</span>
    diff <span>&amp;=</span> <span>-</span>diff<span>;</span>  <span>// 得到最右一位</span>
    <span>int</span><span>[</span><span>]</span> ret <span>=</span> <span>new</span> <span>int</span><span>[</span><span>2</span><span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>(</span>num <span>&amp;</span> diff<span>)</span> <span>==</span> <span>0</span><span>)</span> ret<span>[</span><span>0</span><span>]</span> <span>^=</span> num<span>;</span>
        <span>else</span> ret<span>[</span><span>1</span><span>]</span> <span>^=</span> num<span>;</span>
    <span>}</span>
    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h1 id="_5-翻转一个数的比特位" tabindex="-1"> 5. 翻转一个数的比特位</h1>
<p><a href="https://leetcode.com/problems/reverse-bits/description/" target="_blank" rel="noopener noreferrer">190. Reverse Bits (Easy)</a></p>
<div><pre><code><span>public</span> <span>int</span> <span>reverseBits</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>int</span> ret <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>32</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        ret <span>&lt;&lt;=</span> <span>1</span><span>;</span>
        ret <span>|=</span> <span>(</span>n <span>&amp;</span> <span>1</span><span>)</span><span>;</span>
        n <span>>>>=</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre></div><p>如果该函数需要被调用很多次，可以将 int 拆成 4 个 byte，然后缓存 byte 对应的比特位翻转，最后再拼接起来。</p>
<div><pre><code><span>private</span> <span>static</span> <span>Map</span><span><span>&lt;</span><span>Byte</span><span>,</span> <span>Integer</span><span>></span></span> cache <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

<span>public</span> <span>int</span> <span>reverseBits</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>int</span> ret <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>4</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        ret <span>&lt;&lt;=</span> <span>8</span><span>;</span>
        ret <span>|=</span> <span>reverseByte</span><span>(</span><span>(</span><span>byte</span><span>)</span> <span>(</span>n <span>&amp;</span> <span>0b11111111</span><span>)</span><span>)</span><span>;</span>
        n <span>>>=</span> <span>8</span><span>;</span>
    <span>}</span>
    <span>return</span> ret<span>;</span>
<span>}</span>

<span>private</span> <span>int</span> <span>reverseByte</span><span>(</span><span>byte</span> b<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>cache<span>.</span><span>containsKey</span><span>(</span>b<span>)</span><span>)</span> <span>return</span> cache<span>.</span><span>get</span><span>(</span>b<span>)</span><span>;</span>
    <span>int</span> ret <span>=</span> <span>0</span><span>;</span>
    <span>byte</span> t <span>=</span> b<span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>8</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        ret <span>&lt;&lt;=</span> <span>1</span><span>;</span>
        ret <span>|=</span> t <span>&amp;</span> <span>1</span><span>;</span>
        t <span>>>=</span> <span>1</span><span>;</span>
    <span>}</span>
    cache<span>.</span><span>put</span><span>(</span>b<span>,</span> ret<span>)</span><span>;</span>
    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h1 id="_6-不用额外变量交换两个整数" tabindex="-1"> 6. 不用额外变量交换两个整数</h1>
<p></p>
<div><pre><code>a <span>=</span> a <span>^</span> b<span>;</span>
b <span>=</span> a <span>^</span> b<span>;</span>
a <span>=</span> a <span>^</span> b<span>;</span>
</code></pre></div><h1 id="_7-判断一个数是不是-2-的-n-次方" tabindex="-1"> 7. 判断一个数是不是 2 的 n 次方</h1>
<p><a href="https://leetcode.com/problems/power-of-two/description/" target="_blank" rel="noopener noreferrer">231. Power of Two (Easy)</a></p>
<p>二进制表示只有一个 1 存在。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>isPowerOfTwo</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>return</span> n <span>></span> <span>0</span> <span>&amp;&amp;</span> <span>Integer</span><span>.</span><span>bitCount</span><span>(</span>n<span>)</span> <span>==</span> <span>1</span><span>;</span>
<span>}</span>
</code></pre></div><p>利用 1000 &amp; 0111 == 0 这种性质，得到以下解法：</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>isPowerOfTwo</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>return</span> n <span>></span> <span>0</span> <span>&amp;&amp;</span> <span>(</span>n <span>&amp;</span> <span>(</span>n <span>-</span> <span>1</span><span>)</span><span>)</span> <span>==</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div><h1 id="_8-判断一个数是不是-4-的-n-次方" tabindex="-1"> 8.  判断一个数是不是 4 的 n 次方</h1>
<p><a href="https://leetcode.com/problems/power-of-four/" target="_blank" rel="noopener noreferrer">342. Power of Four (Easy)</a></p>
<p>这种数在二进制表示中有且只有一个奇数位为 1，例如 16（10000）。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>isPowerOfFour</span><span>(</span><span>int</span> num<span>)</span> <span>{</span>
    <span>return</span> num <span>></span> <span>0</span> <span>&amp;&amp;</span> <span>(</span>num <span>&amp;</span> <span>(</span>num <span>-</span> <span>1</span><span>)</span><span>)</span> <span>==</span> <span>0</span> <span>&amp;&amp;</span> <span>(</span>num <span>&amp;</span> <span>0b01010101010101010101010101010101</span><span>)</span> <span>!=</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div><p>也可以使用正则表达式进行匹配。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>isPowerOfFour</span><span>(</span><span>int</span> num<span>)</span> <span>{</span>
    <span>return</span> <span>Integer</span><span>.</span><span>toString</span><span>(</span>num<span>,</span> <span>4</span><span>)</span><span>.</span><span>matches</span><span>(</span><span>"10*"</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h1 id="_9-判断一个数的位级表示是否不会出现连续的-0-和-1" tabindex="-1"> 9. 判断一个数的位级表示是否不会出现连续的 0 和 1</h1>
<p><a href="https://leetcode.com/problems/binary-number-with-alternating-bits/description/" target="_blank" rel="noopener noreferrer">693. Binary Number with Alternating Bits (Easy)</a></p>
<div><pre><code>Input: 10
Output: True
Explanation:
The binary representation of 10 is: 1010.

Input: 11
Output: False
Explanation:
The binary representation of 11 is: 1011.
</code></pre></div><p>对于 1010 这种位级表示的数，把它向右移动 1 位得到 101，这两个数每个位都不同，因此异或得到的结果为 1111。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>hasAlternatingBits</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>int</span> a <span>=</span> <span>(</span>n <span>^</span> <span>(</span>n <span>>></span> <span>1</span><span>)</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span>a <span>&amp;</span> <span>(</span>a <span>+</span> <span>1</span><span>)</span><span>)</span> <span>==</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div><h1 id="_10-求一个数的补码" tabindex="-1"> 10. 求一个数的补码</h1>
<p><a href="https://leetcode.com/problems/number-complement/description/" target="_blank" rel="noopener noreferrer">476. Number Complement (Easy)</a></p>
<div><pre><code>Input: 5
Output: 2
Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.
</code></pre></div><p>题目描述：不考虑二进制表示中的首 0 部分。</p>
<p>对于 00000101，要求补码可以将它与 00000111 进行异或操作。那么问题就转换为求掩码 00000111。</p>
<div><pre><code><span>public</span> <span>int</span> <span>findComplement</span><span>(</span><span>int</span> num<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>num <span>==</span> <span>0</span><span>)</span> <span>return</span> <span>1</span><span>;</span>
    <span>int</span> mask <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>30</span><span>;</span>
    <span>while</span> <span>(</span><span>(</span>num <span>&amp;</span> mask<span>)</span> <span>==</span> <span>0</span><span>)</span> mask <span>>>=</span> <span>1</span><span>;</span>
    mask <span>=</span> <span>(</span>mask <span>&lt;&lt;</span> <span>1</span><span>)</span> <span>-</span> <span>1</span><span>;</span>
    <span>return</span> num <span>^</span> mask<span>;</span>
<span>}</span>
</code></pre></div><p>可以利用 Java 的 Integer.highestOneBit() 方法来获得含有首 1 的数。</p>
<div><pre><code><span>public</span> <span>int</span> <span>findComplement</span><span>(</span><span>int</span> num<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>num <span>==</span> <span>0</span><span>)</span> <span>return</span> <span>1</span><span>;</span>
    <span>int</span> mask <span>=</span> <span>Integer</span><span>.</span><span>highestOneBit</span><span>(</span>num<span>)</span><span>;</span>
    mask <span>=</span> <span>(</span>mask <span>&lt;&lt;</span> <span>1</span><span>)</span> <span>-</span> <span>1</span><span>;</span>
    <span>return</span> num <span>^</span> mask<span>;</span>
<span>}</span>
</code></pre></div><p>对于 10000000 这样的数要扩展成 11111111，可以利用以下方法：</p>
<div><pre><code>mask |= mask >> 1    11000000
mask |= mask >> 2    11110000
mask |= mask >> 4    11111111
</code></pre></div><div><pre><code><span>public</span> <span>int</span> <span>findComplement</span><span>(</span><span>int</span> num<span>)</span> <span>{</span>
    <span>int</span> mask <span>=</span> num<span>;</span>
    mask <span>|=</span> mask <span>>></span> <span>1</span><span>;</span>
    mask <span>|=</span> mask <span>>></span> <span>2</span><span>;</span>
    mask <span>|=</span> mask <span>>></span> <span>4</span><span>;</span>
    mask <span>|=</span> mask <span>>></span> <span>8</span><span>;</span>
    mask <span>|=</span> mask <span>>></span> <span>16</span><span>;</span>
    <span>return</span> <span>(</span>mask <span>^</span> num<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h1 id="_11-实现整数的加法" tabindex="-1"> 11. 实现整数的加法</h1>
<p><a href="https://leetcode.com/problems/sum-of-two-integers/description/" target="_blank" rel="noopener noreferrer">371. Sum of Two Integers (Easy)</a></p>
<p>a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) &lt;&lt; 1 就是进位。</p>
<p>递归会终止的原因是 (a &amp; b) &lt;&lt; 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。</p>
<div><pre><code><span>public</span> <span>int</span> <span>getSum</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>
    <span>return</span> b <span>==</span> <span>0</span> <span>?</span> a <span>:</span> <span>getSum</span><span>(</span><span>(</span>a <span>^</span> b<span>)</span><span>,</span> <span>(</span>a <span>&amp;</span> b<span>)</span> <span>&lt;&lt;</span> <span>1</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h1 id="_12-字符串数组最大乘积" tabindex="-1"> 12. 字符串数组最大乘积</h1>
<p><a href="https://leetcode.com/problems/maximum-product-of-word-lengths/description/" target="_blank" rel="noopener noreferrer">318. Maximum Product of Word Lengths (Medium)</a></p>
<div><pre><code>Given ["abcw", "baz", "foo", "bar", "xtfn", "abcdef"]
Return 16
The two words can be "abcw", "xtfn".
</code></pre></div><p>题目描述：字符串数组的字符串只含有小写字符。求解字符串数组中两个字符串长度的最大乘积，要求这两个字符串不能含有相同字符。</p>
<p>本题主要问题是判断两个字符串是否含相同字符，由于字符串只含有小写字符，总共 26 位，因此可以用一个 32 位的整数来存储每个字符是否出现过。</p>
<div><pre><code><span>public</span> <span>int</span> <span>maxProduct</span><span>(</span><span>String</span><span>[</span><span>]</span> words<span>)</span> <span>{</span>
    <span>int</span> n <span>=</span> words<span>.</span>length<span>;</span>
    <span>int</span><span>[</span><span>]</span> val <span>=</span> <span>new</span> <span>int</span><span>[</span>n<span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>char</span> c <span>:</span> words<span>[</span>i<span>]</span><span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            val<span>[</span>i<span>]</span> <span>|=</span> <span>1</span> <span>&lt;&lt;</span> <span>(</span>c <span>-</span> <span>'a'</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>int</span> ret <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> i <span>+</span> <span>1</span><span>;</span> j <span>&lt;</span> n<span>;</span> j<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>(</span>val<span>[</span>i<span>]</span> <span>&amp;</span> val<span>[</span>j<span>]</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
                ret <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>ret<span>,</span> words<span>[</span>i<span>]</span><span>.</span><span>length</span><span>(</span><span>)</span> <span>*</span> words<span>[</span>j<span>]</span><span>.</span><span>length</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h1 id="_13-统计从-0-n-每个数的二进制表示中-1-的个数" tabindex="-1"> 13. 统计从 0 ~ n 每个数的二进制表示中 1 的个数</h1>
<p><a href="https://leetcode.com/problems/counting-bits/description/" target="_blank" rel="noopener noreferrer">338. Counting Bits (Medium)</a></p>
<p>对于数字 6(110)，它可以看成是 4(100) 再加一个 2(10)，因此 dp[i] = dp[i&amp;(i-1)] + 1;</p>
<div><pre><code><span>public</span> <span>int</span><span>[</span><span>]</span> <span>countBits</span><span>(</span><span>int</span> num<span>)</span> <span>{</span>
    <span>int</span><span>[</span><span>]</span> ret <span>=</span> <span>new</span> <span>int</span><span>[</span>num <span>+</span> <span>1</span><span>]</span><span>;</span>
    <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> num<span>;</span> i<span>++</span><span>)</span><span>{</span>
        ret<span>[</span>i<span>]</span> <span>=</span> ret<span>[</span>i<span>&amp;</span><span>(</span>i<span>-</span><span>1</span><span>)</span><span>]</span> <span>+</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>1. 给表达式加括号</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E5%88%86%E6%B2%BB.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E5%88%86%E6%B2%BB.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">1. 给表达式加括号</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li></li>
</ul>

<h1 id="_1-给表达式加括号" tabindex="-1"> 1. 给表达式加括号</h1>
<p><a href="https://leetcode.com/problems/different-ways-to-add-parentheses/description/" target="_blank" rel="noopener noreferrer">241. Different Ways to Add Parentheses (Medium)</a></p>
<div><pre><code>Input: "2-1-1".

((2-1)-1) = 0
(2-(1-1)) = 2

Output : [0, 2]
</code></pre></div><div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>diffWaysToCompute</span><span>(</span><span>String</span> input<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> ways <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> input<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>char</span> c <span>=</span> input<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>;</span>
        <span>if</span> <span>(</span>c <span>==</span> <span>'+'</span> <span>||</span> c <span>==</span> <span>'-'</span> <span>||</span> c <span>==</span> <span>'*'</span><span>)</span> <span>{</span>
            <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> left <span>=</span> <span>diffWaysToCompute</span><span>(</span>input<span>.</span><span>substring</span><span>(</span><span>0</span><span>,</span> i<span>)</span><span>)</span><span>;</span>
            <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> right <span>=</span> <span>diffWaysToCompute</span><span>(</span>input<span>.</span><span>substring</span><span>(</span>i <span>+</span> <span>1</span><span>)</span><span>)</span><span>;</span>
            <span>for</span> <span>(</span><span>int</span> l <span>:</span> left<span>)</span> <span>{</span>
                <span>for</span> <span>(</span><span>int</span> r <span>:</span> right<span>)</span> <span>{</span>
                    <span>switch</span> <span>(</span>c<span>)</span> <span>{</span>
                        <span>case</span> <span>'+'</span><span>:</span>
                            ways<span>.</span><span>add</span><span>(</span>l <span>+</span> r<span>)</span><span>;</span>
                            <span>break</span><span>;</span>
                        <span>case</span> <span>'-'</span><span>:</span>
                            ways<span>.</span><span>add</span><span>(</span>l <span>-</span> r<span>)</span><span>;</span>
                            <span>break</span><span>;</span>
                        <span>case</span> <span>'*'</span><span>:</span>
                            ways<span>.</span><span>add</span><span>(</span>l <span>*</span> r<span>)</span><span>;</span>
                            <span>break</span><span>;</span>
                    <span>}</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>if</span> <span>(</span>ways<span>.</span><span>size</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
        ways<span>.</span><span>add</span><span>(</span><span>Integer</span><span>.</span><span>valueOf</span><span>(</span>input<span>)</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> ways<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h1 id="_2-不同的二叉搜索树" tabindex="-1"> 2. 不同的二叉搜索树</h1>
<p><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/description/" target="_blank" rel="noopener noreferrer">95. Unique Binary Search Trees II (Medium)</a></p>
<p>给定一个数字 n，要求生成所有值为 1...n 的二叉搜索树。</p>
<div><pre><code>Input: 3
Output:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
Explanation:
The above output corresponds to the 5 unique BST's shown below:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> <span>generateTrees</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>n <span>&lt;</span> <span>1</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>generateSubtrees</span><span>(</span><span>1</span><span>,</span> n<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>List</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> <span>generateSubtrees</span><span>(</span><span>int</span> s<span>,</span> <span>int</span> e<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> res <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>s <span>></span> e<span>)</span> <span>{</span>
        res<span>.</span><span>add</span><span>(</span><span>null</span><span>)</span><span>;</span>
        <span>return</span> res<span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> s<span>;</span> i <span>&lt;=</span> e<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
        <span>List</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> leftSubtrees <span>=</span> <span>generateSubtrees</span><span>(</span>s<span>,</span> i <span>-</span> <span>1</span><span>)</span><span>;</span>
        <span>List</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> rightSubtrees <span>=</span> <span>generateSubtrees</span><span>(</span>i <span>+</span> <span>1</span><span>,</span> e<span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>TreeNode</span> left <span>:</span> leftSubtrees<span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>TreeNode</span> right <span>:</span> rightSubtrees<span>)</span> <span>{</span>
                <span>TreeNode</span> root <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span>i<span>)</span><span>;</span>
                root<span>.</span>left <span>=</span> left<span>;</span>
                root<span>.</span>right <span>=</span> right<span>;</span>
                res<span>.</span><span>add</span><span>(</span>root<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> res<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>斐波那契数列</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">斐波那契数列</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>

<p>递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。</p>
<h1 id="斐波那契数列" tabindex="-1"> 斐波那契数列</h1>
<h2 id="_1-爬楼梯" tabindex="-1"> 1. 爬楼梯</h2>
<p><a href="https://leetcode.com/problems/climbing-stairs/description/" target="_blank" rel="noopener noreferrer">70. Climbing Stairs (Easy)</a></p>
<p>题目描述：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法。</p>
<p>定义一个数组 dp 存储上楼梯的方法数（为了方便讨论，数组下标从 1 开始），dp[i] 表示走到第 i 个楼梯的方法数目。</p>
<p>第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。</p>

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/14fe1e71-8518-458f-a220-116003061a83.png" width="200px"> </div><br>
<p>考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2]，使得原来的 O(N) 空间复杂度优化为 O(1) 复杂度。</p>
<div><pre><code><span>public</span> <span>int</span> <span>climbStairs</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>n <span>&lt;=</span> <span>2</span><span>)</span> <span>{</span>
        <span>return</span> n<span>;</span>
    <span>}</span>
    <span>int</span> pre2 <span>=</span> <span>1</span><span>,</span> pre1 <span>=</span> <span>2</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>int</span> cur <span>=</span> pre1 <span>+</span> pre2<span>;</span>
        pre2 <span>=</span> pre1<span>;</span>
        pre1 <span>=</span> cur<span>;</span>
    <span>}</span>
    <span>return</span> pre1<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="_2-强盗抢劫" tabindex="-1"> 2. 强盗抢劫</h2>
<p><a href="https://leetcode.com/problems/house-robber/description/" target="_blank" rel="noopener noreferrer">198. House Robber (Easy)</a></p>
<p>题目描述：抢劫一排住户，但是不能抢邻近的住户，求最大抢劫量。</p>
<p>定义 dp 数组用来存储最大的抢劫量，其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量。</p>
<p>由于不能抢劫邻近住户，如果抢劫了第 i -1 个住户，那么就不能再抢劫第 i 个住户，所以</p>

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2de794ca-aa7b-48f3-a556-a0e2708cb976.jpg" width="350px"> </div><br>
<div><pre><code><span>public</span> <span>int</span> <span>rob</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>int</span> pre2 <span>=</span> <span>0</span><span>,</span> pre1 <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>int</span> cur <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>pre2 <span>+</span> nums<span>[</span>i<span>]</span><span>,</span> pre1<span>)</span><span>;</span>
        pre2 <span>=</span> pre1<span>;</span>
        pre1 <span>=</span> cur<span>;</span>
    <span>}</span>
    <span>return</span> pre1<span>;</span>
<span>}</span>
</code></pre></div><h2 id="_3-强盗在环形街区抢劫" tabindex="-1"> 3. 强盗在环形街区抢劫</h2>
<p><a href="https://leetcode.com/problems/house-robber-ii/description/" target="_blank" rel="noopener noreferrer">213. House Robber II (Medium)</a></p>
<div><pre><code><span>public</span> <span>int</span> <span>rob</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nums <span>==</span> <span>null</span> <span>||</span> nums<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>int</span> n <span>=</span> nums<span>.</span>length<span>;</span>
    <span>if</span> <span>(</span>n <span>==</span> <span>1</span><span>)</span> <span>{</span>
        <span>return</span> nums<span>[</span><span>0</span><span>]</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>Math</span><span>.</span><span>max</span><span>(</span><span>rob</span><span>(</span>nums<span>,</span> <span>0</span><span>,</span> n <span>-</span> <span>2</span><span>)</span><span>,</span> <span>rob</span><span>(</span>nums<span>,</span> <span>1</span><span>,</span> n <span>-</span> <span>1</span><span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>int</span> <span>rob</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> first<span>,</span> <span>int</span> last<span>)</span> <span>{</span>
    <span>int</span> pre2 <span>=</span> <span>0</span><span>,</span> pre1 <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> first<span>;</span> i <span>&lt;=</span> last<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>int</span> cur <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>pre1<span>,</span> pre2 <span>+</span> nums<span>[</span>i<span>]</span><span>)</span><span>;</span>
        pre2 <span>=</span> pre1<span>;</span>
        pre1 <span>=</span> cur<span>;</span>
    <span>}</span>
    <span>return</span> pre1<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id="_4-信件错排" tabindex="-1"> 4. 信件错排</h2>
<p>题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量。</p>
<p>定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：</p>
<ul>
<li>i==k，交换 i 和 k 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-2] 种错误装信方式。</li>
<li>i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-1] 种错误装信方式。</li>
</ul>
<p>综上所述，错误装信数量方式数量为：</p>

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/da1f96b9-fd4d-44ca-8925-fb14c5733388.png" width="350px"> </div><br>
<h2 id="_5-母牛生产" tabindex="-1"> 5. 母牛生产</h2>
<p></p>
<p>题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。</p>
<p>第 i 年成熟的牛的数量为：</p>

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/879814ee-48b5-4bcb-86f5-dcc400cb81ad.png" width="250px"> </div><br>
<h1 id="矩阵路径" tabindex="-1"> 矩阵路径</h1>
<h2 id="_1-矩阵的最小路径和" tabindex="-1"> 1. 矩阵的最小路径和</h2>
<p><a href="https://leetcode.com/problems/minimum-path-sum/description/" target="_blank" rel="noopener noreferrer">64. Minimum Path Sum (Medium)</a></p>
<div><pre><code>[[1,3,1],
 [1,5,1],
 [4,2,1]]
Given the above grid map, return 7. Because the path 1→3→1→1→1 minimizes the sum.
</code></pre></div><p>题目描述：求从矩阵的左上角到右下角的最小路径和，每次只能向右和向下移动。</p>
<div><pre><code><span>public</span> <span>int</span> <span>minPathSum</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> grid<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>grid<span>.</span>length <span>==</span> <span>0</span> <span>||</span> grid<span>[</span><span>0</span><span>]</span><span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>int</span> m <span>=</span> grid<span>.</span>length<span>,</span> n <span>=</span> grid<span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span>
    <span>int</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span>n<span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> m<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> n<span>;</span> j<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>j <span>==</span> <span>0</span><span>)</span> <span>{</span>
                dp<span>[</span>j<span>]</span> <span>=</span> dp<span>[</span>j<span>]</span><span>;</span>        <span>// 只能从上侧走到该位置</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span>i <span>==</span> <span>0</span><span>)</span> <span>{</span>
                dp<span>[</span>j<span>]</span> <span>=</span> dp<span>[</span>j <span>-</span> <span>1</span><span>]</span><span>;</span>    <span>// 只能从左侧走到该位置</span>
            <span>}</span> <span>else</span> <span>{</span>
                dp<span>[</span>j<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>dp<span>[</span>j <span>-</span> <span>1</span><span>]</span><span>,</span> dp<span>[</span>j<span>]</span><span>)</span><span>;</span>
            <span>}</span>
            dp<span>[</span>j<span>]</span> <span>+=</span> grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> dp<span>[</span>n <span>-</span> <span>1</span><span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id="_2-矩阵的总路径数" tabindex="-1"> 2. 矩阵的总路径数</h2>
<p><a href="https://leetcode.com/problems/unique-paths/description/" target="_blank" rel="noopener noreferrer">62. Unique Paths (Medium)</a></p>
<p>题目描述：统计从矩阵左上角到右下角的路径总数，每次只能向右或者向下移动。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dc82f0f3-c1d4-4ac8-90ac-d5b32a9bd75a.jpg" width=""> </div><br>
<div><pre><code><span>public</span> <span>int</span> <span>uniquePaths</span><span>(</span><span>int</span> m<span>,</span> <span>int</span> n<span>)</span> <span>{</span>
    <span>int</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span>n<span>]</span><span>;</span>
    <span>Arrays</span><span>.</span><span>fill</span><span>(</span>dp<span>,</span> <span>1</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> m<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>1</span><span>;</span> j <span>&lt;</span> n<span>;</span> j<span>++</span><span>)</span> <span>{</span>
            dp<span>[</span>j<span>]</span> <span>=</span> dp<span>[</span>j<span>]</span> <span>+</span> dp<span>[</span>j <span>-</span> <span>1</span><span>]</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> dp<span>[</span>n <span>-</span> <span>1</span><span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>也可以直接用数学公式求解，这是一个组合问题。机器人总共移动的次数 S=m+n-2，向下移动的次数 D=m-1，那么问题可以看成从 S 中取出 D 个位置的组合数量，这个问题的解为 C(S, D)。</p>
<div><pre><code><span>public</span> <span>int</span> <span>uniquePaths</span><span>(</span><span>int</span> m<span>,</span> <span>int</span> n<span>)</span> <span>{</span>
    <span>int</span> <span>S</span> <span>=</span> m <span>+</span> n <span>-</span> <span>2</span><span>;</span>  <span>// 总共的移动次数</span>
    <span>int</span> <span>D</span> <span>=</span> m <span>-</span> <span>1</span><span>;</span>      <span>// 向下的移动次数</span>
    <span>long</span> ret <span>=</span> <span>1</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> <span>D</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        ret <span>=</span> ret <span>*</span> <span>(</span><span>S</span> <span>-</span> <span>D</span> <span>+</span> i<span>)</span> <span>/</span> i<span>;</span>
    <span>}</span>
    <span>return</span> <span>(</span><span>int</span><span>)</span> ret<span>;</span>
<span>}</span>
</code></pre></div><h1 id="数组区间" tabindex="-1"> 数组区间</h1>
<h2 id="_1-数组区间和" tabindex="-1"> 1. 数组区间和</h2>
<p><a href="https://leetcode.com/problems/range-sum-query-immutable/description/" target="_blank" rel="noopener noreferrer">303. Range Sum Query - Immutable (Easy)</a></p>
<div><pre><code>Given nums = [-2, 0, 3, -5, 2, -1]

sumRange(0, 2) -> 1
sumRange(2, 5) -> -1
sumRange(0, 5) -> -3
</code></pre></div><p>求区间 i ~ j 的和，可以转换为 sum[j + 1] - sum[i]，其中 sum[i] 为 0 ~ i - 1 的和。</p>
<div><pre><code><span>class</span> <span>NumArray</span> <span>{</span>

    <span>private</span> <span>int</span><span>[</span><span>]</span> sums<span>;</span>

    <span>public</span> <span>NumArray</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        sums <span>=</span> <span>new</span> <span>int</span><span>[</span>nums<span>.</span>length <span>+</span> <span>1</span><span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            sums<span>[</span>i<span>]</span> <span>=</span> sums<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>+</span> nums<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>sumRange</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>
        <span>return</span> sums<span>[</span>j <span>+</span> <span>1</span><span>]</span> <span>-</span> sums<span>[</span>i<span>]</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="_2-数组中等差递增子区间的个数" tabindex="-1"> 2. 数组中等差递增子区间的个数</h2>
<p><a href="https://leetcode.com/problems/arithmetic-slices/description/" target="_blank" rel="noopener noreferrer">413. Arithmetic Slices (Medium)</a></p>
<div><pre><code>A = [0, 1, 2, 3, 4]

return: 6, for 3 arithmetic slices in A:

[0, 1, 2],
[1, 2, 3],
[0, 1, 2, 3],
[0, 1, 2, 3, 4],
[ 1, 2, 3, 4],
[2, 3, 4]
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>dp[i] 表示以 A[i] 为结尾的等差递增子区间的个数。</p>
<p>当 A[i] - A[i-1] == A[i-1] - A[i-2]，那么 [A[i-2], A[i-1], A[i]] 构成一个等差递增子区间。而且在以 A[i-1] 为结尾的递增子区间的后面再加上一个 A[i]，一样可以构成新的递增子区间。</p>
<div><pre><code>dp[2] = 1
    [0, 1, 2]
dp[3] = dp[2] + 1 = 2
    [0, 1, 2, 3], // [0, 1, 2] 之后加一个 3
    [1, 2, 3]     // 新的递增子区间
dp[4] = dp[3] + 1 = 3
    [0, 1, 2, 3, 4], // [0, 1, 2, 3] 之后加一个 4
    [1, 2, 3, 4],    // [1, 2, 3] 之后加一个 4
    [2, 3, 4]        // 新的递增子区间
</code></pre></div><p>综上，在 A[i] - A[i-1] == A[i-1] - A[i-2] 时，dp[i] = dp[i-1] + 1。</p>
<p>因为递增子区间不一定以最后一个元素为结尾，可以是任意一个元素结尾，因此需要返回 dp 数组累加的结果。</p>
<div><pre><code><span>public</span> <span>int</span> <span>numberOfArithmeticSlices</span><span>(</span><span>int</span><span>[</span><span>]</span> <span>A</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>A</span> <span>==</span> <span>null</span> <span>||</span> <span>A</span><span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>int</span> n <span>=</span> <span>A</span><span>.</span>length<span>;</span>
    <span>int</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span>n<span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>A</span><span>[</span>i<span>]</span> <span>-</span> <span>A</span><span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>==</span> <span>A</span><span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>-</span> <span>A</span><span>[</span>i <span>-</span> <span>2</span><span>]</span><span>)</span> <span>{</span>
            dp<span>[</span>i<span>]</span> <span>=</span> dp<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>+</span> <span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>int</span> total <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> cnt <span>:</span> dp<span>)</span> <span>{</span>
        total <span>+=</span> cnt<span>;</span>
    <span>}</span>
    <span>return</span> total<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h1 id="分割整数" tabindex="-1"> 分割整数</h1>
<h2 id="_1-分割整数的最大乘积" tabindex="-1"> 1. 分割整数的最大乘积</h2>
<p><a href="https://leetcode.com/problems/integer-break/description/" target="_blank" rel="noopener noreferrer">343. Integer Break (Medim)</a></p>
<p>题目描述：For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).</p>
<div><pre><code><span>public</span> <span>int</span> <span>integerBreak</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>int</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span>n <span>+</span> <span>1</span><span>]</span><span>;</span>
    dp<span>[</span><span>1</span><span>]</span> <span>=</span> <span>1</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>1</span><span>;</span> j <span>&lt;=</span> i <span>-</span> <span>1</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>
            dp<span>[</span>i<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>dp<span>[</span>i<span>]</span><span>,</span> <span>Math</span><span>.</span><span>max</span><span>(</span>j <span>*</span> dp<span>[</span>i <span>-</span> j<span>]</span><span>,</span> j <span>*</span> <span>(</span>i <span>-</span> j<span>)</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> dp<span>[</span>n<span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="_2-按平方数来分割整数" tabindex="-1"> 2. 按平方数来分割整数</h2>
<p><a href="https://leetcode.com/problems/perfect-squares/description/" target="_blank" rel="noopener noreferrer">279. Perfect Squares(Medium)</a></p>
<p>题目描述：For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.</p>
<div><pre><code><span>public</span> <span>int</span> <span>numSquares</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> squareList <span>=</span> <span>generateSquareList</span><span>(</span>n<span>)</span><span>;</span>
    <span>int</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span>n <span>+</span> <span>1</span><span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>int</span> min <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>;</span>
        <span>for</span> <span>(</span><span>int</span> square <span>:</span> squareList<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>square <span>></span> i<span>)</span> <span>{</span>
                <span>break</span><span>;</span>
            <span>}</span>
            min <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>min<span>,</span> dp<span>[</span>i <span>-</span> square<span>]</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
        <span>}</span>
        dp<span>[</span>i<span>]</span> <span>=</span> min<span>;</span>
    <span>}</span>
    <span>return</span> dp<span>[</span>n<span>]</span><span>;</span>
<span>}</span>

<span>private</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>generateSquareList</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> squareList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>int</span> diff <span>=</span> <span>3</span><span>;</span>
    <span>int</span> square <span>=</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span>square <span>&lt;=</span> n<span>)</span> <span>{</span>
        squareList<span>.</span><span>add</span><span>(</span>square<span>)</span><span>;</span>
        square <span>+=</span> diff<span>;</span>
        diff <span>+=</span> <span>2</span><span>;</span>
    <span>}</span>
    <span>return</span> squareList<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id="_3-分割整数构成字母字符串" tabindex="-1"> 3. 分割整数构成字母字符串</h2>
<p><a href="https://leetcode.com/problems/decode-ways/description/" target="_blank" rel="noopener noreferrer">91. Decode Ways (Medium)</a></p>
<p>题目描述：Given encoded message &quot;12&quot;, it could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</p>
<div><pre><code><span>public</span> <span>int</span> <span>numDecodings</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>s <span>==</span> <span>null</span> <span>||</span> s<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>int</span> n <span>=</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
    <span>int</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span>n <span>+</span> <span>1</span><span>]</span><span>;</span>
    dp<span>[</span><span>0</span><span>]</span> <span>=</span> <span>1</span><span>;</span>
    dp<span>[</span><span>1</span><span>]</span> <span>=</span> s<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span> <span>==</span> <span>'0'</span> <span>?</span> <span>0</span> <span>:</span> <span>1</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>int</span> one <span>=</span> <span>Integer</span><span>.</span><span>valueOf</span><span>(</span>s<span>.</span><span>substring</span><span>(</span>i <span>-</span> <span>1</span><span>,</span> i<span>)</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>one <span>!=</span> <span>0</span><span>)</span> <span>{</span>
            dp<span>[</span>i<span>]</span> <span>+=</span> dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>s<span>.</span><span>charAt</span><span>(</span>i <span>-</span> <span>2</span><span>)</span> <span>==</span> <span>'0'</span><span>)</span> <span>{</span>
            <span>continue</span><span>;</span>
        <span>}</span>
        <span>int</span> two <span>=</span> <span>Integer</span><span>.</span><span>valueOf</span><span>(</span>s<span>.</span><span>substring</span><span>(</span>i <span>-</span> <span>2</span><span>,</span> i<span>)</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>two <span>&lt;=</span> <span>26</span><span>)</span> <span>{</span>
            dp<span>[</span>i<span>]</span> <span>+=</span> dp<span>[</span>i <span>-</span> <span>2</span><span>]</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> dp<span>[</span>n<span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h1 id="最长递增子序列" tabindex="-1"> 最长递增子序列</h1>
<p>已知一个序列 {S<sub>1</sub>, S<sub>2</sub>,...,S<sub>n</sub>}，取出若干数组成新的序列 {S<sub>i1</sub>, S<sub>i2</sub>,..., S<sub>im</sub>}，其中 i1、i2 ... im 保持递增，即新序列中各个数仍然保持原数列中的先后顺序，称新序列为原序列的一个 <strong>子序列</strong> 。</p>
<p>如果在子序列中，当下标 ix &gt; iy 时，S<sub>ix</sub> &gt; S<sub>iy</sub>，称子序列为原序列的一个 <strong>递增子序列</strong> 。</p>
<p>定义一个数组 dp 存储最长递增子序列的长度，dp[n] 表示以 S<sub>n</sub> 结尾的序列的最长递增子序列长度。对于一个递增子序列 {S<sub>i1</sub>, S<sub>i2</sub>,...,S<sub>im</sub>}，如果 im &lt; n 并且 S<sub>im</sub> &lt; S<sub>n</sub>，此时 {S<sub>i1</sub>, S<sub>i2</sub>,..., S<sub>im</sub>, S<sub>n</sub>} 为一个递增子序列，递增子序列的长度增加 1。满足上述条件的递增子序列中，长度最长的那个递增子序列就是要找的，在长度最长的递增子序列上加上 S<sub>n</sub> 就构成了以 S<sub>n</sub> 为结尾的最长递增子序列。因此 dp[n] = max{ dp[i]+1 | S<sub>i</sub> &lt; S<sub>n</sub> &amp;&amp; i &lt; n} 。</p>
<p>因为在求 dp[n] 时可能无法找到一个满足条件的递增子序列，此时 {S<sub>n</sub>} 就构成了递增子序列，需要对前面的求解方程做修改，令 dp[n] 最小为 1，即：</p>

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ee994da4-0fc7-443d-ac56-c08caf00a204.jpg" width="350px"> </div><br>
<p>对于一个长度为 N 的序列，最长递增子序列并不一定会以 S<sub>N</sub> 为结尾，因此 dp[N] 不是序列的最长递增子序列的长度，需要遍历 dp 数组找出最大值才是所要的结果，max{ dp[i] | 1 &lt;= i &lt;= N} 即为所求。</p>
<h2 id="_1-最长递增子序列" tabindex="-1"> 1. 最长递增子序列</h2>
<p><a href="https://leetcode.com/problems/longest-increasing-subsequence/description/" target="_blank" rel="noopener noreferrer">300. Longest Increasing Subsequence (Medium)</a></p>
<div><pre><code><span>public</span> <span>int</span> <span>lengthOfLIS</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>int</span> n <span>=</span> nums<span>.</span>length<span>;</span>
    <span>int</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span>n<span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>int</span> max <span>=</span> <span>1</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> i<span>;</span> j<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>></span> nums<span>[</span>j<span>]</span><span>)</span> <span>{</span>
                max <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>max<span>,</span> dp<span>[</span>j<span>]</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        dp<span>[</span>i<span>]</span> <span>=</span> max<span>;</span>
    <span>}</span>
    <span>return</span> <span>Arrays</span><span>.</span><span>stream</span><span>(</span>dp<span>)</span><span>.</span><span>max</span><span>(</span><span>)</span><span>.</span><span>orElse</span><span>(</span><span>0</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>使用 Stream 求最大值会导致运行时间过长，可以改成以下形式：</p>
<div><pre><code><span>int</span> ret <span>=</span> <span>0</span><span>;</span>
<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    ret <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>ret<span>,</span> dp<span>[</span>i<span>]</span><span>)</span><span>;</span>
<span>}</span>
<span>return</span> ret<span>;</span>
</code></pre></div><p>以上解法的时间复杂度为 O(N<sup>2</sup>)，可以使用二分查找将时间复杂度降低为 O(NlogN)。</p>
<p>定义一个 tails 数组，其中 tails[i] 存储长度为 i + 1 的最长递增子序列的最后一个元素。对于一个元素 x，</p>
<ul>
<li>如果它大于 tails 数组所有的值，那么把它添加到 tails 后面，表示最长递增子序列长度加 1；</li>
<li>如果 tails[i-1] &lt; x &lt;= tails[i]，那么更新 tails[i] = x。</li>
</ul>
<p>例如对于数组 [4,3,6,5]，有：</p>
<div><pre><code>tails      len      num
[]         0        4
[4]        1        3
[3]        1        6
[3,6]      2        5
[3,5]      2        null
</code></pre></div><p>可以看出 tails 数组保持有序，因此在查找 S<sub>i</sub> 位于 tails 数组的位置时就可以使用二分查找。</p>
<div><pre><code><span>public</span> <span>int</span> <span>lengthOfLIS</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>int</span> n <span>=</span> nums<span>.</span>length<span>;</span>
    <span>int</span><span>[</span><span>]</span> tails <span>=</span> <span>new</span> <span>int</span><span>[</span>n<span>]</span><span>;</span>
    <span>int</span> len <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
        <span>int</span> index <span>=</span> <span>binarySearch</span><span>(</span>tails<span>,</span> len<span>,</span> num<span>)</span><span>;</span>
        tails<span>[</span>index<span>]</span> <span>=</span> num<span>;</span>
        <span>if</span> <span>(</span>index <span>==</span> len<span>)</span> <span>{</span>
            len<span>++</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> len<span>;</span>
<span>}</span>

<span>private</span> <span>int</span> <span>binarySearch</span><span>(</span><span>int</span><span>[</span><span>]</span> tails<span>,</span> <span>int</span> len<span>,</span> <span>int</span> key<span>)</span> <span>{</span>
    <span>int</span> l <span>=</span> <span>0</span><span>,</span> h <span>=</span> len<span>;</span>
    <span>while</span> <span>(</span>l <span>&lt;</span> h<span>)</span> <span>{</span>
        <span>int</span> mid <span>=</span> l <span>+</span> <span>(</span>h <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
        <span>if</span> <span>(</span>tails<span>[</span>mid<span>]</span> <span>==</span> key<span>)</span> <span>{</span>
            <span>return</span> mid<span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>tails<span>[</span>mid<span>]</span> <span>></span> key<span>)</span> <span>{</span>
            h <span>=</span> mid<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            l <span>=</span> mid <span>+</span> <span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> l<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h2 id="_2-一组整数对能够构成的最长链" tabindex="-1"> 2. 一组整数对能够构成的最长链</h2>
<p><a href="https://leetcode.com/problems/maximum-length-of-pair-chain/description/" target="_blank" rel="noopener noreferrer">646. Maximum Length of Pair Chain (Medium)</a></p>
<div><pre><code>Input: [[1,2], [2,3], [3,4]]
Output: 2
Explanation: The longest chain is [1,2] -> [3,4]
</code></pre></div><p>题目描述：对于 (a, b) 和 (c, d) ，如果 b &lt; c，则它们可以构成一条链。</p>
<div><pre><code><span>public</span> <span>int</span> <span>findLongestChain</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> pairs<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>pairs <span>==</span> <span>null</span> <span>||</span> pairs<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>Arrays</span><span>.</span><span>sort</span><span>(</span>pairs<span>,</span> <span>(</span>a<span>,</span> b<span>)</span> <span>-></span> <span>(</span>a<span>[</span><span>0</span><span>]</span> <span>-</span> b<span>[</span><span>0</span><span>]</span><span>)</span><span>)</span><span>;</span>
    <span>int</span> n <span>=</span> pairs<span>.</span>length<span>;</span>
    <span>int</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span>n<span>]</span><span>;</span>
    <span>Arrays</span><span>.</span><span>fill</span><span>(</span>dp<span>,</span> <span>1</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> i<span>;</span> j<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>pairs<span>[</span>j<span>]</span><span>[</span><span>1</span><span>]</span> <span>&lt;</span> pairs<span>[</span>i<span>]</span><span>[</span><span>0</span><span>]</span><span>)</span> <span>{</span>
                dp<span>[</span>i<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>dp<span>[</span>i<span>]</span><span>,</span> dp<span>[</span>j<span>]</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>Arrays</span><span>.</span><span>stream</span><span>(</span>dp<span>)</span><span>.</span><span>max</span><span>(</span><span>)</span><span>.</span><span>orElse</span><span>(</span><span>0</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="_3-最长摆动子序列" tabindex="-1"> 3. 最长摆动子序列</h2>
<p><a href="https://leetcode.com/problems/wiggle-subsequence/description/" target="_blank" rel="noopener noreferrer">376. Wiggle Subsequence (Medium)</a></p>
<div><pre><code>Input: [1,7,4,9,2,5]
Output: 6
The entire sequence is a wiggle sequence.

Input: [1,17,5,10,13,15,10,5,16,8]
Output: 7
There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].

Input: [1,2,3,4,5,6,7,8,9]
Output: 2
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>要求：使用 O(N) 时间复杂度求解。</p>
<div><pre><code><span>public</span> <span>int</span> <span>wiggleMaxLength</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nums <span>==</span> <span>null</span> <span>||</span> nums<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>int</span> up <span>=</span> <span>1</span><span>,</span> down <span>=</span> <span>1</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>></span> nums<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span> <span>{</span>
            up <span>=</span> down <span>+</span> <span>1</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>&lt;</span> nums<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span> <span>{</span>
            down <span>=</span> up <span>+</span> <span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>Math</span><span>.</span><span>max</span><span>(</span>up<span>,</span> down<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h1 id="最长公共子序列" tabindex="-1"> 最长公共子序列</h1>
<p>对于两个子序列 S1 和 S2，找出它们最长的公共子序列。</p>
<p>定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 dp[i][j] 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。考虑 S1<sub>i</sub> 与 S2<sub>j</sub> 值是否相等，分为两种情况：</p>
<ul>
<li>当 S1<sub>i</sub>==S2<sub>j</sub> 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1<sub>i</sub> 这个值，最长公共子序列长度加 1，即 dp[i][j] = dp[i-1][j-1] + 1。</li>
<li>当 S1<sub>i</sub> != S2<sub>j</sub> 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，或者 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，取它们的最大者，即 dp[i][j] = max{ dp[i-1][j], dp[i][j-1] }。</li>
</ul>
<p>综上，最长公共子序列的状态转移方程为：</p>

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ecd89a22-c075-4716-8423-e0ba89230e9a.jpg" width="450px"> </div><br>
<p>对于长度为 N 的序列 S<sub>1</sub> 和长度为 M 的序列 S<sub>2</sub>，dp[N][M] 就是序列 S<sub>1</sub> 和序列 S<sub>2</sub> 的最长公共子序列长度。</p>
<p>与最长递增子序列相比，最长公共子序列有以下不同点：</p>
<ul>
<li>针对的是两个序列，求它们的最长公共子序列。</li>
<li>在最长递增子序列中，dp[i] 表示以 S<sub>i</sub> 为结尾的最长递增子序列长度，子序列必须包含 S<sub>i</sub> ；在最长公共子序列中，dp[i][j] 表示 S1 中前 i 个字符与 S2 中前 j 个字符的最长公共子序列长度，不一定包含 S1<sub>i</sub> 和 S2<sub>j</sub>。</li>
<li>在求最终解时，最长公共子序列中 dp[N][M] 就是最终解，而最长递增子序列中 dp[N] 不是最终解，因为以 S<sub>N</sub> 为结尾的最长递增子序列不一定是整个序列最长递增子序列，需要遍历一遍 dp 数组找到最大者。</li>
</ul>
<div><pre><code><span>public</span> <span>int</span> <span>lengthOfLCS</span><span>(</span><span>int</span><span>[</span><span>]</span> nums1<span>,</span> <span>int</span><span>[</span><span>]</span> nums2<span>)</span> <span>{</span>
    <span>int</span> n1 <span>=</span> nums1<span>.</span>length<span>,</span> n2 <span>=</span> nums2<span>.</span>length<span>;</span>
    <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span>n1 <span>+</span> <span>1</span><span>]</span><span>[</span>n2 <span>+</span> <span>1</span><span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> n1<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>1</span><span>;</span> j <span>&lt;=</span> n2<span>;</span> j<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>nums1<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>==</span> nums2<span>[</span>j <span>-</span> <span>1</span><span>]</span><span>)</span> <span>{</span>
                dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span> <span>+</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j<span>]</span><span>,</span> dp<span>[</span>i<span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> dp<span>[</span>n1<span>]</span><span>[</span>n2<span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h1 id="_0-1-背包" tabindex="-1"> 0-1 背包</h1>
<p>有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。</p>
<p>定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：</p>
<ul>
<li>第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i][j] = dp[i-1][j]。</li>
<li>第 i 件物品添加到背包中，dp[i][j] = dp[i-1][j-w] + v。</li>
</ul>
<p>第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为：</p>

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8cb2be66-3d47-41ba-b55b-319fc68940d4.png" width="400px"> </div><br>
<div><pre><code><span>// W 为背包总体积</span>
<span>// N 为物品数量</span>
<span>// weights 数组存储 N 个物品的重量</span>
<span>// values 数组存储 N 个物品的价值</span>
<span>public</span> <span>int</span> <span>knapsack</span><span>(</span><span>int</span> <span>W</span><span>,</span> <span>int</span> <span>N</span><span>,</span> <span>int</span><span>[</span><span>]</span> weights<span>,</span> <span>int</span><span>[</span><span>]</span> values<span>)</span> <span>{</span>
    <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span><span>N</span> <span>+</span> <span>1</span><span>]</span><span>[</span><span>W</span> <span>+</span> <span>1</span><span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>int</span> w <span>=</span> weights<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>,</span> v <span>=</span> values<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>1</span><span>;</span> j <span>&lt;=</span> <span>W</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>j <span>>=</span> w<span>)</span> <span>{</span>
                dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j<span>]</span><span>,</span> dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j <span>-</span> w<span>]</span> <span>+</span> v<span>)</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j<span>]</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> dp<span>[</span><span>N</span><span>]</span><span>[</span><span>W</span><span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><strong>空间优化</strong></p>
<p>在程序实现时可以对 0-1 背包做优化。观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示 dp[i-1][j] 也可以表示 dp[i][j]。此时，</p>

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9ae89f16-7905-4a6f-88a2-874b4cac91f4.jpg" width="300px"> </div><br>
<p>因为 dp[j-w] 表示 dp[i-1][j-w]，因此不能先求 dp[i][j-w]，防止将 dp[i-1][j-w] 覆盖。也就是说要先计算 dp[i][j] 再计算 dp[i][j-w]，在程序实现时需要按倒序来循环求解。</p>
<div><pre><code><span>public</span> <span>int</span> <span>knapsack</span><span>(</span><span>int</span> <span>W</span><span>,</span> <span>int</span> <span>N</span><span>,</span> <span>int</span><span>[</span><span>]</span> weights<span>,</span> <span>int</span><span>[</span><span>]</span> values<span>)</span> <span>{</span>
    <span>int</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span><span>W</span> <span>+</span> <span>1</span><span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>int</span> w <span>=</span> weights<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>,</span> v <span>=</span> values<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>W</span><span>;</span> j <span>>=</span> <span>1</span><span>;</span> j<span>--</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>j <span>>=</span> w<span>)</span> <span>{</span>
                dp<span>[</span>j<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>dp<span>[</span>j<span>]</span><span>,</span> dp<span>[</span>j <span>-</span> w<span>]</span> <span>+</span> v<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> dp<span>[</span><span>W</span><span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>无法使用贪心算法的解释</strong></p>
<p>0-1 背包问题无法使用贪心算法来求解，也就是说不能按照先添加性价比最高的物品来达到最优，这是因为这种方式可能造成背包空间的浪费，从而无法达到最优。考虑下面的物品和一个容量为 5 的背包，如果先添加物品 0 再添加物品 1，那么只能存放的价值为 16，浪费了大小为 2 的空间。最优的方式是存放物品 1 和物品 2，价值为 22.</p>
<table>
<thead>
<tr>
<th>id</th>
<th>w</th>
<th>v</th>
<th>v/w</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>6</td>
<td>6</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>10</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>12</td>
<td>4</td>
</tr>
</tbody>
</table>
<p><strong>变种</strong></p>
<ul>
<li>
<p>完全背包：物品数量为无限个</p>
</li>
<li>
<p>多重背包：物品数量有限制</p>
</li>
<li>
<p>多维费用背包：物品不仅有重量，还有体积，同时考虑这两种限制</p>
</li>
<li>
<p>其它：物品之间相互约束或者依赖</p>
</li>
</ul>
<h2 id="_1-划分数组为和相等的两部分" tabindex="-1"> 1. 划分数组为和相等的两部分</h2>
<p><a href="https://leetcode.com/problems/partition-equal-subset-sum/description/" target="_blank" rel="noopener noreferrer">416. Partition Equal Subset Sum (Medium)</a></p>
<div><pre><code>Input: [1, 5, 11, 5]

Output: true

Explanation: The array can be partitioned as [1, 5, 5] and [11].
</code></pre></div><p>可以看成一个背包大小为 sum/2 的 0-1 背包问题。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>canPartition</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>int</span> sum <span>=</span> <span>computeArraySum</span><span>(</span>nums<span>)</span><span>;</span>
    <span>if</span> <span>(</span>sum <span>%</span> <span>2</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
    <span>int</span> <span>W</span> <span>=</span> sum <span>/</span> <span>2</span><span>;</span>
    <span>boolean</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>boolean</span><span>[</span><span>W</span> <span>+</span> <span>1</span><span>]</span><span>;</span>
    dp<span>[</span><span>0</span><span>]</span> <span>=</span> <span>true</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>                 <span>// 0-1 背包一个物品只能用一次</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>W</span><span>;</span> i <span>>=</span> num<span>;</span> i<span>--</span><span>)</span> <span>{</span>   <span>// 从后往前，先计算 dp[i] 再计算 dp[i-num]</span>
            dp<span>[</span>i<span>]</span> <span>=</span> dp<span>[</span>i<span>]</span> <span>||</span> dp<span>[</span>i <span>-</span> num<span>]</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> dp<span>[</span><span>W</span><span>]</span><span>;</span>
<span>}</span>

<span>private</span> <span>int</span> <span>computeArraySum</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>int</span> sum <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
        sum <span>+=</span> num<span>;</span>
    <span>}</span>
    <span>return</span> sum<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id="_2-改变一组数的正负号使得它们的和为一给定数" tabindex="-1"> 2. 改变一组数的正负号使得它们的和为一给定数</h2>
<p><a href="https://leetcode.com/problems/target-sum/description/" target="_blank" rel="noopener noreferrer">494. Target Sum (Medium)</a></p>
<div><pre><code>Input: nums is [1, 1, 1, 1, 1], S is 3.
Output: 5
Explanation:

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

There are 5 ways to assign symbols to make the sum of nums be target 3.
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>该问题可以转换为 Subset Sum 问题，从而使用 0-1 背包的方法来求解。</p>
<p>可以将这组数看成两部分，P 和 N，其中 P 使用正号，N 使用负号，有以下推导：</p>
<div><pre><code>                  sum(P) - sum(N) = target
sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)
                       2 * sum(P) = target + sum(nums)
</code></pre></div><p>因此只要找到一个子集，令它们都取正号，并且和等于 (target + sum(nums))/2，就证明存在解。</p>
<div><pre><code><span>public</span> <span>int</span> <span>findTargetSumWays</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> <span>S</span><span>)</span> <span>{</span>
    <span>int</span> sum <span>=</span> <span>computeArraySum</span><span>(</span>nums<span>)</span><span>;</span>
    <span>if</span> <span>(</span>sum <span>&lt;</span> <span>S</span> <span>||</span> <span>(</span>sum <span>+</span> <span>S</span><span>)</span> <span>%</span> <span>2</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>int</span> <span>W</span> <span>=</span> <span>(</span>sum <span>+</span> <span>S</span><span>)</span> <span>/</span> <span>2</span><span>;</span>
    <span>int</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span><span>W</span> <span>+</span> <span>1</span><span>]</span><span>;</span>
    dp<span>[</span><span>0</span><span>]</span> <span>=</span> <span>1</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>W</span><span>;</span> i <span>>=</span> num<span>;</span> i<span>--</span><span>)</span> <span>{</span>
            dp<span>[</span>i<span>]</span> <span>=</span> dp<span>[</span>i<span>]</span> <span>+</span> dp<span>[</span>i <span>-</span> num<span>]</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> dp<span>[</span><span>W</span><span>]</span><span>;</span>
<span>}</span>

<span>private</span> <span>int</span> <span>computeArraySum</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>int</span> sum <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
        sum <span>+=</span> num<span>;</span>
    <span>}</span>
    <span>return</span> sum<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>DFS 解法：</p>
<div><pre><code><span>public</span> <span>int</span> <span>findTargetSumWays</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> <span>S</span><span>)</span> <span>{</span>
    <span>return</span> <span>findTargetSumWays</span><span>(</span>nums<span>,</span> <span>0</span><span>,</span> <span>S</span><span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>int</span> <span>findTargetSumWays</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> start<span>,</span> <span>int</span> <span>S</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>start <span>==</span> nums<span>.</span>length<span>)</span> <span>{</span>
        <span>return</span> <span>S</span> <span>==</span> <span>0</span> <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>findTargetSumWays</span><span>(</span>nums<span>,</span> start <span>+</span> <span>1</span><span>,</span> <span>S</span> <span>+</span> nums<span>[</span>start<span>]</span><span>)</span>
            <span>+</span> <span>findTargetSumWays</span><span>(</span>nums<span>,</span> start <span>+</span> <span>1</span><span>,</span> <span>S</span> <span>-</span> nums<span>[</span>start<span>]</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="_3-01-字符构成最多的字符串" tabindex="-1"> 3. 01 字符构成最多的字符串</h2>
<p><a href="https://leetcode.com/problems/ones-and-zeroes/description/" target="_blank" rel="noopener noreferrer">474. Ones and Zeroes (Medium)</a></p>
<div><pre><code>Input: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3
Output: 4

Explanation: There are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are "10","0001","1","0"
</code></pre></div><p>这是一个多维费用的 0-1 背包问题，有两个背包大小，0 的数量和 1 的数量。</p>
<div><pre><code><span>public</span> <span>int</span> <span>findMaxForm</span><span>(</span><span>String</span><span>[</span><span>]</span> strs<span>,</span> <span>int</span> m<span>,</span> <span>int</span> n<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>strs <span>==</span> <span>null</span> <span>||</span> strs<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span>m <span>+</span> <span>1</span><span>]</span><span>[</span>n <span>+</span> <span>1</span><span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>String</span> s <span>:</span> strs<span>)</span> <span>{</span>    <span>// 每个字符串只能用一次</span>
        <span>int</span> ones <span>=</span> <span>0</span><span>,</span> zeros <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>char</span> c <span>:</span> s<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>c <span>==</span> <span>'0'</span><span>)</span> <span>{</span>
                zeros<span>++</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                ones<span>++</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> m<span>;</span> i <span>>=</span> zeros<span>;</span> i<span>--</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> j <span>=</span> n<span>;</span> j <span>>=</span> ones<span>;</span> j<span>--</span><span>)</span> <span>{</span>
                dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>,</span> dp<span>[</span>i <span>-</span> zeros<span>]</span><span>[</span>j <span>-</span> ones<span>]</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> dp<span>[</span>m<span>]</span><span>[</span>n<span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id="_4-找零钱的最少硬币数" tabindex="-1"> 4. 找零钱的最少硬币数</h2>
<p><a href="https://leetcode.com/problems/coin-change/description/" target="_blank" rel="noopener noreferrer">322. Coin Change (Medium)</a></p>
<div><pre><code>Example 1:
coins = [1, 2, 5], amount = 11
return 3 (11 = 5 + 5 + 1)

Example 2:
coins = [2], amount = 3
return -1.
</code></pre></div><p>题目描述：给一些面额的硬币，要求用这些硬币来组成给定面额的钱数，并且使得硬币数量最少。硬币可以重复使用。</p>
<ul>
<li>物品：硬币</li>
<li>物品大小：面额</li>
<li>物品价值：数量</li>
</ul>
<p>因为硬币可以重复使用，因此这是一个完全背包问题。完全背包只需要将 0-1 背包的逆序遍历 dp 数组改为正序遍历即可。</p>
<div><pre><code><span>public</span> <span>int</span> <span>coinChange</span><span>(</span><span>int</span><span>[</span><span>]</span> coins<span>,</span> <span>int</span> amount<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>amount <span>==</span> <span>0</span> <span>||</span> coins <span>==</span> <span>null</span> <span>||</span> coins<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>int</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span>amount <span>+</span> <span>1</span><span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> coin <span>:</span> coins<span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> coin<span>;</span> i <span>&lt;=</span> amount<span>;</span> i<span>++</span><span>)</span> <span>{</span> <span>//将逆序遍历改为正序遍历</span>
            <span>if</span> <span>(</span>i <span>==</span> coin<span>)</span> <span>{</span>
                dp<span>[</span>i<span>]</span> <span>=</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span>dp<span>[</span>i<span>]</span> <span>==</span> <span>0</span> <span>&amp;&amp;</span> dp<span>[</span>i <span>-</span> coin<span>]</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
                dp<span>[</span>i<span>]</span> <span>=</span> dp<span>[</span>i <span>-</span> coin<span>]</span> <span>+</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span>dp<span>[</span>i <span>-</span> coin<span>]</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
                dp<span>[</span>i<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>dp<span>[</span>i<span>]</span><span>,</span> dp<span>[</span>i <span>-</span> coin<span>]</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> dp<span>[</span>amount<span>]</span> <span>==</span> <span>0</span> <span>?</span> <span>-</span><span>1</span> <span>:</span> dp<span>[</span>amount<span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id="_5-找零钱的硬币数组合" tabindex="-1"> 5. 找零钱的硬币数组合</h2>
<p><a href="https://leetcode.com/problems/coin-change-2/description/" target="_blank" rel="noopener noreferrer">518. Coin Change 2 (Medium)</a></p>
<div><pre><code>Input: amount = 5, coins = [1, 2, 5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
</code></pre></div><p>完全背包问题，使用 dp 记录可达成目标的组合数目。</p>
<div><pre><code><span>public</span> <span>int</span> <span>change</span><span>(</span><span>int</span> amount<span>,</span> <span>int</span><span>[</span><span>]</span> coins<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>amount <span>==</span> <span>0</span> <span>||</span> coins <span>==</span> <span>null</span> <span>||</span> coins<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>int</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span>amount <span>+</span> <span>1</span><span>]</span><span>;</span>
    dp<span>[</span><span>0</span><span>]</span> <span>=</span> <span>1</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> coin <span>:</span> coins<span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> coin<span>;</span> i <span>&lt;=</span> amount<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            dp<span>[</span>i<span>]</span> <span>+=</span> dp<span>[</span>i <span>-</span> coin<span>]</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> dp<span>[</span>amount<span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="_6-字符串按单词列表分割" tabindex="-1"> 6. 字符串按单词列表分割</h2>
<p><a href="https://leetcode.com/problems/word-break/description/" target="_blank" rel="noopener noreferrer">139. Word Break (Medium)</a></p>
<div><pre><code>s = "leetcode",
dict = ["leet", "code"].
Return true because "leetcode" can be segmented as "leet code".
</code></pre></div><p>dict 中的单词没有使用次数的限制，因此这是一个完全背包问题。</p>
<p>该问题涉及到字典中单词的使用顺序，也就是说物品必须按一定顺序放入背包中，例如下面的 dict 就不够组成字符串 &quot;leetcode&quot;：</p>
<div><pre><code>["lee", "tc", "cod"]
</code></pre></div><p>求解顺序的完全背包问题时，对物品的迭代应该放在最里层，对背包的迭代放在外层，只有这样才能让物品按一定顺序放入背包中。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>wordBreak</span><span>(</span><span>String</span> s<span>,</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> wordDict<span>)</span> <span>{</span>
    <span>int</span> n <span>=</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
    <span>boolean</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>boolean</span><span>[</span>n <span>+</span> <span>1</span><span>]</span><span>;</span>
    dp<span>[</span><span>0</span><span>]</span> <span>=</span> <span>true</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>String</span> word <span>:</span> wordDict<span>)</span> <span>{</span>   <span>// 对物品的迭代应该放在最里层</span>
            <span>int</span> len <span>=</span> word<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>len <span>&lt;=</span> i <span>&amp;&amp;</span> word<span>.</span><span>equals</span><span>(</span>s<span>.</span><span>substring</span><span>(</span>i <span>-</span> len<span>,</span> i<span>)</span><span>)</span><span>)</span> <span>{</span>
                dp<span>[</span>i<span>]</span> <span>=</span> dp<span>[</span>i<span>]</span> <span>||</span> dp<span>[</span>i <span>-</span> len<span>]</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> dp<span>[</span>n<span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="_7-组合总和" tabindex="-1"> 7. 组合总和</h2>
<p><a href="https://leetcode.com/problems/combination-sum-iv/description/" target="_blank" rel="noopener noreferrer">377. Combination Sum IV (Medium)</a></p>
<div><pre><code>nums = [1, 2, 3]
target = 4

The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

Note that different sequences are counted as different combinations.

Therefore the output is 7.
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>涉及顺序的完全背包。</p>
<div><pre><code><span>public</span> <span>int</span> <span>combinationSum4</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> target<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nums <span>==</span> <span>null</span> <span>||</span> nums<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>int</span><span>[</span><span>]</span> maximum <span>=</span> <span>new</span> <span>int</span><span>[</span>target <span>+</span> <span>1</span><span>]</span><span>;</span>
    maximum<span>[</span><span>0</span><span>]</span> <span>=</span> <span>1</span><span>;</span>
    <span>Arrays</span><span>.</span><span>sort</span><span>(</span>nums<span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> target<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> nums<span>.</span>length <span>&amp;&amp;</span> nums<span>[</span>j<span>]</span> <span>&lt;=</span> i<span>;</span> j<span>++</span><span>)</span> <span>{</span>
            maximum<span>[</span>i<span>]</span> <span>+=</span> maximum<span>[</span>i <span>-</span> nums<span>[</span>j<span>]</span><span>]</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> maximum<span>[</span>target<span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h1 id="股票交易" tabindex="-1"> 股票交易</h1>
<h2 id="_1-需要冷却期的股票交易" tabindex="-1"> 1. 需要冷却期的股票交易</h2>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/" target="_blank" rel="noopener noreferrer">309. Best Time to Buy and Sell Stock with Cooldown(Medium)</a></p>
<p>题目描述：交易之后需要有一天的冷却时间。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/83acbb02-872a-4178-b22a-c89c3cb60263.jpg" width="300px"> </div><br>
<div><pre><code><span>public</span> <span>int</span> <span>maxProfit</span><span>(</span><span>int</span><span>[</span><span>]</span> prices<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>prices <span>==</span> <span>null</span> <span>||</span> prices<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>int</span> <span>N</span> <span>=</span> prices<span>.</span>length<span>;</span>
    <span>int</span><span>[</span><span>]</span> buy <span>=</span> <span>new</span> <span>int</span><span>[</span><span>N</span><span>]</span><span>;</span>
    <span>int</span><span>[</span><span>]</span> s1 <span>=</span> <span>new</span> <span>int</span><span>[</span><span>N</span><span>]</span><span>;</span>
    <span>int</span><span>[</span><span>]</span> sell <span>=</span> <span>new</span> <span>int</span><span>[</span><span>N</span><span>]</span><span>;</span>
    <span>int</span><span>[</span><span>]</span> s2 <span>=</span> <span>new</span> <span>int</span><span>[</span><span>N</span><span>]</span><span>;</span>
    s1<span>[</span><span>0</span><span>]</span> <span>=</span> buy<span>[</span><span>0</span><span>]</span> <span>=</span> <span>-</span>prices<span>[</span><span>0</span><span>]</span><span>;</span>
    sell<span>[</span><span>0</span><span>]</span> <span>=</span> s2<span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        buy<span>[</span>i<span>]</span> <span>=</span> s2<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>-</span> prices<span>[</span>i<span>]</span><span>;</span>
        s1<span>[</span>i<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>buy<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>,</span> s1<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span><span>;</span>
        sell<span>[</span>i<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>buy<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>,</span> s1<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span> <span>+</span> prices<span>[</span>i<span>]</span><span>;</span>
        s2<span>[</span>i<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>s2<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>,</span> sell<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>Math</span><span>.</span><span>max</span><span>(</span>sell<span>[</span><span>N</span> <span>-</span> <span>1</span><span>]</span><span>,</span> s2<span>[</span><span>N</span> <span>-</span> <span>1</span><span>]</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="_2-需要交易费用的股票交易" tabindex="-1"> 2. 需要交易费用的股票交易</h2>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/" target="_blank" rel="noopener noreferrer">714. Best Time to Buy and Sell Stock with Transaction Fee (Medium)</a></p>
<div><pre><code>Input: prices = [1, 3, 2, 8, 4, 9], fee = 2
Output: 8
Explanation: The maximum profit can be achieved by:
Buying at prices[0] = 1
Selling at prices[3] = 8
Buying at prices[4] = 4
Selling at prices[5] = 9
The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
</code></pre></div><p>题目描述：每交易一次，都要支付一定的费用。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1e2c588c-72b7-445e-aacb-d55dc8a88c29.png" width="300px"> </div><br>
<div><pre><code><span>public</span> <span>int</span> <span>maxProfit</span><span>(</span><span>int</span><span>[</span><span>]</span> prices<span>,</span> <span>int</span> fee<span>)</span> <span>{</span>
    <span>int</span> <span>N</span> <span>=</span> prices<span>.</span>length<span>;</span>
    <span>int</span><span>[</span><span>]</span> buy <span>=</span> <span>new</span> <span>int</span><span>[</span><span>N</span><span>]</span><span>;</span>
    <span>int</span><span>[</span><span>]</span> s1 <span>=</span> <span>new</span> <span>int</span><span>[</span><span>N</span><span>]</span><span>;</span>
    <span>int</span><span>[</span><span>]</span> sell <span>=</span> <span>new</span> <span>int</span><span>[</span><span>N</span><span>]</span><span>;</span>
    <span>int</span><span>[</span><span>]</span> s2 <span>=</span> <span>new</span> <span>int</span><span>[</span><span>N</span><span>]</span><span>;</span>
    s1<span>[</span><span>0</span><span>]</span> <span>=</span> buy<span>[</span><span>0</span><span>]</span> <span>=</span> <span>-</span>prices<span>[</span><span>0</span><span>]</span><span>;</span>
    sell<span>[</span><span>0</span><span>]</span> <span>=</span> s2<span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        buy<span>[</span>i<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>sell<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>,</span> s2<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span> <span>-</span> prices<span>[</span>i<span>]</span><span>;</span>
        s1<span>[</span>i<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>buy<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>,</span> s1<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span><span>;</span>
        sell<span>[</span>i<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>buy<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>,</span> s1<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span> <span>-</span> fee <span>+</span> prices<span>[</span>i<span>]</span><span>;</span>
        s2<span>[</span>i<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>s2<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>,</span> sell<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>Math</span><span>.</span><span>max</span><span>(</span>sell<span>[</span><span>N</span> <span>-</span> <span>1</span><span>]</span><span>,</span> s2<span>[</span><span>N</span> <span>-</span> <span>1</span><span>]</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="_3-只能进行两次的股票交易" tabindex="-1"> 3. 只能进行两次的股票交易</h2>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/" target="_blank" rel="noopener noreferrer">123. Best Time to Buy and Sell Stock III (Hard)</a></p>
<div><pre><code><span>public</span> <span>int</span> <span>maxProfit</span><span>(</span><span>int</span><span>[</span><span>]</span> prices<span>)</span> <span>{</span>
    <span>int</span> firstBuy <span>=</span> <span>Integer</span><span>.</span>MIN_VALUE<span>,</span> firstSell <span>=</span> <span>0</span><span>;</span>
    <span>int</span> secondBuy <span>=</span> <span>Integer</span><span>.</span>MIN_VALUE<span>,</span> secondSell <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> curPrice <span>:</span> prices<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>firstBuy <span>&lt;</span> <span>-</span>curPrice<span>)</span> <span>{</span>
            firstBuy <span>=</span> <span>-</span>curPrice<span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>firstSell <span>&lt;</span> firstBuy <span>+</span> curPrice<span>)</span> <span>{</span>
            firstSell <span>=</span> firstBuy <span>+</span> curPrice<span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>secondBuy <span>&lt;</span> firstSell <span>-</span> curPrice<span>)</span> <span>{</span>
            secondBuy <span>=</span> firstSell <span>-</span> curPrice<span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>secondSell <span>&lt;</span> secondBuy <span>+</span> curPrice<span>)</span> <span>{</span>
            secondSell <span>=</span> secondBuy <span>+</span> curPrice<span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> secondSell<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="_4-只能进行-k-次的股票交易" tabindex="-1"> 4. 只能进行 k 次的股票交易</h2>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/" target="_blank" rel="noopener noreferrer">188. Best Time to Buy and Sell Stock IV (Hard)</a></p>
<div><pre><code><span>public</span> <span>int</span> <span>maxProfit</span><span>(</span><span>int</span> k<span>,</span> <span>int</span><span>[</span><span>]</span> prices<span>)</span> <span>{</span>
    <span>int</span> n <span>=</span> prices<span>.</span>length<span>;</span>
    <span>if</span> <span>(</span>k <span>>=</span> n <span>/</span> <span>2</span><span>)</span> <span>{</span>   <span>// 这种情况下该问题退化为普通的股票交易问题</span>
        <span>int</span> maxProfit <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>prices<span>[</span>i<span>]</span> <span>></span> prices<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span> <span>{</span>
                maxProfit <span>+=</span> prices<span>[</span>i<span>]</span> <span>-</span> prices<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> maxProfit<span>;</span>
    <span>}</span>
    <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> maxProfit <span>=</span> <span>new</span> <span>int</span><span>[</span>k <span>+</span> <span>1</span><span>]</span><span>[</span>n<span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> k<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>int</span> localMax <span>=</span> maxProfit<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span><span>0</span><span>]</span> <span>-</span> prices<span>[</span><span>0</span><span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>1</span><span>;</span> j <span>&lt;</span> n<span>;</span> j<span>++</span><span>)</span> <span>{</span>
            maxProfit<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>maxProfit<span>[</span>i<span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span><span>,</span> prices<span>[</span>j<span>]</span> <span>+</span> localMax<span>)</span><span>;</span>
            localMax <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>localMax<span>,</span> maxProfit<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j<span>]</span> <span>-</span> prices<span>[</span>j<span>]</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> maxProfit<span>[</span>k<span>]</span><span>[</span>n <span>-</span> <span>1</span><span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h1 id="字符串编辑" tabindex="-1"> 字符串编辑</h1>
<h2 id="_1-删除两个字符串的字符使它们相等" tabindex="-1"> 1. 删除两个字符串的字符使它们相等</h2>
<p><a href="https://leetcode.com/problems/delete-operation-for-two-strings/description/" target="_blank" rel="noopener noreferrer">583. Delete Operation for Two Strings (Medium)</a></p>
<div><pre><code>Input: "sea", "eat"
Output: 2
Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".
</code></pre></div><p>可以转换为求两个字符串的最长公共子序列问题。</p>
<div><pre><code><span>public</span> <span>int</span> <span>minDistance</span><span>(</span><span>String</span> word1<span>,</span> <span>String</span> word2<span>)</span> <span>{</span>
    <span>int</span> m <span>=</span> word1<span>.</span><span>length</span><span>(</span><span>)</span><span>,</span> n <span>=</span> word2<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
    <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span>m <span>+</span> <span>1</span><span>]</span><span>[</span>n <span>+</span> <span>1</span><span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> m<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>1</span><span>;</span> j <span>&lt;=</span> n<span>;</span> j<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>word1<span>.</span><span>charAt</span><span>(</span>i <span>-</span> <span>1</span><span>)</span> <span>==</span> word2<span>.</span><span>charAt</span><span>(</span>j <span>-</span> <span>1</span><span>)</span><span>)</span> <span>{</span>
                dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span> <span>+</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>dp<span>[</span>i<span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span><span>,</span> dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j<span>]</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> m <span>+</span> n <span>-</span> <span>2</span> <span>*</span> dp<span>[</span>m<span>]</span><span>[</span>n<span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="_2-编辑距离" tabindex="-1"> 2. 编辑距离</h2>
<p><a href="https://leetcode.com/problems/edit-distance/description/" target="_blank" rel="noopener noreferrer">72. Edit Distance (Hard)</a></p>
<div><pre><code>Example 1:

Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation:
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')
Example 2:

Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation:
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>题目描述：修改一个字符串成为另一个字符串，使得修改次数最少。一次修改操作包括：插入一个字符、删除一个字符、替换一个字符。</p>
<div><pre><code><span>public</span> <span>int</span> <span>minDistance</span><span>(</span><span>String</span> word1<span>,</span> <span>String</span> word2<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>word1 <span>==</span> <span>null</span> <span>||</span> word2 <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>int</span> m <span>=</span> word1<span>.</span><span>length</span><span>(</span><span>)</span><span>,</span> n <span>=</span> word2<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
    <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span>m <span>+</span> <span>1</span><span>]</span><span>[</span>n <span>+</span> <span>1</span><span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> m<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        dp<span>[</span>i<span>]</span><span>[</span><span>0</span><span>]</span> <span>=</span> i<span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        dp<span>[</span><span>0</span><span>]</span><span>[</span>i<span>]</span> <span>=</span> i<span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> m<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>1</span><span>;</span> j <span>&lt;=</span> n<span>;</span> j<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>word1<span>.</span><span>charAt</span><span>(</span>i <span>-</span> <span>1</span><span>)</span> <span>==</span> word2<span>.</span><span>charAt</span><span>(</span>j <span>-</span> <span>1</span><span>)</span><span>)</span> <span>{</span>
                dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span><span>,</span> <span>Math</span><span>.</span><span>min</span><span>(</span>dp<span>[</span>i<span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span><span>,</span> dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j<span>]</span><span>)</span><span>)</span> <span>+</span> <span>1</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> dp<span>[</span>m<span>]</span><span>[</span>n<span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id="_3-复制粘贴字符" tabindex="-1"> 3. 复制粘贴字符</h2>
<p><a href="https://leetcode.com/problems/2-keys-keyboard/description/" target="_blank" rel="noopener noreferrer">650. 2 Keys Keyboard (Medium)</a></p>
<p>题目描述：最开始只有一个字符 A，问需要多少次操作能够得到 n 个字符 A，每次操作可以复制当前所有的字符，或者粘贴。</p>
<div><pre><code>Input: 3
Output: 3
Explanation:
Intitally, we have one character 'A'.
In step 1, we use Copy All operation.
In step 2, we use Paste operation to get 'AA'.
In step 3, we use Paste operation to get 'AAA'.
</code></pre></div><div><pre><code><span>public</span> <span>int</span> <span>minSteps</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>n <span>==</span> <span>1</span><span>)</span> <span>return</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;=</span> <span>Math</span><span>.</span><span>sqrt</span><span>(</span>n<span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>n <span>%</span> i <span>==</span> <span>0</span><span>)</span> <span>return</span> i <span>+</span> <span>minSteps</span><span>(</span>n <span>/</span> i<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> n<span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>int</span> <span>minSteps</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>int</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span>n <span>+</span> <span>1</span><span>]</span><span>;</span>
    <span>int</span> h <span>=</span> <span>(</span><span>int</span><span>)</span> <span>Math</span><span>.</span><span>sqrt</span><span>(</span>n<span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        dp<span>[</span>i<span>]</span> <span>=</span> i<span>;</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>2</span><span>;</span> j <span>&lt;=</span> h<span>;</span> j<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>i <span>%</span> j <span>==</span> <span>0</span><span>)</span> <span>{</span>
                dp<span>[</span>i<span>]</span> <span>=</span> dp<span>[</span>j<span>]</span> <span>+</span> dp<span>[</span>i <span>/</span> j<span>]</span><span>;</span>
                <span>break</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> dp<span>[</span>n<span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>1. 有序数组的 Two Sum</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E5%8F%8C%E6%8C%87%E9%92%88.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E5%8F%8C%E6%8C%87%E9%92%88.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">1. 有序数组的 Two Sum</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。</p>
<h1 id="_1-有序数组的-two-sum" tabindex="-1"> 1. 有序数组的 Two Sum</h1>
<p><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/" target="_blank" rel="noopener noreferrer">Leetcode ：167. Two Sum II - Input array is sorted (Easy)</a></p>
<div><pre><code>Input: numbers={2, 7, 11, 15}, target=9
Output: index1=1, index2=2
</code></pre></div><p>题目描述：在有序数组中找出两个数，使它们的和为 target。</p>
<p>使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。</p>
<ul>
<li>如果两个指针指向元素的和 sum == target，那么得到要求的结果；</li>
<li>如果 sum &gt; target，移动较大的元素，使 sum 变小一些；</li>
<li>如果 sum &lt; target，移动较小的元素，使 sum 变大一些。</li>
</ul>
<div><pre><code><span>public</span> <span>int</span><span>[</span><span>]</span> <span>twoSum</span><span>(</span><span>int</span><span>[</span><span>]</span> numbers<span>,</span> <span>int</span> target<span>)</span> <span>{</span>
    <span>int</span> i <span>=</span> <span>0</span><span>,</span> j <span>=</span> numbers<span>.</span>length <span>-</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span>i <span>&lt;</span> j<span>)</span> <span>{</span>
        <span>int</span> sum <span>=</span> numbers<span>[</span>i<span>]</span> <span>+</span> numbers<span>[</span>j<span>]</span><span>;</span>
        <span>if</span> <span>(</span>sum <span>==</span> target<span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span>i <span>+</span> <span>1</span><span>,</span> j <span>+</span> <span>1</span><span>}</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>sum <span>&lt;</span> target<span>)</span> <span>{</span>
            i<span>++</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            j<span>--</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h1 id="_2-两数平方和" tabindex="-1"> 2. 两数平方和</h1>
<p><a href="https://leetcode.com/problems/sum-of-square-numbers/description/" target="_blank" rel="noopener noreferrer">633. Sum of Square Numbers (Easy)</a></p>
<div><pre><code>Input: 5
Output: True
Explanation: 1 * 1 + 2 * 2 = 5
</code></pre></div><p>题目描述：判断一个数是否为两个数的平方和。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>judgeSquareSum</span><span>(</span><span>int</span> c<span>)</span> <span>{</span>
    <span>int</span> i <span>=</span> <span>0</span><span>,</span> j <span>=</span> <span>(</span><span>int</span><span>)</span> <span>Math</span><span>.</span><span>sqrt</span><span>(</span>c<span>)</span><span>;</span>
    <span>while</span> <span>(</span>i <span>&lt;=</span> j<span>)</span> <span>{</span>
        <span>int</span> powSum <span>=</span> i <span>*</span> i <span>+</span> j <span>*</span> j<span>;</span>
        <span>if</span> <span>(</span>powSum <span>==</span> c<span>)</span> <span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>powSum <span>></span> c<span>)</span> <span>{</span>
            j<span>--</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            i<span>++</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h1 id="_3-反转字符串中的元音字符" tabindex="-1"> 3. 反转字符串中的元音字符</h1>
<p><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/description/" target="_blank" rel="noopener noreferrer">345. Reverse Vowels of a String (Easy)</a></p>
<div><pre><code>Given s = "leetcode", return "leotcede".
</code></pre></div><p>使用双指针指向待反转的两个元音字符，一个指针从头向尾遍历，一个指针从尾到头遍历。</p>
<div><pre><code><span>private</span> <span>final</span> <span>static</span> <span>HashSet</span><span><span>&lt;</span><span>Character</span><span>></span></span> vowels <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>></span></span><span>(</span>
        <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>'a'</span><span>,</span> <span>'e'</span><span>,</span> <span>'i'</span><span>,</span> <span>'o'</span><span>,</span> <span>'u'</span><span>,</span> <span>'A'</span><span>,</span> <span>'E'</span><span>,</span> <span>'I'</span><span>,</span> <span>'O'</span><span>,</span> <span>'U'</span><span>)</span><span>)</span><span>;</span>

<span>public</span> <span>String</span> <span>reverseVowels</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
    <span>int</span> i <span>=</span> <span>0</span><span>,</span> j <span>=</span> s<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>;</span>
    <span>char</span><span>[</span><span>]</span> result <span>=</span> <span>new</span> <span>char</span><span>[</span>s<span>.</span><span>length</span><span>(</span><span>)</span><span>]</span><span>;</span>
    <span>while</span> <span>(</span>i <span>&lt;=</span> j<span>)</span> <span>{</span>
        <span>char</span> ci <span>=</span> s<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>;</span>
        <span>char</span> cj <span>=</span> s<span>.</span><span>charAt</span><span>(</span>j<span>)</span><span>;</span>
        <span>if</span> <span>(</span><span>!</span>vowels<span>.</span><span>contains</span><span>(</span>ci<span>)</span><span>)</span> <span>{</span>
            result<span>[</span>i<span>++</span><span>]</span> <span>=</span> ci<span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>!</span>vowels<span>.</span><span>contains</span><span>(</span>cj<span>)</span><span>)</span> <span>{</span>
            result<span>[</span>j<span>--</span><span>]</span> <span>=</span> cj<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            result<span>[</span>i<span>++</span><span>]</span> <span>=</span> cj<span>;</span>
            result<span>[</span>j<span>--</span><span>]</span> <span>=</span> ci<span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>new</span> <span>String</span><span>(</span>result<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h1 id="_4-回文字符串" tabindex="-1"> 4. 回文字符串</h1>
<p><a href="https://leetcode.com/problems/valid-palindrome-ii/description/" target="_blank" rel="noopener noreferrer">680. Valid Palindrome II (Easy)</a></p>
<div><pre><code>Input: "abca"
Output: True
Explanation: You could delete the character 'c'.
</code></pre></div><p>题目描述：可以删除一个字符，判断是否能构成回文字符串。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>validPalindrome</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>,</span> j <span>=</span> s<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>;</span> i <span>&lt;</span> j<span>;</span> i<span>++</span><span>,</span> j<span>--</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>s<span>.</span><span>charAt</span><span>(</span>i<span>)</span> <span>!=</span> s<span>.</span><span>charAt</span><span>(</span>j<span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>isPalindrome</span><span>(</span>s<span>,</span> i<span>,</span> j <span>-</span> <span>1</span><span>)</span> <span>||</span> <span>isPalindrome</span><span>(</span>s<span>,</span> i <span>+</span> <span>1</span><span>,</span> j<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>true</span><span>;</span>
<span>}</span>

<span>private</span> <span>boolean</span> <span>isPalindrome</span><span>(</span><span>String</span> s<span>,</span> <span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>
    <span>while</span> <span>(</span>i <span>&lt;</span> j<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>s<span>.</span><span>charAt</span><span>(</span>i<span>++</span><span>)</span> <span>!=</span> s<span>.</span><span>charAt</span><span>(</span>j<span>--</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>true</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h1 id="_5-归并两个有序数组" tabindex="-1"> 5. 归并两个有序数组</h1>
<p><a href="https://leetcode.com/problems/merge-sorted-array/description/" target="_blank" rel="noopener noreferrer">88. Merge Sorted Array (Easy)</a></p>
<div><pre><code>Input:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

Output: [1,2,2,3,5,6]
</code></pre></div><p>题目描述：把归并结果存到第一个数组上。</p>
<p>需要从尾开始遍历，否则在 nums1 上归并得到的值会覆盖还未进行归并比较的值。</p>
<div><pre><code><span>public</span> <span>void</span> <span>merge</span><span>(</span><span>int</span><span>[</span><span>]</span> nums1<span>,</span> <span>int</span> m<span>,</span> <span>int</span><span>[</span><span>]</span> nums2<span>,</span> <span>int</span> n<span>)</span> <span>{</span>
    <span>int</span> index1 <span>=</span> m <span>-</span> <span>1</span><span>,</span> index2 <span>=</span> n <span>-</span> <span>1</span><span>;</span>
    <span>int</span> indexMerge <span>=</span> m <span>+</span> n <span>-</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span>index1 <span>>=</span> <span>0</span> <span>||</span> index2 <span>>=</span> <span>0</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>index1 <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
            nums1<span>[</span>indexMerge<span>--</span><span>]</span> <span>=</span> nums2<span>[</span>index2<span>--</span><span>]</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>index2 <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
            nums1<span>[</span>indexMerge<span>--</span><span>]</span> <span>=</span> nums1<span>[</span>index1<span>--</span><span>]</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>nums1<span>[</span>index1<span>]</span> <span>></span> nums2<span>[</span>index2<span>]</span><span>)</span> <span>{</span>
            nums1<span>[</span>indexMerge<span>--</span><span>]</span> <span>=</span> nums1<span>[</span>index1<span>--</span><span>]</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            nums1<span>[</span>indexMerge<span>--</span><span>]</span> <span>=</span> nums2<span>[</span>index2<span>--</span><span>]</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h1 id="_6-判断链表是否存在环" tabindex="-1"> 6. 判断链表是否存在环</h1>
<p><a href="https://leetcode.com/problems/linked-list-cycle/description/" target="_blank" rel="noopener noreferrer">141. Linked List Cycle (Easy)</a></p>
<p>使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>hasCycle</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>head <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
    <span>ListNode</span> l1 <span>=</span> head<span>,</span> l2 <span>=</span> head<span>.</span>next<span>;</span>
    <span>while</span> <span>(</span>l1 <span>!=</span> <span>null</span> <span>&amp;&amp;</span> l2 <span>!=</span> <span>null</span> <span>&amp;&amp;</span> l2<span>.</span>next <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>l1 <span>==</span> l2<span>)</span> <span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
        l1 <span>=</span> l1<span>.</span>next<span>;</span>
        l2 <span>=</span> l2<span>.</span>next<span>.</span>next<span>;</span>
    <span>}</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h1 id="_7-最长子序列" tabindex="-1"> 7. 最长子序列</h1>
<p><a href="https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/description/" target="_blank" rel="noopener noreferrer">524. Longest Word in Dictionary through Deleting (Medium)</a></p>
<div><pre><code>Input:
s = "abpcplea", d = ["ale","apple","monkey","plea"]

Output:
"apple"
</code></pre></div><p>题目描述：删除 s 中的一些字符，使得它构成字符串列表 d 中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。</p>
<p>通过删除字符串 s 中的一个字符能得到字符串 t，可以认为 t 是 s 的子序列，我们可以使用双指针来判断一个字符串是否为另一个字符串的子序列。</p>
<div><pre><code><span>public</span> <span>String</span> <span>findLongestWord</span><span>(</span><span>String</span> s<span>,</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> d<span>)</span> <span>{</span>
    <span>String</span> longestWord <span>=</span> <span>""</span><span>;</span>
    <span>for</span> <span>(</span><span>String</span> target <span>:</span> d<span>)</span> <span>{</span>
        <span>int</span> l1 <span>=</span> longestWord<span>.</span><span>length</span><span>(</span><span>)</span><span>,</span> l2 <span>=</span> target<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>l1 <span>></span> l2 <span>||</span> <span>(</span>l1 <span>==</span> l2 <span>&amp;&amp;</span> longestWord<span>.</span><span>compareTo</span><span>(</span>target<span>)</span> <span>&lt;</span> <span>0</span><span>)</span><span>)</span> <span>{</span>
            <span>continue</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span><span>isSubstr</span><span>(</span>s<span>,</span> target<span>)</span><span>)</span> <span>{</span>
            longestWord <span>=</span> target<span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> longestWord<span>;</span>
<span>}</span>

<span>private</span> <span>boolean</span> <span>isSubstr</span><span>(</span><span>String</span> s<span>,</span> <span>String</span> target<span>)</span> <span>{</span>
    <span>int</span> i <span>=</span> <span>0</span><span>,</span> j <span>=</span> <span>0</span><span>;</span>
    <span>while</span> <span>(</span>i <span>&lt;</span> s<span>.</span><span>length</span><span>(</span><span>)</span> <span>&amp;&amp;</span> j <span>&lt;</span> target<span>.</span><span>length</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>s<span>.</span><span>charAt</span><span>(</span>i<span>)</span> <span>==</span> target<span>.</span><span>charAt</span><span>(</span>j<span>)</span><span>)</span> <span>{</span>
            j<span>++</span><span>;</span>
        <span>}</span>
        i<span>++</span><span>;</span>
    <span>}</span>
    <span>return</span> j <span>==</span> target<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>1. 数组中两个数的和为给定值</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E5%93%88%E5%B8%8C%E8%A1%A8.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E5%93%88%E5%B8%8C%E8%A1%A8.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">1. 数组中两个数的和为给定值</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>哈希表使用 O(N) 空间复杂度存储数据，并且以 O(1) 时间复杂度求解问题。</p>
<ul>
<li>
<p>Java 中的  <strong>HashSet</strong>  用于存储一个集合，可以查找元素是否在集合中。如果元素有穷，并且范围不大，那么可以用一个布尔数组来存储一个元素是否存在。例如对于只有小写字符的元素，就可以用一个长度为 26 的布尔数组来存储一个字符集合，使得空间复杂度降低为 O(1)。</p>
</li>
<li>
<p>Java 中的  <strong>HashMap</strong>  主要用于映射关系，从而把两个元素联系起来。HashMap 也可以用来对元素进行计数统计，此时键为元素，值为计数。和 HashSet 类似，如果元素有穷并且范围不大，可以用整型数组来进行统计。在对一个内容进行压缩或者其它转换时，利用 HashMap 可以把原始内容和转换后的内容联系起来。例如在一个简化 url 的系统中 <a href="https://leetcode.com/problems/encode-and-decode-tinyurl/description/" target="_blank" rel="noopener noreferrer">Leetcdoe : 535. Encode and Decode TinyURL (Medium)</a>，利用 HashMap 就可以存储精简后的 url 到原始 url 的映射，使得不仅可以显示简化的 url，也可以根据简化的 url 得到原始 url 从而定位到正确的资源。</p>
</li>
</ul>
<h1 id="_1-数组中两个数的和为给定值" tabindex="-1"> 1. 数组中两个数的和为给定值</h1>
<p><a href="https://leetcode.com/problems/two-sum/description/" target="_blank" rel="noopener noreferrer">1. Two Sum (Easy)</a></p>
<p>可以先对数组进行排序，然后使用双指针方法或者二分查找方法。这样做的时间复杂度为 O(NlogN)，空间复杂度为 O(1)。</p>
<p>用 HashMap 存储数组元素和索引的映射，在访问到 nums[i] 时，判断 HashMap 中是否存在 target - nums[i]，如果存在说明 target - nums[i] 所在的索引和 i 就是要找的两个数。该方法的时间复杂度为 O(N)，空间复杂度为 O(N)，使用空间来换取时间。</p>
<div><pre><code><span>public</span> <span>int</span><span>[</span><span>]</span> <span>twoSum</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> target<span>)</span> <span>{</span>
    <span>HashMap</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Integer</span><span>></span></span> indexForNum <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>indexForNum<span>.</span><span>containsKey</span><span>(</span>target <span>-</span> nums<span>[</span>i<span>]</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span>indexForNum<span>.</span><span>get</span><span>(</span>target <span>-</span> nums<span>[</span>i<span>]</span><span>)</span><span>,</span> i<span>}</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            indexForNum<span>.</span><span>put</span><span>(</span>nums<span>[</span>i<span>]</span><span>,</span> i<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h1 id="_2-判断数组是否含有重复元素" tabindex="-1"> 2. 判断数组是否含有重复元素</h1>
<p><a href="https://leetcode.com/problems/contains-duplicate/description/" target="_blank" rel="noopener noreferrer">217. Contains Duplicate (Easy)</a></p>
<div><pre><code><span>public</span> <span>boolean</span> <span>containsDuplicate</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>Set</span><span><span>&lt;</span><span>Integer</span><span>></span></span> set <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
        set<span>.</span><span>add</span><span>(</span>num<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> set<span>.</span><span>size</span><span>(</span><span>)</span> <span>&lt;</span> nums<span>.</span>length<span>;</span>
<span>}</span>
</code></pre></div><h1 id="_3-最长和谐序列" tabindex="-1"> 3. 最长和谐序列</h1>
<p><a href="https://leetcode.com/problems/longest-harmonious-subsequence/description/" target="_blank" rel="noopener noreferrer">594. Longest Harmonious Subsequence (Easy)</a></p>
<div><pre><code>Input: [1,3,2,2,5,2,3,7]
Output: 5
Explanation: The longest harmonious subsequence is [3,2,2,2,3].
</code></pre></div><p>和谐序列中最大数和最小数之差正好为 1，应该注意的是序列的元素不一定是数组的连续元素。</p>
<div><pre><code><span>public</span> <span>int</span> <span>findLHS</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Integer</span><span>></span></span> countForNum <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
        countForNum<span>.</span><span>put</span><span>(</span>num<span>,</span> countForNum<span>.</span><span>getOrDefault</span><span>(</span>num<span>,</span> <span>0</span><span>)</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>
    <span>int</span> longest <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> num <span>:</span> countForNum<span>.</span><span>keySet</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>countForNum<span>.</span><span>containsKey</span><span>(</span>num <span>+</span> <span>1</span><span>)</span><span>)</span> <span>{</span>
            longest <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>longest<span>,</span> countForNum<span>.</span><span>get</span><span>(</span>num <span>+</span> <span>1</span><span>)</span> <span>+</span> countForNum<span>.</span><span>get</span><span>(</span>num<span>)</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> longest<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h1 id="_4-最长连续序列" tabindex="-1"> 4. 最长连续序列</h1>
<p><a href="https://leetcode.com/problems/longest-consecutive-sequence/description/" target="_blank" rel="noopener noreferrer">128. Longest Consecutive Sequence (Hard)</a></p>
<div><pre><code>Given [100, 4, 200, 1, 3, 2],
The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.
</code></pre></div><p>要求以 O(N) 的时间复杂度求解。</p>
<div><pre><code><span>public</span> <span>int</span> <span>longestConsecutive</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Integer</span><span>></span></span> countForNum <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
        countForNum<span>.</span><span>put</span><span>(</span>num<span>,</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
        <span>forward</span><span>(</span>countForNum<span>,</span> num<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>maxCount</span><span>(</span>countForNum<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>int</span> <span>forward</span><span>(</span><span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Integer</span><span>></span></span> countForNum<span>,</span> <span>int</span> num<span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>countForNum<span>.</span><span>containsKey</span><span>(</span>num<span>)</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>int</span> cnt <span>=</span> countForNum<span>.</span><span>get</span><span>(</span>num<span>)</span><span>;</span>
    <span>if</span> <span>(</span>cnt <span>></span> <span>1</span><span>)</span> <span>{</span>
        <span>return</span> cnt<span>;</span>
    <span>}</span>
    cnt <span>=</span> <span>forward</span><span>(</span>countForNum<span>,</span> num <span>+</span> <span>1</span><span>)</span> <span>+</span> <span>1</span><span>;</span>
    countForNum<span>.</span><span>put</span><span>(</span>num<span>,</span> cnt<span>)</span><span>;</span>
    <span>return</span> cnt<span>;</span>
<span>}</span>

<span>private</span> <span>int</span> <span>maxCount</span><span>(</span><span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Integer</span><span>></span></span> countForNum<span>)</span> <span>{</span>
    <span>int</span> max <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> num <span>:</span> countForNum<span>.</span><span>keySet</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        max <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>max<span>,</span> countForNum<span>.</span><span>get</span><span>(</span>num<span>)</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> max<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>二分图</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E5%9B%BE.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E5%9B%BE.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">二分图</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
</ul>

<h1 id="二分图" tabindex="-1"> 二分图</h1>
<p>如果可以用两种颜色对图中的节点进行着色，并且保证相邻的节点颜色不同，那么这个图就是二分图。</p>
<h2 id="_1-判断是否为二分图" tabindex="-1"> 1. 判断是否为二分图</h2>
<p><a href="https://leetcode.com/problems/is-graph-bipartite/description/" target="_blank" rel="noopener noreferrer">785. Is Graph Bipartite? (Medium)</a></p>
<div><pre><code>Input: [[1,3], [0,2], [1,3], [0,2]]
Output: true
Explanation:
The graph looks like this:
0----1
|    |
|    |
3----2
We can divide the vertices into two groups: {0, 2} and {1, 3}.
</code></pre></div><div><pre><code>Example 2:
Input: [[1,2,3], [0,2], [0,1,3], [0,2]]
Output: false
Explanation:
The graph looks like this:
0----1
| \  |
|  \ |
3----2
We cannot find a way to divide the set of nodes into two independent subsets.
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>public</span> <span>boolean</span> <span>isBipartite</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> graph<span>)</span> <span>{</span>
    <span>int</span><span>[</span><span>]</span> colors <span>=</span> <span>new</span> <span>int</span><span>[</span>graph<span>.</span>length<span>]</span><span>;</span>
    <span>Arrays</span><span>.</span><span>fill</span><span>(</span>colors<span>,</span> <span>-</span><span>1</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> graph<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>  <span>// 处理图不是连通的情况</span>
        <span>if</span> <span>(</span>colors<span>[</span>i<span>]</span> <span>==</span> <span>-</span><span>1</span> <span>&amp;&amp;</span> <span>!</span><span>isBipartite</span><span>(</span>i<span>,</span> <span>0</span><span>,</span> colors<span>,</span> graph<span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>true</span><span>;</span>
<span>}</span>

<span>private</span> <span>boolean</span> <span>isBipartite</span><span>(</span><span>int</span> curNode<span>,</span> <span>int</span> curColor<span>,</span> <span>int</span><span>[</span><span>]</span> colors<span>,</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> graph<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>colors<span>[</span>curNode<span>]</span> <span>!=</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
        <span>return</span> colors<span>[</span>curNode<span>]</span> <span>==</span> curColor<span>;</span>
    <span>}</span>
    colors<span>[</span>curNode<span>]</span> <span>=</span> curColor<span>;</span>
    <span>for</span> <span>(</span><span>int</span> nextNode <span>:</span> graph<span>[</span>curNode<span>]</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span><span>isBipartite</span><span>(</span>nextNode<span>,</span> <span>1</span> <span>-</span> curColor<span>,</span> colors<span>,</span> graph<span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>true</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h1 id="拓扑排序" tabindex="-1"> 拓扑排序</h1>
<p>常用于在具有先序关系的任务规划中。</p>
<h2 id="_1-课程安排的合法性" tabindex="-1"> 1. 课程安排的合法性</h2>
<p><a href="https://leetcode.com/problems/course-schedule/description/" target="_blank" rel="noopener noreferrer">207. Course Schedule (Medium)</a></p>
<div><pre><code>2, [[1,0]]
return true
</code></pre></div><div><pre><code>2, [[1,0],[0,1]]
return false
</code></pre></div><p>题目描述：一个课程可能会先修课程，判断给定的先修课程规定是否合法。</p>
<p>本题不需要使用拓扑排序，只需要检测有向图是否存在环即可。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>canFinish</span><span>(</span><span>int</span> numCourses<span>,</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> prerequisites<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>[</span><span>]</span> graphic <span>=</span> <span>new</span> <span>List</span><span>[</span>numCourses<span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> numCourses<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        graphic<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span><span>[</span><span>]</span> pre <span>:</span> prerequisites<span>)</span> <span>{</span>
        graphic<span>[</span>pre<span>[</span><span>0</span><span>]</span><span>]</span><span>.</span><span>add</span><span>(</span>pre<span>[</span><span>1</span><span>]</span><span>)</span><span>;</span>
    <span>}</span>
    <span>boolean</span><span>[</span><span>]</span> globalMarked <span>=</span> <span>new</span> <span>boolean</span><span>[</span>numCourses<span>]</span><span>;</span>
    <span>boolean</span><span>[</span><span>]</span> localMarked <span>=</span> <span>new</span> <span>boolean</span><span>[</span>numCourses<span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> numCourses<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>hasCycle</span><span>(</span>globalMarked<span>,</span> localMarked<span>,</span> graphic<span>,</span> i<span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>true</span><span>;</span>
<span>}</span>

<span>private</span> <span>boolean</span> <span>hasCycle</span><span>(</span><span>boolean</span><span>[</span><span>]</span> globalMarked<span>,</span> <span>boolean</span><span>[</span><span>]</span> localMarked<span>,</span>
                         <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>[</span><span>]</span> graphic<span>,</span> <span>int</span> curNode<span>)</span> <span>{</span>

    <span>if</span> <span>(</span>localMarked<span>[</span>curNode<span>]</span><span>)</span> <span>{</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>globalMarked<span>[</span>curNode<span>]</span><span>)</span> <span>{</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
    globalMarked<span>[</span>curNode<span>]</span> <span>=</span> <span>true</span><span>;</span>
    localMarked<span>[</span>curNode<span>]</span> <span>=</span> <span>true</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> nextNode <span>:</span> graphic<span>[</span>curNode<span>]</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>hasCycle</span><span>(</span>globalMarked<span>,</span> localMarked<span>,</span> graphic<span>,</span> nextNode<span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
    <span>}</span>
    localMarked<span>[</span>curNode<span>]</span> <span>=</span> <span>false</span><span>;</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><h2 id="_2-课程安排的顺序" tabindex="-1"> 2. 课程安排的顺序</h2>
<p><a href="https://leetcode.com/problems/course-schedule-ii/description/" target="_blank" rel="noopener noreferrer">210. Course Schedule II (Medium)</a></p>
<div><pre><code>4, [[1,0],[2,0],[3,1],[3,2]]
There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].
</code></pre></div><p>使用 DFS 来实现拓扑排序，使用一个栈存储后序遍历结果，这个栈的逆序结果就是拓扑排序结果。</p>
<p>证明：对于任何先序关系：v-&gt;w，后序遍历结果可以保证 w 先进入栈中，因此栈的逆序结果中 v 会在 w 之前。</p>
<div><pre><code><span>public</span> <span>int</span><span>[</span><span>]</span> <span>findOrder</span><span>(</span><span>int</span> numCourses<span>,</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> prerequisites<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>[</span><span>]</span> graphic <span>=</span> <span>new</span> <span>List</span><span>[</span>numCourses<span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> numCourses<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        graphic<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span><span>[</span><span>]</span> pre <span>:</span> prerequisites<span>)</span> <span>{</span>
        graphic<span>[</span>pre<span>[</span><span>0</span><span>]</span><span>]</span><span>.</span><span>add</span><span>(</span>pre<span>[</span><span>1</span><span>]</span><span>)</span><span>;</span>
    <span>}</span>
    <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> postOrder <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>boolean</span><span>[</span><span>]</span> globalMarked <span>=</span> <span>new</span> <span>boolean</span><span>[</span>numCourses<span>]</span><span>;</span>
    <span>boolean</span><span>[</span><span>]</span> localMarked <span>=</span> <span>new</span> <span>boolean</span><span>[</span>numCourses<span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> numCourses<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>hasCycle</span><span>(</span>globalMarked<span>,</span> localMarked<span>,</span> graphic<span>,</span> i<span>,</span> postOrder<span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>int</span><span>[</span><span>0</span><span>]</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>int</span><span>[</span><span>]</span> orders <span>=</span> <span>new</span> <span>int</span><span>[</span>numCourses<span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> numCourses <span>-</span> <span>1</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span> <span>{</span>
        orders<span>[</span>i<span>]</span> <span>=</span> postOrder<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> orders<span>;</span>
<span>}</span>

<span>private</span> <span>boolean</span> <span>hasCycle</span><span>(</span><span>boolean</span><span>[</span><span>]</span> globalMarked<span>,</span> <span>boolean</span><span>[</span><span>]</span> localMarked<span>,</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>[</span><span>]</span> graphic<span>,</span>
                         <span>int</span> curNode<span>,</span> <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> postOrder<span>)</span> <span>{</span>

    <span>if</span> <span>(</span>localMarked<span>[</span>curNode<span>]</span><span>)</span> <span>{</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>globalMarked<span>[</span>curNode<span>]</span><span>)</span> <span>{</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
    globalMarked<span>[</span>curNode<span>]</span> <span>=</span> <span>true</span><span>;</span>
    localMarked<span>[</span>curNode<span>]</span> <span>=</span> <span>true</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> nextNode <span>:</span> graphic<span>[</span>curNode<span>]</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>hasCycle</span><span>(</span>globalMarked<span>,</span> localMarked<span>,</span> graphic<span>,</span> nextNode<span>,</span> postOrder<span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
    <span>}</span>
    localMarked<span>[</span>curNode<span>]</span> <span>=</span> <span>false</span><span>;</span>
    postOrder<span>.</span><span>push</span><span>(</span>curNode<span>)</span><span>;</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><h1 id="并查集" tabindex="-1"> 并查集</h1>
<p>并查集可以动态地连通两个点，并且可以非常快速地判断两个点是否连通。</p>
<h2 id="_1-冗余连接" tabindex="-1"> 1. 冗余连接</h2>
<p><a href="https://leetcode.com/problems/redundant-connection/description/" target="_blank" rel="noopener noreferrer">684. Redundant Connection (Medium)</a></p>
<div><pre><code>Input: [[1,2], [1,3], [2,3]]
Output: [2,3]
Explanation: The given undirected graph will be like this:
  1
 / \
2 - 3
</code></pre></div><p>题目描述：有一系列的边连成的图，找出一条边，移除它之后该图能够成为一棵树。</p>
<div><pre><code><span>public</span> <span>int</span><span>[</span><span>]</span> <span>findRedundantConnection</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> edges<span>)</span> <span>{</span>
    <span>int</span> <span>N</span> <span>=</span> edges<span>.</span>length<span>;</span>
    <span>UF</span> uf <span>=</span> <span>new</span> <span>UF</span><span>(</span><span>N</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span><span>[</span><span>]</span> e <span>:</span> edges<span>)</span> <span>{</span>
        <span>int</span> u <span>=</span> e<span>[</span><span>0</span><span>]</span><span>,</span> v <span>=</span> e<span>[</span><span>1</span><span>]</span><span>;</span>
        <span>if</span> <span>(</span>uf<span>.</span><span>connect</span><span>(</span>u<span>,</span> v<span>)</span><span>)</span> <span>{</span>
            <span>return</span> e<span>;</span>
        <span>}</span>
        uf<span>.</span><span>union</span><span>(</span>u<span>,</span> v<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span><span>-</span><span>1</span><span>,</span> <span>-</span><span>1</span><span>}</span><span>;</span>
<span>}</span>

<span>private</span> <span>class</span> <span>UF</span> <span>{</span>

    <span>private</span> <span>int</span><span>[</span><span>]</span> id<span>;</span>

    <span>UF</span><span>(</span><span>int</span> <span>N</span><span>)</span> <span>{</span>
        id <span>=</span> <span>new</span> <span>int</span><span>[</span><span>N</span> <span>+</span> <span>1</span><span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> id<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            id<span>[</span>i<span>]</span> <span>=</span> i<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>void</span> <span>union</span><span>(</span><span>int</span> u<span>,</span> <span>int</span> v<span>)</span> <span>{</span>
        <span>int</span> uID <span>=</span> <span>find</span><span>(</span>u<span>)</span><span>;</span>
        <span>int</span> vID <span>=</span> <span>find</span><span>(</span>v<span>)</span><span>;</span>
        <span>if</span> <span>(</span>uID <span>==</span> vID<span>)</span> <span>{</span>
            <span>return</span><span>;</span>
        <span>}</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> id<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>id<span>[</span>i<span>]</span> <span>==</span> uID<span>)</span> <span>{</span>
                id<span>[</span>i<span>]</span> <span>=</span> vID<span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>int</span> <span>find</span><span>(</span><span>int</span> p<span>)</span> <span>{</span>
        <span>return</span> id<span>[</span>p<span>]</span><span>;</span>
    <span>}</span>

    <span>boolean</span> <span>connect</span><span>(</span><span>int</span> u<span>,</span> <span>int</span> v<span>)</span> <span>{</span>
        <span>return</span> <span>find</span><span>(</span>u<span>)</span> <span>==</span> <span>find</span><span>(</span>v<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>1. 字符串循环移位包含</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E5%AD%97%E7%AC%A6%E4%B8%B2.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E5%AD%97%E7%AC%A6%E4%B8%B2.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">1. 字符串循环移位包含</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<h1 id="_1-字符串循环移位包含" tabindex="-1"> 1. 字符串循环移位包含</h1>
<p></p>
<div><pre><code>s1 = AABCD, s2 = CDAA
Return : true
</code></pre></div><p>给定两个字符串 s1 和 s2，要求判定 s2 是否能够被 s1 做循环移位得到的字符串包含。</p>
<p>s1 进行循环移位的结果是 s1s1 的子字符串，因此只要判断 s2 是否是 s1s1 的子字符串即可。</p>
<h1 id="_2-字符串循环移位" tabindex="-1"> 2. 字符串循环移位</h1>
<p></p>
<div><pre><code>s = "abcd123" k = 3
Return "123abcd"
</code></pre></div><p>将字符串向右循环移动 k 位。</p>
<p>将 abcd123 中的 abcd 和 123 单独翻转，得到 dcba321，然后对整个字符串进行翻转，得到 123abcd。</p>
<h1 id="_3-字符串中单词的翻转" tabindex="-1"> 3. 字符串中单词的翻转</h1>
<p></p>
<div><pre><code>s = "I am a student"
Return "student a am I"
</code></pre></div><p>将每个单词翻转，然后将整个字符串翻转。</p>
<h1 id="_4-两个字符串包含的字符是否完全相同" tabindex="-1"> 4. 两个字符串包含的字符是否完全相同</h1>
<p><a href="https://leetcode.com/problems/valid-anagram/description/" target="_blank" rel="noopener noreferrer">242. Valid Anagram (Easy)</a></p>
<div><pre><code>s = "anagram", t = "nagaram", return true.
s = "rat", t = "car", return false.
</code></pre></div><p>可以用 HashMap 来映射字符与出现次数，然后比较两个字符串出现的字符数量是否相同。</p>
<p>由于本题的字符串只包含 26 个小写字符，因此可以使用长度为 26 的整型数组对字符串出现的字符进行统计，不再使用 HashMap。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>isAnagram</span><span>(</span><span>String</span> s<span>,</span> <span>String</span> t<span>)</span> <span>{</span>
    <span>int</span><span>[</span><span>]</span> cnts <span>=</span> <span>new</span> <span>int</span><span>[</span><span>26</span><span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>char</span> c <span>:</span> s<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        cnts<span>[</span>c <span>-</span> <span>'a'</span><span>]</span><span>++</span><span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>char</span> c <span>:</span> t<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        cnts<span>[</span>c <span>-</span> <span>'a'</span><span>]</span><span>--</span><span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> cnt <span>:</span> cnts<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>cnt <span>!=</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>true</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h1 id="_5-计算一组字符集合可以组成的回文字符串的最大长度" tabindex="-1"> 5. 计算一组字符集合可以组成的回文字符串的最大长度</h1>
<p><a href="https://leetcode.com/problems/longest-palindrome/description/" target="_blank" rel="noopener noreferrer">409. Longest Palindrome (Easy)</a></p>
<div><pre><code>Input : "abccccdd"
Output : 7
Explanation : One longest palindrome that can be built is "dccaccd", whose length is 7.
</code></pre></div><p>使用长度为 256 的整型数组来统计每个字符出现的个数，每个字符有偶数个可以用来构成回文字符串。</p>
<p>因为回文字符串最中间的那个字符可以单独出现，所以如果有单独的字符就把它放到最中间。</p>
<div><pre><code><span>public</span> <span>int</span> <span>longestPalindrome</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
    <span>int</span><span>[</span><span>]</span> cnts <span>=</span> <span>new</span> <span>int</span><span>[</span><span>256</span><span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>char</span> c <span>:</span> s<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        cnts<span>[</span>c<span>]</span><span>++</span><span>;</span>
    <span>}</span>
    <span>int</span> palindrome <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> cnt <span>:</span> cnts<span>)</span> <span>{</span>
        palindrome <span>+=</span> <span>(</span>cnt <span>/</span> <span>2</span><span>)</span> <span>*</span> <span>2</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>palindrome <span>&lt;</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        palindrome<span>++</span><span>;</span>   <span>// 这个条件下 s 中一定有单个未使用的字符存在，可以把这个字符放到回文的最中间</span>
    <span>}</span>
    <span>return</span> palindrome<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h1 id="_6-字符串同构" tabindex="-1"> 6. 字符串同构</h1>
<p><a href="https://leetcode.com/problems/isomorphic-strings/description/" target="_blank" rel="noopener noreferrer">205. Isomorphic Strings (Easy)</a></p>
<div><pre><code>Given "egg", "add", return true.
Given "foo", "bar", return false.
Given "paper", "title", return true.
</code></pre></div><p>记录一个字符上次出现的位置，如果两个字符串中的字符上次出现的位置一样，那么就属于同构。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>isIsomorphic</span><span>(</span><span>String</span> s<span>,</span> <span>String</span> t<span>)</span> <span>{</span>
    <span>int</span><span>[</span><span>]</span> preIndexOfS <span>=</span> <span>new</span> <span>int</span><span>[</span><span>256</span><span>]</span><span>;</span>
    <span>int</span><span>[</span><span>]</span> preIndexOfT <span>=</span> <span>new</span> <span>int</span><span>[</span><span>256</span><span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>char</span> sc <span>=</span> s<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>,</span> tc <span>=</span> t<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>;</span>
        <span>if</span> <span>(</span>preIndexOfS<span>[</span>sc<span>]</span> <span>!=</span> preIndexOfT<span>[</span>tc<span>]</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
        preIndexOfS<span>[</span>sc<span>]</span> <span>=</span> i <span>+</span> <span>1</span><span>;</span>
        preIndexOfT<span>[</span>tc<span>]</span> <span>=</span> i <span>+</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>true</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h1 id="_7-回文子字符串个数" tabindex="-1"> 7. 回文子字符串个数</h1>
<p><a href="https://leetcode.com/problems/palindromic-substrings/description/" target="_blank" rel="noopener noreferrer">647. Palindromic Substrings (Medium)</a></p>
<div><pre><code>Input: "aaa"
Output: 6
Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".
</code></pre></div><p>从字符串的某一位开始，尝试着去扩展子字符串。</p>
<div><pre><code><span>private</span> <span>int</span> cnt <span>=</span> <span>0</span><span>;</span>

<span>public</span> <span>int</span> <span>countSubstrings</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>extendSubstrings</span><span>(</span>s<span>,</span> i<span>,</span> i<span>)</span><span>;</span>     <span>// 奇数长度</span>
        <span>extendSubstrings</span><span>(</span>s<span>,</span> i<span>,</span> i <span>+</span> <span>1</span><span>)</span><span>;</span> <span>// 偶数长度</span>
    <span>}</span>
    <span>return</span> cnt<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>extendSubstrings</span><span>(</span><span>String</span> s<span>,</span> <span>int</span> start<span>,</span> <span>int</span> end<span>)</span> <span>{</span>
    <span>while</span> <span>(</span>start <span>>=</span> <span>0</span> <span>&amp;&amp;</span> end <span>&lt;</span> s<span>.</span><span>length</span><span>(</span><span>)</span> <span>&amp;&amp;</span> s<span>.</span><span>charAt</span><span>(</span>start<span>)</span> <span>==</span> s<span>.</span><span>charAt</span><span>(</span>end<span>)</span><span>)</span> <span>{</span>
        start<span>--</span><span>;</span>
        end<span>++</span><span>;</span>
        cnt<span>++</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h1 id="_8-判断一个整数是否是回文数" tabindex="-1"> 8. 判断一个整数是否是回文数</h1>
<p><a href="https://leetcode.com/problems/palindrome-number/description/" target="_blank" rel="noopener noreferrer">9. Palindrome Number (Easy)</a></p>
<p>要求不能使用额外空间，也就不能将整数转换为字符串进行判断。</p>
<p>将整数分成左右两部分，右边那部分需要转置，然后判断这两部分是否相等。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>isPalindrome</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>x <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>x <span>&lt;</span> <span>0</span> <span>||</span> x <span>%</span> <span>10</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
    <span>int</span> right <span>=</span> <span>0</span><span>;</span>
    <span>while</span> <span>(</span>x <span>></span> right<span>)</span> <span>{</span>
        right <span>=</span> right <span>*</span> <span>10</span> <span>+</span> x <span>%</span> <span>10</span><span>;</span>
        x <span>/=</span> <span>10</span><span>;</span>
    <span>}</span>
    <span>return</span> x <span>==</span> right <span>||</span> x <span>==</span> right <span>/</span> <span>10</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h1 id="_9-统计二进制字符串中连续-1-和连续-0-数量相同的子字符串个数" tabindex="-1"> 9. 统计二进制字符串中连续 1 和连续 0 数量相同的子字符串个数</h1>
<p><a href="https://leetcode.com/problems/count-binary-substrings/description/" target="_blank" rel="noopener noreferrer">696. Count Binary Substrings (Easy)</a></p>
<div><pre><code>Input: "00110011"
Output: 6
Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "01", "1100", "10", "0011", and "01".
</code></pre></div><div><pre><code><span>public</span> <span>int</span> <span>countBinarySubstrings</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
    <span>int</span> preLen <span>=</span> <span>0</span><span>,</span> curLen <span>=</span> <span>1</span><span>,</span> count <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>s<span>.</span><span>charAt</span><span>(</span>i<span>)</span> <span>==</span> s<span>.</span><span>charAt</span><span>(</span>i <span>-</span> <span>1</span><span>)</span><span>)</span> <span>{</span>
            curLen<span>++</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            preLen <span>=</span> curLen<span>;</span>
            curLen <span>=</span> <span>1</span><span>;</span>
        <span>}</span>

        <span>if</span> <span>(</span>preLen <span>>=</span> curLen<span>)</span> <span>{</span>
            count<span>++</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> count<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>快速选择</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E6%8E%92%E5%BA%8F.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E6%8E%92%E5%BA%8F.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">快速选择</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
</ul>

<h1 id="快速选择" tabindex="-1"> 快速选择</h1>
<p>用于求解  <strong>Kth Element</strong>  问题，也就是第 K 个元素的问题。</p>
<p>可以使用快速排序的 partition() 进行实现。需要先打乱数组，否则最坏情况下时间复杂度为 O(N<sup>2</sup>)。</p>
<h1 id="堆" tabindex="-1"> 堆</h1>
<p>用于求解  <strong>TopK Elements</strong>  问题，也就是 K 个最小元素的问题。可以维护一个大小为 K 的最小堆，最小堆中的元素就是最小元素。最小堆需要使用大顶堆来实现，大顶堆表示堆顶元素是堆中最大元素。这是因为我们要得到 k 个最小的元素，因此当遍历到一个新的元素时，需要知道这个新元素是否比堆中最大的元素更小，更小的话就把堆中最大元素去除，并将新元素添加到堆中。所以我们需要很容易得到最大元素并移除最大元素，大顶堆就能很好满足这个要求。</p>
<p>堆也可以用于求解 Kth Element 问题，得到了大小为 k 的最小堆之后，因为使用了大顶堆来实现，因此堆顶元素就是第 k 大的元素。</p>
<p>快速选择也可以求解 TopK Elements 问题，因为找到 Kth Element 之后，再遍历一次数组，所有小于等于 Kth Element 的元素都是 TopK Elements。</p>
<p>可以看到，快速选择和堆排序都可以求解 Kth Element 和 TopK Elements 问题。</p>
<h2 id="_1-kth-element" tabindex="-1"> 1. Kth Element</h2>
<p><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/" target="_blank" rel="noopener noreferrer">215. Kth Largest Element in an Array (Medium)</a></p>
<div><pre><code>Input: [3,2,1,5,6,4] and k = 2
Output: 5
</code></pre></div><p>题目描述：找到倒数第 k 个的元素。</p>
<p><strong>排序</strong> ：时间复杂度 O(NlogN)，空间复杂度 O(1)</p>
<div><pre><code><span>public</span> <span>int</span> <span>findKthLargest</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
    <span>Arrays</span><span>.</span><span>sort</span><span>(</span>nums<span>)</span><span>;</span>
    <span>return</span> nums<span>[</span>nums<span>.</span>length <span>-</span> k<span>]</span><span>;</span>
<span>}</span>
</code></pre></div><p><strong>堆</strong> ：时间复杂度 O(NlogK)，空间复杂度 O(K)。</p>
<div><pre><code><span>public</span> <span>int</span> <span>findKthLargest</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
    <span>PriorityQueue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> pq <span>=</span> <span>new</span> <span>PriorityQueue</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span> <span>// 小顶堆</span>
    <span>for</span> <span>(</span><span>int</span> val <span>:</span> nums<span>)</span> <span>{</span>
        pq<span>.</span><span>add</span><span>(</span>val<span>)</span><span>;</span>
        <span>if</span> <span>(</span>pq<span>.</span><span>size</span><span>(</span><span>)</span> <span>></span> k<span>)</span>  <span>// 维护堆的大小为 K</span>
            pq<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> pq<span>.</span><span>peek</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><p><strong>快速选择</strong> ：时间复杂度 O(N)，空间复杂度 O(1)</p>
<div><pre><code><span>public</span> <span>int</span> <span>findKthLargest</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
    k <span>=</span> nums<span>.</span>length <span>-</span> k<span>;</span>
    <span>int</span> l <span>=</span> <span>0</span><span>,</span> h <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span>l <span>&lt;</span> h<span>)</span> <span>{</span>
        <span>int</span> j <span>=</span> <span>partition</span><span>(</span>nums<span>,</span> l<span>,</span> h<span>)</span><span>;</span>
        <span>if</span> <span>(</span>j <span>==</span> k<span>)</span> <span>{</span>
            <span>break</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>j <span>&lt;</span> k<span>)</span> <span>{</span>
            l <span>=</span> j <span>+</span> <span>1</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            h <span>=</span> j <span>-</span> <span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> nums<span>[</span>k<span>]</span><span>;</span>
<span>}</span>

<span>private</span> <span>int</span> <span>partition</span><span>(</span><span>int</span><span>[</span><span>]</span> a<span>,</span> <span>int</span> l<span>,</span> <span>int</span> h<span>)</span> <span>{</span>
    <span>int</span> i <span>=</span> l<span>,</span> j <span>=</span> h <span>+</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
        <span>while</span> <span>(</span>a<span>[</span><span>++</span>i<span>]</span> <span>&lt;</span> a<span>[</span>l<span>]</span> <span>&amp;&amp;</span> i <span>&lt;</span> h<span>)</span> <span>;</span>
        <span>while</span> <span>(</span>a<span>[</span><span>--</span>j<span>]</span> <span>></span> a<span>[</span>l<span>]</span> <span>&amp;&amp;</span> j <span>></span> l<span>)</span> <span>;</span>
        <span>if</span> <span>(</span>i <span>>=</span> j<span>)</span> <span>{</span>
            <span>break</span><span>;</span>
        <span>}</span>
        <span>swap</span><span>(</span>a<span>,</span> i<span>,</span> j<span>)</span><span>;</span>
    <span>}</span>
    <span>swap</span><span>(</span>a<span>,</span> l<span>,</span> j<span>)</span><span>;</span>
    <span>return</span> j<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> a<span>,</span> <span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>
    <span>int</span> t <span>=</span> a<span>[</span>i<span>]</span><span>;</span>
    a<span>[</span>i<span>]</span> <span>=</span> a<span>[</span>j<span>]</span><span>;</span>
    a<span>[</span>j<span>]</span> <span>=</span> t<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><h1 id="桶排序" tabindex="-1"> 桶排序</h1>
<h2 id="_1-出现频率最多的-k-个元素" tabindex="-1"> 1. 出现频率最多的 k 个元素</h2>
<p><a href="https://leetcode.com/problems/top-k-frequent-elements/description/" target="_blank" rel="noopener noreferrer">347. Top K Frequent Elements (Medium)</a></p>
<div><pre><code>Given [1,1,1,2,2,3] and k = 2, return [1,2].
</code></pre></div><p>设置若干个桶，每个桶存储出现频率相同的数。桶的下标表示数出现的频率，即第 i 个桶中存储的数出现的频率为 i。</p>
<p>把数都放到桶之后，从后向前遍历桶，最先得到的 k 个数就是出现频率最多的的 k 个数。</p>
<div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>topKFrequent</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
    <span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Integer</span><span>></span></span> frequencyForNum <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
        frequencyForNum<span>.</span><span>put</span><span>(</span>num<span>,</span> frequencyForNum<span>.</span><span>getOrDefault</span><span>(</span>num<span>,</span> <span>0</span><span>)</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>
    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>[</span><span>]</span> buckets <span>=</span> <span>new</span> <span>ArrayList</span><span>[</span>nums<span>.</span>length <span>+</span> <span>1</span><span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> key <span>:</span> frequencyForNum<span>.</span><span>keySet</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>int</span> frequency <span>=</span> frequencyForNum<span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>
        <span>if</span> <span>(</span>buckets<span>[</span>frequency<span>]</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
            buckets<span>[</span>frequency<span>]</span> <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        buckets<span>[</span>frequency<span>]</span><span>.</span><span>add</span><span>(</span>key<span>)</span><span>;</span>
    <span>}</span>
    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> topK <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> buckets<span>.</span>length <span>-</span> <span>1</span><span>;</span> i <span>>=</span> <span>0</span> <span>&amp;&amp;</span> topK<span>.</span><span>size</span><span>(</span><span>)</span> <span>&lt;</span> k<span>;</span> i<span>--</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>buckets<span>[</span>i<span>]</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>continue</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>buckets<span>[</span>i<span>]</span><span>.</span><span>size</span><span>(</span><span>)</span> <span>&lt;=</span> <span>(</span>k <span>-</span> topK<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>
            topK<span>.</span><span>addAll</span><span>(</span>buckets<span>[</span>i<span>]</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            topK<span>.</span><span>addAll</span><span>(</span>buckets<span>[</span>i<span>]</span><span>.</span><span>subList</span><span>(</span><span>0</span><span>,</span> k <span>-</span> topK<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> topK<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h2 id="_2-按照字符出现次数对字符串排序" tabindex="-1"> 2. 按照字符出现次数对字符串排序</h2>
<p><a href="https://leetcode.com/problems/sort-characters-by-frequency/description/" target="_blank" rel="noopener noreferrer">451. Sort Characters By Frequency (Medium)</a></p>
<div><pre><code>Input:
"tree"

Output:
"eert"

Explanation:
'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.
</code></pre></div><div><pre><code><span>public</span> <span>String</span> <span>frequencySort</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
    <span>Map</span><span><span>&lt;</span><span>Character</span><span>,</span> <span>Integer</span><span>></span></span> frequencyForNum <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>char</span> c <span>:</span> s<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>)</span>
        frequencyForNum<span>.</span><span>put</span><span>(</span>c<span>,</span> frequencyForNum<span>.</span><span>getOrDefault</span><span>(</span>c<span>,</span> <span>0</span><span>)</span> <span>+</span> <span>1</span><span>)</span><span>;</span>

    <span>List</span><span><span>&lt;</span><span>Character</span><span>></span></span><span>[</span><span>]</span> frequencyBucket <span>=</span> <span>new</span> <span>ArrayList</span><span>[</span>s<span>.</span><span>length</span><span>(</span><span>)</span> <span>+</span> <span>1</span><span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>char</span> c <span>:</span> frequencyForNum<span>.</span><span>keySet</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>int</span> f <span>=</span> frequencyForNum<span>.</span><span>get</span><span>(</span>c<span>)</span><span>;</span>
        <span>if</span> <span>(</span>frequencyBucket<span>[</span>f<span>]</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
            frequencyBucket<span>[</span>f<span>]</span> <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        frequencyBucket<span>[</span>f<span>]</span><span>.</span><span>add</span><span>(</span>c<span>)</span><span>;</span>
    <span>}</span>
    <span>StringBuilder</span> str <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> frequencyBucket<span>.</span>length <span>-</span> <span>1</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>frequencyBucket<span>[</span>i<span>]</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>continue</span><span>;</span>
        <span>}</span>
        <span>for</span> <span>(</span><span>char</span> c <span>:</span> frequencyBucket<span>[</span>i<span>]</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> i<span>;</span> j<span>++</span><span>)</span> <span>{</span>
                str<span>.</span><span>append</span><span>(</span>c<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> str<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h1 id="荷兰国旗问题" tabindex="-1"> 荷兰国旗问题</h1>
<p>荷兰国旗包含三种颜色：红、白、蓝。</p>
<p>有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7a3215ec-6fb7-4935-8b0d-cb408208f7cb.png"/> </div><br>
<h2 id="_1-按颜色进行排序" tabindex="-1"> 1. 按颜色进行排序</h2>
<p><a href="https://leetcode.com/problems/sort-colors/description/" target="_blank" rel="noopener noreferrer">75. Sort Colors (Medium)</a></p>
<div><pre><code>Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
</code></pre></div><p>题目描述：只有 0/1/2 三种颜色。</p>
<div><pre><code><span>public</span> <span>void</span> <span>sortColors</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>int</span> zero <span>=</span> <span>-</span><span>1</span><span>,</span> one <span>=</span> <span>0</span><span>,</span> two <span>=</span> nums<span>.</span>length<span>;</span>
    <span>while</span> <span>(</span>one <span>&lt;</span> two<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>nums<span>[</span>one<span>]</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>swap</span><span>(</span>nums<span>,</span> <span>++</span>zero<span>,</span> one<span>++</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>nums<span>[</span>one<span>]</span> <span>==</span> <span>2</span><span>)</span> <span>{</span>
            <span>swap</span><span>(</span>nums<span>,</span> <span>--</span>two<span>,</span> one<span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>++</span>one<span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>private</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>
    <span>int</span> t <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
    nums<span>[</span>i<span>]</span> <span>=</span> nums<span>[</span>j<span>]</span><span>;</span>
    nums<span>[</span>j<span>]</span> <span>=</span> t<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>BFS</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E6%90%9C%E7%B4%A2.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E6%90%9C%E7%B4%A2.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">BFS</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>

<p>深度优先搜索和广度优先搜索广泛运用于树和图中，但是它们的应用远远不止如此。</p>
<h1 id="bfs" tabindex="-1"> BFS</h1>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/95903878-725b-4ed9-bded-bc4aae0792a9.jpg"/> </div><br>
<p>广度优先搜索一层一层地进行遍历，每层遍历都以上一层遍历的结果作为起点，遍历一个距离能访问到的所有节点。需要注意的是，遍历过的节点不能再次被遍历。</p>
<p>第一层：</p>
<ul>
<li>0 -&gt; {6,2,1,5}</li>
</ul>
<p>第二层：</p>
<ul>
<li>6 -&gt; {4}</li>
<li>2 -&gt; {}</li>
<li>1 -&gt; {}</li>
<li>5 -&gt; {3}</li>
</ul>
<p>第三层：</p>
<ul>
<li>4 -&gt; {}</li>
<li>3 -&gt; {}</li>
</ul>
<p>每一层遍历的节点都与根节点距离相同。设 d<sub>i</sub> 表示第 i 个节点与根节点的距离，推导出一个结论：对于先遍历的节点 i 与后遍历的节点 j，有 d<sub>i</sub> &lt;= d<sub>j</sub>。利用这个结论，可以求解最短路径等  <strong>最优解</strong>  问题：第一次遍历到目的节点，其所经过的路径为最短路径。应该注意的是，使用 BFS 只能求解无权图的最短路径，无权图是指从一个节点到另一个节点的代价都记为 1。</p>
<p>在程序实现 BFS 时需要考虑以下问题：</p>
<ul>
<li>队列：用来存储每一轮遍历得到的节点；</li>
<li>标记：对于遍历过的节点，应该将它标记，防止重复遍历。</li>
</ul>
<h2 id="_1-计算在网格中从原点到特定点的最短路径长度" tabindex="-1"> 1. 计算在网格中从原点到特定点的最短路径长度</h2>
<div><pre><code>[[1,1,0,1],
 [1,0,1,0],
 [1,1,1,1],
 [1,0,1,1]]
</code></pre></div><p>题目描述：1 表示可以经过某个位置，求解从 (0, 0) 位置到 (tr, tc) 位置的最短路径长度。</p>
<div><pre><code><span>public</span> <span>int</span> <span>minPathLength</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> grids<span>,</span> <span>int</span> tr<span>,</span> <span>int</span> tc<span>)</span> <span>{</span>
    <span>final</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> direction <span>=</span> <span>{</span><span>{</span><span>1</span><span>,</span> <span>0</span><span>}</span><span>,</span> <span>{</span><span>-</span><span>1</span><span>,</span> <span>0</span><span>}</span><span>,</span> <span>{</span><span>0</span><span>,</span> <span>1</span><span>}</span><span>,</span> <span>{</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>}</span><span>}</span><span>;</span>
    <span>final</span> <span>int</span> m <span>=</span> grids<span>.</span>length<span>,</span> n <span>=</span> grids<span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span>
    <span>Queue</span><span><span>&lt;</span><span>Pair</span><span>&lt;</span><span>Integer</span><span>,</span> <span>Integer</span><span>></span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    queue<span>.</span><span>add</span><span>(</span><span>new</span> <span>Pair</span><span><span>&lt;</span><span>></span></span><span>(</span><span>0</span><span>,</span> <span>0</span><span>)</span><span>)</span><span>;</span>
    <span>int</span> pathLength <span>=</span> <span>0</span><span>;</span>
    <span>while</span> <span>(</span><span>!</span>queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>int</span> size <span>=</span> queue<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>
        pathLength<span>++</span><span>;</span>
        <span>while</span> <span>(</span>size<span>--</span> <span>></span> <span>0</span><span>)</span> <span>{</span>
            <span>Pair</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Integer</span><span>></span></span> cur <span>=</span> queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
            <span>int</span> cr <span>=</span> cur<span>.</span><span>getKey</span><span>(</span><span>)</span><span>,</span> cc <span>=</span> cur<span>.</span><span>getValue</span><span>(</span><span>)</span><span>;</span>
            grids<span>[</span>cr<span>]</span><span>[</span>cc<span>]</span> <span>=</span> <span>0</span><span>;</span> <span>// 标记</span>
            <span>for</span> <span>(</span><span>int</span><span>[</span><span>]</span> d <span>:</span> direction<span>)</span> <span>{</span>
                <span>int</span> nr <span>=</span> cr <span>+</span> d<span>[</span><span>0</span><span>]</span><span>,</span> nc <span>=</span> cc <span>+</span> d<span>[</span><span>1</span><span>]</span><span>;</span>
                <span>if</span> <span>(</span>nr <span>&lt;</span> <span>0</span> <span>||</span> nr <span>>=</span> m <span>||</span> nc <span>&lt;</span> <span>0</span> <span>||</span> nc <span>>=</span> n <span>||</span> grids<span>[</span>nr<span>]</span><span>[</span>nc<span>]</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
                    <span>continue</span><span>;</span>
                <span>}</span>
                <span>if</span> <span>(</span>nr <span>==</span> tr <span>&amp;&amp;</span> nc <span>==</span> tc<span>)</span> <span>{</span>
                    <span>return</span> pathLength<span>;</span>
                <span>}</span>
                queue<span>.</span><span>add</span><span>(</span><span>new</span> <span>Pair</span><span><span>&lt;</span><span>></span></span><span>(</span>nr<span>,</span> nc<span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>-</span><span>1</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id="_2-组成整数的最小平方数数量" tabindex="-1"> 2. 组成整数的最小平方数数量</h2>
<p><a href="https://leetcode.com/problems/perfect-squares/description/" target="_blank" rel="noopener noreferrer">279. Perfect Squares (Medium)</a></p>
<div><pre><code>For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.
</code></pre></div><p>可以将每个整数看成图中的一个节点，如果两个整数之差为一个平方数，那么这两个整数所在的节点就有一条边。</p>
<p>要求解最小的平方数数量，就是求解从节点 n 到节点 0 的最短路径。</p>
<p>本题也可以用动态规划求解，在之后动态规划部分中会再次出现。</p>
<div><pre><code><span>public</span> <span>int</span> <span>numSquares</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> squares <span>=</span> <span>generateSquares</span><span>(</span>n<span>)</span><span>;</span>
    <span>Queue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>boolean</span><span>[</span><span>]</span> marked <span>=</span> <span>new</span> <span>boolean</span><span>[</span>n <span>+</span> <span>1</span><span>]</span><span>;</span>
    queue<span>.</span><span>add</span><span>(</span>n<span>)</span><span>;</span>
    marked<span>[</span>n<span>]</span> <span>=</span> <span>true</span><span>;</span>
    <span>int</span> level <span>=</span> <span>0</span><span>;</span>
    <span>while</span> <span>(</span><span>!</span>queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>int</span> size <span>=</span> queue<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>
        level<span>++</span><span>;</span>
        <span>while</span> <span>(</span>size<span>--</span> <span>></span> <span>0</span><span>)</span> <span>{</span>
            <span>int</span> cur <span>=</span> queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
            <span>for</span> <span>(</span><span>int</span> s <span>:</span> squares<span>)</span> <span>{</span>
                <span>int</span> next <span>=</span> cur <span>-</span> s<span>;</span>
                <span>if</span> <span>(</span>next <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
                    <span>break</span><span>;</span>
                <span>}</span>
                <span>if</span> <span>(</span>next <span>==</span> <span>0</span><span>)</span> <span>{</span>
                    <span>return</span> level<span>;</span>
                <span>}</span>
                <span>if</span> <span>(</span>marked<span>[</span>next<span>]</span><span>)</span> <span>{</span>
                    <span>continue</span><span>;</span>
                <span>}</span>
                marked<span>[</span>next<span>]</span> <span>=</span> <span>true</span><span>;</span>
                queue<span>.</span><span>add</span><span>(</span>next<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> n<span>;</span>
<span>}</span>

<span>/**
 * 生成小于 n 的平方数序列
 * <span>@return</span> 1,4,9,...
 */</span>
<span>private</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>generateSquares</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> squares <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>int</span> square <span>=</span> <span>1</span><span>;</span>
    <span>int</span> diff <span>=</span> <span>3</span><span>;</span>
    <span>while</span> <span>(</span>square <span>&lt;=</span> n<span>)</span> <span>{</span>
        squares<span>.</span><span>add</span><span>(</span>square<span>)</span><span>;</span>
        square <span>+=</span> diff<span>;</span>
        diff <span>+=</span> <span>2</span><span>;</span>
    <span>}</span>
    <span>return</span> squares<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h2 id="_3-最短单词路径" tabindex="-1"> 3. 最短单词路径</h2>
<p><a href="https://leetcode.com/problems/word-ladder/description/" target="_blank" rel="noopener noreferrer">127. Word Ladder (Medium)</a></p>
<div><pre><code>Input:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

Output: 5

Explanation: As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
return its length 5.
</code></pre></div><div><pre><code>Input:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

Output: 0

Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.
</code></pre></div><p>题目描述：找出一条从 beginWord 到 endWord 的最短路径，每次移动规定为改变一个字符，并且改变之后的字符串必须在 wordList 中。</p>
<div><pre><code><span>public</span> <span>int</span> <span>ladderLength</span><span>(</span><span>String</span> beginWord<span>,</span> <span>String</span> endWord<span>,</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> wordList<span>)</span> <span>{</span>
    wordList<span>.</span><span>add</span><span>(</span>beginWord<span>)</span><span>;</span>
    <span>int</span> <span>N</span> <span>=</span> wordList<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>
    <span>int</span> start <span>=</span> <span>N</span> <span>-</span> <span>1</span><span>;</span>
    <span>int</span> end <span>=</span> <span>0</span><span>;</span>
    <span>while</span> <span>(</span>end <span>&lt;</span> <span>N</span> <span>&amp;&amp;</span> <span>!</span>wordList<span>.</span><span>get</span><span>(</span>end<span>)</span><span>.</span><span>equals</span><span>(</span>endWord<span>)</span><span>)</span> <span>{</span>
        end<span>++</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>end <span>==</span> <span>N</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>[</span><span>]</span> graphic <span>=</span> <span>buildGraphic</span><span>(</span>wordList<span>)</span><span>;</span>
    <span>return</span> <span>getShortestPath</span><span>(</span>graphic<span>,</span> start<span>,</span> end<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>[</span><span>]</span> <span>buildGraphic</span><span>(</span><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> wordList<span>)</span> <span>{</span>
    <span>int</span> <span>N</span> <span>=</span> wordList<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>
    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>[</span><span>]</span> graphic <span>=</span> <span>new</span> <span>List</span><span>[</span><span>N</span><span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        graphic<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> <span>N</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>isConnect</span><span>(</span>wordList<span>.</span><span>get</span><span>(</span>i<span>)</span><span>,</span> wordList<span>.</span><span>get</span><span>(</span>j<span>)</span><span>)</span><span>)</span> <span>{</span>
                graphic<span>[</span>i<span>]</span><span>.</span><span>add</span><span>(</span>j<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> graphic<span>;</span>
<span>}</span>

<span>private</span> <span>boolean</span> <span>isConnect</span><span>(</span><span>String</span> s1<span>,</span> <span>String</span> s2<span>)</span> <span>{</span>
    <span>int</span> diffCnt <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s1<span>.</span><span>length</span><span>(</span><span>)</span> <span>&amp;&amp;</span> diffCnt <span>&lt;=</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>s1<span>.</span><span>charAt</span><span>(</span>i<span>)</span> <span>!=</span> s2<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>)</span> <span>{</span>
            diffCnt<span>++</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> diffCnt <span>==</span> <span>1</span><span>;</span>
<span>}</span>

<span>private</span> <span>int</span> <span>getShortestPath</span><span>(</span><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>[</span><span>]</span> graphic<span>,</span> <span>int</span> start<span>,</span> <span>int</span> end<span>)</span> <span>{</span>
    <span>Queue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>boolean</span><span>[</span><span>]</span> marked <span>=</span> <span>new</span> <span>boolean</span><span>[</span>graphic<span>.</span>length<span>]</span><span>;</span>
    queue<span>.</span><span>add</span><span>(</span>start<span>)</span><span>;</span>
    marked<span>[</span>start<span>]</span> <span>=</span> <span>true</span><span>;</span>
    <span>int</span> path <span>=</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span><span>!</span>queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>int</span> size <span>=</span> queue<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>
        path<span>++</span><span>;</span>
        <span>while</span> <span>(</span>size<span>--</span> <span>></span> <span>0</span><span>)</span> <span>{</span>
            <span>int</span> cur <span>=</span> queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
            <span>for</span> <span>(</span><span>int</span> next <span>:</span> graphic<span>[</span>cur<span>]</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span>next <span>==</span> end<span>)</span> <span>{</span>
                    <span>return</span> path<span>;</span>
                <span>}</span>
                <span>if</span> <span>(</span>marked<span>[</span>next<span>]</span><span>)</span> <span>{</span>
                    <span>continue</span><span>;</span>
                <span>}</span>
                marked<span>[</span>next<span>]</span> <span>=</span> <span>true</span><span>;</span>
                queue<span>.</span><span>add</span><span>(</span>next<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br></div></div><h1 id="dfs" tabindex="-1"> DFS</h1>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/74dc31eb-6baa-47ea-ab1c-d27a0ca35093.png"/> </div><br>
<p>广度优先搜索一层一层遍历，每一层得到的所有新节点，要用队列存储起来以备下一层遍历的时候再遍历。</p>
<p>而深度优先搜索在得到一个新节点时立即对新节点进行遍历：从节点 0 出发开始遍历，得到到新节点 6 时，立马对新节点 6 进行遍历，得到新节点 4；如此反复以这种方式遍历新节点，直到没有新节点了，此时返回。返回到根节点 0 的情况是，继续对根节点 0 进行遍历，得到新节点 2，然后继续以上步骤。</p>
<p>从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，DFS 常用来求解这种  <strong>可达性</strong>  问题。</p>
<p>在程序实现 DFS 时需要考虑以下问题：</p>
<ul>
<li>栈：用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。</li>
<li>标记：和 BFS 一样同样需要对已经遍历过的节点进行标记。</li>
</ul>
<h2 id="_1-查找最大的连通面积" tabindex="-1"> 1. 查找最大的连通面积</h2>
<p><a href="https://leetcode.com/problems/max-area-of-island/description/" target="_blank" rel="noopener noreferrer">695. Max Area of Island (Medium)</a></p>
<div><pre><code>[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
</code></pre></div><div><pre><code><span>private</span> <span>int</span> m<span>,</span> n<span>;</span>
<span>private</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> direction <span>=</span> <span>{</span><span>{</span><span>0</span><span>,</span> <span>1</span><span>}</span><span>,</span> <span>{</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>}</span><span>,</span> <span>{</span><span>1</span><span>,</span> <span>0</span><span>}</span><span>,</span> <span>{</span><span>-</span><span>1</span><span>,</span> <span>0</span><span>}</span><span>}</span><span>;</span>

<span>public</span> <span>int</span> <span>maxAreaOfIsland</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> grid<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>grid <span>==</span> <span>null</span> <span>||</span> grid<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    m <span>=</span> grid<span>.</span>length<span>;</span>
    n <span>=</span> grid<span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span>
    <span>int</span> maxArea <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> m<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> n<span>;</span> j<span>++</span><span>)</span> <span>{</span>
            maxArea <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>maxArea<span>,</span> <span>dfs</span><span>(</span>grid<span>,</span> i<span>,</span> j<span>)</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> maxArea<span>;</span>
<span>}</span>

<span>private</span> <span>int</span> <span>dfs</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> grid<span>,</span> <span>int</span> r<span>,</span> <span>int</span> c<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>r <span>&lt;</span> <span>0</span> <span>||</span> r <span>>=</span> m <span>||</span> c <span>&lt;</span> <span>0</span> <span>||</span> c <span>>=</span> n <span>||</span> grid<span>[</span>r<span>]</span><span>[</span>c<span>]</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    grid<span>[</span>r<span>]</span><span>[</span>c<span>]</span> <span>=</span> <span>0</span><span>;</span>
    <span>int</span> area <span>=</span> <span>1</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span><span>[</span><span>]</span> d <span>:</span> direction<span>)</span> <span>{</span>
        area <span>+=</span> <span>dfs</span><span>(</span>grid<span>,</span> r <span>+</span> d<span>[</span><span>0</span><span>]</span><span>,</span> c <span>+</span> d<span>[</span><span>1</span><span>]</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> area<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h2 id="_2-矩阵中的连通分量数目" tabindex="-1"> 2. 矩阵中的连通分量数目</h2>
<p><a href="https://leetcode.com/problems/number-of-islands/description/" target="_blank" rel="noopener noreferrer">200. Number of Islands (Medium)</a></p>
<div><pre><code>Input:
11000
11000
00100
00011

Output: 3
</code></pre></div><p>可以将矩阵表示看成一张有向图。</p>
<div><pre><code><span>private</span> <span>int</span> m<span>,</span> n<span>;</span>
<span>private</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> direction <span>=</span> <span>{</span><span>{</span><span>0</span><span>,</span> <span>1</span><span>}</span><span>,</span> <span>{</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>}</span><span>,</span> <span>{</span><span>1</span><span>,</span> <span>0</span><span>}</span><span>,</span> <span>{</span><span>-</span><span>1</span><span>,</span> <span>0</span><span>}</span><span>}</span><span>;</span>

<span>public</span> <span>int</span> <span>numIslands</span><span>(</span><span>char</span><span>[</span><span>]</span><span>[</span><span>]</span> grid<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>grid <span>==</span> <span>null</span> <span>||</span> grid<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    m <span>=</span> grid<span>.</span>length<span>;</span>
    n <span>=</span> grid<span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span>
    <span>int</span> islandsNum <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> m<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> n<span>;</span> j<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>!=</span> <span>'0'</span><span>)</span> <span>{</span>
                <span>dfs</span><span>(</span>grid<span>,</span> i<span>,</span> j<span>)</span><span>;</span>
                islandsNum<span>++</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> islandsNum<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>dfs</span><span>(</span><span>char</span><span>[</span><span>]</span><span>[</span><span>]</span> grid<span>,</span> <span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>i <span>&lt;</span> <span>0</span> <span>||</span> i <span>>=</span> m <span>||</span> j <span>&lt;</span> <span>0</span> <span>||</span> j <span>>=</span> n <span>||</span> grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>==</span> <span>'0'</span><span>)</span> <span>{</span>
        <span>return</span><span>;</span>
    <span>}</span>
    grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> <span>'0'</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span><span>[</span><span>]</span> d <span>:</span> direction<span>)</span> <span>{</span>
        <span>dfs</span><span>(</span>grid<span>,</span> i <span>+</span> d<span>[</span><span>0</span><span>]</span><span>,</span> j <span>+</span> d<span>[</span><span>1</span><span>]</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h2 id="_3-好友关系的连通分量数目" tabindex="-1"> 3. 好友关系的连通分量数目</h2>
<p><a href="https://leetcode.com/problems/friend-circles/description/" target="_blank" rel="noopener noreferrer">547. Friend Circles (Medium)</a></p>
<div><pre><code>Input:
[[1,1,0],
 [1,1,0],
 [0,0,1]]

Output: 2

Explanation:The 0th and 1st students are direct friends, so they are in a friend circle.
The 2nd student himself is in a friend circle. So return 2.
</code></pre></div><p>题目描述：好友关系可以看成是一个无向图，例如第 0 个人与第 1 个人是好友，那么 M[0][1] 和 M[1][0] 的值都为 1。</p>
<div><pre><code><span>private</span> <span>int</span> n<span>;</span>

<span>public</span> <span>int</span> <span>findCircleNum</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> <span>M</span><span>)</span> <span>{</span>
    n <span>=</span> <span>M</span><span>.</span>length<span>;</span>
    <span>int</span> circleNum <span>=</span> <span>0</span><span>;</span>
    <span>boolean</span><span>[</span><span>]</span> hasVisited <span>=</span> <span>new</span> <span>boolean</span><span>[</span>n<span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span>hasVisited<span>[</span>i<span>]</span><span>)</span> <span>{</span>
            <span>dfs</span><span>(</span><span>M</span><span>,</span> i<span>,</span> hasVisited<span>)</span><span>;</span>
            circleNum<span>++</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> circleNum<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>dfs</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> <span>M</span><span>,</span> <span>int</span> i<span>,</span> <span>boolean</span><span>[</span><span>]</span> hasVisited<span>)</span> <span>{</span>
    hasVisited<span>[</span>i<span>]</span> <span>=</span> <span>true</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> k <span>=</span> <span>0</span><span>;</span> k <span>&lt;</span> n<span>;</span> k<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>M</span><span>[</span>i<span>]</span><span>[</span>k<span>]</span> <span>==</span> <span>1</span> <span>&amp;&amp;</span> <span>!</span>hasVisited<span>[</span>k<span>]</span><span>)</span> <span>{</span>
            <span>dfs</span><span>(</span><span>M</span><span>,</span> k<span>,</span> hasVisited<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id="_4-填充封闭区域" tabindex="-1"> 4. 填充封闭区域</h2>
<p><a href="https://leetcode.com/problems/surrounded-regions/description/" target="_blank" rel="noopener noreferrer">130. Surrounded Regions (Medium)</a></p>
<div><pre><code>For example,
X X X X
X O O X
X X O X
X O X X

After running your function, the board should be:
X X X X
X X X X
X X X X
X O X X
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>题目描述：使被 'X' 包围的 'O' 转换为 'X'。</p>
<p>先填充最外侧，剩下的就是里侧了。</p>
<div><pre><code><span>private</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> direction <span>=</span> <span>{</span><span>{</span><span>0</span><span>,</span> <span>1</span><span>}</span><span>,</span> <span>{</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>}</span><span>,</span> <span>{</span><span>1</span><span>,</span> <span>0</span><span>}</span><span>,</span> <span>{</span><span>-</span><span>1</span><span>,</span> <span>0</span><span>}</span><span>}</span><span>;</span>
<span>private</span> <span>int</span> m<span>,</span> n<span>;</span>

<span>public</span> <span>void</span> <span>solve</span><span>(</span><span>char</span><span>[</span><span>]</span><span>[</span><span>]</span> board<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>board <span>==</span> <span>null</span> <span>||</span> board<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span><span>;</span>
    <span>}</span>

    m <span>=</span> board<span>.</span>length<span>;</span>
    n <span>=</span> board<span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span>

    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> m<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>dfs</span><span>(</span>board<span>,</span> i<span>,</span> <span>0</span><span>)</span><span>;</span>
        <span>dfs</span><span>(</span>board<span>,</span> i<span>,</span> n <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>dfs</span><span>(</span>board<span>,</span> <span>0</span><span>,</span> i<span>)</span><span>;</span>
        <span>dfs</span><span>(</span>board<span>,</span> m <span>-</span> <span>1</span><span>,</span> i<span>)</span><span>;</span>
    <span>}</span>

    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> m<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> n<span>;</span> j<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>board<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>==</span> <span>'T'</span><span>)</span> <span>{</span>
                board<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> <span>'O'</span><span>;</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span>board<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>==</span> <span>'O'</span><span>)</span> <span>{</span>
                board<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> <span>'X'</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>private</span> <span>void</span> <span>dfs</span><span>(</span><span>char</span><span>[</span><span>]</span><span>[</span><span>]</span> board<span>,</span> <span>int</span> r<span>,</span> <span>int</span> c<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>r <span>&lt;</span> <span>0</span> <span>||</span> r <span>>=</span> m <span>||</span> c <span>&lt;</span> <span>0</span> <span>||</span> c <span>>=</span> n <span>||</span> board<span>[</span>r<span>]</span><span>[</span>c<span>]</span> <span>!=</span> <span>'O'</span><span>)</span> <span>{</span>
        <span>return</span><span>;</span>
    <span>}</span>
    board<span>[</span>r<span>]</span><span>[</span>c<span>]</span> <span>=</span> <span>'T'</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span><span>[</span><span>]</span> d <span>:</span> direction<span>)</span> <span>{</span>
        <span>dfs</span><span>(</span>board<span>,</span> r <span>+</span> d<span>[</span><span>0</span><span>]</span><span>,</span> c <span>+</span> d<span>[</span><span>1</span><span>]</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><h2 id="_5-能到达的太平洋和大西洋的区域" tabindex="-1"> 5. 能到达的太平洋和大西洋的区域</h2>
<p><a href="https://leetcode.com/problems/pacific-atlantic-water-flow/description/" target="_blank" rel="noopener noreferrer">417. Pacific Atlantic Water Flow (Medium)</a></p>
<div><pre><code>Given the following 5x5 matrix:

  Pacific ~   ~   ~   ~   ~
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * Atlantic

Return:
[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>左边和上边是太平洋，右边和下边是大西洋，内部的数字代表海拔，海拔高的地方的水能够流到低的地方，求解水能够流到太平洋和大西洋的所有位置。</p>
<div><pre><code>
<span>private</span> <span>int</span> m<span>,</span> n<span>;</span>
<span>private</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> matrix<span>;</span>
<span>private</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> direction <span>=</span> <span>{</span><span>{</span><span>0</span><span>,</span> <span>1</span><span>}</span><span>,</span> <span>{</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>}</span><span>,</span> <span>{</span><span>1</span><span>,</span> <span>0</span><span>}</span><span>,</span> <span>{</span><span>-</span><span>1</span><span>,</span> <span>0</span><span>}</span><span>}</span><span>;</span>

<span>public</span> <span>List</span><span>&lt;</span><span>int</span><span>[</span><span>]</span><span>></span> <span>pacificAtlantic</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> matrix<span>)</span> <span>{</span>
    <span>List</span><span>&lt;</span><span>int</span><span>[</span><span>]</span><span>></span> ret <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>matrix <span>==</span> <span>null</span> <span>||</span> matrix<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> ret<span>;</span>
    <span>}</span>

    m <span>=</span> matrix<span>.</span>length<span>;</span>
    n <span>=</span> matrix<span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span>
    <span>this</span><span>.</span>matrix <span>=</span> matrix<span>;</span>
    <span>boolean</span><span>[</span><span>]</span><span>[</span><span>]</span> canReachP <span>=</span> <span>new</span> <span>boolean</span><span>[</span>m<span>]</span><span>[</span>n<span>]</span><span>;</span>
    <span>boolean</span><span>[</span><span>]</span><span>[</span><span>]</span> canReachA <span>=</span> <span>new</span> <span>boolean</span><span>[</span>m<span>]</span><span>[</span>n<span>]</span><span>;</span>

    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> m<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>dfs</span><span>(</span>i<span>,</span> <span>0</span><span>,</span> canReachP<span>)</span><span>;</span>
        <span>dfs</span><span>(</span>i<span>,</span> n <span>-</span> <span>1</span><span>,</span> canReachA<span>)</span><span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>dfs</span><span>(</span><span>0</span><span>,</span> i<span>,</span> canReachP<span>)</span><span>;</span>
        <span>dfs</span><span>(</span>m <span>-</span> <span>1</span><span>,</span> i<span>,</span> canReachA<span>)</span><span>;</span>
    <span>}</span>

    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> m<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> n<span>;</span> j<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>canReachP<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>&amp;&amp;</span> canReachA<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>)</span> <span>{</span>
                ret<span>.</span><span>add</span><span>(</span><span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span>i<span>,</span> j<span>}</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>return</span> ret<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>dfs</span><span>(</span><span>int</span> r<span>,</span> <span>int</span> c<span>,</span> <span>boolean</span><span>[</span><span>]</span><span>[</span><span>]</span> canReach<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>canReach<span>[</span>r<span>]</span><span>[</span>c<span>]</span><span>)</span> <span>{</span>
        <span>return</span><span>;</span>
    <span>}</span>
    canReach<span>[</span>r<span>]</span><span>[</span>c<span>]</span> <span>=</span> <span>true</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span><span>[</span><span>]</span> d <span>:</span> direction<span>)</span> <span>{</span>
        <span>int</span> nextR <span>=</span> d<span>[</span><span>0</span><span>]</span> <span>+</span> r<span>;</span>
        <span>int</span> nextC <span>=</span> d<span>[</span><span>1</span><span>]</span> <span>+</span> c<span>;</span>
        <span>if</span> <span>(</span>nextR <span>&lt;</span> <span>0</span> <span>||</span> nextR <span>>=</span> m <span>||</span> nextC <span>&lt;</span> <span>0</span> <span>||</span> nextC <span>>=</span> n
                <span>||</span> matrix<span>[</span>r<span>]</span><span>[</span>c<span>]</span> <span>></span> matrix<span>[</span>nextR<span>]</span><span>[</span>nextC<span>]</span><span>)</span> <span>{</span>

            <span>continue</span><span>;</span>
        <span>}</span>
        <span>dfs</span><span>(</span>nextR<span>,</span> nextC<span>,</span> canReach<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><h1 id="backtracking" tabindex="-1"> Backtracking</h1>
<p>Backtracking（回溯）属于 DFS。</p>
<ul>
<li>普通 DFS 主要用在  <strong>可达性问题</strong> ，这种问题只需要执行到特点的位置然后返回即可。</li>
<li>而 Backtracking 主要用于求解  <strong>排列组合</strong>  问题，例如有 { 'a','b','c' } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。</li>
</ul>
<p>因为 Backtracking 不是立即返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：</p>
<ul>
<li>在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；</li>
<li>但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。</li>
</ul>
<h2 id="_1-数字键盘组合" tabindex="-1"> 1. 数字键盘组合</h2>
<p><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/" target="_blank" rel="noopener noreferrer">17. Letter Combinations of a Phone Number (Medium)</a></p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9823768c-212b-4b1a-b69a-b3f59e07b977.jpg"/> </div><br>
<div><pre><code>Input:Digit string "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
</code></pre></div><div><pre><code><span>private</span> <span>static</span> <span>final</span> <span>String</span><span>[</span><span>]</span> KEYS <span>=</span> <span>{</span><span>""</span><span>,</span> <span>""</span><span>,</span> <span>"abc"</span><span>,</span> <span>"def"</span><span>,</span> <span>"ghi"</span><span>,</span> <span>"jkl"</span><span>,</span> <span>"mno"</span><span>,</span> <span>"pqrs"</span><span>,</span> <span>"tuv"</span><span>,</span> <span>"wxyz"</span><span>}</span><span>;</span>

<span>public</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>letterCombinations</span><span>(</span><span>String</span> digits<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> combinations <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>digits <span>==</span> <span>null</span> <span>||</span> digits<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> combinations<span>;</span>
    <span>}</span>
    <span>doCombination</span><span>(</span><span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>,</span> combinations<span>,</span> digits<span>)</span><span>;</span>
    <span>return</span> combinations<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>doCombination</span><span>(</span><span>StringBuilder</span> prefix<span>,</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> combinations<span>,</span> <span>final</span> <span>String</span> digits<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>prefix<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> digits<span>.</span><span>length</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        combinations<span>.</span><span>add</span><span>(</span>prefix<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>return</span><span>;</span>
    <span>}</span>
    <span>int</span> curDigits <span>=</span> digits<span>.</span><span>charAt</span><span>(</span>prefix<span>.</span><span>length</span><span>(</span><span>)</span><span>)</span> <span>-</span> <span>'0'</span><span>;</span>
    <span>String</span> letters <span>=</span> KEYS<span>[</span>curDigits<span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>char</span> c <span>:</span> letters<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        prefix<span>.</span><span>append</span><span>(</span>c<span>)</span><span>;</span>                         <span>// 添加</span>
        <span>doCombination</span><span>(</span>prefix<span>,</span> combinations<span>,</span> digits<span>)</span><span>;</span>
        prefix<span>.</span><span>deleteCharAt</span><span>(</span>prefix<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span> <span>// 删除</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h2 id="_2-ip-地址划分" tabindex="-1"> 2. IP 地址划分</h2>
<p><a href="https://leetcode.com/problems/restore-ip-addresses/description/" target="_blank" rel="noopener noreferrer">93. Restore IP Addresses(Medium)</a></p>
<div><pre><code>Given "25525511135",
return ["255.255.11.135", "255.255.111.35"].
</code></pre></div><div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>restoreIpAddresses</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> addresses <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>StringBuilder</span> tempAddress <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
    <span>doRestore</span><span>(</span><span>0</span><span>,</span> tempAddress<span>,</span> addresses<span>,</span> s<span>)</span><span>;</span>
    <span>return</span> addresses<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>doRestore</span><span>(</span><span>int</span> k<span>,</span> <span>StringBuilder</span> tempAddress<span>,</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> addresses<span>,</span> <span>String</span> s<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>k <span>==</span> <span>4</span> <span>||</span> s<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>k <span>==</span> <span>4</span> <span>&amp;&amp;</span> s<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
            addresses<span>.</span><span>add</span><span>(</span>tempAddress<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span><span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span><span>length</span><span>(</span><span>)</span> <span>&amp;&amp;</span> i <span>&lt;=</span> <span>2</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>i <span>!=</span> <span>0</span> <span>&amp;&amp;</span> s<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span> <span>==</span> <span>'0'</span><span>)</span> <span>{</span>
            <span>break</span><span>;</span>
        <span>}</span>
        <span>String</span> part <span>=</span> s<span>.</span><span>substring</span><span>(</span><span>0</span><span>,</span> i <span>+</span> <span>1</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span><span>Integer</span><span>.</span><span>valueOf</span><span>(</span>part<span>)</span> <span>&lt;=</span> <span>255</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>tempAddress<span>.</span><span>length</span><span>(</span><span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
                part <span>=</span> <span>"."</span> <span>+</span> part<span>;</span>
            <span>}</span>
            tempAddress<span>.</span><span>append</span><span>(</span>part<span>)</span><span>;</span>
            <span>doRestore</span><span>(</span>k <span>+</span> <span>1</span><span>,</span> tempAddress<span>,</span> addresses<span>,</span> s<span>.</span><span>substring</span><span>(</span>i <span>+</span> <span>1</span><span>)</span><span>)</span><span>;</span>
            tempAddress<span>.</span><span>delete</span><span>(</span>tempAddress<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> part<span>.</span><span>length</span><span>(</span><span>)</span><span>,</span> tempAddress<span>.</span><span>length</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h2 id="_3-在矩阵中寻找字符串" tabindex="-1"> 3. 在矩阵中寻找字符串</h2>
<p><a href="https://leetcode.com/problems/word-search/description/" target="_blank" rel="noopener noreferrer">79. Word Search (Medium)</a></p>
<div><pre><code>For example,
Given board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
word = "ABCCED", -> returns true,
word = "SEE", -> returns true,
word = "ABCB", -> returns false.
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>private</span> <span>final</span> <span>static</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> direction <span>=</span> <span>{</span><span>{</span><span>1</span><span>,</span> <span>0</span><span>}</span><span>,</span> <span>{</span><span>-</span><span>1</span><span>,</span> <span>0</span><span>}</span><span>,</span> <span>{</span><span>0</span><span>,</span> <span>1</span><span>}</span><span>,</span> <span>{</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>}</span><span>}</span><span>;</span>
<span>private</span> <span>int</span> m<span>;</span>
<span>private</span> <span>int</span> n<span>;</span>

<span>public</span> <span>boolean</span> <span>exist</span><span>(</span><span>char</span><span>[</span><span>]</span><span>[</span><span>]</span> board<span>,</span> <span>String</span> word<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>word <span>==</span> <span>null</span> <span>||</span> word<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>board <span>==</span> <span>null</span> <span>||</span> board<span>.</span>length <span>==</span> <span>0</span> <span>||</span> board<span>[</span><span>0</span><span>]</span><span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>

    m <span>=</span> board<span>.</span>length<span>;</span>
    n <span>=</span> board<span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span>
    <span>boolean</span><span>[</span><span>]</span><span>[</span><span>]</span> hasVisited <span>=</span> <span>new</span> <span>boolean</span><span>[</span>m<span>]</span><span>[</span>n<span>]</span><span>;</span>

    <span>for</span> <span>(</span><span>int</span> r <span>=</span> <span>0</span><span>;</span> r <span>&lt;</span> m<span>;</span> r<span>++</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> c <span>=</span> <span>0</span><span>;</span> c <span>&lt;</span> n<span>;</span> c<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>backtracking</span><span>(</span><span>0</span><span>,</span> r<span>,</span> c<span>,</span> hasVisited<span>,</span> board<span>,</span> word<span>)</span><span>)</span> <span>{</span>
                <span>return</span> <span>true</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>return</span> <span>false</span><span>;</span>
<span>}</span>

<span>private</span> <span>boolean</span> <span>backtracking</span><span>(</span><span>int</span> curLen<span>,</span> <span>int</span> r<span>,</span> <span>int</span> c<span>,</span> <span>boolean</span><span>[</span><span>]</span><span>[</span><span>]</span> visited<span>,</span> <span>final</span> <span>char</span><span>[</span><span>]</span><span>[</span><span>]</span> board<span>,</span> <span>final</span> <span>String</span> word<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>curLen <span>==</span> word<span>.</span><span>length</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>r <span>&lt;</span> <span>0</span> <span>||</span> r <span>>=</span> m <span>||</span> c <span>&lt;</span> <span>0</span> <span>||</span> c <span>>=</span> n
            <span>||</span> board<span>[</span>r<span>]</span><span>[</span>c<span>]</span> <span>!=</span> word<span>.</span><span>charAt</span><span>(</span>curLen<span>)</span> <span>||</span> visited<span>[</span>r<span>]</span><span>[</span>c<span>]</span><span>)</span> <span>{</span>

        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>

    visited<span>[</span>r<span>]</span><span>[</span>c<span>]</span> <span>=</span> <span>true</span><span>;</span>

    <span>for</span> <span>(</span><span>int</span><span>[</span><span>]</span> d <span>:</span> direction<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>backtracking</span><span>(</span>curLen <span>+</span> <span>1</span><span>,</span> r <span>+</span> d<span>[</span><span>0</span><span>]</span><span>,</span> c <span>+</span> d<span>[</span><span>1</span><span>]</span><span>,</span> visited<span>,</span> board<span>,</span> word<span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
    <span>}</span>

    visited<span>[</span>r<span>]</span><span>[</span>c<span>]</span> <span>=</span> <span>false</span><span>;</span>

    <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><h2 id="_4-输出二叉树中所有从根到叶子的路径" tabindex="-1"> 4. 输出二叉树中所有从根到叶子的路径</h2>
<p><a href="https://leetcode.com/problems/binary-tree-paths/description/" target="_blank" rel="noopener noreferrer">257. Binary Tree Paths (Easy)</a></p>
<div><pre><code>  1
 /  \
2    3
 \
  5
</code></pre></div><div><pre><code>["1->2->5", "1->3"]
</code></pre></div><div><pre><code>
<span>public</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>binaryTreePaths</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> paths <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> paths<span>;</span>
    <span>}</span>
    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> values <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>backtracking</span><span>(</span>root<span>,</span> values<span>,</span> paths<span>)</span><span>;</span>
    <span>return</span> paths<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>backtracking</span><span>(</span><span>TreeNode</span> node<span>,</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> values<span>,</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> paths<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span><span>;</span>
    <span>}</span>
    values<span>.</span><span>add</span><span>(</span>node<span>.</span>val<span>)</span><span>;</span>
    <span>if</span> <span>(</span><span>isLeaf</span><span>(</span>node<span>)</span><span>)</span> <span>{</span>
        paths<span>.</span><span>add</span><span>(</span><span>buildPath</span><span>(</span>values<span>)</span><span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>backtracking</span><span>(</span>node<span>.</span>left<span>,</span> values<span>,</span> paths<span>)</span><span>;</span>
        <span>backtracking</span><span>(</span>node<span>.</span>right<span>,</span> values<span>,</span> paths<span>)</span><span>;</span>
    <span>}</span>
    values<span>.</span><span>remove</span><span>(</span>values<span>.</span><span>size</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>boolean</span> <span>isLeaf</span><span>(</span><span>TreeNode</span> node<span>)</span> <span>{</span>
    <span>return</span> node<span>.</span>left <span>==</span> <span>null</span> <span>&amp;&amp;</span> node<span>.</span>right <span>==</span> <span>null</span><span>;</span>
<span>}</span>

<span>private</span> <span>String</span> <span>buildPath</span><span>(</span><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> values<span>)</span> <span>{</span>
    <span>StringBuilder</span> str <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> values<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        str<span>.</span><span>append</span><span>(</span>values<span>.</span><span>get</span><span>(</span>i<span>)</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>i <span>!=</span> values<span>.</span><span>size</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>)</span> <span>{</span>
            str<span>.</span><span>append</span><span>(</span><span>"->"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> str<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><h2 id="_5-排列" tabindex="-1"> 5. 排列</h2>
<p><a href="https://leetcode.com/problems/permutations/description/" target="_blank" rel="noopener noreferrer">46. Permutations (Medium)</a></p>
<div><pre><code>[1,2,3] have the following permutations:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
</code></pre></div><div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> <span>permute</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> permutes <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> permuteList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>boolean</span><span>[</span><span>]</span> hasVisited <span>=</span> <span>new</span> <span>boolean</span><span>[</span>nums<span>.</span>length<span>]</span><span>;</span>
    <span>backtracking</span><span>(</span>permuteList<span>,</span> permutes<span>,</span> hasVisited<span>,</span> nums<span>)</span><span>;</span>
    <span>return</span> permutes<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>backtracking</span><span>(</span><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> permuteList<span>,</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> permutes<span>,</span> <span>boolean</span><span>[</span><span>]</span> visited<span>,</span> <span>final</span> <span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>permuteList<span>.</span><span>size</span><span>(</span><span>)</span> <span>==</span> nums<span>.</span>length<span>)</span> <span>{</span>
        permutes<span>.</span><span>add</span><span>(</span><span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span>permuteList<span>)</span><span>)</span><span>;</span> <span>// 重新构造一个 List</span>
        <span>return</span><span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> visited<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>visited<span>[</span>i<span>]</span><span>)</span> <span>{</span>
            <span>continue</span><span>;</span>
        <span>}</span>
        visited<span>[</span>i<span>]</span> <span>=</span> <span>true</span><span>;</span>
        permuteList<span>.</span><span>add</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span><span>;</span>
        <span>backtracking</span><span>(</span>permuteList<span>,</span> permutes<span>,</span> visited<span>,</span> nums<span>)</span><span>;</span>
        permuteList<span>.</span><span>remove</span><span>(</span>permuteList<span>.</span><span>size</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
        visited<span>[</span>i<span>]</span> <span>=</span> <span>false</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h2 id="_6-含有相同元素求排列" tabindex="-1"> 6. 含有相同元素求排列</h2>
<p><a href="https://leetcode.com/problems/permutations-ii/description/" target="_blank" rel="noopener noreferrer">47. Permutations II (Medium)</a></p>
<div><pre><code>[1,1,2] have the following unique permutations:
[[1,1,2], [1,2,1], [2,1,1]]
</code></pre></div><p>数组元素可能含有相同的元素，进行排列时就有可能出现重复的排列，要求重复的排列只返回一个。</p>
<p>在实现上，和 Permutations 不同的是要先排序，然后在添加一个元素时，判断这个元素是否等于前一个元素，如果等于，并且前一个元素还未访问，那么就跳过这个元素。</p>
<div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> <span>permuteUnique</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> permutes <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> permuteList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>Arrays</span><span>.</span><span>sort</span><span>(</span>nums<span>)</span><span>;</span>  <span>// 排序</span>
    <span>boolean</span><span>[</span><span>]</span> hasVisited <span>=</span> <span>new</span> <span>boolean</span><span>[</span>nums<span>.</span>length<span>]</span><span>;</span>
    <span>backtracking</span><span>(</span>permuteList<span>,</span> permutes<span>,</span> hasVisited<span>,</span> nums<span>)</span><span>;</span>
    <span>return</span> permutes<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>backtracking</span><span>(</span><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> permuteList<span>,</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> permutes<span>,</span> <span>boolean</span><span>[</span><span>]</span> visited<span>,</span> <span>final</span> <span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>permuteList<span>.</span><span>size</span><span>(</span><span>)</span> <span>==</span> nums<span>.</span>length<span>)</span> <span>{</span>
        permutes<span>.</span><span>add</span><span>(</span><span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span>permuteList<span>)</span><span>)</span><span>;</span>
        <span>return</span><span>;</span>
    <span>}</span>

    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> visited<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>i <span>!=</span> <span>0</span> <span>&amp;&amp;</span> nums<span>[</span>i<span>]</span> <span>==</span> nums<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>&amp;&amp;</span> <span>!</span>visited<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span> <span>{</span>
            <span>continue</span><span>;</span>  <span>// 防止重复</span>
        <span>}</span>
        <span>if</span> <span>(</span>visited<span>[</span>i<span>]</span><span>)</span><span>{</span>
            <span>continue</span><span>;</span>
        <span>}</span>
        visited<span>[</span>i<span>]</span> <span>=</span> <span>true</span><span>;</span>
        permuteList<span>.</span><span>add</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span><span>;</span>
        <span>backtracking</span><span>(</span>permuteList<span>,</span> permutes<span>,</span> visited<span>,</span> nums<span>)</span><span>;</span>
        permuteList<span>.</span><span>remove</span><span>(</span>permuteList<span>.</span><span>size</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
        visited<span>[</span>i<span>]</span> <span>=</span> <span>false</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h2 id="_7-组合" tabindex="-1"> 7. 组合</h2>
<p><a href="https://leetcode.com/problems/combinations/description/" target="_blank" rel="noopener noreferrer">77. Combinations (Medium)</a></p>
<div><pre><code>If n = 4 and k = 2, a solution is:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
</code></pre></div><div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> <span>combine</span><span>(</span><span>int</span> n<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> combinations <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> combineList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>backtracking</span><span>(</span>combineList<span>,</span> combinations<span>,</span> <span>1</span><span>,</span> k<span>,</span> n<span>)</span><span>;</span>
    <span>return</span> combinations<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>backtracking</span><span>(</span><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> combineList<span>,</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> combinations<span>,</span> <span>int</span> start<span>,</span> <span>int</span> k<span>,</span> <span>final</span> <span>int</span> n<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>k <span>==</span> <span>0</span><span>)</span> <span>{</span>
        combinations<span>.</span><span>add</span><span>(</span><span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span>combineList<span>)</span><span>)</span><span>;</span>
        <span>return</span><span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> start<span>;</span> i <span>&lt;=</span> n <span>-</span> k <span>+</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>  <span>// 剪枝</span>
        combineList<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>
        <span>backtracking</span><span>(</span>combineList<span>,</span> combinations<span>,</span> i <span>+</span> <span>1</span><span>,</span> k <span>-</span> <span>1</span><span>,</span> n<span>)</span><span>;</span>
        combineList<span>.</span><span>remove</span><span>(</span>combineList<span>.</span><span>size</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id="_8-组合求和" tabindex="-1"> 8. 组合求和</h2>
<p><a href="https://leetcode.com/problems/combination-sum/description/" target="_blank" rel="noopener noreferrer">39. Combination Sum (Medium)</a></p>
<div><pre><code>given candidate set [2, 3, 6, 7] and target 7,
A solution set is:
[[7],[2, 2, 3]]
</code></pre></div><div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> <span>combinationSum</span><span>(</span><span>int</span><span>[</span><span>]</span> candidates<span>,</span> <span>int</span> target<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> combinations <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>backtracking</span><span>(</span><span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>,</span> combinations<span>,</span> <span>0</span><span>,</span> target<span>,</span> candidates<span>)</span><span>;</span>
    <span>return</span> combinations<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>backtracking</span><span>(</span><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> tempCombination<span>,</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> combinations<span>,</span>
                          <span>int</span> start<span>,</span> <span>int</span> target<span>,</span> <span>final</span> <span>int</span><span>[</span><span>]</span> candidates<span>)</span> <span>{</span>

    <span>if</span> <span>(</span>target <span>==</span> <span>0</span><span>)</span> <span>{</span>
        combinations<span>.</span><span>add</span><span>(</span><span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span>tempCombination<span>)</span><span>)</span><span>;</span>
        <span>return</span><span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> start<span>;</span> i <span>&lt;</span> candidates<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>candidates<span>[</span>i<span>]</span> <span>&lt;=</span> target<span>)</span> <span>{</span>
            tempCombination<span>.</span><span>add</span><span>(</span>candidates<span>[</span>i<span>]</span><span>)</span><span>;</span>
            <span>backtracking</span><span>(</span>tempCombination<span>,</span> combinations<span>,</span> i<span>,</span> target <span>-</span> candidates<span>[</span>i<span>]</span><span>,</span> candidates<span>)</span><span>;</span>
            tempCombination<span>.</span><span>remove</span><span>(</span>tempCombination<span>.</span><span>size</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id="_9-含有相同元素的组合求和" tabindex="-1"> 9. 含有相同元素的组合求和</h2>
<p><a href="https://leetcode.com/problems/combination-sum-ii/description/" target="_blank" rel="noopener noreferrer">40. Combination Sum II (Medium)</a></p>
<div><pre><code>For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,
A solution set is:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
</code></pre></div><div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> <span>combinationSum2</span><span>(</span><span>int</span><span>[</span><span>]</span> candidates<span>,</span> <span>int</span> target<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> combinations <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>Arrays</span><span>.</span><span>sort</span><span>(</span>candidates<span>)</span><span>;</span>
    <span>backtracking</span><span>(</span><span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>,</span> combinations<span>,</span> <span>new</span> <span>boolean</span><span>[</span>candidates<span>.</span>length<span>]</span><span>,</span> <span>0</span><span>,</span> target<span>,</span> candidates<span>)</span><span>;</span>
    <span>return</span> combinations<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>backtracking</span><span>(</span><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> tempCombination<span>,</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> combinations<span>,</span>
                          <span>boolean</span><span>[</span><span>]</span> hasVisited<span>,</span> <span>int</span> start<span>,</span> <span>int</span> target<span>,</span> <span>final</span> <span>int</span><span>[</span><span>]</span> candidates<span>)</span> <span>{</span>

    <span>if</span> <span>(</span>target <span>==</span> <span>0</span><span>)</span> <span>{</span>
        combinations<span>.</span><span>add</span><span>(</span><span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span>tempCombination<span>)</span><span>)</span><span>;</span>
        <span>return</span><span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> start<span>;</span> i <span>&lt;</span> candidates<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>i <span>!=</span> <span>0</span> <span>&amp;&amp;</span> candidates<span>[</span>i<span>]</span> <span>==</span> candidates<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>&amp;&amp;</span> <span>!</span>hasVisited<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span> <span>{</span>
            <span>continue</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>candidates<span>[</span>i<span>]</span> <span>&lt;=</span> target<span>)</span> <span>{</span>
            tempCombination<span>.</span><span>add</span><span>(</span>candidates<span>[</span>i<span>]</span><span>)</span><span>;</span>
            hasVisited<span>[</span>i<span>]</span> <span>=</span> <span>true</span><span>;</span>
            <span>backtracking</span><span>(</span>tempCombination<span>,</span> combinations<span>,</span> hasVisited<span>,</span> i <span>+</span> <span>1</span><span>,</span> target <span>-</span> candidates<span>[</span>i<span>]</span><span>,</span> candidates<span>)</span><span>;</span>
            hasVisited<span>[</span>i<span>]</span> <span>=</span> <span>false</span><span>;</span>
            tempCombination<span>.</span><span>remove</span><span>(</span>tempCombination<span>.</span><span>size</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id="_10-1-9-数字的组合求和" tabindex="-1"> 10. 1-9 数字的组合求和</h2>
<p><a href="https://leetcode.com/problems/combination-sum-iii/description/" target="_blank" rel="noopener noreferrer">216. Combination Sum III (Medium)</a></p>
<div><pre><code>Input: k = 3, n = 9

Output:

[[1,2,6], [1,3,5], [2,3,4]]
</code></pre></div><p>从 1-9 数字中选出 k 个数不重复的数，使得它们的和为 n。</p>
<div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> <span>combinationSum3</span><span>(</span><span>int</span> k<span>,</span> <span>int</span> n<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> combinations <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> path <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>backtracking</span><span>(</span>k<span>,</span> n<span>,</span> <span>1</span><span>,</span> path<span>,</span> combinations<span>)</span><span>;</span>
    <span>return</span> combinations<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>backtracking</span><span>(</span><span>int</span> k<span>,</span> <span>int</span> n<span>,</span> <span>int</span> start<span>,</span>
                          <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> tempCombination<span>,</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> combinations<span>)</span> <span>{</span>

    <span>if</span> <span>(</span>k <span>==</span> <span>0</span> <span>&amp;&amp;</span> n <span>==</span> <span>0</span><span>)</span> <span>{</span>
        combinations<span>.</span><span>add</span><span>(</span><span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span>tempCombination<span>)</span><span>)</span><span>;</span>
        <span>return</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>k <span>==</span> <span>0</span> <span>||</span> n <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span><span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> start<span>;</span> i <span>&lt;=</span> <span>9</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        tempCombination<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>
        <span>backtracking</span><span>(</span>k <span>-</span> <span>1</span><span>,</span> n <span>-</span> i<span>,</span> i <span>+</span> <span>1</span><span>,</span> tempCombination<span>,</span> combinations<span>)</span><span>;</span>
        tempCombination<span>.</span><span>remove</span><span>(</span>tempCombination<span>.</span><span>size</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id="_11-子集" tabindex="-1"> 11. 子集</h2>
<p><a href="https://leetcode.com/problems/subsets/description/" target="_blank" rel="noopener noreferrer">78. Subsets (Medium)</a></p>
<p>找出集合的所有子集，子集不能重复，[1, 2] 和 [2, 1] 这种子集算重复</p>
<div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> <span>subsets</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> subsets <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> tempSubset <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> size <span>=</span> <span>0</span><span>;</span> size <span>&lt;=</span> nums<span>.</span>length<span>;</span> size<span>++</span><span>)</span> <span>{</span>
        <span>backtracking</span><span>(</span><span>0</span><span>,</span> tempSubset<span>,</span> subsets<span>,</span> size<span>,</span> nums<span>)</span><span>;</span> <span>// 不同的子集大小</span>
    <span>}</span>
    <span>return</span> subsets<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>backtracking</span><span>(</span><span>int</span> start<span>,</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> tempSubset<span>,</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> subsets<span>,</span>
                          <span>final</span> <span>int</span> size<span>,</span> <span>final</span> <span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>

    <span>if</span> <span>(</span>tempSubset<span>.</span><span>size</span><span>(</span><span>)</span> <span>==</span> size<span>)</span> <span>{</span>
        subsets<span>.</span><span>add</span><span>(</span><span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span>tempSubset<span>)</span><span>)</span><span>;</span>
        <span>return</span><span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> start<span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        tempSubset<span>.</span><span>add</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span><span>;</span>
        <span>backtracking</span><span>(</span>i <span>+</span> <span>1</span><span>,</span> tempSubset<span>,</span> subsets<span>,</span> size<span>,</span> nums<span>)</span><span>;</span>
        tempSubset<span>.</span><span>remove</span><span>(</span>tempSubset<span>.</span><span>size</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id="_12-含有相同元素求子集" tabindex="-1"> 12. 含有相同元素求子集</h2>
<p><a href="https://leetcode.com/problems/subsets-ii/description/" target="_blank" rel="noopener noreferrer">90. Subsets II (Medium)</a></p>
<div><pre><code>For example,
If nums = [1,2,2], a solution is:

[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> <span>subsetsWithDup</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>Arrays</span><span>.</span><span>sort</span><span>(</span>nums<span>)</span><span>;</span>
    <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> subsets <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> tempSubset <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>boolean</span><span>[</span><span>]</span> hasVisited <span>=</span> <span>new</span> <span>boolean</span><span>[</span>nums<span>.</span>length<span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> size <span>=</span> <span>0</span><span>;</span> size <span>&lt;=</span> nums<span>.</span>length<span>;</span> size<span>++</span><span>)</span> <span>{</span>
        <span>backtracking</span><span>(</span><span>0</span><span>,</span> tempSubset<span>,</span> subsets<span>,</span> hasVisited<span>,</span> size<span>,</span> nums<span>)</span><span>;</span> <span>// 不同的子集大小</span>
    <span>}</span>
    <span>return</span> subsets<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>backtracking</span><span>(</span><span>int</span> start<span>,</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> tempSubset<span>,</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> subsets<span>,</span> <span>boolean</span><span>[</span><span>]</span> hasVisited<span>,</span>
                          <span>final</span> <span>int</span> size<span>,</span> <span>final</span> <span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>

    <span>if</span> <span>(</span>tempSubset<span>.</span><span>size</span><span>(</span><span>)</span> <span>==</span> size<span>)</span> <span>{</span>
        subsets<span>.</span><span>add</span><span>(</span><span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span>tempSubset<span>)</span><span>)</span><span>;</span>
        <span>return</span><span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> start<span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>i <span>!=</span> <span>0</span> <span>&amp;&amp;</span> nums<span>[</span>i<span>]</span> <span>==</span> nums<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>&amp;&amp;</span> <span>!</span>hasVisited<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span> <span>{</span>
            <span>continue</span><span>;</span>
        <span>}</span>
        tempSubset<span>.</span><span>add</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span><span>;</span>
        hasVisited<span>[</span>i<span>]</span> <span>=</span> <span>true</span><span>;</span>
        <span>backtracking</span><span>(</span>i <span>+</span> <span>1</span><span>,</span> tempSubset<span>,</span> subsets<span>,</span> hasVisited<span>,</span> size<span>,</span> nums<span>)</span><span>;</span>
        hasVisited<span>[</span>i<span>]</span> <span>=</span> <span>false</span><span>;</span>
        tempSubset<span>.</span><span>remove</span><span>(</span>tempSubset<span>.</span><span>size</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h2 id="_13-分割字符串使得每个部分都是回文数" tabindex="-1"> 13. 分割字符串使得每个部分都是回文数</h2>
<p><a href="https://leetcode.com/problems/palindrome-partitioning/description/" target="_blank" rel="noopener noreferrer">131. Palindrome Partitioning (Medium)</a></p>
<div><pre><code>For example, given s = "aab",
Return

[
  ["aa","b"],
  ["a","a","b"]
]
</code></pre></div><div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>String</span><span>></span><span>></span></span> <span>partition</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>String</span><span>></span><span>></span></span> partitions <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> tempPartition <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>doPartition</span><span>(</span>s<span>,</span> partitions<span>,</span> tempPartition<span>)</span><span>;</span>
    <span>return</span> partitions<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>doPartition</span><span>(</span><span>String</span> s<span>,</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>String</span><span>></span><span>></span></span> partitions<span>,</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> tempPartition<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>s<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
        partitions<span>.</span><span>add</span><span>(</span><span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span>tempPartition<span>)</span><span>)</span><span>;</span>
        <span>return</span><span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>isPalindrome</span><span>(</span>s<span>,</span> <span>0</span><span>,</span> i<span>)</span><span>)</span> <span>{</span>
            tempPartition<span>.</span><span>add</span><span>(</span>s<span>.</span><span>substring</span><span>(</span><span>0</span><span>,</span> i <span>+</span> <span>1</span><span>)</span><span>)</span><span>;</span>
            <span>doPartition</span><span>(</span>s<span>.</span><span>substring</span><span>(</span>i <span>+</span> <span>1</span><span>)</span><span>,</span> partitions<span>,</span> tempPartition<span>)</span><span>;</span>
            tempPartition<span>.</span><span>remove</span><span>(</span>tempPartition<span>.</span><span>size</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>private</span> <span>boolean</span> <span>isPalindrome</span><span>(</span><span>String</span> s<span>,</span> <span>int</span> begin<span>,</span> <span>int</span> end<span>)</span> <span>{</span>
    <span>while</span> <span>(</span>begin <span>&lt;</span> end<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>s<span>.</span><span>charAt</span><span>(</span>begin<span>++</span><span>)</span> <span>!=</span> s<span>.</span><span>charAt</span><span>(</span>end<span>--</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>true</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h2 id="_14-数独" tabindex="-1"> 14. 数独</h2>
<p><a href="https://leetcode.com/problems/sudoku-solver/description/" target="_blank" rel="noopener noreferrer">37. Sudoku Solver (Hard)</a></p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0e8fdc96-83c1-4798-9abe-45fc91d70b9d.png"/> </div><br>
<div><pre><code><span>private</span> <span>boolean</span><span>[</span><span>]</span><span>[</span><span>]</span> rowsUsed <span>=</span> <span>new</span> <span>boolean</span><span>[</span><span>9</span><span>]</span><span>[</span><span>10</span><span>]</span><span>;</span>
<span>private</span> <span>boolean</span><span>[</span><span>]</span><span>[</span><span>]</span> colsUsed <span>=</span> <span>new</span> <span>boolean</span><span>[</span><span>9</span><span>]</span><span>[</span><span>10</span><span>]</span><span>;</span>
<span>private</span> <span>boolean</span><span>[</span><span>]</span><span>[</span><span>]</span> cubesUsed <span>=</span> <span>new</span> <span>boolean</span><span>[</span><span>9</span><span>]</span><span>[</span><span>10</span><span>]</span><span>;</span>
<span>private</span> <span>char</span><span>[</span><span>]</span><span>[</span><span>]</span> board<span>;</span>

<span>public</span> <span>void</span> <span>solveSudoku</span><span>(</span><span>char</span><span>[</span><span>]</span><span>[</span><span>]</span> board<span>)</span> <span>{</span>
    <span>this</span><span>.</span>board <span>=</span> board<span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>9</span><span>;</span> i<span>++</span><span>)</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> <span>9</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>board<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>==</span> <span>'.'</span><span>)</span> <span>{</span>
                <span>continue</span><span>;</span>
            <span>}</span>
            <span>int</span> num <span>=</span> board<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>-</span> <span>'0'</span><span>;</span>
            rowsUsed<span>[</span>i<span>]</span><span>[</span>num<span>]</span> <span>=</span> <span>true</span><span>;</span>
            colsUsed<span>[</span>j<span>]</span><span>[</span>num<span>]</span> <span>=</span> <span>true</span><span>;</span>
            cubesUsed<span>[</span><span>cubeNum</span><span>(</span>i<span>,</span> j<span>)</span><span>]</span><span>[</span>num<span>]</span> <span>=</span> <span>true</span><span>;</span>
        <span>}</span>
        <span>backtracking</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>boolean</span> <span>backtracking</span><span>(</span><span>int</span> row<span>,</span> <span>int</span> col<span>)</span> <span>{</span>
    <span>while</span> <span>(</span>row <span>&lt;</span> <span>9</span> <span>&amp;&amp;</span> board<span>[</span>row<span>]</span><span>[</span>col<span>]</span> <span>!=</span> <span>'.'</span><span>)</span> <span>{</span>
        row <span>=</span> col <span>==</span> <span>8</span> <span>?</span> row <span>+</span> <span>1</span> <span>:</span> row<span>;</span>
        col <span>=</span> col <span>==</span> <span>8</span> <span>?</span> <span>0</span> <span>:</span> col <span>+</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>row <span>==</span> <span>9</span><span>)</span> <span>{</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> num <span>=</span> <span>1</span><span>;</span> num <span>&lt;=</span> <span>9</span><span>;</span> num<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>rowsUsed<span>[</span>row<span>]</span><span>[</span>num<span>]</span> <span>||</span> colsUsed<span>[</span>col<span>]</span><span>[</span>num<span>]</span> <span>||</span> cubesUsed<span>[</span><span>cubeNum</span><span>(</span>row<span>,</span> col<span>)</span><span>]</span><span>[</span>num<span>]</span><span>)</span> <span>{</span>
            <span>continue</span><span>;</span>
        <span>}</span>
        rowsUsed<span>[</span>row<span>]</span><span>[</span>num<span>]</span> <span>=</span> colsUsed<span>[</span>col<span>]</span><span>[</span>num<span>]</span> <span>=</span> cubesUsed<span>[</span><span>cubeNum</span><span>(</span>row<span>,</span> col<span>)</span><span>]</span><span>[</span>num<span>]</span> <span>=</span> <span>true</span><span>;</span>
        board<span>[</span>row<span>]</span><span>[</span>col<span>]</span> <span>=</span> <span>(</span><span>char</span><span>)</span> <span>(</span>num <span>+</span> <span>'0'</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span><span>backtracking</span><span>(</span>row<span>,</span> col<span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
        board<span>[</span>row<span>]</span><span>[</span>col<span>]</span> <span>=</span> <span>'.'</span><span>;</span>
        rowsUsed<span>[</span>row<span>]</span><span>[</span>num<span>]</span> <span>=</span> colsUsed<span>[</span>col<span>]</span><span>[</span>num<span>]</span> <span>=</span> cubesUsed<span>[</span><span>cubeNum</span><span>(</span>row<span>,</span> col<span>)</span><span>]</span><span>[</span>num<span>]</span> <span>=</span> <span>false</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>

<span>private</span> <span>int</span> <span>cubeNum</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>
    <span>int</span> r <span>=</span> i <span>/</span> <span>3</span><span>;</span>
    <span>int</span> c <span>=</span> j <span>/</span> <span>3</span><span>;</span>
    <span>return</span> r <span>*</span> <span>3</span> <span>+</span> c<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><h2 id="_15-n-皇后" tabindex="-1"> 15. N 皇后</h2>
<p><a href="https://leetcode.com/problems/n-queens/description/" target="_blank" rel="noopener noreferrer">51. N-Queens (Hard)</a></p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/067b310c-6877-40fe-9dcf-10654e737485.jpg"/> </div><br>
<p>在 n*n 的矩阵中摆放 n 个皇后，并且每个皇后不能在同一行，同一列，同一对角线上，求所有的 n 皇后的解。</p>
<p>一行一行地摆放，在确定一行中的那个皇后应该摆在哪一列时，需要用三个标记数组来确定某一列是否合法，这三个标记数组分别为：列标记数组、45 度对角线标记数组和 135 度对角线标记数组。</p>
<p>45 度对角线标记数组的长度为 2 * n - 1，通过下图可以明确 (r, c) 的位置所在的数组下标为 r + c。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9c422923-1447-4a3b-a4e1-97e663738187.jpg" width="300px"> </div><br>
<p>135 度对角线标记数组的长度也是 2 * n - 1，(r, c) 的位置所在的数组下标为 n - 1 - (r - c)。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7a85e285-e152-4116-b6dc-3fab27ba9437.jpg" width="300px"> </div><br>
<div><pre><code><span>private</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>String</span><span>></span><span>></span></span> solutions<span>;</span>
<span>private</span> <span>char</span><span>[</span><span>]</span><span>[</span><span>]</span> nQueens<span>;</span>
<span>private</span> <span>boolean</span><span>[</span><span>]</span> colUsed<span>;</span>
<span>private</span> <span>boolean</span><span>[</span><span>]</span> diagonals45Used<span>;</span>
<span>private</span> <span>boolean</span><span>[</span><span>]</span> diagonals135Used<span>;</span>
<span>private</span> <span>int</span> n<span>;</span>

<span>public</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>String</span><span>></span><span>></span></span> <span>solveNQueens</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    solutions <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    nQueens <span>=</span> <span>new</span> <span>char</span><span>[</span>n<span>]</span><span>[</span>n<span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>Arrays</span><span>.</span><span>fill</span><span>(</span>nQueens<span>[</span>i<span>]</span><span>,</span> <span>'.'</span><span>)</span><span>;</span>
    <span>}</span>
    colUsed <span>=</span> <span>new</span> <span>boolean</span><span>[</span>n<span>]</span><span>;</span>
    diagonals45Used <span>=</span> <span>new</span> <span>boolean</span><span>[</span><span>2</span> <span>*</span> n <span>-</span> <span>1</span><span>]</span><span>;</span>
    diagonals135Used <span>=</span> <span>new</span> <span>boolean</span><span>[</span><span>2</span> <span>*</span> n <span>-</span> <span>1</span><span>]</span><span>;</span>
    <span>this</span><span>.</span>n <span>=</span> n<span>;</span>
    <span>backtracking</span><span>(</span><span>0</span><span>)</span><span>;</span>
    <span>return</span> solutions<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>backtracking</span><span>(</span><span>int</span> row<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>row <span>==</span> n<span>)</span> <span>{</span>
        <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>char</span><span>[</span><span>]</span> chars <span>:</span> nQueens<span>)</span> <span>{</span>
            list<span>.</span><span>add</span><span>(</span><span>new</span> <span>String</span><span>(</span>chars<span>)</span><span>)</span><span>;</span>
        <span>}</span>
        solutions<span>.</span><span>add</span><span>(</span>list<span>)</span><span>;</span>
        <span>return</span><span>;</span>
    <span>}</span>

    <span>for</span> <span>(</span><span>int</span> col <span>=</span> <span>0</span><span>;</span> col <span>&lt;</span> n<span>;</span> col<span>++</span><span>)</span> <span>{</span>
        <span>int</span> diagonals45Idx <span>=</span> row <span>+</span> col<span>;</span>
        <span>int</span> diagonals135Idx <span>=</span> n <span>-</span> <span>1</span> <span>-</span> <span>(</span>row <span>-</span> col<span>)</span><span>;</span>
        <span>if</span> <span>(</span>colUsed<span>[</span>col<span>]</span> <span>||</span> diagonals45Used<span>[</span>diagonals45Idx<span>]</span> <span>||</span> diagonals135Used<span>[</span>diagonals135Idx<span>]</span><span>)</span> <span>{</span>
            <span>continue</span><span>;</span>
        <span>}</span>
        nQueens<span>[</span>row<span>]</span><span>[</span>col<span>]</span> <span>=</span> <span>'Q'</span><span>;</span>
        colUsed<span>[</span>col<span>]</span> <span>=</span> diagonals45Used<span>[</span>diagonals45Idx<span>]</span> <span>=</span> diagonals135Used<span>[</span>diagonals135Idx<span>]</span> <span>=</span> <span>true</span><span>;</span>
        <span>backtracking</span><span>(</span>row <span>+</span> <span>1</span><span>)</span><span>;</span>
        colUsed<span>[</span>col<span>]</span> <span>=</span> diagonals45Used<span>[</span>diagonals45Idx<span>]</span> <span>=</span> diagonals135Used<span>[</span>diagonals135Idx<span>]</span> <span>=</span> <span>false</span><span>;</span>
        nQueens<span>[</span>row<span>]</span><span>[</span>col<span>]</span> <span>=</span> <span>'.'</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>素数分解</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E6%95%B0%E5%AD%A6.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E6%95%B0%E5%AD%A6.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">素数分解</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>

<h1 id="素数分解" tabindex="-1"> 素数分解</h1>
<p>每一个数都可以分解成素数的乘积，例如 84 = 2<sup>2</sup> * 3<sup>1</sup> * 5<sup>0</sup> * 7<sup>1</sup> * 11<sup>0</sup> * 13<sup>0</sup> * 17<sup>0</sup> * …</p>
<h1 id="整除" tabindex="-1"> 整除</h1>
<p>令 x = 2<sup>m0</sup> * 3<sup>m1</sup> * 5<sup>m2</sup> * 7<sup>m3</sup> * 11<sup>m4</sup> * …</p>
<p>令 y = 2<sup>n0</sup> * 3<sup>n1</sup> * 5<sup>n2</sup> * 7<sup>n3</sup> * 11<sup>n4</sup> * …</p>
<p>如果 x 整除 y（y mod x == 0），则对于所有 i，mi &lt;= ni。</p>
<h1 id="最大公约数最小公倍数" tabindex="-1"> 最大公约数最小公倍数</h1>
<p>x 和 y 的最大公约数为：gcd(x,y) =  2<sup>min(m0,n0)</sup> * 3<sup>min(m1,n1)</sup> * 5<sup>min(m2,n2)</sup> * ...</p>
<p>x 和 y 的最小公倍数为：lcm(x,y) =  2<sup>max(m0,n0)</sup> * 3<sup>max(m1,n1)</sup> * 5<sup>max(m2,n2)</sup> * ...</p>
<h2 id="_1-生成素数序列" tabindex="-1"> 1. 生成素数序列</h2>
<p><a href="https://leetcode.com/problems/count-primes/description/" target="_blank" rel="noopener noreferrer">204. Count Primes (Easy)</a></p>
<p>埃拉托斯特尼筛法在每次找到一个素数时，将能被素数整除的数排除掉。</p>
<div><pre><code><span>public</span> <span>int</span> <span>countPrimes</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>boolean</span><span>[</span><span>]</span> notPrimes <span>=</span> <span>new</span> <span>boolean</span><span>[</span>n <span>+</span> <span>1</span><span>]</span><span>;</span>
    <span>int</span> count <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>notPrimes<span>[</span>i<span>]</span><span>)</span> <span>{</span>
            <span>continue</span><span>;</span>
        <span>}</span>
        count<span>++</span><span>;</span>
        <span>// 从 i * i 开始，因为如果 k &lt; i，那么 k * i 在之前就已经被去除过了</span>
        <span>for</span> <span>(</span><span>long</span> j <span>=</span> <span>(</span><span>long</span><span>)</span> <span>(</span>i<span>)</span> <span>*</span> i<span>;</span> j <span>&lt;</span> n<span>;</span> j <span>+=</span> i<span>)</span> <span>{</span>
            notPrimes<span>[</span><span>(</span><span>int</span><span>)</span> j<span>]</span> <span>=</span> <span>true</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> count<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="_2-最大公约数" tabindex="-1"> 2. 最大公约数</h2>
<div><pre><code><span>int</span> <span>gcd</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>
    <span>return</span> b <span>==</span> <span>0</span> <span>?</span> a <span>:</span> <span>gcd</span><span>(</span>b<span>,</span> a <span>%</span> b<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><p>最小公倍数为两数的乘积除以最大公约数。</p>
<div><pre><code><span>int</span> <span>lcm</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>
    <span>return</span> a <span>*</span> b <span>/</span> <span>gcd</span><span>(</span>a<span>,</span> b<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h2 id="_3-使用位操作和减法求解最大公约数" tabindex="-1"> 3. 使用位操作和减法求解最大公约数</h2>
<p></p>
<p>对于 a 和 b 的最大公约数 f(a, b)，有：</p>
<ul>
<li>如果 a 和 b 均为偶数，f(a, b) = 2*f(a/2, b/2);</li>
<li>如果 a 是偶数 b 是奇数，f(a, b) = f(a/2, b);</li>
<li>如果 b 是偶数 a 是奇数，f(a, b) = f(a, b/2);</li>
<li>如果 a 和 b 均为奇数，f(a, b) = f(b, a-b);</li>
</ul>
<p>乘 2 和除 2 都可以转换为移位操作。</p>
<div><pre><code><span>public</span> <span>int</span> <span>gcd</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>a <span>&lt;</span> b<span>)</span> <span>{</span>
        <span>return</span> <span>gcd</span><span>(</span>b<span>,</span> a<span>)</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>b <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> a<span>;</span>
    <span>}</span>
    <span>boolean</span> isAEven <span>=</span> <span>isEven</span><span>(</span>a<span>)</span><span>,</span> isBEven <span>=</span> <span>isEven</span><span>(</span>b<span>)</span><span>;</span>
    <span>if</span> <span>(</span>isAEven <span>&amp;&amp;</span> isBEven<span>)</span> <span>{</span>
        <span>return</span> <span>2</span> <span>*</span> <span>gcd</span><span>(</span>a <span>>></span> <span>1</span><span>,</span> b <span>>></span> <span>1</span><span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>isAEven <span>&amp;&amp;</span> <span>!</span>isBEven<span>)</span> <span>{</span>
        <span>return</span> <span>gcd</span><span>(</span>a <span>>></span> <span>1</span><span>,</span> b<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>!</span>isAEven <span>&amp;&amp;</span> isBEven<span>)</span> <span>{</span>
        <span>return</span> <span>gcd</span><span>(</span>a<span>,</span> b <span>>></span> <span>1</span><span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>return</span> <span>gcd</span><span>(</span>b<span>,</span> a <span>-</span> b<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h1 id="进制转换" tabindex="-1"> 进制转换</h1>
<h2 id="_1-7-进制" tabindex="-1"> 1. 7 进制</h2>
<p><a href="https://leetcode.com/problems/base-7/description/" target="_blank" rel="noopener noreferrer">504. Base 7 (Easy)</a></p>
<div><pre><code><span>public</span> <span>String</span> <span>convertToBase7</span><span>(</span><span>int</span> num<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>num <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>"0"</span><span>;</span>
    <span>}</span>
    <span>StringBuilder</span> sb <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
    <span>boolean</span> isNegative <span>=</span> num <span>&lt;</span> <span>0</span><span>;</span>
    <span>if</span> <span>(</span>isNegative<span>)</span> <span>{</span>
        num <span>=</span> <span>-</span>num<span>;</span>
    <span>}</span>
    <span>while</span> <span>(</span>num <span>></span> <span>0</span><span>)</span> <span>{</span>
        sb<span>.</span><span>append</span><span>(</span>num <span>%</span> <span>7</span><span>)</span><span>;</span>
        num <span>/=</span> <span>7</span><span>;</span>
    <span>}</span>
    <span>String</span> ret <span>=</span> sb<span>.</span><span>reverse</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> isNegative <span>?</span> <span>"-"</span> <span>+</span> ret <span>:</span> ret<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>Java 中 static String toString(int num, int radix) 可以将一个整数转换为 radix 进制表示的字符串。</p>
<div><pre><code><span>public</span> <span>String</span> <span>convertToBase7</span><span>(</span><span>int</span> num<span>)</span> <span>{</span>
    <span>return</span> <span>Integer</span><span>.</span><span>toString</span><span>(</span>num<span>,</span> <span>7</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h2 id="_2-16-进制" tabindex="-1"> 2. 16 进制</h2>
<p><a href="https://leetcode.com/problems/convert-a-number-to-hexadecimal/description/" target="_blank" rel="noopener noreferrer">405. Convert a Number to Hexadecimal (Easy)</a></p>
<div><pre><code>Input:
26

Output:
"1a"

Input:
-1

Output:
"ffffffff"
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>负数要用它的补码形式。</p>
<div><pre><code><span>public</span> <span>String</span> <span>toHex</span><span>(</span><span>int</span> num<span>)</span> <span>{</span>
    <span>char</span><span>[</span><span>]</span> map <span>=</span> <span>{</span><span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span> <span>'a'</span><span>,</span> <span>'b'</span><span>,</span> <span>'c'</span><span>,</span> <span>'d'</span><span>,</span> <span>'e'</span><span>,</span> <span>'f'</span><span>}</span><span>;</span>
    <span>if</span> <span>(</span>num <span>==</span> <span>0</span><span>)</span> <span>return</span> <span>"0"</span><span>;</span>
    <span>StringBuilder</span> sb <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
    <span>while</span> <span>(</span>num <span>!=</span> <span>0</span><span>)</span> <span>{</span>
        sb<span>.</span><span>append</span><span>(</span>map<span>[</span>num <span>&amp;</span> <span>0b1111</span><span>]</span><span>)</span><span>;</span>
        num <span>>>>=</span> <span>4</span><span>;</span> <span>// 因为考虑的是补码形式，因此符号位就不能有特殊的意义，需要使用无符号右移，左边填 0</span>
    <span>}</span>
    <span>return</span> sb<span>.</span><span>reverse</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="_3-26-进制" tabindex="-1"> 3. 26 进制</h2>
<p><a href="https://leetcode.com/problems/excel-sheet-column-title/description/" target="_blank" rel="noopener noreferrer">168. Excel Sheet Column Title (Easy)</a></p>
<div><pre><code>1 -> A
2 -> B
3 -> C
...
26 -> Z
27 -> AA
28 -> AB
</code></pre></div><p>因为是从 1 开始计算的，而不是从 0 开始，因此需要对 n 执行 -1 操作。</p>
<div><pre><code><span>public</span> <span>String</span> <span>convertToTitle</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>n <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>""</span><span>;</span>
    <span>}</span>
    n<span>--</span><span>;</span>
    <span>return</span> <span>convertToTitle</span><span>(</span>n <span>/</span> <span>26</span><span>)</span> <span>+</span> <span>(</span><span>char</span><span>)</span> <span>(</span>n <span>%</span> <span>26</span> <span>+</span> <span>'A'</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h1 id="阶乘" tabindex="-1"> 阶乘</h1>
<h2 id="_1-统计阶乘尾部有多少个-0" tabindex="-1"> 1. 统计阶乘尾部有多少个 0</h2>
<p><a href="https://leetcode.com/problems/factorial-trailing-zeroes/description/" target="_blank" rel="noopener noreferrer">172. Factorial Trailing Zeroes (Easy)</a></p>
<p>尾部的 0 由 2 * 5 得来，2 的数量明显多于 5 的数量，因此只要统计有多少个 5 即可。</p>
<p>对于一个数 N，它所包含 5 的个数为：N/5 + N/5<sup>2</sup> + N/5<sup>3</sup> + ...，其中 N/5 表示不大于 N 的数中 5 的倍数贡献一个 5，N/5<sup>2</sup> 表示不大于 N 的数中 5<sup>2</sup> 的倍数再贡献一个 5 ...。</p>
<div><pre><code><span>public</span> <span>int</span> <span>trailingZeroes</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>return</span> n <span>==</span> <span>0</span> <span>?</span> <span>0</span> <span>:</span> n <span>/</span> <span>5</span> <span>+</span> <span>trailingZeroes</span><span>(</span>n <span>/</span> <span>5</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><p>如果统计的是 N! 的二进制表示中最低位 1 的位置，只要统计有多少个 2 即可，该题目出自  。和求解有多少个 5 一样，2 的个数为 N/2 + N/2<sup>2</sup> + N/2<sup>3</sup> + ...</p>
<h1 id="字符串加法减法" tabindex="-1"> 字符串加法减法</h1>
<h2 id="_1-二进制加法" tabindex="-1"> 1. 二进制加法</h2>
<p><a href="https://leetcode.com/problems/add-binary/description/" target="_blank" rel="noopener noreferrer">67. Add Binary (Easy)</a></p>
<div><pre><code>a = "11"
b = "1"
Return "100".
</code></pre></div><div><pre><code><span>public</span> <span>String</span> <span>addBinary</span><span>(</span><span>String</span> a<span>,</span> <span>String</span> b<span>)</span> <span>{</span>
    <span>int</span> i <span>=</span> a<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>,</span> j <span>=</span> b<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>,</span> carry <span>=</span> <span>0</span><span>;</span>
    <span>StringBuilder</span> str <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
    <span>while</span> <span>(</span>carry <span>==</span> <span>1</span> <span>||</span> i <span>>=</span> <span>0</span> <span>||</span> j <span>>=</span> <span>0</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>i <span>>=</span> <span>0</span> <span>&amp;&amp;</span> a<span>.</span><span>charAt</span><span>(</span>i<span>--</span><span>)</span> <span>==</span> <span>'1'</span><span>)</span> <span>{</span>
            carry<span>++</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>j <span>>=</span> <span>0</span> <span>&amp;&amp;</span> b<span>.</span><span>charAt</span><span>(</span>j<span>--</span><span>)</span> <span>==</span> <span>'1'</span><span>)</span> <span>{</span>
            carry<span>++</span><span>;</span>
        <span>}</span>
        str<span>.</span><span>append</span><span>(</span>carry <span>%</span> <span>2</span><span>)</span><span>;</span>
        carry <span>/=</span> <span>2</span><span>;</span>
    <span>}</span>
    <span>return</span> str<span>.</span><span>reverse</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="_2-字符串加法" tabindex="-1"> 2. 字符串加法</h2>
<p><a href="https://leetcode.com/problems/add-strings/description/" target="_blank" rel="noopener noreferrer">415. Add Strings (Easy)</a></p>
<p>字符串的值为非负整数。</p>
<div><pre><code><span>public</span> <span>String</span> <span>addStrings</span><span>(</span><span>String</span> num1<span>,</span> <span>String</span> num2<span>)</span> <span>{</span>
    <span>StringBuilder</span> str <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
    <span>int</span> carry <span>=</span> <span>0</span><span>,</span> i <span>=</span> num1<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>,</span> j <span>=</span> num2<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span>carry <span>==</span> <span>1</span> <span>||</span> i <span>>=</span> <span>0</span> <span>||</span> j <span>>=</span> <span>0</span><span>)</span> <span>{</span>
        <span>int</span> x <span>=</span> i <span>&lt;</span> <span>0</span> <span>?</span> <span>0</span> <span>:</span> num1<span>.</span><span>charAt</span><span>(</span>i<span>--</span><span>)</span> <span>-</span> <span>'0'</span><span>;</span>
        <span>int</span> y <span>=</span> j <span>&lt;</span> <span>0</span> <span>?</span> <span>0</span> <span>:</span> num2<span>.</span><span>charAt</span><span>(</span>j<span>--</span><span>)</span> <span>-</span> <span>'0'</span><span>;</span>
        str<span>.</span><span>append</span><span>(</span><span>(</span>x <span>+</span> y <span>+</span> carry<span>)</span> <span>%</span> <span>10</span><span>)</span><span>;</span>
        carry <span>=</span> <span>(</span>x <span>+</span> y <span>+</span> carry<span>)</span> <span>/</span> <span>10</span><span>;</span>
    <span>}</span>
    <span>return</span> str<span>.</span><span>reverse</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h1 id="相遇问题" tabindex="-1"> 相遇问题</h1>
<h2 id="_1-改变数组元素使所有的数组元素都相等" tabindex="-1"> 1. 改变数组元素使所有的数组元素都相等</h2>
<p><a href="https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/" target="_blank" rel="noopener noreferrer">462. Minimum Moves to Equal Array Elements II (Medium)</a></p>
<div><pre><code>Input:
[1,2,3]

Output:
2

Explanation:
Only two moves are needed (remember each move increments or decrements one element):

[1,2,3]  =>  [2,2,3]  =>  [2,2,2]
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>每次可以对一个数组元素加一或者减一，求最小的改变次数。</p>
<p>这是个典型的相遇问题，移动距离最小的方式是所有元素都移动到中位数。理由如下：</p>
<p>设 m 为中位数。a 和 b 是 m 两边的两个元素，且 b &gt; a。要使 a 和 b 相等，它们总共移动的次数为 b - a，这个值等于 (b - m) + (m - a)，也就是把这两个数移动到中位数的移动次数。</p>
<p>设数组长度为 N，则可以找到 N/2 对 a 和 b 的组合，使它们都移动到 m 的位置。</p>
<p><strong>解法 1</strong></p>
<p>先排序，时间复杂度：O(NlogN)</p>
<div><pre><code><span>public</span> <span>int</span> <span>minMoves2</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>Arrays</span><span>.</span><span>sort</span><span>(</span>nums<span>)</span><span>;</span>
    <span>int</span> move <span>=</span> <span>0</span><span>;</span>
    <span>int</span> l <span>=</span> <span>0</span><span>,</span> h <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span>l <span>&lt;=</span> h<span>)</span> <span>{</span>
        move <span>+=</span> nums<span>[</span>h<span>]</span> <span>-</span> nums<span>[</span>l<span>]</span><span>;</span>
        l<span>++</span><span>;</span>
        h<span>--</span><span>;</span>
    <span>}</span>
    <span>return</span> move<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>解法 2</strong></p>
<p>使用快速选择找到中位数，时间复杂度 O(N)</p>
<div><pre><code><span>public</span> <span>int</span> <span>minMoves2</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>int</span> move <span>=</span> <span>0</span><span>;</span>
    <span>int</span> median <span>=</span> <span>findKthSmallest</span><span>(</span>nums<span>,</span> nums<span>.</span>length <span>/</span> <span>2</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
        move <span>+=</span> <span>Math</span><span>.</span><span>abs</span><span>(</span>num <span>-</span> median<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> move<span>;</span>
<span>}</span>

<span>private</span> <span>int</span> <span>findKthSmallest</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
    <span>int</span> l <span>=</span> <span>0</span><span>,</span> h <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span>l <span>&lt;</span> h<span>)</span> <span>{</span>
        <span>int</span> j <span>=</span> <span>partition</span><span>(</span>nums<span>,</span> l<span>,</span> h<span>)</span><span>;</span>
        <span>if</span> <span>(</span>j <span>==</span> k<span>)</span> <span>{</span>
            <span>break</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>j <span>&lt;</span> k<span>)</span> <span>{</span>
            l <span>=</span> j <span>+</span> <span>1</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            h <span>=</span> j <span>-</span> <span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> nums<span>[</span>k<span>]</span><span>;</span>
<span>}</span>

<span>private</span> <span>int</span> <span>partition</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> l<span>,</span> <span>int</span> h<span>)</span> <span>{</span>
    <span>int</span> i <span>=</span> l<span>,</span> j <span>=</span> h <span>+</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
        <span>while</span> <span>(</span>nums<span>[</span><span>++</span>i<span>]</span> <span>&lt;</span> nums<span>[</span>l<span>]</span> <span>&amp;&amp;</span> i <span>&lt;</span> h<span>)</span> <span>;</span>
        <span>while</span> <span>(</span>nums<span>[</span><span>--</span>j<span>]</span> <span>></span> nums<span>[</span>l<span>]</span> <span>&amp;&amp;</span> j <span>></span> l<span>)</span> <span>;</span>
        <span>if</span> <span>(</span>i <span>>=</span> j<span>)</span> <span>{</span>
            <span>break</span><span>;</span>
        <span>}</span>
        <span>swap</span><span>(</span>nums<span>,</span> i<span>,</span> j<span>)</span><span>;</span>
    <span>}</span>
    <span>swap</span><span>(</span>nums<span>,</span> l<span>,</span> j<span>)</span><span>;</span>
    <span>return</span> j<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>
    <span>int</span> tmp <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
    nums<span>[</span>i<span>]</span> <span>=</span> nums<span>[</span>j<span>]</span><span>;</span>
    nums<span>[</span>j<span>]</span> <span>=</span> tmp<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h1 id="多数投票问题" tabindex="-1"> 多数投票问题</h1>
<h2 id="_1-数组中出现次数多于-n-2-的元素" tabindex="-1"> 1. 数组中出现次数多于 n / 2 的元素</h2>
<p><a href="https://leetcode.com/problems/majority-element/description/" target="_blank" rel="noopener noreferrer">169. Majority Element (Easy)</a></p>
<p>先对数组排序，最中间那个数出现次数一定多于 n / 2。</p>
<div><pre><code><span>public</span> <span>int</span> <span>majorityElement</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>Arrays</span><span>.</span><span>sort</span><span>(</span>nums<span>)</span><span>;</span>
    <span>return</span> nums<span>[</span>nums<span>.</span>length <span>/</span> <span>2</span><span>]</span><span>;</span>
<span>}</span>
</code></pre></div><p>可以利用 Boyer-Moore Majority Vote Algorithm 来解决这个问题，使得时间复杂度为 O(N)。可以这么理解该算法：使用 cnt 来统计一个元素出现的次数，当遍历到的元素和统计元素不相等时，令 cnt--。如果前面查找了 i 个元素，且 cnt == 0，说明前 i 个元素没有 majority，或者有 majority，但是出现的次数少于 i / 2，因为如果多于 i / 2 的话 cnt 就一定不会为 0。此时剩下的 n - i 个元素中，majority 的数目依然多于 (n - i) / 2，因此继续查找就能找出 majority。</p>
<div><pre><code><span>public</span> <span>int</span> <span>majorityElement</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>int</span> cnt <span>=</span> <span>0</span><span>,</span> majority <span>=</span> nums<span>[</span><span>0</span><span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
        majority <span>=</span> <span>(</span>cnt <span>==</span> <span>0</span><span>)</span> <span>?</span> num <span>:</span> majority<span>;</span>
        cnt <span>=</span> <span>(</span>majority <span>==</span> num<span>)</span> <span>?</span> cnt <span>+</span> <span>1</span> <span>:</span> cnt <span>-</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>return</span> majority<span>;</span>
<span>}</span>
</code></pre></div><h1 id="其它" tabindex="-1"> 其它</h1>
<h2 id="_1-平方数" tabindex="-1"> 1. 平方数</h2>
<p><a href="https://leetcode.com/problems/valid-perfect-square/description/" target="_blank" rel="noopener noreferrer">367. Valid Perfect Square (Easy)</a></p>
<div><pre><code>Input: 16
Returns: True
</code></pre></div><p>平方序列：1,4,9,16,..</p>
<p>间隔：3,5,7,...</p>
<p>间隔为等差数列，使用这个特性可以得到从 1 开始的平方序列。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>isPerfectSquare</span><span>(</span><span>int</span> num<span>)</span> <span>{</span>
    <span>int</span> subNum <span>=</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span>num <span>></span> <span>0</span><span>)</span> <span>{</span>
        num <span>-=</span> subNum<span>;</span>
        subNum <span>+=</span> <span>2</span><span>;</span>
    <span>}</span>
    <span>return</span> num <span>==</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div><h2 id="_2-3-的-n-次方" tabindex="-1"> 2. 3 的 n 次方</h2>
<p><a href="https://leetcode.com/problems/power-of-three/description/" target="_blank" rel="noopener noreferrer">326. Power of Three (Easy)</a></p>
<div><pre><code><span>public</span> <span>boolean</span> <span>isPowerOfThree</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>return</span> n <span>></span> <span>0</span> <span>&amp;&amp;</span> <span>(</span><span>1162261467</span> <span>%</span> n <span>==</span> <span>0</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h2 id="_3-乘积数组" tabindex="-1"> 3. 乘积数组</h2>
<p><a href="https://leetcode.com/problems/product-of-array-except-self/description/" target="_blank" rel="noopener noreferrer">238. Product of Array Except Self (Medium)</a></p>
<div><pre><code>For example, given [1,2,3,4], return [24,12,8,6].
</code></pre></div><p>给定一个数组，创建一个新数组，新数组的每个元素为原始数组中除了该位置上的元素之外所有元素的乘积。</p>
<p>要求时间复杂度为 O(N)，并且不能使用除法。</p>
<div><pre><code><span>public</span> <span>int</span><span>[</span><span>]</span> <span>productExceptSelf</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>int</span> n <span>=</span> nums<span>.</span>length<span>;</span>
    <span>int</span><span>[</span><span>]</span> products <span>=</span> <span>new</span> <span>int</span><span>[</span>n<span>]</span><span>;</span>
    <span>Arrays</span><span>.</span><span>fill</span><span>(</span>products<span>,</span> <span>1</span><span>)</span><span>;</span>
    <span>int</span> left <span>=</span> <span>1</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        left <span>*=</span> nums<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>;</span>
        products<span>[</span>i<span>]</span> <span>*=</span> left<span>;</span>
    <span>}</span>
    <span>int</span> right <span>=</span> <span>1</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> n <span>-</span> <span>2</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span> <span>{</span>
        right <span>*=</span> nums<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>;</span>
        products<span>[</span>i<span>]</span> <span>*=</span> right<span>;</span>
    <span>}</span>
    <span>return</span> products<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="_4-找出数组中的乘积最大的三个数" tabindex="-1"> 4. 找出数组中的乘积最大的三个数</h2>
<p><a href="https://leetcode.com/problems/maximum-product-of-three-numbers/description/" target="_blank" rel="noopener noreferrer">628. Maximum Product of Three Numbers (Easy)</a></p>
<div><pre><code>Input: [1,2,3,4]
Output: 24
</code></pre></div><div><pre><code><span>public</span> <span>int</span> <span>maximumProduct</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>int</span> max1 <span>=</span> <span>Integer</span><span>.</span>MIN_VALUE<span>,</span> max2 <span>=</span> <span>Integer</span><span>.</span>MIN_VALUE<span>,</span> max3 <span>=</span> <span>Integer</span><span>.</span>MIN_VALUE<span>,</span> min1 <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>,</span> min2 <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>;</span>
    <span>for</span> <span>(</span><span>int</span> n <span>:</span> nums<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>n <span>></span> max1<span>)</span> <span>{</span>
            max3 <span>=</span> max2<span>;</span>
            max2 <span>=</span> max1<span>;</span>
            max1 <span>=</span> n<span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>n <span>></span> max2<span>)</span> <span>{</span>
            max3 <span>=</span> max2<span>;</span>
            max2 <span>=</span> n<span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>n <span>></span> max3<span>)</span> <span>{</span>
            max3 <span>=</span> n<span>;</span>
        <span>}</span>

        <span>if</span> <span>(</span>n <span>&lt;</span> min1<span>)</span> <span>{</span>
            min2 <span>=</span> min1<span>;</span>
            min1 <span>=</span> n<span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>n <span>&lt;</span> min2<span>)</span> <span>{</span>
            min2 <span>=</span> n<span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>Math</span><span>.</span><span>max</span><span>(</span>max1<span>*</span>max2<span>*</span>max3<span>,</span> max1<span>*</span>min1<span>*</span>min2<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>1. 把数组中的 0 移到末尾</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E6%95%B0%E7%BB%84%E4%B8%8E%E7%9F%A9%E9%98%B5.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E6%95%B0%E7%BB%84%E4%B8%8E%E7%9F%A9%E9%98%B5.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">1. 把数组中的 0 移到末尾</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<h1 id="_1-把数组中的-0-移到末尾" tabindex="-1"> 1. 把数组中的 0 移到末尾</h1>
<p><a href="https://leetcode.com/problems/move-zeroes/description/" target="_blank" rel="noopener noreferrer">283. Move Zeroes (Easy)</a></p>
<div><pre><code>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].
</code></pre></div><div><pre><code><span>public</span> <span>void</span> <span>moveZeroes</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>int</span> idx <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>num <span>!=</span> <span>0</span><span>)</span> <span>{</span>
            nums<span>[</span>idx<span>++</span><span>]</span> <span>=</span> num<span>;</span>
        <span>}</span>
    <span>}</span>
    <span>while</span> <span>(</span>idx <span>&lt;</span> nums<span>.</span>length<span>)</span> <span>{</span>
        nums<span>[</span>idx<span>++</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h1 id="_2-改变矩阵维度" tabindex="-1"> 2. 改变矩阵维度</h1>
<p><a href="https://leetcode.com/problems/reshape-the-matrix/description/" target="_blank" rel="noopener noreferrer">566. Reshape the Matrix (Easy)</a></p>
<div><pre><code>Input:
nums =
[[1,2],
 [3,4]]
r = 1, c = 4

Output:
[[1,2,3,4]]

Explanation:
The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> <span>matrixReshape</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> r<span>,</span> <span>int</span> c<span>)</span> <span>{</span>
    <span>int</span> m <span>=</span> nums<span>.</span>length<span>,</span> n <span>=</span> nums<span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span>
    <span>if</span> <span>(</span>m <span>*</span> n <span>!=</span> r <span>*</span> c<span>)</span> <span>{</span>
        <span>return</span> nums<span>;</span>
    <span>}</span>
    <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> reshapedNums <span>=</span> <span>new</span> <span>int</span><span>[</span>r<span>]</span><span>[</span>c<span>]</span><span>;</span>
    <span>int</span> index <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> r<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> c<span>;</span> j<span>++</span><span>)</span> <span>{</span>
            reshapedNums<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> nums<span>[</span>index <span>/</span> n<span>]</span><span>[</span>index <span>%</span> n<span>]</span><span>;</span>
            index<span>++</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> reshapedNums<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h1 id="_3-找出数组中最长的连续-1" tabindex="-1"> 3. 找出数组中最长的连续 1</h1>
<p><a href="https://leetcode.com/problems/max-consecutive-ones/description/" target="_blank" rel="noopener noreferrer">485. Max Consecutive Ones (Easy)</a></p>
<div><pre><code><span>public</span> <span>int</span> <span>findMaxConsecutiveOnes</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>int</span> max <span>=</span> <span>0</span><span>,</span> cur <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> x <span>:</span> nums<span>)</span> <span>{</span>
        cur <span>=</span> x <span>==</span> <span>0</span> <span>?</span> <span>0</span> <span>:</span> cur <span>+</span> <span>1</span><span>;</span>
        max <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>max<span>,</span> cur<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> max<span>;</span>
<span>}</span>
</code></pre></div><h1 id="_4-有序矩阵查找" tabindex="-1"> 4. 有序矩阵查找</h1>
<p><a href="https://leetcode.com/problems/search-a-2d-matrix-ii/description/" target="_blank" rel="noopener noreferrer">240. Search a 2D Matrix II (Medium)</a></p>
<div><pre><code>[
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
]
</code></pre></div><div><pre><code><span>public</span> <span>boolean</span> <span>searchMatrix</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> matrix<span>,</span> <span>int</span> target<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>matrix <span>==</span> <span>null</span> <span>||</span> matrix<span>.</span>length <span>==</span> <span>0</span> <span>||</span> matrix<span>[</span><span>0</span><span>]</span><span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>return</span> <span>false</span><span>;</span>
    <span>int</span> m <span>=</span> matrix<span>.</span>length<span>,</span> n <span>=</span> matrix<span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span>
    <span>int</span> row <span>=</span> <span>0</span><span>,</span> col <span>=</span> n <span>-</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span>row <span>&lt;</span> m <span>&amp;&amp;</span> col <span>>=</span> <span>0</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>target <span>==</span> matrix<span>[</span>row<span>]</span><span>[</span>col<span>]</span><span>)</span> <span>return</span> <span>true</span><span>;</span>
        <span>else</span> <span>if</span> <span>(</span>target <span>&lt;</span> matrix<span>[</span>row<span>]</span><span>[</span>col<span>]</span><span>)</span> col<span>--</span><span>;</span>
        <span>else</span> row<span>++</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h1 id="_5-有序矩阵的-kth-element" tabindex="-1"> 5. 有序矩阵的 Kth Element</h1>
<p><a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/" target="_blank" rel="noopener noreferrer">378. Kth Smallest Element in a Sorted Matrix ((Medium))</a></p>
<div><pre><code>matrix = [
  [ 1,  5,  9],
  [10, 11, 13],
  [12, 13, 15]
],
k = 8,

return 13.
</code></pre></div><p>解题参考：<a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/85173" target="_blank" rel="noopener noreferrer">Share my thoughts and Clean Java Code</a></p>
<p>二分查找解法：</p>
<div><pre><code><span>public</span> <span>int</span> <span>kthSmallest</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> matrix<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
    <span>int</span> m <span>=</span> matrix<span>.</span>length<span>,</span> n <span>=</span> matrix<span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span>
    <span>int</span> lo <span>=</span> matrix<span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span><span>,</span> hi <span>=</span> matrix<span>[</span>m <span>-</span> <span>1</span><span>]</span><span>[</span>n <span>-</span> <span>1</span><span>]</span><span>;</span>
    <span>while</span> <span>(</span>lo <span>&lt;=</span> hi<span>)</span> <span>{</span>
        <span>int</span> mid <span>=</span> lo <span>+</span> <span>(</span>hi <span>-</span> lo<span>)</span> <span>/</span> <span>2</span><span>;</span>
        <span>int</span> cnt <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> m<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> n <span>&amp;&amp;</span> matrix<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>&lt;=</span> mid<span>;</span> j<span>++</span><span>)</span> <span>{</span>
                cnt<span>++</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>if</span> <span>(</span>cnt <span>&lt;</span> k<span>)</span> lo <span>=</span> mid <span>+</span> <span>1</span><span>;</span>
        <span>else</span> hi <span>=</span> mid <span>-</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>return</span> lo<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>堆解法：</p>
<div><pre><code><span>public</span> <span>int</span> <span>kthSmallest</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> matrix<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
    <span>int</span> m <span>=</span> matrix<span>.</span>length<span>,</span> n <span>=</span> matrix<span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span>
    <span>PriorityQueue</span><span><span>&lt;</span><span>Tuple</span><span>></span></span> pq <span>=</span> <span>new</span> <span>PriorityQueue</span><span><span>&lt;</span><span>Tuple</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> n<span>;</span> j<span>++</span><span>)</span> pq<span>.</span><span>offer</span><span>(</span><span>new</span> <span>Tuple</span><span>(</span><span>0</span><span>,</span> j<span>,</span> matrix<span>[</span><span>0</span><span>]</span><span>[</span>j<span>]</span><span>)</span><span>)</span><span>;</span>
    <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> k <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span> <span>// 小根堆，去掉 k - 1 个堆顶元素，此时堆顶元素就是第 k 的数</span>
        <span>Tuple</span> t <span>=</span> pq<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
        <span>if</span><span>(</span>t<span>.</span>x <span>==</span> m <span>-</span> <span>1</span><span>)</span> <span>continue</span><span>;</span>
        pq<span>.</span><span>offer</span><span>(</span><span>new</span> <span>Tuple</span><span>(</span>t<span>.</span>x <span>+</span> <span>1</span><span>,</span> t<span>.</span>y<span>,</span> matrix<span>[</span>t<span>.</span>x <span>+</span> <span>1</span><span>]</span><span>[</span>t<span>.</span>y<span>]</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> pq<span>.</span><span>poll</span><span>(</span><span>)</span><span>.</span>val<span>;</span>
<span>}</span>

<span>class</span> <span>Tuple</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Tuple</span><span>></span></span> <span>{</span>
    <span>int</span> x<span>,</span> y<span>,</span> val<span>;</span>
    <span>public</span> <span>Tuple</span><span>(</span><span>int</span> x<span>,</span> <span>int</span> y<span>,</span> <span>int</span> val<span>)</span> <span>{</span>
        <span>this</span><span>.</span>x <span>=</span> x<span>;</span> <span>this</span><span>.</span>y <span>=</span> y<span>;</span> <span>this</span><span>.</span>val <span>=</span> val<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>int</span> <span>compareTo</span><span>(</span><span>Tuple</span> that<span>)</span> <span>{</span>
        <span>return</span> <span>this</span><span>.</span>val <span>-</span> that<span>.</span>val<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h1 id="_6-一个数组元素在-1-n-之间-其中一个数被替换为另一个数-找出重复的数和丢失的数" tabindex="-1"> 6. 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数</h1>
<p><a href="https://leetcode.com/problems/set-mismatch/description/" target="_blank" rel="noopener noreferrer">645. Set Mismatch (Easy)</a></p>
<div><pre><code>Input: nums = [1,2,2,4]
Output: [2,3]
</code></pre></div><div><pre><code>Input: nums = [1,2,2,4]
Output: [2,3]
</code></pre></div><p>最直接的方法是先对数组进行排序，这种方法时间复杂度为 O(NlogN)。本题可以以 O(N) 的时间复杂度、O(1) 空间复杂度来求解。</p>
<p>主要思想是通过交换数组元素，使得数组上的元素在正确的位置上。</p>
<div><pre><code><span>public</span> <span>int</span><span>[</span><span>]</span> <span>findErrorNums</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>while</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>!=</span> i <span>+</span> <span>1</span> <span>&amp;&amp;</span> nums<span>[</span>nums<span>[</span>i<span>]</span> <span>-</span> <span>1</span><span>]</span> <span>!=</span> nums<span>[</span>i<span>]</span><span>)</span> <span>{</span>
            <span>swap</span><span>(</span>nums<span>,</span> i<span>,</span> nums<span>[</span>i<span>]</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>!=</span> i <span>+</span> <span>1</span><span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span>nums<span>[</span>i<span>]</span><span>,</span> i <span>+</span> <span>1</span><span>}</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>
    <span>int</span> tmp <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
    nums<span>[</span>i<span>]</span> <span>=</span> nums<span>[</span>j<span>]</span><span>;</span>
    nums<span>[</span>j<span>]</span> <span>=</span> tmp<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>类似题目：</p>
<ul>
<li><a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/description/" target="_blank" rel="noopener noreferrer">448. Find All Numbers Disappeared in an Array (Easy)</a>，寻找所有丢失的元素</li>
<li><a href="https://leetcode.com/problems/find-all-duplicates-in-an-array/description/" target="_blank" rel="noopener noreferrer">442. Find All Duplicates in an Array (Medium)</a>，寻找所有重复的元素。</li>
</ul>
<h1 id="_7-找出数组中重复的数-数组值在-1-n-之间" tabindex="-1"> 7. 找出数组中重复的数，数组值在 [1, n] 之间</h1>
<p><a href="https://leetcode.com/problems/find-the-duplicate-number/description/" target="_blank" rel="noopener noreferrer">287. Find the Duplicate Number (Medium)</a></p>
<p>要求不能修改数组，也不能使用额外的空间。</p>
<p>二分查找解法：</p>
<div><pre><code><span>public</span> <span>int</span> <span>findDuplicate</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
     <span>int</span> l <span>=</span> <span>1</span><span>,</span> h <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>
     <span>while</span> <span>(</span>l <span>&lt;=</span> h<span>)</span> <span>{</span>
         <span>int</span> mid <span>=</span> l <span>+</span> <span>(</span>h <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
         <span>int</span> cnt <span>=</span> <span>0</span><span>;</span>
         <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
             <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>&lt;=</span> mid<span>)</span> cnt<span>++</span><span>;</span>
         <span>}</span>
         <span>if</span> <span>(</span>cnt <span>></span> mid<span>)</span> h <span>=</span> mid <span>-</span> <span>1</span><span>;</span>
         <span>else</span> l <span>=</span> mid <span>+</span> <span>1</span><span>;</span>
     <span>}</span>
     <span>return</span> l<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>双指针解法，类似于有环链表中找出环的入口：</p>
<div><pre><code><span>public</span> <span>int</span> <span>findDuplicate</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>int</span> slow <span>=</span> nums<span>[</span><span>0</span><span>]</span><span>,</span> fast <span>=</span> nums<span>[</span>nums<span>[</span><span>0</span><span>]</span><span>]</span><span>;</span>
    <span>while</span> <span>(</span>slow <span>!=</span> fast<span>)</span> <span>{</span>
        slow <span>=</span> nums<span>[</span>slow<span>]</span><span>;</span>
        fast <span>=</span> nums<span>[</span>nums<span>[</span>fast<span>]</span><span>]</span><span>;</span>
    <span>}</span>
    fast <span>=</span> <span>0</span><span>;</span>
    <span>while</span> <span>(</span>slow <span>!=</span> fast<span>)</span> <span>{</span>
        slow <span>=</span> nums<span>[</span>slow<span>]</span><span>;</span>
        fast <span>=</span> nums<span>[</span>fast<span>]</span><span>;</span>
    <span>}</span>
    <span>return</span> slow<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h1 id="_8-数组相邻差值的个数" tabindex="-1"> 8. 数组相邻差值的个数</h1>
<p><a href="https://leetcode.com/problems/beautiful-arrangement-ii/description/" target="_blank" rel="noopener noreferrer">667. Beautiful Arrangement II (Medium)</a></p>
<div><pre><code>Input: n = 3, k = 2
Output: [1, 3, 2]
Explanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.
</code></pre></div><p>题目描述：数组元素为 1~n 的整数，要求构建数组，使得相邻元素的差值不相同的个数为 k。</p>
<p>让前 k+1 个元素构建出 k 个不相同的差值，序列为：1 k+1 2 k 3 k-1 ... k/2 k/2+1.</p>
<div><pre><code><span>public</span> <span>int</span><span>[</span><span>]</span> <span>constructArray</span><span>(</span><span>int</span> n<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
    <span>int</span><span>[</span><span>]</span> ret <span>=</span> <span>new</span> <span>int</span><span>[</span>n<span>]</span><span>;</span>
    ret<span>[</span><span>0</span><span>]</span> <span>=</span> <span>1</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>,</span> interval <span>=</span> k<span>;</span> i <span>&lt;=</span> k<span>;</span> i<span>++</span><span>,</span> interval<span>--</span><span>)</span> <span>{</span>
        ret<span>[</span>i<span>]</span> <span>=</span> i <span>%</span> <span>2</span> <span>==</span> <span>1</span> <span>?</span> ret<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>+</span> interval <span>:</span> ret<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>-</span> interval<span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> k <span>+</span> <span>1</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        ret<span>[</span>i<span>]</span> <span>=</span> i <span>+</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h1 id="_9-数组的度" tabindex="-1"> 9. 数组的度</h1>
<p><a href="https://leetcode.com/problems/degree-of-an-array/description/" target="_blank" rel="noopener noreferrer">697. Degree of an Array (Easy)</a></p>
<div><pre><code>Input: [1,2,2,3,1,4,2]
Output: 6
</code></pre></div><p>题目描述：数组的度定义为元素出现的最高频率，例如上面的数组度为 3。要求找到一个最小的子数组，这个子数组的度和原数组一样。</p>
<div><pre><code><span>public</span> <span>int</span> <span>findShortestSubArray</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Integer</span><span>></span></span> numsCnt <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Integer</span><span>></span></span> numsLastIndex <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Integer</span><span>></span></span> numsFirstIndex <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>int</span> num <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
        numsCnt<span>.</span><span>put</span><span>(</span>num<span>,</span> numsCnt<span>.</span><span>getOrDefault</span><span>(</span>num<span>,</span> <span>0</span><span>)</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
        numsLastIndex<span>.</span><span>put</span><span>(</span>num<span>,</span> i<span>)</span><span>;</span>
        <span>if</span> <span>(</span><span>!</span>numsFirstIndex<span>.</span><span>containsKey</span><span>(</span>num<span>)</span><span>)</span> <span>{</span>
            numsFirstIndex<span>.</span><span>put</span><span>(</span>num<span>,</span> i<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>int</span> maxCnt <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
        maxCnt <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>maxCnt<span>,</span> numsCnt<span>.</span><span>get</span><span>(</span>num<span>)</span><span>)</span><span>;</span>
    <span>}</span>
    <span>int</span> ret <span>=</span> nums<span>.</span>length<span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>int</span> num <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
        <span>int</span> cnt <span>=</span> numsCnt<span>.</span><span>get</span><span>(</span>num<span>)</span><span>;</span>
        <span>if</span> <span>(</span>cnt <span>!=</span> maxCnt<span>)</span> <span>continue</span><span>;</span>
        ret <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>ret<span>,</span> numsLastIndex<span>.</span><span>get</span><span>(</span>num<span>)</span> <span>-</span> numsFirstIndex<span>.</span><span>get</span><span>(</span>num<span>)</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h1 id="_10-对角元素相等的矩阵" tabindex="-1"> 10. 对角元素相等的矩阵</h1>
<p><a href="https://leetcode.com/problems/toeplitz-matrix/description/" target="_blank" rel="noopener noreferrer">766. Toeplitz Matrix (Easy)</a></p>
<div><pre><code>1234
5123
9512

In the above grid, the diagonals are "[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]", and in each diagonal all elements are the same, so the answer is True.
</code></pre></div><div><pre><code><span>public</span> <span>boolean</span> <span>isToeplitzMatrix</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> matrix<span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> matrix<span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span><span>check</span><span>(</span>matrix<span>,</span> matrix<span>[</span><span>0</span><span>]</span><span>[</span>i<span>]</span><span>,</span> <span>0</span><span>,</span> i<span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> matrix<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span><span>check</span><span>(</span>matrix<span>,</span> matrix<span>[</span>i<span>]</span><span>[</span><span>0</span><span>]</span><span>,</span> i<span>,</span> <span>0</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>true</span><span>;</span>
<span>}</span>

<span>private</span> <span>boolean</span> <span>check</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> matrix<span>,</span> <span>int</span> expectValue<span>,</span> <span>int</span> row<span>,</span> <span>int</span> col<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>row <span>>=</span> matrix<span>.</span>length <span>||</span> col <span>>=</span> matrix<span>[</span><span>0</span><span>]</span><span>.</span>length<span>)</span> <span>{</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>matrix<span>[</span>row<span>]</span><span>[</span>col<span>]</span> <span>!=</span> expectValue<span>)</span> <span>{</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>check</span><span>(</span>matrix<span>,</span> expectValue<span>,</span> row <span>+</span> <span>1</span><span>,</span> col <span>+</span> <span>1</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h1 id="_11-嵌套数组" tabindex="-1"> 11. 嵌套数组</h1>
<p><a href="https://leetcode.com/problems/array-nesting/description/" target="_blank" rel="noopener noreferrer">565. Array Nesting (Medium)</a></p>
<div><pre><code>Input: A = [5,4,0,3,1,6,2]
Output: 4
Explanation:
A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.

One of the longest S[K]:
S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}
</code></pre></div><p>题目描述：S[i] 表示一个集合，集合的第一个元素是 A[i]，第二个元素是 A[A[i]]，如此嵌套下去。求最大的 S[i]。</p>
<div><pre><code><span>public</span> <span>int</span> <span>arrayNesting</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>int</span> max <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>int</span> cnt <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> i<span>;</span> nums<span>[</span>j<span>]</span> <span>!=</span> <span>-</span><span>1</span><span>;</span> <span>)</span> <span>{</span>
            cnt<span>++</span><span>;</span>
            <span>int</span> t <span>=</span> nums<span>[</span>j<span>]</span><span>;</span>
            nums<span>[</span>j<span>]</span> <span>=</span> <span>-</span><span>1</span><span>;</span> <span>// 标记该位置已经被访问</span>
            j <span>=</span> t<span>;</span>

        <span>}</span>
        max <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>max<span>,</span> cnt<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> max<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h1 id="_12-分隔数组" tabindex="-1"> 12. 分隔数组</h1>
<p><a href="https://leetcode.com/problems/max-chunks-to-make-sorted/description/" target="_blank" rel="noopener noreferrer">769. Max Chunks To Make Sorted (Medium)</a></p>
<div><pre><code>Input: arr = [1,0,2,3,4]
Output: 4
Explanation:
We can split into two chunks, such as [1, 0], [2, 3, 4].
However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.
</code></pre></div><p>题目描述：分隔数组，使得对每部分排序后数组就为有序。</p>
<div><pre><code><span>public</span> <span>int</span> <span>maxChunksToSorted</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>arr <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>0</span><span>;</span>
    <span>int</span> ret <span>=</span> <span>0</span><span>;</span>
    <span>int</span> right <span>=</span> arr<span>[</span><span>0</span><span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        right <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>right<span>,</span> arr<span>[</span>i<span>]</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>right <span>==</span> i<span>)</span> ret<span>++</span><span>;</span>
    <span>}</span>
    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>1. 用栈实现队列</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">1. 用栈实现队列</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<h1 id="_1-用栈实现队列" tabindex="-1"> 1. 用栈实现队列</h1>
<p><a href="https://leetcode.com/problems/implement-queue-using-stacks/description/" target="_blank" rel="noopener noreferrer">232. Implement Queue using Stacks (Easy)</a></p>
<p>栈的顺序为后进先出，而队列的顺序为先进先出。使用两个栈实现队列，一个元素需要经过两个栈才能出队列，在经过第一个栈时元素顺序被反转，经过第二个栈时再次被反转，此时就是先进先出顺序。</p>
<div><pre><code><span>class</span> <span>MyQueue</span> <span>{</span>

    <span>private</span> <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> in <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>private</span> <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> out <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>void</span> <span>push</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
        in<span>.</span><span>push</span><span>(</span>x<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>pop</span><span>(</span><span>)</span> <span>{</span>
        <span>in2out</span><span>(</span><span>)</span><span>;</span>
        <span>return</span> out<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>peek</span><span>(</span><span>)</span> <span>{</span>
        <span>in2out</span><span>(</span><span>)</span><span>;</span>
        <span>return</span> out<span>.</span><span>peek</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>in2out</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>out<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>while</span> <span>(</span><span>!</span>in<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
                out<span>.</span><span>push</span><span>(</span>in<span>.</span><span>pop</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>boolean</span> <span>empty</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> in<span>.</span><span>isEmpty</span><span>(</span><span>)</span> <span>&amp;&amp;</span> out<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><h1 id="_2-用队列实现栈" tabindex="-1"> 2. 用队列实现栈</h1>
<p><a href="https://leetcode.com/problems/implement-stack-using-queues/description/" target="_blank" rel="noopener noreferrer">225. Implement Stack using Queues (Easy)</a></p>
<p>在将一个元素 x 插入队列时，为了维护原来的后进先出顺序，需要让 x 插入队列首部。而队列的默认插入顺序是队列尾部，因此在将 x 插入队列尾部之后，需要让除了 x 之外的所有元素出队列，再入队列。</p>
<div><pre><code><span>class</span> <span>MyStack</span> <span>{</span>

    <span>private</span> <span>Queue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> queue<span>;</span>

    <span>public</span> <span>MyStack</span><span>(</span><span>)</span> <span>{</span>
        queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>push</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
        queue<span>.</span><span>add</span><span>(</span>x<span>)</span><span>;</span>
        <span>int</span> cnt <span>=</span> queue<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>
        <span>while</span> <span>(</span>cnt<span>--</span> <span>></span> <span>1</span><span>)</span> <span>{</span>
            queue<span>.</span><span>add</span><span>(</span>queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>pop</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> queue<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>top</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> queue<span>.</span><span>peek</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>boolean</span> <span>empty</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h1 id="_3-最小值栈" tabindex="-1"> 3. 最小值栈</h1>
<p><a href="https://leetcode.com/problems/min-stack/description/" target="_blank" rel="noopener noreferrer">155. Min Stack (Easy)</a></p>
<div><pre><code><span>class</span> <span>MinStack</span> <span>{</span>

    <span>private</span> <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> dataStack<span>;</span>
    <span>private</span> <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> minStack<span>;</span>
    <span>private</span> <span>int</span> min<span>;</span>

    <span>public</span> <span>MinStack</span><span>(</span><span>)</span> <span>{</span>
        dataStack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        minStack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        min <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>push</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
        dataStack<span>.</span><span>add</span><span>(</span>x<span>)</span><span>;</span>
        min <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>min<span>,</span> x<span>)</span><span>;</span>
        minStack<span>.</span><span>add</span><span>(</span>min<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>pop</span><span>(</span><span>)</span> <span>{</span>
        dataStack<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>
        minStack<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>
        min <span>=</span> minStack<span>.</span><span>isEmpty</span><span>(</span><span>)</span> <span>?</span> <span>Integer</span><span>.</span>MAX_VALUE <span>:</span> minStack<span>.</span><span>peek</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>top</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> dataStack<span>.</span><span>peek</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getMin</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> minStack<span>.</span><span>peek</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>对于实现最小值队列问题，可以先将队列使用栈来实现，然后就将问题转换为最小值栈，这个问题出现在 编程之美：3.7。</p>
<h1 id="_4-用栈实现括号匹配" tabindex="-1"> 4. 用栈实现括号匹配</h1>
<p><a href="https://leetcode.com/problems/valid-parentheses/description/" target="_blank" rel="noopener noreferrer">20. Valid Parentheses (Easy)</a></p>
<div><pre><code>"()[]{}"

Output : true
</code></pre></div><div><pre><code><span>public</span> <span>boolean</span> <span>isValid</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
    <span>Stack</span><span><span>&lt;</span><span>Character</span><span>></span></span> stack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>char</span> c <span>:</span> s<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>c <span>==</span> <span>'('</span> <span>||</span> c <span>==</span> <span>'{'</span> <span>||</span> c <span>==</span> <span>'['</span><span>)</span> <span>{</span>
            stack<span>.</span><span>push</span><span>(</span>c<span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>if</span> <span>(</span>stack<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
                <span>return</span> <span>false</span><span>;</span>
            <span>}</span>
            <span>char</span> cStack <span>=</span> stack<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>
            <span>boolean</span> b1 <span>=</span> c <span>==</span> <span>')'</span> <span>&amp;&amp;</span> cStack <span>!=</span> <span>'('</span><span>;</span>
            <span>boolean</span> b2 <span>=</span> c <span>==</span> <span>']'</span> <span>&amp;&amp;</span> cStack <span>!=</span> <span>'['</span><span>;</span>
            <span>boolean</span> b3 <span>=</span> c <span>==</span> <span>'}'</span> <span>&amp;&amp;</span> cStack <span>!=</span> <span>'{'</span><span>;</span>
            <span>if</span> <span>(</span>b1 <span>||</span> b2 <span>||</span> b3<span>)</span> <span>{</span>
                <span>return</span> <span>false</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> stack<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h1 id="_5-数组中元素与下一个比它大的元素之间的距离" tabindex="-1"> 5. 数组中元素与下一个比它大的元素之间的距离</h1>
<p><a href="https://leetcode.com/problems/daily-temperatures/description/" target="_blank" rel="noopener noreferrer">739. Daily Temperatures (Medium)</a></p>
<div><pre><code>Input: [73, 74, 75, 71, 69, 72, 76, 73]
Output: [1, 1, 4, 2, 1, 1, 0, 0]
</code></pre></div><p>在遍历数组时用栈把数组中的数存起来，如果当前遍历的数比栈顶元素来的大，说明栈顶元素的下一个比它大的数就是当前元素。</p>
<div><pre><code><span>public</span> <span>int</span><span>[</span><span>]</span> <span>dailyTemperatures</span><span>(</span><span>int</span><span>[</span><span>]</span> temperatures<span>)</span> <span>{</span>
    <span>int</span> n <span>=</span> temperatures<span>.</span>length<span>;</span>
    <span>int</span><span>[</span><span>]</span> dist <span>=</span> <span>new</span> <span>int</span><span>[</span>n<span>]</span><span>;</span>
    <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> indexs <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> curIndex <span>=</span> <span>0</span><span>;</span> curIndex <span>&lt;</span> n<span>;</span> curIndex<span>++</span><span>)</span> <span>{</span>
        <span>while</span> <span>(</span><span>!</span>indexs<span>.</span><span>isEmpty</span><span>(</span><span>)</span> <span>&amp;&amp;</span> temperatures<span>[</span>curIndex<span>]</span> <span>></span> temperatures<span>[</span>indexs<span>.</span><span>peek</span><span>(</span><span>)</span><span>]</span><span>)</span> <span>{</span>
            <span>int</span> preIndex <span>=</span> indexs<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>
            dist<span>[</span>preIndex<span>]</span> <span>=</span> curIndex <span>-</span> preIndex<span>;</span>
        <span>}</span>
        indexs<span>.</span><span>add</span><span>(</span>curIndex<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> dist<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h1 id="_6-循环数组中比当前元素大的下一个元素" tabindex="-1"> 6. 循环数组中比当前元素大的下一个元素</h1>
<p><a href="https://leetcode.com/problems/next-greater-element-ii/description/" target="_blank" rel="noopener noreferrer">503. Next Greater Element II (Medium)</a></p>
<div><pre><code>Input: [1,2,1]
Output: [2,-1,2]
Explanation: The first 1's next greater number is 2;
The number 2 can't find next greater number;
The second 1's next greater number needs to search circularly, which is also 2.
</code></pre></div><p>与 739. Daily Temperatures (Medium) 不同的是，数组是循环数组，并且最后要求的不是距离而是下一个元素。</p>
<div><pre><code><span>public</span> <span>int</span><span>[</span><span>]</span> <span>nextGreaterElements</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>int</span> n <span>=</span> nums<span>.</span>length<span>;</span>
    <span>int</span><span>[</span><span>]</span> next <span>=</span> <span>new</span> <span>int</span><span>[</span>n<span>]</span><span>;</span>
    <span>Arrays</span><span>.</span><span>fill</span><span>(</span>next<span>,</span> <span>-</span><span>1</span><span>)</span><span>;</span>
    <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> pre <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n <span>*</span> <span>2</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>int</span> num <span>=</span> nums<span>[</span>i <span>%</span> n<span>]</span><span>;</span>
        <span>while</span> <span>(</span><span>!</span>pre<span>.</span><span>isEmpty</span><span>(</span><span>)</span> <span>&amp;&amp;</span> nums<span>[</span>pre<span>.</span><span>peek</span><span>(</span><span>)</span><span>]</span> <span>&lt;</span> num<span>)</span> <span>{</span>
            next<span>[</span>pre<span>.</span><span>pop</span><span>(</span><span>)</span><span>]</span> <span>=</span> num<span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>i <span>&lt;</span> n<span>)</span><span>{</span>
            pre<span>.</span><span>push</span><span>(</span>i<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> next<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>递归</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E6%A0%91.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E6%A0%91.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">递归</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>

<h1 id="递归" tabindex="-1"> 递归</h1>
<p>一棵树要么是空树，要么有两个指针，每个指针指向一棵树。树是一种递归结构，很多树的问题可以使用递归来处理。</p>
<h2 id="_1-树的高度" tabindex="-1"> 1. 树的高度</h2>
<p><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/" target="_blank" rel="noopener noreferrer">104. Maximum Depth of Binary Tree (Easy)</a></p>
<div><pre><code><span>public</span> <span>int</span> <span>maxDepth</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>0</span><span>;</span>
    <span>return</span> <span>Math</span><span>.</span><span>max</span><span>(</span><span>maxDepth</span><span>(</span>root<span>.</span>left<span>)</span><span>,</span> <span>maxDepth</span><span>(</span>root<span>.</span>right<span>)</span><span>)</span> <span>+</span> <span>1</span><span>;</span>
<span>}</span>
</code></pre></div><h2 id="_2-平衡树" tabindex="-1"> 2. 平衡树</h2>
<p><a href="https://leetcode.com/problems/balanced-binary-tree/description/" target="_blank" rel="noopener noreferrer">110. Balanced Binary Tree (Easy)</a></p>
<div><pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre></div><p>平衡树左右子树高度差都小于等于 1</p>
<div><pre><code><span>private</span> <span>boolean</span> result <span>=</span> <span>true</span><span>;</span>

<span>public</span> <span>boolean</span> <span>isBalanced</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>maxDepth</span><span>(</span>root<span>)</span><span>;</span>
    <span>return</span> result<span>;</span>
<span>}</span>

<span>public</span> <span>int</span> <span>maxDepth</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>0</span><span>;</span>
    <span>int</span> l <span>=</span> <span>maxDepth</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>
    <span>int</span> r <span>=</span> <span>maxDepth</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>
    <span>if</span> <span>(</span><span>Math</span><span>.</span><span>abs</span><span>(</span>l <span>-</span> r<span>)</span> <span>></span> <span>1</span><span>)</span> result <span>=</span> <span>false</span><span>;</span>
    <span>return</span> <span>1</span> <span>+</span> <span>Math</span><span>.</span><span>max</span><span>(</span>l<span>,</span> r<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="_3-两节点的最长路径" tabindex="-1"> 3. 两节点的最长路径</h2>
<p><a href="https://leetcode.com/problems/diameter-of-binary-tree/description/" target="_blank" rel="noopener noreferrer">543. Diameter of Binary Tree (Easy)</a></p>
<div><pre><code>Input:

         1
        / \
       2  3
      / \
     4   5

Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].
</code></pre></div><div><pre><code><span>private</span> <span>int</span> max <span>=</span> <span>0</span><span>;</span>

<span>public</span> <span>int</span> <span>diameterOfBinaryTree</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>depth</span><span>(</span>root<span>)</span><span>;</span>
    <span>return</span> max<span>;</span>
<span>}</span>

<span>private</span> <span>int</span> <span>depth</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>0</span><span>;</span>
    <span>int</span> leftDepth <span>=</span> <span>depth</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>
    <span>int</span> rightDepth <span>=</span> <span>depth</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>
    max <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>max<span>,</span> leftDepth <span>+</span> rightDepth<span>)</span><span>;</span>
    <span>return</span> <span>Math</span><span>.</span><span>max</span><span>(</span>leftDepth<span>,</span> rightDepth<span>)</span> <span>+</span> <span>1</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="_4-翻转树" tabindex="-1"> 4. 翻转树</h2>
<p><a href="https://leetcode.com/problems/invert-binary-tree/description/" target="_blank" rel="noopener noreferrer">226. Invert Binary Tree (Easy)</a></p>
<div><pre><code><span>public</span> <span>TreeNode</span> <span>invertTree</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>null</span><span>;</span>
    <span>TreeNode</span> left <span>=</span> root<span>.</span>left<span>;</span>  <span>// 后面的操作会改变 left 指针，因此先保存下来</span>
    root<span>.</span>left <span>=</span> <span>invertTree</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>
    root<span>.</span>right <span>=</span> <span>invertTree</span><span>(</span>left<span>)</span><span>;</span>
    <span>return</span> root<span>;</span>
<span>}</span>
</code></pre></div><h2 id="_5-归并两棵树" tabindex="-1"> 5. 归并两棵树</h2>
<p><a href="https://leetcode.com/problems/merge-two-binary-trees/description/" target="_blank" rel="noopener noreferrer">617. Merge Two Binary Trees (Easy)</a></p>
<div><pre><code>Input:
       Tree 1                     Tree 2
          1                         2
         / \                       / \
        3   2                     1   3
       /                           \   \
      5                             4   7

Output:
         3
        / \
       4   5
      / \   \
     5   4   7
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code><span>public</span> <span>TreeNode</span> <span>mergeTrees</span><span>(</span><span>TreeNode</span> t1<span>,</span> <span>TreeNode</span> t2<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>t1 <span>==</span> <span>null</span> <span>&amp;&amp;</span> t2 <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>null</span><span>;</span>
    <span>if</span> <span>(</span>t1 <span>==</span> <span>null</span><span>)</span> <span>return</span> t2<span>;</span>
    <span>if</span> <span>(</span>t2 <span>==</span> <span>null</span><span>)</span> <span>return</span> t1<span>;</span>
    <span>TreeNode</span> root <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span>t1<span>.</span>val <span>+</span> t2<span>.</span>val<span>)</span><span>;</span>
    root<span>.</span>left <span>=</span> <span>mergeTrees</span><span>(</span>t1<span>.</span>left<span>,</span> t2<span>.</span>left<span>)</span><span>;</span>
    root<span>.</span>right <span>=</span> <span>mergeTrees</span><span>(</span>t1<span>.</span>right<span>,</span> t2<span>.</span>right<span>)</span><span>;</span>
    <span>return</span> root<span>;</span>
<span>}</span>
</code></pre></div><h2 id="_6-判断路径和是否等于一个数" tabindex="-1"> 6. 判断路径和是否等于一个数</h2>
<p><a href="https://leetcode.com/problems/path-sum/description/" target="_blank" rel="noopener noreferrer">Leetcdoe : 112. Path Sum (Easy)</a></p>
<div><pre><code>Given the below binary tree and sum = 22,

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1

return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>路径和定义为从 root 到 leaf 的所有节点的和。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>hasPathSum</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>int</span> sum<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>false</span><span>;</span>
    <span>if</span> <span>(</span>root<span>.</span>left <span>==</span> <span>null</span> <span>&amp;&amp;</span> root<span>.</span>right <span>==</span> <span>null</span> <span>&amp;&amp;</span> root<span>.</span>val <span>==</span> sum<span>)</span> <span>return</span> <span>true</span><span>;</span>
    <span>return</span> <span>hasPathSum</span><span>(</span>root<span>.</span>left<span>,</span> sum <span>-</span> root<span>.</span>val<span>)</span> <span>||</span> <span>hasPathSum</span><span>(</span>root<span>.</span>right<span>,</span> sum <span>-</span> root<span>.</span>val<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h2 id="_7-统计路径和等于一个数的路径数量" tabindex="-1"> 7. 统计路径和等于一个数的路径数量</h2>
<p><a href="https://leetcode.com/problems/path-sum-iii/description/" target="_blank" rel="noopener noreferrer">437. Path Sum III (Easy)</a></p>
<div><pre><code>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

Return 3. The paths that sum to 8 are:

1.  5 -> 3
2.  5 -> 2 -> 1
3. -3 -> 11
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>路径不一定以 root 开头，也不一定以 leaf 结尾，但是必须连续。</p>
<div><pre><code><span>public</span> <span>int</span> <span>pathSum</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>int</span> sum<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>0</span><span>;</span>
    <span>int</span> ret <span>=</span> <span>pathSumStartWithRoot</span><span>(</span>root<span>,</span> sum<span>)</span> <span>+</span> <span>pathSum</span><span>(</span>root<span>.</span>left<span>,</span> sum<span>)</span> <span>+</span> <span>pathSum</span><span>(</span>root<span>.</span>right<span>,</span> sum<span>)</span><span>;</span>
    <span>return</span> ret<span>;</span>
<span>}</span>

<span>private</span> <span>int</span> <span>pathSumStartWithRoot</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>int</span> sum<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>0</span><span>;</span>
    <span>int</span> ret <span>=</span> <span>0</span><span>;</span>
    <span>if</span> <span>(</span>root<span>.</span>val <span>==</span> sum<span>)</span> ret<span>++</span><span>;</span>
    ret <span>+=</span> <span>pathSumStartWithRoot</span><span>(</span>root<span>.</span>left<span>,</span> sum <span>-</span> root<span>.</span>val<span>)</span> <span>+</span> <span>pathSumStartWithRoot</span><span>(</span>root<span>.</span>right<span>,</span> sum <span>-</span> root<span>.</span>val<span>)</span><span>;</span>
    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="_8-子树" tabindex="-1"> 8. 子树</h2>
<p><a href="https://leetcode.com/problems/subtree-of-another-tree/description/" target="_blank" rel="noopener noreferrer">572. Subtree of Another Tree (Easy)</a></p>
<div><pre><code>Given tree s:
     3
    / \
   4   5
  / \
 1   2

Given tree t:
   4
  / \
 1   2

Return true, because t has the same structure and node values with a subtree of s.

Given tree s:

     3
    / \
   4   5
  / \
 1   2
    /
   0

Given tree t:
   4
  / \
 1   2

Return false.
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><div><pre><code><span>public</span> <span>boolean</span> <span>isSubtree</span><span>(</span><span>TreeNode</span> s<span>,</span> <span>TreeNode</span> t<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>s <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>false</span><span>;</span>
    <span>return</span> <span>isSubtreeWithRoot</span><span>(</span>s<span>,</span> t<span>)</span> <span>||</span> <span>isSubtree</span><span>(</span>s<span>.</span>left<span>,</span> t<span>)</span> <span>||</span> <span>isSubtree</span><span>(</span>s<span>.</span>right<span>,</span> t<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>boolean</span> <span>isSubtreeWithRoot</span><span>(</span><span>TreeNode</span> s<span>,</span> <span>TreeNode</span> t<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>t <span>==</span> <span>null</span> <span>&amp;&amp;</span> s <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>true</span><span>;</span>
    <span>if</span> <span>(</span>t <span>==</span> <span>null</span> <span>||</span> s <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>false</span><span>;</span>
    <span>if</span> <span>(</span>t<span>.</span>val <span>!=</span> s<span>.</span>val<span>)</span> <span>return</span> <span>false</span><span>;</span>
    <span>return</span> <span>isSubtreeWithRoot</span><span>(</span>s<span>.</span>left<span>,</span> t<span>.</span>left<span>)</span> <span>&amp;&amp;</span> <span>isSubtreeWithRoot</span><span>(</span>s<span>.</span>right<span>,</span> t<span>.</span>right<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="_9-树的对称" tabindex="-1"> 9. 树的对称</h2>
<p><a href="https://leetcode.com/problems/symmetric-tree/description/" target="_blank" rel="noopener noreferrer">101. Symmetric Tree (Easy)</a></p>
<div><pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre></div><div><pre><code><span>public</span> <span>boolean</span> <span>isSymmetric</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>true</span><span>;</span>
    <span>return</span> <span>isSymmetric</span><span>(</span>root<span>.</span>left<span>,</span> root<span>.</span>right<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>boolean</span> <span>isSymmetric</span><span>(</span><span>TreeNode</span> t1<span>,</span> <span>TreeNode</span> t2<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>t1 <span>==</span> <span>null</span> <span>&amp;&amp;</span> t2 <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>true</span><span>;</span>
    <span>if</span> <span>(</span>t1 <span>==</span> <span>null</span> <span>||</span> t2 <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>false</span><span>;</span>
    <span>if</span> <span>(</span>t1<span>.</span>val <span>!=</span> t2<span>.</span>val<span>)</span> <span>return</span> <span>false</span><span>;</span>
    <span>return</span> <span>isSymmetric</span><span>(</span>t1<span>.</span>left<span>,</span> t2<span>.</span>right<span>)</span> <span>&amp;&amp;</span> <span>isSymmetric</span><span>(</span>t1<span>.</span>right<span>,</span> t2<span>.</span>left<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="_10-最小路径" tabindex="-1"> 10. 最小路径</h2>
<p><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/" target="_blank" rel="noopener noreferrer">111. Minimum Depth of Binary Tree (Easy)</a></p>
<p>树的根节点到叶子节点的最小路径长度</p>
<div><pre><code><span>public</span> <span>int</span> <span>minDepth</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>0</span><span>;</span>
    <span>int</span> left <span>=</span> <span>minDepth</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>
    <span>int</span> right <span>=</span> <span>minDepth</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>
    <span>if</span> <span>(</span>left <span>==</span> <span>0</span> <span>||</span> right <span>==</span> <span>0</span><span>)</span> <span>return</span> left <span>+</span> right <span>+</span> <span>1</span><span>;</span>
    <span>return</span> <span>Math</span><span>.</span><span>min</span><span>(</span>left<span>,</span> right<span>)</span> <span>+</span> <span>1</span><span>;</span>
<span>}</span>
</code></pre></div><h2 id="_11-统计左叶子节点的和" tabindex="-1"> 11. 统计左叶子节点的和</h2>
<p><a href="https://leetcode.com/problems/sum-of-left-leaves/description/" target="_blank" rel="noopener noreferrer">404. Sum of Left Leaves (Easy)</a></p>
<div><pre><code>    3
   / \
  9  20
    /  \
   15   7

There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.
</code></pre></div><div><pre><code><span>public</span> <span>int</span> <span>sumOfLeftLeaves</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>0</span><span>;</span>
    <span>if</span> <span>(</span><span>isLeaf</span><span>(</span>root<span>.</span>left<span>)</span><span>)</span> <span>return</span> root<span>.</span>left<span>.</span>val <span>+</span> <span>sumOfLeftLeaves</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>
    <span>return</span> <span>sumOfLeftLeaves</span><span>(</span>root<span>.</span>left<span>)</span> <span>+</span> <span>sumOfLeftLeaves</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>boolean</span> <span>isLeaf</span><span>(</span><span>TreeNode</span> node<span>)</span><span>{</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>false</span><span>;</span>
    <span>return</span> node<span>.</span>left <span>==</span> <span>null</span> <span>&amp;&amp;</span> node<span>.</span>right <span>==</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="_12-相同节点值的最大路径长度" tabindex="-1"> 12. 相同节点值的最大路径长度</h2>
<p><a href="https://leetcode.com/problems/longest-univalue-path/" target="_blank" rel="noopener noreferrer">687. Longest Univalue Path (Easy)</a></p>
<div><pre><code>             1
            / \
           4   5
          / \   \
         4   4   5

Output : 2
</code></pre></div><div><pre><code><span>private</span> <span>int</span> path <span>=</span> <span>0</span><span>;</span>

<span>public</span> <span>int</span> <span>longestUnivaluePath</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>dfs</span><span>(</span>root<span>)</span><span>;</span>
    <span>return</span> path<span>;</span>
<span>}</span>

<span>private</span> <span>int</span> <span>dfs</span><span>(</span><span>TreeNode</span> root<span>)</span><span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>0</span><span>;</span>
    <span>int</span> left <span>=</span> <span>dfs</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>
    <span>int</span> right <span>=</span> <span>dfs</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>
    <span>int</span> leftPath <span>=</span> root<span>.</span>left <span>!=</span> <span>null</span> <span>&amp;&amp;</span> root<span>.</span>left<span>.</span>val <span>==</span> root<span>.</span>val <span>?</span> left <span>+</span> <span>1</span> <span>:</span> <span>0</span><span>;</span>
    <span>int</span> rightPath <span>=</span> root<span>.</span>right <span>!=</span> <span>null</span> <span>&amp;&amp;</span> root<span>.</span>right<span>.</span>val <span>==</span> root<span>.</span>val <span>?</span> right <span>+</span> <span>1</span> <span>:</span> <span>0</span><span>;</span>
    path <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>path<span>,</span> leftPath <span>+</span> rightPath<span>)</span><span>;</span>
    <span>return</span> <span>Math</span><span>.</span><span>max</span><span>(</span>leftPath<span>,</span> rightPath<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="_13-间隔遍历" tabindex="-1"> 13. 间隔遍历</h2>
<p><a href="https://leetcode.com/problems/house-robber-iii/description/" target="_blank" rel="noopener noreferrer">337. House Robber III (Medium)</a></p>
<div><pre><code>     3
    / \
   2   3
    \   \
     3   1
Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.
</code></pre></div><div><pre><code><span>public</span> <span>int</span> <span>rob</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>0</span><span>;</span>
    <span>int</span> val1 <span>=</span> root<span>.</span>val<span>;</span>
    <span>if</span> <span>(</span>root<span>.</span>left <span>!=</span> <span>null</span><span>)</span> val1 <span>+=</span> <span>rob</span><span>(</span>root<span>.</span>left<span>.</span>left<span>)</span> <span>+</span> <span>rob</span><span>(</span>root<span>.</span>left<span>.</span>right<span>)</span><span>;</span>
    <span>if</span> <span>(</span>root<span>.</span>right <span>!=</span> <span>null</span><span>)</span> val1 <span>+=</span> <span>rob</span><span>(</span>root<span>.</span>right<span>.</span>left<span>)</span> <span>+</span> <span>rob</span><span>(</span>root<span>.</span>right<span>.</span>right<span>)</span><span>;</span>
    <span>int</span> val2 <span>=</span> <span>rob</span><span>(</span>root<span>.</span>left<span>)</span> <span>+</span> <span>rob</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>
    <span>return</span> <span>Math</span><span>.</span><span>max</span><span>(</span>val1<span>,</span> val2<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h2 id="_14-找出二叉树中第二小的节点" tabindex="-1"> 14. 找出二叉树中第二小的节点</h2>
<p><a href="https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/description/" target="_blank" rel="noopener noreferrer">671. Second Minimum Node In a Binary Tree (Easy)</a></p>
<div><pre><code>Input:
   2
  / \
 2   5
    / \
    5  7

Output: 5
</code></pre></div><p>一个节点要么具有 0 个或 2 个子节点，如果有子节点，那么根节点是最小的节点。</p>
<div><pre><code><span>public</span> <span>int</span> <span>findSecondMinimumValue</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>-</span><span>1</span><span>;</span>
    <span>if</span> <span>(</span>root<span>.</span>left <span>==</span> <span>null</span> <span>&amp;&amp;</span> root<span>.</span>right <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>-</span><span>1</span><span>;</span>
    <span>int</span> leftVal <span>=</span> root<span>.</span>left<span>.</span>val<span>;</span>
    <span>int</span> rightVal <span>=</span> root<span>.</span>right<span>.</span>val<span>;</span>
    <span>if</span> <span>(</span>leftVal <span>==</span> root<span>.</span>val<span>)</span> leftVal <span>=</span> <span>findSecondMinimumValue</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>
    <span>if</span> <span>(</span>rightVal <span>==</span> root<span>.</span>val<span>)</span> rightVal <span>=</span> <span>findSecondMinimumValue</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>
    <span>if</span> <span>(</span>leftVal <span>!=</span> <span>-</span><span>1</span> <span>&amp;&amp;</span> rightVal <span>!=</span> <span>-</span><span>1</span><span>)</span> <span>return</span> <span>Math</span><span>.</span><span>min</span><span>(</span>leftVal<span>,</span> rightVal<span>)</span><span>;</span>
    <span>if</span> <span>(</span>leftVal <span>!=</span> <span>-</span><span>1</span><span>)</span> <span>return</span> leftVal<span>;</span>
    <span>return</span> rightVal<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h1 id="层次遍历" tabindex="-1"> 层次遍历</h1>
<p>使用 BFS 进行层次遍历。不需要使用两个队列来分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。</p>
<h2 id="_1-一棵树每层节点的平均数" tabindex="-1"> 1. 一棵树每层节点的平均数</h2>
<p><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/description/" target="_blank" rel="noopener noreferrer">637. Average of Levels in Binary Tree (Easy)</a></p>
<div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>Double</span><span>></span></span> <span>averageOfLevels</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>Double</span><span>></span></span> ret <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> ret<span>;</span>
    <span>Queue</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    queue<span>.</span><span>add</span><span>(</span>root<span>)</span><span>;</span>
    <span>while</span> <span>(</span><span>!</span>queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>int</span> cnt <span>=</span> queue<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>
        <span>double</span> sum <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cnt<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>TreeNode</span> node <span>=</span> queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
            sum <span>+=</span> node<span>.</span>val<span>;</span>
            <span>if</span> <span>(</span>node<span>.</span>left <span>!=</span> <span>null</span><span>)</span> queue<span>.</span><span>add</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
            <span>if</span> <span>(</span>node<span>.</span>right <span>!=</span> <span>null</span><span>)</span> queue<span>.</span><span>add</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
        <span>}</span>
        ret<span>.</span><span>add</span><span>(</span>sum <span>/</span> cnt<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id="_2-得到左下角的节点" tabindex="-1"> 2. 得到左下角的节点</h2>
<p><a href="https://leetcode.com/problems/find-bottom-left-tree-value/description/" target="_blank" rel="noopener noreferrer">513. Find Bottom Left Tree Value (Easy)</a></p>
<div><pre><code>Input:

        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7

Output:
7
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>public</span> <span>int</span> <span>findBottomLeftValue</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>Queue</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    queue<span>.</span><span>add</span><span>(</span>root<span>)</span><span>;</span>
    <span>while</span> <span>(</span><span>!</span>queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        root <span>=</span> queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>root<span>.</span>right <span>!=</span> <span>null</span><span>)</span> queue<span>.</span><span>add</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>
        <span>if</span> <span>(</span>root<span>.</span>left <span>!=</span> <span>null</span><span>)</span> queue<span>.</span><span>add</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> root<span>.</span>val<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h1 id="前中后序遍历" tabindex="-1"> 前中后序遍历</h1>
<div><pre><code>    1
   / \
  2   3
 / \   \
4   5   6
</code></pre></div><ul>
<li>层次遍历顺序：[1 2 3 4 5 6]</li>
<li>前序遍历顺序：[1 2 4 5 3 6]</li>
<li>中序遍历顺序：[4 2 5 1 3 6]</li>
<li>后序遍历顺序：[4 5 2 6 3 1]</li>
</ul>
<p>层次遍历使用 BFS 实现，利用的就是 BFS 一层一层遍历的特性；而前序、中序、后序遍历利用了 DFS 实现。</p>
<p>前序、中序、后序遍只是在对节点访问的顺序有一点不同，其它都相同。</p>
<p>① 前序</p>
<div><pre><code><span>void</span> <span>dfs</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>visit</span><span>(</span>root<span>)</span><span>;</span>
    <span>dfs</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>
    <span>dfs</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><p>② 中序</p>
<div><pre><code><span>void</span> <span>dfs</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>dfs</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>
    <span>visit</span><span>(</span>root<span>)</span><span>;</span>
    <span>dfs</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><p>③ 后序</p>
<div><pre><code><span>void</span> <span>dfs</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>dfs</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>
    <span>dfs</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>
    <span>visit</span><span>(</span>root<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h2 id="_1-非递归实现二叉树的前序遍历" tabindex="-1"> 1. 非递归实现二叉树的前序遍历</h2>
<p><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/" target="_blank" rel="noopener noreferrer">144. Binary Tree Preorder Traversal (Medium)</a></p>
<div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>preorderTraversal</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> ret <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>Stack</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> stack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    stack<span>.</span><span>push</span><span>(</span>root<span>)</span><span>;</span>
    <span>while</span> <span>(</span><span>!</span>stack<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>TreeNode</span> node <span>=</span> stack<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>continue</span><span>;</span>
        ret<span>.</span><span>add</span><span>(</span>node<span>.</span>val<span>)</span><span>;</span>
        stack<span>.</span><span>push</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>  <span>// 先右后左，保证左子树先遍历</span>
        stack<span>.</span><span>push</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="_2-非递归实现二叉树的后序遍历" tabindex="-1"> 2. 非递归实现二叉树的后序遍历</h2>
<p><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/description/" target="_blank" rel="noopener noreferrer">145. Binary Tree Postorder Traversal (Medium)</a></p>
<p>前序遍历为 root -&gt; left -&gt; right，后序遍历为 left -&gt; right -&gt; root。可以修改前序遍历成为 root -&gt; right -&gt; left，那么这个顺序就和后序遍历正好相反。</p>
<div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>postorderTraversal</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> ret <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>Stack</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> stack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    stack<span>.</span><span>push</span><span>(</span>root<span>)</span><span>;</span>
    <span>while</span> <span>(</span><span>!</span>stack<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>TreeNode</span> node <span>=</span> stack<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>continue</span><span>;</span>
        ret<span>.</span><span>add</span><span>(</span>node<span>.</span>val<span>)</span><span>;</span>
        stack<span>.</span><span>push</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
        stack<span>.</span><span>push</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
    <span>}</span>
    <span>Collections</span><span>.</span><span>reverse</span><span>(</span>ret<span>)</span><span>;</span>
    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="_3-非递归实现二叉树的中序遍历" tabindex="-1"> 3. 非递归实现二叉树的中序遍历</h2>
<p><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/" target="_blank" rel="noopener noreferrer">94. Binary Tree Inorder Traversal (Medium)</a></p>
<div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>inorderTraversal</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> ret <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> ret<span>;</span>
    <span>Stack</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> stack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>TreeNode</span> cur <span>=</span> root<span>;</span>
    <span>while</span> <span>(</span>cur <span>!=</span> <span>null</span> <span>||</span> <span>!</span>stack<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>while</span> <span>(</span>cur <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            stack<span>.</span><span>push</span><span>(</span>cur<span>)</span><span>;</span>
            cur <span>=</span> cur<span>.</span>left<span>;</span>
        <span>}</span>
        <span>TreeNode</span> node <span>=</span> stack<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>
        ret<span>.</span><span>add</span><span>(</span>node<span>.</span>val<span>)</span><span>;</span>
        cur <span>=</span> node<span>.</span>right<span>;</span>
    <span>}</span>
    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h1 id="bst" tabindex="-1"> BST</h1>
<p>二叉查找树（BST）：根节点大于等于左子树所有节点，小于等于右子树所有节点。</p>
<p>二叉查找树中序遍历有序。</p>
<h2 id="_1-修剪二叉查找树" tabindex="-1"> 1. 修剪二叉查找树</h2>
<p><a href="https://leetcode.com/problems/trim-a-binary-search-tree/description/" target="_blank" rel="noopener noreferrer">669. Trim a Binary Search Tree (Easy)</a></p>
<div><pre><code>Input:

    3
   / \
  0   4
   \
    2
   /
  1

  L = 1
  R = 3

Output:

      3
     /
   2
  /
 1
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>题目描述：只保留值在 L ~ R 之间的节点</p>
<div><pre><code><span>public</span> <span>TreeNode</span> <span>trimBST</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>int</span> <span>L</span><span>,</span> <span>int</span> <span>R</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>null</span><span>;</span>
    <span>if</span> <span>(</span>root<span>.</span>val <span>></span> <span>R</span><span>)</span> <span>return</span> <span>trimBST</span><span>(</span>root<span>.</span>left<span>,</span> <span>L</span><span>,</span> <span>R</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>root<span>.</span>val <span>&lt;</span> <span>L</span><span>)</span> <span>return</span> <span>trimBST</span><span>(</span>root<span>.</span>right<span>,</span> <span>L</span><span>,</span> <span>R</span><span>)</span><span>;</span>
    root<span>.</span>left <span>=</span> <span>trimBST</span><span>(</span>root<span>.</span>left<span>,</span> <span>L</span><span>,</span> <span>R</span><span>)</span><span>;</span>
    root<span>.</span>right <span>=</span> <span>trimBST</span><span>(</span>root<span>.</span>right<span>,</span> <span>L</span><span>,</span> <span>R</span><span>)</span><span>;</span>
    <span>return</span> root<span>;</span>
<span>}</span>
</code></pre></div><h2 id="_2-寻找二叉查找树的第-k-个元素" tabindex="-1"> 2. 寻找二叉查找树的第 k 个元素</h2>
<p><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/" target="_blank" rel="noopener noreferrer">230. Kth Smallest Element in a BST (Medium)</a></p>
<p>中序遍历解法：</p>
<div><pre><code><span>private</span> <span>int</span> cnt <span>=</span> <span>0</span><span>;</span>
<span>private</span> <span>int</span> val<span>;</span>

<span>public</span> <span>int</span> <span>kthSmallest</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
    <span>inOrder</span><span>(</span>root<span>,</span> k<span>)</span><span>;</span>
    <span>return</span> val<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>inOrder</span><span>(</span><span>TreeNode</span> node<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>return</span><span>;</span>
    <span>inOrder</span><span>(</span>node<span>.</span>left<span>,</span> k<span>)</span><span>;</span>
    cnt<span>++</span><span>;</span>
    <span>if</span> <span>(</span>cnt <span>==</span> k<span>)</span> <span>{</span>
        val <span>=</span> node<span>.</span>val<span>;</span>
        <span>return</span><span>;</span>
    <span>}</span>
    <span>inOrder</span><span>(</span>node<span>.</span>right<span>,</span> k<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>递归解法：</p>
<div><pre><code><span>public</span> <span>int</span> <span>kthSmallest</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
    <span>int</span> leftCnt <span>=</span> <span>count</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>
    <span>if</span> <span>(</span>leftCnt <span>==</span> k <span>-</span> <span>1</span><span>)</span> <span>return</span> root<span>.</span>val<span>;</span>
    <span>if</span> <span>(</span>leftCnt <span>></span> k <span>-</span> <span>1</span><span>)</span> <span>return</span> <span>kthSmallest</span><span>(</span>root<span>.</span>left<span>,</span> k<span>)</span><span>;</span>
    <span>return</span> <span>kthSmallest</span><span>(</span>root<span>.</span>right<span>,</span> k <span>-</span> leftCnt <span>-</span> <span>1</span><span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>int</span> <span>count</span><span>(</span><span>TreeNode</span> node<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>0</span><span>;</span>
    <span>return</span> <span>1</span> <span>+</span> <span>count</span><span>(</span>node<span>.</span>left<span>)</span> <span>+</span> <span>count</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="_3-把二叉查找树每个节点的值都加上比它大的节点的值" tabindex="-1"> 3. 把二叉查找树每个节点的值都加上比它大的节点的值</h2>
<p><a href="https://leetcode.com/problems/convert-bst-to-greater-tree/description/" target="_blank" rel="noopener noreferrer">Convert BST to Greater Tree (Easy)</a></p>
<div><pre><code>Input: The root of a Binary Search Tree like this:

              5
            /   \
           2     13

Output: The root of a Greater Tree like this:

             18
            /   \
          20     13
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>先遍历右子树。</p>
<div><pre><code><span>private</span> <span>int</span> sum <span>=</span> <span>0</span><span>;</span>

<span>public</span> <span>TreeNode</span> <span>convertBST</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>traver</span><span>(</span>root<span>)</span><span>;</span>
    <span>return</span> root<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>traver</span><span>(</span><span>TreeNode</span> node<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>return</span><span>;</span>
    <span>traver</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
    sum <span>+=</span> node<span>.</span>val<span>;</span>
    node<span>.</span>val <span>=</span> sum<span>;</span>
    <span>traver</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="_4-二叉查找树的最近公共祖先" tabindex="-1"> 4. 二叉查找树的最近公共祖先</h2>
<p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/" target="_blank" rel="noopener noreferrer">235. Lowest Common Ancestor of a Binary Search Tree (Easy)</a></p>
<div><pre><code>        _______6______
      /                \
  ___2__             ___8__
 /      \           /      \
0        4         7        9
        /  \
       3   5

For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
</code></pre></div><div><pre><code><span>public</span> <span>TreeNode</span> <span>lowestCommonAncestor</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>TreeNode</span> p<span>,</span> <span>TreeNode</span> q<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root<span>.</span>val <span>></span> p<span>.</span>val <span>&amp;&amp;</span> root<span>.</span>val <span>></span> q<span>.</span>val<span>)</span> <span>return</span> <span>lowestCommonAncestor</span><span>(</span>root<span>.</span>left<span>,</span> p<span>,</span> q<span>)</span><span>;</span>
    <span>if</span> <span>(</span>root<span>.</span>val <span>&lt;</span> p<span>.</span>val <span>&amp;&amp;</span> root<span>.</span>val <span>&lt;</span> q<span>.</span>val<span>)</span> <span>return</span> <span>lowestCommonAncestor</span><span>(</span>root<span>.</span>right<span>,</span> p<span>,</span> q<span>)</span><span>;</span>
    <span>return</span> root<span>;</span>
<span>}</span>
</code></pre></div><h2 id="_5-二叉树的最近公共祖先" tabindex="-1"> 5. 二叉树的最近公共祖先</h2>
<p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/" target="_blank" rel="noopener noreferrer">236. Lowest Common Ancestor of a Binary Tree (Medium) </a></p>
<div><pre><code>       _______3______
      /              \
  ___5__           ___1__
 /      \         /      \
6        2       0        8
        /  \
       7    4

For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
</code></pre></div><div><pre><code><span>public</span> <span>TreeNode</span> <span>lowestCommonAncestor</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>TreeNode</span> p<span>,</span> <span>TreeNode</span> q<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span> <span>||</span> root <span>==</span> p <span>||</span> root <span>==</span> q<span>)</span> <span>return</span> root<span>;</span>
    <span>TreeNode</span> left <span>=</span> <span>lowestCommonAncestor</span><span>(</span>root<span>.</span>left<span>,</span> p<span>,</span> q<span>)</span><span>;</span>
    <span>TreeNode</span> right <span>=</span> <span>lowestCommonAncestor</span><span>(</span>root<span>.</span>right<span>,</span> p<span>,</span> q<span>)</span><span>;</span>
    <span>return</span> left <span>==</span> <span>null</span> <span>?</span> right <span>:</span> right <span>==</span> <span>null</span> <span>?</span> left <span>:</span> root<span>;</span>
<span>}</span>
</code></pre></div><h2 id="_6-从有序数组中构造二叉查找树" tabindex="-1"> 6. 从有序数组中构造二叉查找树</h2>
<p><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/" target="_blank" rel="noopener noreferrer">108. Convert Sorted Array to Binary Search Tree (Easy)</a></p>
<div><pre><code><span>public</span> <span>TreeNode</span> <span>sortedArrayToBST</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>return</span> <span>toBST</span><span>(</span>nums<span>,</span> <span>0</span><span>,</span> nums<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>TreeNode</span> <span>toBST</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> sIdx<span>,</span> <span>int</span> eIdx<span>)</span><span>{</span>
    <span>if</span> <span>(</span>sIdx <span>></span> eIdx<span>)</span> <span>return</span> <span>null</span><span>;</span>
    <span>int</span> mIdx <span>=</span> <span>(</span>sIdx <span>+</span> eIdx<span>)</span> <span>/</span> <span>2</span><span>;</span>
    <span>TreeNode</span> root <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span>nums<span>[</span>mIdx<span>]</span><span>)</span><span>;</span>
    root<span>.</span>left <span>=</span>  <span>toBST</span><span>(</span>nums<span>,</span> sIdx<span>,</span> mIdx <span>-</span> <span>1</span><span>)</span><span>;</span>
    root<span>.</span>right <span>=</span> <span>toBST</span><span>(</span>nums<span>,</span> mIdx <span>+</span> <span>1</span><span>,</span> eIdx<span>)</span><span>;</span>
    <span>return</span> root<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="_7-根据有序链表构造平衡的二叉查找树" tabindex="-1"> 7. 根据有序链表构造平衡的二叉查找树</h2>
<p><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/description/" target="_blank" rel="noopener noreferrer">109. Convert Sorted List to Binary Search Tree (Medium)</a></p>
<div><pre><code>Given the sorted linked list: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
</code></pre></div><div><pre><code><span>public</span> <span>TreeNode</span> <span>sortedListToBST</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>head <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>null</span><span>;</span>
    <span>if</span> <span>(</span>head<span>.</span>next <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>new</span> <span>TreeNode</span><span>(</span>head<span>.</span>val<span>)</span><span>;</span>
    <span>ListNode</span> preMid <span>=</span> <span>preMid</span><span>(</span>head<span>)</span><span>;</span>
    <span>ListNode</span> mid <span>=</span> preMid<span>.</span>next<span>;</span>
    preMid<span>.</span>next <span>=</span> <span>null</span><span>;</span>  <span>// 断开链表</span>
    <span>TreeNode</span> t <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span>mid<span>.</span>val<span>)</span><span>;</span>
    t<span>.</span>left <span>=</span> <span>sortedListToBST</span><span>(</span>head<span>)</span><span>;</span>
    t<span>.</span>right <span>=</span> <span>sortedListToBST</span><span>(</span>mid<span>.</span>next<span>)</span><span>;</span>
    <span>return</span> t<span>;</span>
<span>}</span>

<span>private</span> <span>ListNode</span> <span>preMid</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>
    <span>ListNode</span> slow <span>=</span> head<span>,</span> fast <span>=</span> head<span>.</span>next<span>;</span>
    <span>ListNode</span> pre <span>=</span> head<span>;</span>
    <span>while</span> <span>(</span>fast <span>!=</span> <span>null</span> <span>&amp;&amp;</span> fast<span>.</span>next <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        pre <span>=</span> slow<span>;</span>
        slow <span>=</span> slow<span>.</span>next<span>;</span>
        fast <span>=</span> fast<span>.</span>next<span>.</span>next<span>;</span>
    <span>}</span>
    <span>return</span> pre<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id="_8-在二叉查找树中寻找两个节点-使它们的和为一个给定值" tabindex="-1"> 8. 在二叉查找树中寻找两个节点，使它们的和为一个给定值</h2>
<p><a href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/description/" target="_blank" rel="noopener noreferrer">653. Two Sum IV - Input is a BST (Easy)</a></p>
<div><pre><code>Input:

    5
   / \
  3   6
 / \   \
2   4   7

Target = 9

Output: True
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>使用中序遍历得到有序数组之后，再利用双指针对数组进行查找。</p>
<p>应该注意到，这一题不能用分别在左右子树两部分来处理这种思想，因为两个待求的节点可能分别在左右子树中。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>findTarget</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> nums <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>inOrder</span><span>(</span>root<span>,</span> nums<span>)</span><span>;</span>
    <span>int</span> i <span>=</span> <span>0</span><span>,</span> j <span>=</span> nums<span>.</span><span>size</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span>i <span>&lt;</span> j<span>)</span> <span>{</span>
        <span>int</span> sum <span>=</span> nums<span>.</span><span>get</span><span>(</span>i<span>)</span> <span>+</span> nums<span>.</span><span>get</span><span>(</span>j<span>)</span><span>;</span>
        <span>if</span> <span>(</span>sum <span>==</span> k<span>)</span> <span>return</span> <span>true</span><span>;</span>
        <span>if</span> <span>(</span>sum <span>&lt;</span> k<span>)</span> i<span>++</span><span>;</span>
        <span>else</span> j<span>--</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>inOrder</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> nums<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span><span>;</span>
    <span>inOrder</span><span>(</span>root<span>.</span>left<span>,</span> nums<span>)</span><span>;</span>
    nums<span>.</span><span>add</span><span>(</span>root<span>.</span>val<span>)</span><span>;</span>
    <span>inOrder</span><span>(</span>root<span>.</span>right<span>,</span> nums<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="_9-在二叉查找树中查找两个节点之差的最小绝对值" tabindex="-1"> 9. 在二叉查找树中查找两个节点之差的最小绝对值</h2>
<p><a href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/description/" target="_blank" rel="noopener noreferrer">530. Minimum Absolute Difference in BST (Easy)</a></p>
<div><pre><code>Input:

   1
    \
     3
    /
   2

Output:

1
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>利用二叉查找树的中序遍历为有序的性质，计算中序遍历中临近的两个节点之差的绝对值，取最小值。</p>
<div><pre><code><span>private</span> <span>int</span> minDiff <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>;</span>
<span>private</span> <span>TreeNode</span> preNode <span>=</span> <span>null</span><span>;</span>

<span>public</span> <span>int</span> <span>getMinimumDifference</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>inOrder</span><span>(</span>root<span>)</span><span>;</span>
    <span>return</span> minDiff<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>inOrder</span><span>(</span><span>TreeNode</span> node<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>return</span><span>;</span>
    <span>inOrder</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
    <span>if</span> <span>(</span>preNode <span>!=</span> <span>null</span><span>)</span> minDiff <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>minDiff<span>,</span> node<span>.</span>val <span>-</span> preNode<span>.</span>val<span>)</span><span>;</span>
    preNode <span>=</span> node<span>;</span>
    <span>inOrder</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="_10-寻找二叉查找树中出现次数最多的值" tabindex="-1"> 10. 寻找二叉查找树中出现次数最多的值</h2>
<p><a href="https://leetcode.com/problems/find-mode-in-binary-search-tree/description/" target="_blank" rel="noopener noreferrer">501. Find Mode in Binary Search Tree (Easy)</a></p>
<div><pre><code>   1
    \
     2
    /
   2

return [2].
</code></pre></div><p>答案可能不止一个，也就是有多个值出现的次数一样多。</p>
<div><pre><code><span>private</span> <span>int</span> curCnt <span>=</span> <span>1</span><span>;</span>
<span>private</span> <span>int</span> maxCnt <span>=</span> <span>1</span><span>;</span>
<span>private</span> <span>TreeNode</span> preNode <span>=</span> <span>null</span><span>;</span>

<span>public</span> <span>int</span><span>[</span><span>]</span> <span>findMode</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> maxCntNums <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>inOrder</span><span>(</span>root<span>,</span> maxCntNums<span>)</span><span>;</span>
    <span>int</span><span>[</span><span>]</span> ret <span>=</span> <span>new</span> <span>int</span><span>[</span>maxCntNums<span>.</span><span>size</span><span>(</span><span>)</span><span>]</span><span>;</span>
    <span>int</span> idx <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> num <span>:</span> maxCntNums<span>)</span> <span>{</span>
        ret<span>[</span>idx<span>++</span><span>]</span> <span>=</span> num<span>;</span>
    <span>}</span>
    <span>return</span> ret<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>inOrder</span><span>(</span><span>TreeNode</span> node<span>,</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> nums<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>return</span><span>;</span>
    <span>inOrder</span><span>(</span>node<span>.</span>left<span>,</span> nums<span>)</span><span>;</span>
    <span>if</span> <span>(</span>preNode <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>preNode<span>.</span>val <span>==</span> node<span>.</span>val<span>)</span> curCnt<span>++</span><span>;</span>
        <span>else</span> curCnt <span>=</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>curCnt <span>></span> maxCnt<span>)</span> <span>{</span>
        maxCnt <span>=</span> curCnt<span>;</span>
        nums<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>
        nums<span>.</span><span>add</span><span>(</span>node<span>.</span>val<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>curCnt <span>==</span> maxCnt<span>)</span> <span>{</span>
        nums<span>.</span><span>add</span><span>(</span>node<span>.</span>val<span>)</span><span>;</span>
    <span>}</span>
    preNode <span>=</span> node<span>;</span>
    <span>inOrder</span><span>(</span>node<span>.</span>right<span>,</span> nums<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h1 id="trie" tabindex="-1"> Trie</h1>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5c638d59-d4ae-4ba4-ad44-80bdc30f38dd.jpg"/> </div><br>
<p>Trie，又称前缀树或字典树，用于判断字符串是否存在或者是否具有某种字符串前缀。</p>
<h2 id="_1-实现一个-trie" tabindex="-1"> 1. 实现一个 Trie</h2>
<p><a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/" target="_blank" rel="noopener noreferrer">208. Implement Trie (Prefix Tree) (Medium)</a></p>
<div><pre><code><span>class</span> <span>Trie</span> <span>{</span>

    <span>private</span> <span>class</span> <span>Node</span> <span>{</span>
        <span>Node</span><span>[</span><span>]</span> childs <span>=</span> <span>new</span> <span>Node</span><span>[</span><span>26</span><span>]</span><span>;</span>
        <span>boolean</span> isLeaf<span>;</span>
    <span>}</span>

    <span>private</span> <span>Node</span> root <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>Trie</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>insert</span><span>(</span><span>String</span> word<span>)</span> <span>{</span>
        <span>insert</span><span>(</span>word<span>,</span> root<span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>insert</span><span>(</span><span>String</span> word<span>,</span> <span>Node</span> node<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>return</span><span>;</span>
        <span>if</span> <span>(</span>word<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
            node<span>.</span>isLeaf <span>=</span> <span>true</span><span>;</span>
            <span>return</span><span>;</span>
        <span>}</span>
        <span>int</span> index <span>=</span> <span>indexForChar</span><span>(</span>word<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>node<span>.</span>childs<span>[</span>index<span>]</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
            node<span>.</span>childs<span>[</span>index<span>]</span> <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>insert</span><span>(</span>word<span>.</span><span>substring</span><span>(</span><span>1</span><span>)</span><span>,</span> node<span>.</span>childs<span>[</span>index<span>]</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>boolean</span> <span>search</span><span>(</span><span>String</span> word<span>)</span> <span>{</span>
        <span>return</span> <span>search</span><span>(</span>word<span>,</span> root<span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>boolean</span> <span>search</span><span>(</span><span>String</span> word<span>,</span> <span>Node</span> node<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>false</span><span>;</span>
        <span>if</span> <span>(</span>word<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>return</span> node<span>.</span>isLeaf<span>;</span>
        <span>int</span> index <span>=</span> <span>indexForChar</span><span>(</span>word<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span><span>)</span><span>;</span>
        <span>return</span> <span>search</span><span>(</span>word<span>.</span><span>substring</span><span>(</span><span>1</span><span>)</span><span>,</span> node<span>.</span>childs<span>[</span>index<span>]</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>boolean</span> <span>startsWith</span><span>(</span><span>String</span> prefix<span>)</span> <span>{</span>
        <span>return</span> <span>startWith</span><span>(</span>prefix<span>,</span> root<span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>boolean</span> <span>startWith</span><span>(</span><span>String</span> prefix<span>,</span> <span>Node</span> node<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>false</span><span>;</span>
        <span>if</span> <span>(</span>prefix<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>return</span> <span>true</span><span>;</span>
        <span>int</span> index <span>=</span> <span>indexForChar</span><span>(</span>prefix<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span><span>)</span><span>;</span>
        <span>return</span> <span>startWith</span><span>(</span>prefix<span>.</span><span>substring</span><span>(</span><span>1</span><span>)</span><span>,</span> node<span>.</span>childs<span>[</span>index<span>]</span><span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>int</span> <span>indexForChar</span><span>(</span><span>char</span> c<span>)</span> <span>{</span>
        <span>return</span> c <span>-</span> <span>'a'</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><h2 id="_2-实现一个-trie-用来求前缀和" tabindex="-1"> 2. 实现一个 Trie，用来求前缀和</h2>
<p><a href="https://leetcode.com/problems/map-sum-pairs/description/" target="_blank" rel="noopener noreferrer">677. Map Sum Pairs (Medium)</a></p>
<div><pre><code>Input: insert("apple", 3), Output: Null
Input: sum("ap"), Output: 3
Input: insert("app", 2), Output: Null
Input: sum("ap"), Output: 5
</code></pre></div><div><pre><code><span>class</span> <span>MapSum</span> <span>{</span>

    <span>private</span> <span>class</span> <span>Node</span> <span>{</span>
        <span>Node</span><span>[</span><span>]</span> child <span>=</span> <span>new</span> <span>Node</span><span>[</span><span>26</span><span>]</span><span>;</span>
        <span>int</span> value<span>;</span>
    <span>}</span>

    <span>private</span> <span>Node</span> root <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>MapSum</span><span>(</span><span>)</span> <span>{</span>

    <span>}</span>

    <span>public</span> <span>void</span> <span>insert</span><span>(</span><span>String</span> key<span>,</span> <span>int</span> val<span>)</span> <span>{</span>
        <span>insert</span><span>(</span>key<span>,</span> root<span>,</span> val<span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>insert</span><span>(</span><span>String</span> key<span>,</span> <span>Node</span> node<span>,</span> <span>int</span> val<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>return</span><span>;</span>
        <span>if</span> <span>(</span>key<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
            node<span>.</span>value <span>=</span> val<span>;</span>
            <span>return</span><span>;</span>
        <span>}</span>
        <span>int</span> index <span>=</span> <span>indexForChar</span><span>(</span>key<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>node<span>.</span>child<span>[</span>index<span>]</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
            node<span>.</span>child<span>[</span>index<span>]</span> <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>insert</span><span>(</span>key<span>.</span><span>substring</span><span>(</span><span>1</span><span>)</span><span>,</span> node<span>.</span>child<span>[</span>index<span>]</span><span>,</span> val<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>sum</span><span>(</span><span>String</span> prefix<span>)</span> <span>{</span>
        <span>return</span> <span>sum</span><span>(</span>prefix<span>,</span> root<span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>int</span> <span>sum</span><span>(</span><span>String</span> prefix<span>,</span> <span>Node</span> node<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>0</span><span>;</span>
        <span>if</span> <span>(</span>prefix<span>.</span><span>length</span><span>(</span><span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
            <span>int</span> index <span>=</span> <span>indexForChar</span><span>(</span>prefix<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span><span>)</span><span>;</span>
            <span>return</span> <span>sum</span><span>(</span>prefix<span>.</span><span>substring</span><span>(</span><span>1</span><span>)</span><span>,</span> node<span>.</span>child<span>[</span>index<span>]</span><span>)</span><span>;</span>
        <span>}</span>
        <span>int</span> sum <span>=</span> node<span>.</span>value<span>;</span>
        <span>for</span> <span>(</span><span>Node</span> child <span>:</span> node<span>.</span>child<span>)</span> <span>{</span>
            sum <span>+=</span> <span>sum</span><span>(</span>prefix<span>,</span> child<span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> sum<span>;</span>
    <span>}</span>

    <span>private</span> <span>int</span> <span>indexForChar</span><span>(</span><span>char</span> c<span>)</span> <span>{</span>
        <span>return</span> c <span>-</span> <span>'a'</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>算法思想</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E7%9B%AE%E5%BD%95.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E7%9B%AE%E5%BD%95.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">算法思想</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文从 Leetcode 中精选大概 200 左右的题目，去除了某些繁杂但是没有多少算法思想的题目，同时保留了面试中经常被问到的经典题目。</p>
<h1 id="算法思想" tabindex="-1"> 算法思想</h1>
<ul>
<li><a href="/notes/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8F%8C%E6%8C%87%E9%92%88.html">双指针</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%8E%92%E5%BA%8F.html">排序</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3.html">贪心思想</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html">二分查找</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%88%86%E6%B2%BB.html">分治</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%90%9C%E7%B4%A2.html">搜索</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html">动态规划</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%95%B0%E5%AD%A6.html">数学</a></li>
</ul>
<h1 id="数据结构相关" tabindex="-1"> 数据结构相关</h1>
<ul>
<li><a href="/notes/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E9%93%BE%E8%A1%A8.html">链表</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%A0%91.html">树</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.html">栈和队列</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%93%88%E5%B8%8C%E8%A1%A8.html">哈希表</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%AD%97%E7%AC%A6%E4%B8%B2.html">字符串</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%95%B0%E7%BB%84%E4%B8%8E%E7%9F%A9%E9%98%B5.html">数组与矩阵</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%9B%BE.html">图</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E4%BD%8D%E8%BF%90%E7%AE%97.html">位运算</a></li>
</ul>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li>Leetcode</li>
<li>Weiss M A, 冯舜玺. 数据结构与算法分析——C 语言描述[J]. 2004.</li>
<li>Sedgewick R. Algorithms[M]. Pearson Education India, 1988.</li>
<li>何海涛, 软件工程师. 剑指 Offer: 名企面试官精讲典型编程题[M]. 电子工业出版社, 2014.</li>
<li>《编程之美》小组. 编程之美[M]. 电子工业出版社, 2008.</li>
<li>左程云. 程序员代码面试指南[M]. 电子工业出版社, 2015.</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>1. 分配饼干</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">1. 分配饼干</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>保证每次操作都是局部最优的，并且最后得到的结果是全局最优的。</p>
<h1 id="_1-分配饼干" tabindex="-1"> 1. 分配饼干</h1>
<p><a href="https://leetcode.com/problems/assign-cookies/description/" target="_blank" rel="noopener noreferrer">455. Assign Cookies (Easy)</a></p>
<div><pre><code>Input: [1,2], [1,2,3]
Output: 2

Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.
You have 3 cookies and their sizes are big enough to gratify all of the children,
You need to output 2.
</code></pre></div><p>题目描述：每个孩子都有一个满足度，每个饼干都有一个大小，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。</p>
<p>给一个孩子的饼干应当尽量小又能满足该孩子，这样大饼干就能拿来给满足度比较大的孩子。因为最小的孩子最容易得到满足，所以先满足最小的孩子。</p>
<p>证明：假设在某次选择中，贪心策略选择给当前满足度最小的孩子分配第 m 个饼干，第 m 个饼干为可以满足该孩子的最小饼干。假设存在一种最优策略，给该孩子分配第 n 个饼干，并且 m &lt; n。我们可以发现，经过这一轮分配，贪心策略分配后剩下的饼干一定有一个比最优策略来得大。因此在后续的分配中，贪心策略一定能满足更多的孩子。也就是说不存在比贪心策略更优的策略，即贪心策略就是最优策略。</p>
<div><pre><code><span>public</span> <span>int</span> <span>findContentChildren</span><span>(</span><span>int</span><span>[</span><span>]</span> g<span>,</span> <span>int</span><span>[</span><span>]</span> s<span>)</span> <span>{</span>
    <span>Arrays</span><span>.</span><span>sort</span><span>(</span>g<span>)</span><span>;</span>
    <span>Arrays</span><span>.</span><span>sort</span><span>(</span>s<span>)</span><span>;</span>
    <span>int</span> gi <span>=</span> <span>0</span><span>,</span> si <span>=</span> <span>0</span><span>;</span>
    <span>while</span> <span>(</span>gi <span>&lt;</span> g<span>.</span>length <span>&amp;&amp;</span> si <span>&lt;</span> s<span>.</span>length<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>g<span>[</span>gi<span>]</span> <span>&lt;=</span> s<span>[</span>si<span>]</span><span>)</span> <span>{</span>
            gi<span>++</span><span>;</span>
        <span>}</span>
        si<span>++</span><span>;</span>
    <span>}</span>
    <span>return</span> gi<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h1 id="_2-不重叠的区间个数" tabindex="-1"> 2. 不重叠的区间个数</h1>
<p><a href="https://leetcode.com/problems/non-overlapping-intervals/description/" target="_blank" rel="noopener noreferrer">435. Non-overlapping Intervals (Medium)</a></p>
<div><pre><code>Input: [ [1,2], [1,2], [1,2] ]

Output: 2

Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.
</code></pre></div><div><pre><code>Input: [ [1,2], [2,3] ]

Output: 0

Explanation: You don't need to remove any of the intervals since they're already non-overlapping.
</code></pre></div><p>题目描述：计算让一组区间不重叠所需要移除的区间个数。</p>
<p>先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。</p>
<p>在每次选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。</p>
<p>按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。</p>
<div><pre><code><span>public</span> <span>int</span> <span>eraseOverlapIntervals</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> intervals<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>intervals<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>Arrays</span><span>.</span><span>sort</span><span>(</span>intervals<span>,</span> <span>Comparator</span><span>.</span><span>comparingInt</span><span>(</span>o <span>-></span> o<span>[</span><span>1</span><span>]</span><span>)</span><span>)</span><span>;</span>
    <span>int</span> cnt <span>=</span> <span>1</span><span>;</span>
    <span>int</span> end <span>=</span> intervals<span>[</span><span>0</span><span>]</span><span>[</span><span>1</span><span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> intervals<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>intervals<span>[</span>i<span>]</span><span>[</span><span>0</span><span>]</span> <span>&lt;</span> end<span>)</span> <span>{</span>
            <span>continue</span><span>;</span>
        <span>}</span>
        end <span>=</span> intervals<span>[</span>i<span>]</span><span>[</span><span>1</span><span>]</span><span>;</span>
        cnt<span>++</span><span>;</span>
    <span>}</span>
    <span>return</span> intervals<span>.</span>length <span>-</span> cnt<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>使用 lambda 表示式创建 Comparator 会导致算法运行时间过长，如果注重运行时间，可以修改为普通创建 Comparator 语句：</p>
<div><pre><code><span>Arrays</span><span>.</span><span>sort</span><span>(</span>intervals<span>,</span> <span>new</span> <span>Comparator</span><span>&lt;</span><span>int</span><span>[</span><span>]</span><span>></span><span>(</span><span>)</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>int</span> <span>compare</span><span>(</span><span>int</span><span>[</span><span>]</span> o1<span>,</span> <span>int</span><span>[</span><span>]</span> o2<span>)</span> <span>{</span>
        <span>return</span> o1<span>[</span><span>1</span><span>]</span> <span>-</span> o2<span>[</span><span>1</span><span>]</span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span><span>;</span>
</code></pre></div><h1 id="_3-投飞镖刺破气球" tabindex="-1"> 3. 投飞镖刺破气球</h1>
<p><a href="https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/description/" target="_blank" rel="noopener noreferrer">452. Minimum Number of Arrows to Burst Balloons (Medium)</a></p>
<div><pre><code>Input:
[[10,16], [2,8], [1,6], [7,12]]

Output:
2
</code></pre></div><p>题目描述：气球在一个水平数轴上摆放，可以重叠，飞镖垂直投向坐标轴，使得路径上的气球都被刺破。求解最小的投飞镖次数使所有气球都被刺破。</p>
<p>也是计算不重叠的区间个数，不过和 Non-overlapping Intervals 的区别在于，[1, 2] 和 [2, 3] 在本题中算是重叠区间。</p>
<div><pre><code><span>public</span> <span>int</span> <span>findMinArrowShots</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> points<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>points<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>Arrays</span><span>.</span><span>sort</span><span>(</span>points<span>,</span> <span>Comparator</span><span>.</span><span>comparingInt</span><span>(</span>o <span>-></span> o<span>[</span><span>1</span><span>]</span><span>)</span><span>)</span><span>;</span>
    <span>int</span> cnt <span>=</span> <span>1</span><span>,</span> end <span>=</span> points<span>[</span><span>0</span><span>]</span><span>[</span><span>1</span><span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> points<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>points<span>[</span>i<span>]</span><span>[</span><span>0</span><span>]</span> <span>&lt;=</span> end<span>)</span> <span>{</span>
            <span>continue</span><span>;</span>
        <span>}</span>
        cnt<span>++</span><span>;</span>
        end <span>=</span> points<span>[</span>i<span>]</span><span>[</span><span>1</span><span>]</span><span>;</span>
    <span>}</span>
    <span>return</span> cnt<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h1 id="_4-根据身高和序号重组队列" tabindex="-1"> 4. 根据身高和序号重组队列</h1>
<p><a href="https://leetcode.com/problems/queue-reconstruction-by-height/description/" target="_blank" rel="noopener noreferrer">406. Queue Reconstruction by Height(Medium)</a></p>
<div><pre><code>Input:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

Output:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
</code></pre></div><p>题目描述：一个学生用两个分量 (h, k) 描述，h 表示身高，k 表示排在前面的有 k 个学生的身高比他高或者和他一样高。</p>
<p>为了使插入操作不影响后续的操作，身高较高的学生应该先做插入操作，否则身高较小的学生原先正确插入的第 k 个位置可能会变成第 k+1 个位置。</p>
<p>身高 h 降序、个数 k 值升序，然后将某个学生插入队列的第 k 个位置中。</p>
<div><pre><code><span>public</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> <span>reconstructQueue</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> people<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>people <span>==</span> <span>null</span> <span>||</span> people<span>.</span>length <span>==</span> <span>0</span> <span>||</span> people<span>[</span><span>0</span><span>]</span><span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>int</span><span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span><span>;</span>
    <span>}</span>
    <span>Arrays</span><span>.</span><span>sort</span><span>(</span>people<span>,</span> <span>(</span>a<span>,</span> b<span>)</span> <span>-></span> <span>(</span>a<span>[</span><span>0</span><span>]</span> <span>==</span> b<span>[</span><span>0</span><span>]</span> <span>?</span> a<span>[</span><span>1</span><span>]</span> <span>-</span> b<span>[</span><span>1</span><span>]</span> <span>:</span> b<span>[</span><span>0</span><span>]</span> <span>-</span> a<span>[</span><span>0</span><span>]</span><span>)</span><span>)</span><span>;</span>
    <span>List</span><span>&lt;</span><span>int</span><span>[</span><span>]</span><span>></span> queue <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span><span>[</span><span>]</span> p <span>:</span> people<span>)</span> <span>{</span>
        queue<span>.</span><span>add</span><span>(</span>p<span>[</span><span>1</span><span>]</span><span>,</span> p<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> queue<span>.</span><span>toArray</span><span>(</span><span>new</span> <span>int</span><span>[</span>queue<span>.</span><span>size</span><span>(</span><span>)</span><span>]</span><span>[</span><span>]</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h1 id="_5-买卖股票最大的收益" tabindex="-1"> 5. 买卖股票最大的收益</h1>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/" target="_blank" rel="noopener noreferrer">121. Best Time to Buy and Sell Stock (Easy)</a></p>
<p>题目描述：一次股票交易包含买入和卖出，只进行一次交易，求最大收益。</p>
<p>只要记录前面的最小价格，将这个最小价格作为买入价格，然后将当前的价格作为售出价格，查看当前收益是不是最大收益。</p>
<div><pre><code><span>public</span> <span>int</span> <span>maxProfit</span><span>(</span><span>int</span><span>[</span><span>]</span> prices<span>)</span> <span>{</span>
    <span>int</span> n <span>=</span> prices<span>.</span>length<span>;</span>
    <span>if</span> <span>(</span>n <span>==</span> <span>0</span><span>)</span> <span>return</span> <span>0</span><span>;</span>
    <span>int</span> soFarMin <span>=</span> prices<span>[</span><span>0</span><span>]</span><span>;</span>
    <span>int</span> max <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>soFarMin <span>></span> prices<span>[</span>i<span>]</span><span>)</span> soFarMin <span>=</span> prices<span>[</span>i<span>]</span><span>;</span>
        <span>else</span> max <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>max<span>,</span> prices<span>[</span>i<span>]</span> <span>-</span> soFarMin<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> max<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h1 id="_6-买卖股票的最大收益-ii" tabindex="-1"> 6. 买卖股票的最大收益 II</h1>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/" target="_blank" rel="noopener noreferrer">122. Best Time to Buy and Sell Stock II (Easy)</a></p>
<p>题目描述：可以进行多次交易，多次交易之间不能交叉进行，可以进行多次交易。</p>
<p>对于 [a, b, c, d]，如果有 a &lt;= b &lt;= c &lt;= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ，因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0，那么就把 prices[i] - prices[i-1] 添加到收益中。</p>
<div><pre><code><span>public</span> <span>int</span> <span>maxProfit</span><span>(</span><span>int</span><span>[</span><span>]</span> prices<span>)</span> <span>{</span>
    <span>int</span> profit <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> prices<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>prices<span>[</span>i<span>]</span> <span>></span> prices<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span> <span>{</span>
            profit <span>+=</span> <span>(</span>prices<span>[</span>i<span>]</span> <span>-</span> prices<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> profit<span>;</span>
<span>}</span>
</code></pre></div><h1 id="_7-种植花朵" tabindex="-1"> 7. 种植花朵</h1>
<p><a href="https://leetcode.com/problems/can-place-flowers/description/" target="_blank" rel="noopener noreferrer">605. Can Place Flowers (Easy)</a></p>
<div><pre><code>Input: flowerbed = [1,0,0,0,1], n = 1
Output: True
</code></pre></div><p>题目描述：flowerbed 数组中 1 表示已经种下了花朵。花朵之间至少需要一个单位的间隔，求解是否能种下 n 朵花。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>canPlaceFlowers</span><span>(</span><span>int</span><span>[</span><span>]</span> flowerbed<span>,</span> <span>int</span> n<span>)</span> <span>{</span>
    <span>int</span> len <span>=</span> flowerbed<span>.</span>length<span>;</span>
    <span>int</span> cnt <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len <span>&amp;&amp;</span> cnt <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>flowerbed<span>[</span>i<span>]</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>
            <span>continue</span><span>;</span>
        <span>}</span>
        <span>int</span> pre <span>=</span> i <span>==</span> <span>0</span> <span>?</span> <span>0</span> <span>:</span> flowerbed<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>;</span>
        <span>int</span> next <span>=</span> i <span>==</span> len <span>-</span> <span>1</span> <span>?</span> <span>0</span> <span>:</span> flowerbed<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>;</span>
        <span>if</span> <span>(</span>pre <span>==</span> <span>0</span> <span>&amp;&amp;</span> next <span>==</span> <span>0</span><span>)</span> <span>{</span>
            cnt<span>++</span><span>;</span>
            flowerbed<span>[</span>i<span>]</span> <span>=</span> <span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> cnt <span>>=</span> n<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h1 id="_8-判断是否为子序列" tabindex="-1"> 8. 判断是否为子序列</h1>
<p><a href="https://leetcode.com/problems/is-subsequence/description/" target="_blank" rel="noopener noreferrer">392. Is Subsequence (Medium)</a></p>
<div><pre><code>s = "abc", t = "ahbgdc"
Return true.
</code></pre></div><div><pre><code><span>public</span> <span>boolean</span> <span>isSubsequence</span><span>(</span><span>String</span> s<span>,</span> <span>String</span> t<span>)</span> <span>{</span>
    <span>int</span> index <span>=</span> <span>-</span><span>1</span><span>;</span>
    <span>for</span> <span>(</span><span>char</span> c <span>:</span> s<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        index <span>=</span> t<span>.</span><span>indexOf</span><span>(</span>c<span>,</span> index <span>+</span> <span>1</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>index <span>==</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>true</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h1 id="_9-修改一个数成为非递减数组" tabindex="-1"> 9. 修改一个数成为非递减数组</h1>
<p><a href="https://leetcode.com/problems/non-decreasing-array/description/" target="_blank" rel="noopener noreferrer">665. Non-decreasing Array (Easy)</a></p>
<div><pre><code>Input: [4,2,3]
Output: True
Explanation: You could modify the first 4 to 1 to get a non-decreasing array.
</code></pre></div><p>题目描述：判断一个数组是否能只修改一个数就成为非递减数组。</p>
<p>在出现 nums[i] &lt; nums[i - 1] 时，需要考虑的是应该修改数组的哪个数，使得本次修改能使 i 之前的数组成为非递减数组，并且  <strong>不影响后续的操作</strong> 。优先考虑令 nums[i - 1] = nums[i]，因为如果修改 nums[i] = nums[i - 1] 的话，那么 nums[i] 这个数会变大，就有可能比 nums[i + 1] 大，从而影响了后续操作。还有一个比较特别的情况就是 nums[i] &lt; nums[i - 2]，修改 nums[i - 1] = nums[i] 不能使数组成为非递减数组，只能修改 nums[i] = nums[i - 1]。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>checkPossibility</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>int</span> cnt <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length <span>&amp;&amp;</span> cnt <span>&lt;</span> <span>2</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>>=</span> nums<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span> <span>{</span>
            <span>continue</span><span>;</span>
        <span>}</span>
        cnt<span>++</span><span>;</span>
        <span>if</span> <span>(</span>i <span>-</span> <span>2</span> <span>>=</span> <span>0</span> <span>&amp;&amp;</span> nums<span>[</span>i <span>-</span> <span>2</span><span>]</span> <span>></span> nums<span>[</span>i<span>]</span><span>)</span> <span>{</span>
            nums<span>[</span>i<span>]</span> <span>=</span> nums<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            nums<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> cnt <span>&lt;=</span> <span>1</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h1 id="_10-子数组最大的和" tabindex="-1"> 10. 子数组最大的和</h1>
<p><a href="https://leetcode.com/problems/maximum-subarray/description/" target="_blank" rel="noopener noreferrer">53. Maximum Subarray (Easy)</a></p>
<div><pre><code>For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
the contiguous subarray [4,-1,2,1] has the largest sum = 6.
</code></pre></div><div><pre><code><span>public</span> <span>int</span> <span>maxSubArray</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nums <span>==</span> <span>null</span> <span>||</span> nums<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>int</span> preSum <span>=</span> nums<span>[</span><span>0</span><span>]</span><span>;</span>
    <span>int</span> maxSum <span>=</span> preSum<span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        preSum <span>=</span> preSum <span>></span> <span>0</span> <span>?</span> preSum <span>+</span> nums<span>[</span>i<span>]</span> <span>:</span> nums<span>[</span>i<span>]</span><span>;</span>
        maxSum <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>maxSum<span>,</span> preSum<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> maxSum<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h1 id="_11-分隔字符串使同种字符出现在一起" tabindex="-1"> 11. 分隔字符串使同种字符出现在一起</h1>
<p><a href="https://leetcode.com/problems/partition-labels/description/" target="_blank" rel="noopener noreferrer">763. Partition Labels (Medium)</a></p>
<div><pre><code>Input: S = "ababcbacadefegdehijhklij"
Output: [9,7,8]
Explanation:
The partition is "ababcbaca", "defegde", "hijhklij".
This is a partition so that each letter appears in at most one part.
A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits S into less parts.
</code></pre></div><div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>partitionLabels</span><span>(</span><span>String</span> <span>S</span><span>)</span> <span>{</span>
    <span>int</span><span>[</span><span>]</span> lastIndexsOfChar <span>=</span> <span>new</span> <span>int</span><span>[</span><span>26</span><span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>S</span><span>.</span><span>length</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        lastIndexsOfChar<span>[</span><span>char2Index</span><span>(</span><span>S</span><span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>)</span><span>]</span> <span>=</span> i<span>;</span>
    <span>}</span>
    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> partitions <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>int</span> firstIndex <span>=</span> <span>0</span><span>;</span>
    <span>while</span> <span>(</span>firstIndex <span>&lt;</span> <span>S</span><span>.</span><span>length</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>int</span> lastIndex <span>=</span> firstIndex<span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> firstIndex<span>;</span> i <span>&lt;</span> <span>S</span><span>.</span><span>length</span><span>(</span><span>)</span> <span>&amp;&amp;</span> i <span>&lt;=</span> lastIndex<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>int</span> index <span>=</span> lastIndexsOfChar<span>[</span><span>char2Index</span><span>(</span><span>S</span><span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>)</span><span>]</span><span>;</span>
            <span>if</span> <span>(</span>index <span>></span> lastIndex<span>)</span> <span>{</span>
                lastIndex <span>=</span> index<span>;</span>
            <span>}</span>
        <span>}</span>
        partitions<span>.</span><span>add</span><span>(</span>lastIndex <span>-</span> firstIndex <span>+</span> <span>1</span><span>)</span><span>;</span>
        firstIndex <span>=</span> lastIndex <span>+</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>return</span> partitions<span>;</span>
<span>}</span>

<span>private</span> <span>int</span> <span>char2Index</span><span>(</span><span>char</span> c<span>)</span> <span>{</span>
    <span>return</span> c <span>-</span> <span>'a'</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>1. 找出两个链表的交点</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E9%93%BE%E8%A1%A8.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E9%93%BE%E8%A1%A8.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">1. 找出两个链表的交点</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>链表是空节点，或者有一个值和一个指向下一个链表的指针，因此很多链表问题可以用递归来处理。</p>
<h1 id="_1-找出两个链表的交点" tabindex="-1"> 1. 找出两个链表的交点</h1>
<p><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/" target="_blank" rel="noopener noreferrer">160. Intersection of Two Linked Lists (Easy)</a></p>
<p>例如以下示例中 A 和 B 两个链表相交于 c1：</p>
<div><pre><code>A:          a1 → a2
                    ↘
                      c1 → c2 → c3
                    ↗
B:    b1 → b2 → b3
</code></pre></div><p>但是不会出现以下相交的情况，因为每个节点只有一个 next 指针，也就只能有一个后继节点，而以下示例中节点 c 有两个后继节点。</p>
<div><pre><code>A:          a1 → a2       d1 → d2
                    ↘  ↗
                      c
                    ↗  ↘
B:    b1 → b2 → b3        e1 → e2
</code></pre></div><p>要求时间复杂度为 O(N)，空间复杂度为 O(1)。如果不存在交点则返回 null。</p>
<p>设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。</p>
<p>当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。</p>
<p>如果不存在交点，那么 a + b = b + a，以下实现代码中 l1 和 l2 会同时为 null，从而退出循环。</p>
<div><pre><code><span>public</span> <span>ListNode</span> <span>getIntersectionNode</span><span>(</span><span>ListNode</span> headA<span>,</span> <span>ListNode</span> headB<span>)</span> <span>{</span>
    <span>ListNode</span> l1 <span>=</span> headA<span>,</span> l2 <span>=</span> headB<span>;</span>
    <span>while</span> <span>(</span>l1 <span>!=</span> l2<span>)</span> <span>{</span>
        l1 <span>=</span> <span>(</span>l1 <span>==</span> <span>null</span><span>)</span> <span>?</span> headB <span>:</span> l1<span>.</span>next<span>;</span>
        l2 <span>=</span> <span>(</span>l2 <span>==</span> <span>null</span><span>)</span> <span>?</span> headA <span>:</span> l2<span>.</span>next<span>;</span>
    <span>}</span>
    <span>return</span> l1<span>;</span>
<span>}</span>
</code></pre></div><p>如果只是判断是否存在交点，那么就是另一个问题，即 <a href="">编程之美 3.6</a> 的问题。有两种解法：</p>
<ul>
<li>把第一个链表的结尾连接到第二个链表的开头，看第二个链表是否存在环；</li>
<li>或者直接比较两个链表的最后一个节点是否相同。</li>
</ul>
<h1 id="_2-链表反转" tabindex="-1"> 2. 链表反转</h1>
<p><a href="https://leetcode.com/problems/reverse-linked-list/description/" target="_blank" rel="noopener noreferrer">206. Reverse Linked List (Easy)</a></p>
<p>递归</p>
<div><pre><code><span>public</span> <span>ListNode</span> <span>reverseList</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>head <span>==</span> <span>null</span> <span>||</span> head<span>.</span>next <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> head<span>;</span>
    <span>}</span>
    <span>ListNode</span> next <span>=</span> head<span>.</span>next<span>;</span>
    <span>ListNode</span> newHead <span>=</span> <span>reverseList</span><span>(</span>next<span>)</span><span>;</span>
    next<span>.</span>next <span>=</span> head<span>;</span>
    head<span>.</span>next <span>=</span> <span>null</span><span>;</span>
    <span>return</span> newHead<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>头插法</p>
<div><pre><code><span>public</span> <span>ListNode</span> <span>reverseList</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>
    <span>ListNode</span> newHead <span>=</span> <span>new</span> <span>ListNode</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>
    <span>while</span> <span>(</span>head <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>ListNode</span> next <span>=</span> head<span>.</span>next<span>;</span>
        head<span>.</span>next <span>=</span> newHead<span>.</span>next<span>;</span>
        newHead<span>.</span>next <span>=</span> head<span>;</span>
        head <span>=</span> next<span>;</span>
    <span>}</span>
    <span>return</span> newHead<span>.</span>next<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h1 id="_3-归并两个有序的链表" tabindex="-1"> 3. 归并两个有序的链表</h1>
<p><a href="https://leetcode.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener noreferrer">21. Merge Two Sorted Lists (Easy)</a></p>
<div><pre><code><span>public</span> <span>ListNode</span> <span>mergeTwoLists</span><span>(</span><span>ListNode</span> l1<span>,</span> <span>ListNode</span> l2<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>l1 <span>==</span> <span>null</span><span>)</span> <span>return</span> l2<span>;</span>
    <span>if</span> <span>(</span>l2 <span>==</span> <span>null</span><span>)</span> <span>return</span> l1<span>;</span>
    <span>if</span> <span>(</span>l1<span>.</span>val <span>&lt;</span> l2<span>.</span>val<span>)</span> <span>{</span>
        l1<span>.</span>next <span>=</span> <span>mergeTwoLists</span><span>(</span>l1<span>.</span>next<span>,</span> l2<span>)</span><span>;</span>
        <span>return</span> l1<span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        l2<span>.</span>next <span>=</span> <span>mergeTwoLists</span><span>(</span>l1<span>,</span> l2<span>.</span>next<span>)</span><span>;</span>
        <span>return</span> l2<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h1 id="_4-从有序链表中删除重复节点" tabindex="-1"> 4. 从有序链表中删除重复节点</h1>
<p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/" target="_blank" rel="noopener noreferrer">83. Remove Duplicates from Sorted List (Easy)</a></p>
<div><pre><code>Given 1->1->2, return 1->2.
Given 1->1->2->3->3, return 1->2->3.
</code></pre></div><div><pre><code><span>public</span> <span>ListNode</span> <span>deleteDuplicates</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>head <span>==</span> <span>null</span> <span>||</span> head<span>.</span>next <span>==</span> <span>null</span><span>)</span> <span>return</span> head<span>;</span>
    head<span>.</span>next <span>=</span> <span>deleteDuplicates</span><span>(</span>head<span>.</span>next<span>)</span><span>;</span>
    <span>return</span> head<span>.</span>val <span>==</span> head<span>.</span>next<span>.</span>val <span>?</span> head<span>.</span>next <span>:</span> head<span>;</span>
<span>}</span>
</code></pre></div><h1 id="_5-删除链表的倒数第-n-个节点" tabindex="-1"> 5. 删除链表的倒数第 n 个节点</h1>
<p><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/" target="_blank" rel="noopener noreferrer">19. Remove Nth Node From End of List (Medium)</a></p>
<div><pre><code>Given linked list: 1->2->3->4->5, and n = 2.
After removing the second node from the end, the linked list becomes 1->2->3->5.
</code></pre></div><div><pre><code><span>public</span> <span>ListNode</span> <span>removeNthFromEnd</span><span>(</span><span>ListNode</span> head<span>,</span> <span>int</span> n<span>)</span> <span>{</span>
    <span>ListNode</span> fast <span>=</span> head<span>;</span>
    <span>while</span> <span>(</span>n<span>--</span> <span>></span> <span>0</span><span>)</span> <span>{</span>
        fast <span>=</span> fast<span>.</span>next<span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>fast <span>==</span> <span>null</span><span>)</span> <span>return</span> head<span>.</span>next<span>;</span>
    <span>ListNode</span> slow <span>=</span> head<span>;</span>
    <span>while</span> <span>(</span>fast<span>.</span>next <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        fast <span>=</span> fast<span>.</span>next<span>;</span>
        slow <span>=</span> slow<span>.</span>next<span>;</span>
    <span>}</span>
    slow<span>.</span>next <span>=</span> slow<span>.</span>next<span>.</span>next<span>;</span>
    <span>return</span> head<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h1 id="_6-交换链表中的相邻结点" tabindex="-1"> 6. 交换链表中的相邻结点</h1>
<p><a href="https://leetcode.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="noopener noreferrer">24. Swap Nodes in Pairs (Medium)</a></p>
<div><pre><code>Given 1->2->3->4, you should return the list as 2->1->4->3.
</code></pre></div><p>题目要求：不能修改结点的 val 值，O(1) 空间复杂度。</p>
<div><pre><code><span>public</span> <span>ListNode</span> <span>swapPairs</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>
    <span>ListNode</span> node <span>=</span> <span>new</span> <span>ListNode</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>
    node<span>.</span>next <span>=</span> head<span>;</span>
    <span>ListNode</span> pre <span>=</span> node<span>;</span>
    <span>while</span> <span>(</span>pre<span>.</span>next <span>!=</span> <span>null</span> <span>&amp;&amp;</span> pre<span>.</span>next<span>.</span>next <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>ListNode</span> l1 <span>=</span> pre<span>.</span>next<span>,</span> l2 <span>=</span> pre<span>.</span>next<span>.</span>next<span>;</span>
        <span>ListNode</span> next <span>=</span> l2<span>.</span>next<span>;</span>
        l1<span>.</span>next <span>=</span> next<span>;</span>
        l2<span>.</span>next <span>=</span> l1<span>;</span>
        pre<span>.</span>next <span>=</span> l2<span>;</span>

        pre <span>=</span> l1<span>;</span>
    <span>}</span>
    <span>return</span> node<span>.</span>next<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h1 id="_7-链表求和" tabindex="-1"> 7. 链表求和</h1>
<p><a href="https://leetcode.com/problems/add-two-numbers-ii/description/" target="_blank" rel="noopener noreferrer">445. Add Two Numbers II (Medium)</a></p>
<div><pre><code>Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 8 -> 0 -> 7
</code></pre></div><p>题目要求：不能修改原始链表。</p>
<div><pre><code><span>public</span> <span>ListNode</span> <span>addTwoNumbers</span><span>(</span><span>ListNode</span> l1<span>,</span> <span>ListNode</span> l2<span>)</span> <span>{</span>
    <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> l1Stack <span>=</span> <span>buildStack</span><span>(</span>l1<span>)</span><span>;</span>
    <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> l2Stack <span>=</span> <span>buildStack</span><span>(</span>l2<span>)</span><span>;</span>
    <span>ListNode</span> head <span>=</span> <span>new</span> <span>ListNode</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>
    <span>int</span> carry <span>=</span> <span>0</span><span>;</span>
    <span>while</span> <span>(</span><span>!</span>l1Stack<span>.</span><span>isEmpty</span><span>(</span><span>)</span> <span>||</span> <span>!</span>l2Stack<span>.</span><span>isEmpty</span><span>(</span><span>)</span> <span>||</span> carry <span>!=</span> <span>0</span><span>)</span> <span>{</span>
        <span>int</span> x <span>=</span> l1Stack<span>.</span><span>isEmpty</span><span>(</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> l1Stack<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> y <span>=</span> l2Stack<span>.</span><span>isEmpty</span><span>(</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> l2Stack<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> sum <span>=</span> x <span>+</span> y <span>+</span> carry<span>;</span>
        <span>ListNode</span> node <span>=</span> <span>new</span> <span>ListNode</span><span>(</span>sum <span>%</span> <span>10</span><span>)</span><span>;</span>
        node<span>.</span>next <span>=</span> head<span>.</span>next<span>;</span>
        head<span>.</span>next <span>=</span> node<span>;</span>
        carry <span>=</span> sum <span>/</span> <span>10</span><span>;</span>
    <span>}</span>
    <span>return</span> head<span>.</span>next<span>;</span>
<span>}</span>

<span>private</span> <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>buildStack</span><span>(</span><span>ListNode</span> l<span>)</span> <span>{</span>
    <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> stack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>while</span> <span>(</span>l <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        stack<span>.</span><span>push</span><span>(</span>l<span>.</span>val<span>)</span><span>;</span>
        l <span>=</span> l<span>.</span>next<span>;</span>
    <span>}</span>
    <span>return</span> stack<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h1 id="_8-回文链表" tabindex="-1"> 8. 回文链表</h1>
<p><a href="https://leetcode.com/problems/palindrome-linked-list/description/" target="_blank" rel="noopener noreferrer">234. Palindrome Linked List (Easy)</a></p>
<p>题目要求：以 O(1) 的空间复杂度来求解。</p>
<p>切成两半，把后半段反转，然后比较两半是否相等。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>isPalindrome</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>head <span>==</span> <span>null</span> <span>||</span> head<span>.</span>next <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>true</span><span>;</span>
    <span>ListNode</span> slow <span>=</span> head<span>,</span> fast <span>=</span> head<span>.</span>next<span>;</span>
    <span>while</span> <span>(</span>fast <span>!=</span> <span>null</span> <span>&amp;&amp;</span> fast<span>.</span>next <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        slow <span>=</span> slow<span>.</span>next<span>;</span>
        fast <span>=</span> fast<span>.</span>next<span>.</span>next<span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>fast <span>!=</span> <span>null</span><span>)</span> slow <span>=</span> slow<span>.</span>next<span>;</span>  <span>// 偶数节点，让 slow 指向下一个节点</span>
    <span>cut</span><span>(</span>head<span>,</span> slow<span>)</span><span>;</span>                     <span>// 切成两个链表</span>
    <span>return</span> <span>isEqual</span><span>(</span>head<span>,</span> <span>reverse</span><span>(</span>slow<span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>cut</span><span>(</span><span>ListNode</span> head<span>,</span> <span>ListNode</span> cutNode<span>)</span> <span>{</span>
    <span>while</span> <span>(</span>head<span>.</span>next <span>!=</span> cutNode<span>)</span> <span>{</span>
        head <span>=</span> head<span>.</span>next<span>;</span>
    <span>}</span>
    head<span>.</span>next <span>=</span> <span>null</span><span>;</span>
<span>}</span>

<span>private</span> <span>ListNode</span> <span>reverse</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>
    <span>ListNode</span> newHead <span>=</span> <span>null</span><span>;</span>
    <span>while</span> <span>(</span>head <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>ListNode</span> nextNode <span>=</span> head<span>.</span>next<span>;</span>
        head<span>.</span>next <span>=</span> newHead<span>;</span>
        newHead <span>=</span> head<span>;</span>
        head <span>=</span> nextNode<span>;</span>
    <span>}</span>
    <span>return</span> newHead<span>;</span>
<span>}</span>

<span>private</span> <span>boolean</span> <span>isEqual</span><span>(</span><span>ListNode</span> l1<span>,</span> <span>ListNode</span> l2<span>)</span> <span>{</span>
    <span>while</span> <span>(</span>l1 <span>!=</span> <span>null</span> <span>&amp;&amp;</span> l2 <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>l1<span>.</span>val <span>!=</span> l2<span>.</span>val<span>)</span> <span>return</span> <span>false</span><span>;</span>
        l1 <span>=</span> l1<span>.</span>next<span>;</span>
        l2 <span>=</span> l2<span>.</span>next<span>;</span>
    <span>}</span>
    <span>return</span> <span>true</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><h1 id="_9-分隔链表" tabindex="-1"> 9. 分隔链表</h1>
<p><a href="https://leetcode.com/problems/split-linked-list-in-parts/description/" target="_blank" rel="noopener noreferrer">725. Split Linked List in Parts(Medium)</a></p>
<div><pre><code>Input:
root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3
Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]
Explanation:
The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.
</code></pre></div><p>题目描述：把链表分隔成 k 部分，每部分的长度都应该尽可能相同，排在前面的长度应该大于等于后面的。</p>
<div><pre><code><span>public</span> <span>ListNode</span><span>[</span><span>]</span> <span>splitListToParts</span><span>(</span><span>ListNode</span> root<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
    <span>int</span> <span>N</span> <span>=</span> <span>0</span><span>;</span>
    <span>ListNode</span> cur <span>=</span> root<span>;</span>
    <span>while</span> <span>(</span>cur <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>N</span><span>++</span><span>;</span>
        cur <span>=</span> cur<span>.</span>next<span>;</span>
    <span>}</span>
    <span>int</span> mod <span>=</span> <span>N</span> <span>%</span> k<span>;</span>
    <span>int</span> size <span>=</span> <span>N</span> <span>/</span> k<span>;</span>
    <span>ListNode</span><span>[</span><span>]</span> ret <span>=</span> <span>new</span> <span>ListNode</span><span>[</span>k<span>]</span><span>;</span>
    cur <span>=</span> root<span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> cur <span>!=</span> <span>null</span> <span>&amp;&amp;</span> i <span>&lt;</span> k<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        ret<span>[</span>i<span>]</span> <span>=</span> cur<span>;</span>
        <span>int</span> curSize <span>=</span> size <span>+</span> <span>(</span>mod<span>--</span> <span>></span> <span>0</span> <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> curSize <span>-</span> <span>1</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>
            cur <span>=</span> cur<span>.</span>next<span>;</span>
        <span>}</span>
        <span>ListNode</span> next <span>=</span> cur<span>.</span>next<span>;</span>
        cur<span>.</span>next <span>=</span> <span>null</span><span>;</span>
        cur <span>=</span> next<span>;</span>
    <span>}</span>
    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h1 id="_10-链表元素按奇偶聚集" tabindex="-1"> 10. 链表元素按奇偶聚集</h1>
<p><a href="https://leetcode.com/problems/odd-even-linked-list/description/" target="_blank" rel="noopener noreferrer">328. Odd Even Linked List (Medium)</a></p>
<div><pre><code>Example:
Given 1->2->3->4->5->NULL,
return 1->3->5->2->4->NULL.
</code></pre></div><div><pre><code><span>public</span> <span>ListNode</span> <span>oddEvenList</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>head <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> head<span>;</span>
    <span>}</span>
    <span>ListNode</span> odd <span>=</span> head<span>,</span> even <span>=</span> head<span>.</span>next<span>,</span> evenHead <span>=</span> even<span>;</span>
    <span>while</span> <span>(</span>even <span>!=</span> <span>null</span> <span>&amp;&amp;</span> even<span>.</span>next <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        odd<span>.</span>next <span>=</span> odd<span>.</span>next<span>.</span>next<span>;</span>
        odd <span>=</span> odd<span>.</span>next<span>;</span>
        even<span>.</span>next <span>=</span> even<span>.</span>next<span>.</span>next<span>;</span>
        even <span>=</span> even<span>.</span>next<span>;</span>
    <span>}</span>
    odd<span>.</span>next <span>=</span> evenHead<span>;</span>
    <span>return</span> head<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>10.1 斐波那契数列</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-10~19.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-10~19.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">10.1 斐波那契数列</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>

<h1 id="_10-1-斐波那契数列" tabindex="-1"> 10.1 斐波那契数列</h1>
<p><a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&amp;tqId=11160&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述" tabindex="-1"> 题目描述</h2>
<p>求斐波那契数列的第 n 项，n &lt;= 39。</p>

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/45be9587-6069-4ab7-b9ac-840db1a53744.jpg" width="300px"> </div><br>
<h2 id="解题思路" tabindex="-1"> 解题思路</h2>
<p>如果使用递归求解，会重复计算一些子问题。例如，计算 f(4) 需要计算 f(3) 和 f(2)，计算 f(3) 需要计算 f(2) 和 f(1)，可以看到 f(2) 被重复计算了。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c13e2a3d-b01c-4a08-a69b-db2c4e821e09.png" width="350px"/> </div><br>
<p>递归是将一个问题划分成多个子问题求解，动态规划也是如此，但是动态规划会把子问题的解缓存起来，从而避免重复求解子问题。</p>
<div><pre><code><span>public</span> <span>int</span> <span>Fibonacci</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>n <span>&lt;=</span> <span>1</span><span>)</span>
        <span>return</span> n<span>;</span>
    <span>int</span><span>[</span><span>]</span> fib <span>=</span> <span>new</span> <span>int</span><span>[</span>n <span>+</span> <span>1</span><span>]</span><span>;</span>
    fib<span>[</span><span>1</span><span>]</span> <span>=</span> <span>1</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span>
        fib<span>[</span>i<span>]</span> <span>=</span> fib<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>+</span> fib<span>[</span>i <span>-</span> <span>2</span><span>]</span><span>;</span>
    <span>return</span> fib<span>[</span>n<span>]</span><span>;</span>
<span>}</span>
</code></pre></div><p>考虑到第 i 项只与第 i-1 和第 i-2 项有关，因此只需要存储前两项的值就能求解第 i 项，从而将空间复杂度由 O(N) 降低为 O(1)。</p>
<div><pre><code><span>public</span> <span>int</span> <span>Fibonacci</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>n <span>&lt;=</span> <span>1</span><span>)</span>
        <span>return</span> n<span>;</span>
    <span>int</span> pre2 <span>=</span> <span>0</span><span>,</span> pre1 <span>=</span> <span>1</span><span>;</span>
    <span>int</span> fib <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        fib <span>=</span> pre2 <span>+</span> pre1<span>;</span>
        pre2 <span>=</span> pre1<span>;</span>
        pre1 <span>=</span> fib<span>;</span>
    <span>}</span>
    <span>return</span> fib<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>由于待求解的 n 小于 40，因此可以将前 40 项的结果先进行计算，之后就能以 O(1) 时间复杂度得到第 n 项的值。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>private</span> <span>int</span><span>[</span><span>]</span> fib <span>=</span> <span>new</span> <span>int</span><span>[</span><span>40</span><span>]</span><span>;</span>

    <span>public</span> <span>Solution</span><span>(</span><span>)</span> <span>{</span>
        fib<span>[</span><span>1</span><span>]</span> <span>=</span> <span>1</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;</span> fib<span>.</span>length<span>;</span> i<span>++</span><span>)</span>
            fib<span>[</span>i<span>]</span> <span>=</span> fib<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>+</span> fib<span>[</span>i <span>-</span> <span>2</span><span>]</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>Fibonacci</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
        <span>return</span> fib<span>[</span>n<span>]</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h1 id="_10-2-矩形覆盖" tabindex="-1"> 10.2 矩形覆盖</h1>
<p><a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-1" tabindex="-1"> 题目描述</h2>
<p>我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b903fda8-07d0-46a7-91a7-e803892895cf.gif" width="100px"> </div><br>
<h2 id="解题思路-1" tabindex="-1"> 解题思路</h2>
<p>当 n 为 1 时，只有一种覆盖方法：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f6e146f1-57ad-411b-beb3-770a142164ef.png" width="100px"> </div><br>
<p>当 n 为 2 时，有两种覆盖方法：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/fb3b8f7a-4293-4a38-aae1-62284db979a3.png" width="200px"> </div><br>
<p>要覆盖 2*n 的大矩形，可以先覆盖 2*1 的矩形，再覆盖 2*(n-1) 的矩形；或者先覆盖 2*2 的矩形，再覆盖 2*(n-2) 的矩形。而覆盖 2*(n-1) 和 2*(n-2) 的矩形可以看成子问题。该问题的递推公式如下：</p>

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/508c6e52-9f93-44ed-b6b9-e69050e14807.jpg" width="350px"> </div><br>
<div><pre><code><span>public</span> <span>int</span> <span>RectCover</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>n <span>&lt;=</span> <span>2</span><span>)</span>
        <span>return</span> n<span>;</span>
    <span>int</span> pre2 <span>=</span> <span>1</span><span>,</span> pre1 <span>=</span> <span>2</span><span>;</span>
    <span>int</span> result <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>3</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        result <span>=</span> pre2 <span>+</span> pre1<span>;</span>
        pre2 <span>=</span> pre1<span>;</span>
        pre1 <span>=</span> result<span>;</span>
    <span>}</span>
    <span>return</span> result<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h1 id="_10-3-跳台阶" tabindex="-1"> 10.3 跳台阶</h1>
<p><a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&amp;tqId=11161&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-2" tabindex="-1"> 题目描述</h2>
<p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9dae7475-934f-42e5-b3b3-12724337170a.png" width="380px"> </div><br>
<h2 id="解题思路-2" tabindex="-1"> 解题思路</h2>
<p>当 n = 1 时，只有一种跳法：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/72aac98a-d5df-4bfa-a71a-4bb16a87474c.png" width="250px"> </div><br>
<p>当 n = 2 时，有两种跳法：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1b80288d-1b35-4cd3-aa17-7e27ab9a2389.png" width="300px"> </div><br>
<p>跳 n 阶台阶，可以先跳 1 阶台阶，再跳 n-1 阶台阶；或者先跳 2 阶台阶，再跳 n-2 阶台阶。而 n-1 和 n-2 阶台阶的跳法可以看成子问题，该问题的递推公式为：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/508c6e52-9f93-44ed-b6b9-e69050e14807.jpg" width="350px"> </div><br>
<div><pre><code><span>public</span> <span>int</span> <span>JumpFloor</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>n <span>&lt;=</span> <span>2</span><span>)</span>
        <span>return</span> n<span>;</span>
    <span>int</span> pre2 <span>=</span> <span>1</span><span>,</span> pre1 <span>=</span> <span>2</span><span>;</span>
    <span>int</span> result <span>=</span> <span>1</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        result <span>=</span> pre2 <span>+</span> pre1<span>;</span>
        pre2 <span>=</span> pre1<span>;</span>
        pre1 <span>=</span> result<span>;</span>
    <span>}</span>
    <span>return</span> result<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h1 id="_10-4-变态跳台阶" tabindex="-1"> 10.4 变态跳台阶</h1>
<p><a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&amp;tqId=11162&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-3" tabindex="-1"> 题目描述</h2>
<p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级... 它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cd411a94-3786-4c94-9e08-f28320e010d5.png" width="380px"> </div><br>
<h2 id="解题思路-3" tabindex="-1"> 解题思路</h2>
<h3 id="动态规划" tabindex="-1"> 动态规划</h3>
<div><pre><code><span>public</span> <span>int</span> <span>JumpFloorII</span><span>(</span><span>int</span> target<span>)</span> <span>{</span>
    <span>int</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span>target<span>]</span><span>;</span>
    <span>Arrays</span><span>.</span><span>fill</span><span>(</span>dp<span>,</span> <span>1</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> target<span>;</span> i<span>++</span><span>)</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> i<span>;</span> j<span>++</span><span>)</span>
            dp<span>[</span>i<span>]</span> <span>+=</span> dp<span>[</span>j<span>]</span><span>;</span>
    <span>return</span> dp<span>[</span>target <span>-</span> <span>1</span><span>]</span><span>;</span>
<span>}</span>
</code></pre></div><h3 id="数学推导" tabindex="-1"> 数学推导</h3>
<p>跳上 n-1 级台阶，可以从 n-2 级跳 1 级上去，也可以从 n-3 级跳 2 级上去...，那么</p>
<div><pre><code>f(n-1) = f(n-2) + f(n-3) + ... + f(0)
</code></pre></div><p>同样，跳上 n 级台阶，可以从 n-1 级跳 1 级上去，也可以从 n-2 级跳 2 级上去... ，那么</p>
<div><pre><code>f(n) = f(n-1) + f(n-2) + ... + f(0)
</code></pre></div><p>综上可得</p>
<div><pre><code>f(n) - f(n-1) = f(n-1)
</code></pre></div><p>即</p>
<div><pre><code>f(n) = 2*f(n-1)
</code></pre></div><p>所以 f(n) 是一个等比数列</p>
<div><pre><code>public int JumpFloorII(int target) {
    return (int) Math.pow(2, target - 1);
}
</code></pre></div><h1 id="_11-旋转数组的最小数字" tabindex="-1"> 11. 旋转数组的最小数字</h1>
<p><a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&amp;tqId=11159&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-4" tabindex="-1"> 题目描述</h2>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0038204c-4b8a-42a5-921d-080f6674f989.png" width="210px"> </div><br>
<h2 id="解题思路-4" tabindex="-1"> 解题思路</h2>
<p>将旋转数组对半分可以得到一个包含最小元素的新旋转数组，以及一个非递减排序的数组。新的旋转数组的数组元素是原数组的一半，从而将问题规模减少了一半，这种折半性质的算法的时间复杂度为 O(logN)（为了方便，这里将 log<sub>2</sub>N 写为 logN）。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/424f34ab-a9fd-49a6-9969-d76b42251365.png" width="300px"> </div><br>
<p>此时问题的关键在于确定对半分得到的两个数组哪一个是旋转数组，哪一个是非递减数组。我们很容易知道非递减数组的第一个元素一定小于等于最后一个元素。</p>
<p>通过修改二分查找算法进行求解（l 代表 low，m 代表 mid，h 代表 high）：</p>
<ul>
<li>当 nums[m] &lt;= nums[h] 时，表示 [m, h] 区间内的数组是非递减数组，[l, m] 区间内的数组是旋转数组，此时令 h = m；</li>
<li>否则 [m + 1, h] 区间内的数组是旋转数组，令 l = m + 1。</li>
</ul>
<div><pre><code><span>public</span> <span>int</span> <span>minNumberInRotateArray</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nums<span>.</span>length <span>==</span> <span>0</span><span>)</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>int</span> l <span>=</span> <span>0</span><span>,</span> h <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span>l <span>&lt;</span> h<span>)</span> <span>{</span>
        <span>int</span> m <span>=</span> l <span>+</span> <span>(</span>h <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
        <span>if</span> <span>(</span>nums<span>[</span>m<span>]</span> <span>&lt;=</span> nums<span>[</span>h<span>]</span><span>)</span>
            h <span>=</span> m<span>;</span>
        <span>else</span>
            l <span>=</span> m <span>+</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>return</span> nums<span>[</span>l<span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>如果数组元素允许重复，会出现一个特殊的情况：nums[l] == nums[m] == nums[h]，此时无法确定解在哪个区间，需要切换到顺序查找。例如对于数组 {1,1,1,0,1}，l、m 和 h 指向的数都为 1，此时无法知道最小数字 0 在哪个区间。</p>
<div><pre><code><span>public</span> <span>int</span> <span>minNumberInRotateArray</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nums<span>.</span>length <span>==</span> <span>0</span><span>)</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>int</span> l <span>=</span> <span>0</span><span>,</span> h <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span>l <span>&lt;</span> h<span>)</span> <span>{</span>
        <span>int</span> m <span>=</span> l <span>+</span> <span>(</span>h <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
        <span>if</span> <span>(</span>nums<span>[</span>l<span>]</span> <span>==</span> nums<span>[</span>m<span>]</span> <span>&amp;&amp;</span> nums<span>[</span>m<span>]</span> <span>==</span> nums<span>[</span>h<span>]</span><span>)</span>
            <span>return</span> <span>minNumber</span><span>(</span>nums<span>,</span> l<span>,</span> h<span>)</span><span>;</span>
        <span>else</span> <span>if</span> <span>(</span>nums<span>[</span>m<span>]</span> <span>&lt;=</span> nums<span>[</span>h<span>]</span><span>)</span>
            h <span>=</span> m<span>;</span>
        <span>else</span>
            l <span>=</span> m <span>+</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>return</span> nums<span>[</span>l<span>]</span><span>;</span>
<span>}</span>

<span>private</span> <span>int</span> <span>minNumber</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> l<span>,</span> <span>int</span> h<span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> l<span>;</span> i <span>&lt;</span> h<span>;</span> i<span>++</span><span>)</span>
        <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>></span> nums<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>)</span>
            <span>return</span> nums<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>;</span>
    <span>return</span> nums<span>[</span>l<span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h1 id="_12-矩阵中的路径" tabindex="-1"> 12. 矩阵中的路径</h1>
<p><a href="https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&amp;tqId=11218&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-5" tabindex="-1"> 题目描述</h2>
<p>判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向上下左右移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。</p>
<p>例如下面的矩阵包含了一条 bfce 路径。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1db1c7ea-0443-478b-8df9-7e33b1336cc4.png" width="200px"> </div><br>
<h2 id="解题思路-5" tabindex="-1"> 解题思路</h2>
<p>使用回溯法（backtracking）进行求解，它是一种暴力搜索方法，通过搜索所有可能的结果来求解问题。回溯法在一次搜索结束时需要进行回溯（回退），将这一次搜索过程中设置的状态进行清除，从而开始一次新的搜索过程。例如下图示例中，从 f 开始，下一步有 4 种搜索可能，如果先搜索 b，需要将 b 标记为已经使用，防止重复使用。在这一次搜索结束之后，需要将 b 的已经使用状态清除，并搜索 c。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dc964b86-7a08-4bde-a3d9-e6ddceb29f98.png" width="200px"> </div><br>
<p>本题的输入是数组而不是矩阵（二维数组），因此需要先将数组转换成矩阵。</p>
<div><pre><code><span>private</span> <span>final</span> <span>static</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> next <span>=</span> <span>{</span><span>{</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>}</span><span>,</span> <span>{</span><span>0</span><span>,</span> <span>1</span><span>}</span><span>,</span> <span>{</span><span>-</span><span>1</span><span>,</span> <span>0</span><span>}</span><span>,</span> <span>{</span><span>1</span><span>,</span> <span>0</span><span>}</span><span>}</span><span>;</span>
<span>private</span> <span>int</span> rows<span>;</span>
<span>private</span> <span>int</span> cols<span>;</span>

<span>public</span> <span>boolean</span> <span>hasPath</span><span>(</span><span>char</span><span>[</span><span>]</span> array<span>,</span> <span>int</span> rows<span>,</span> <span>int</span> cols<span>,</span> <span>char</span><span>[</span><span>]</span> str<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>rows <span>==</span> <span>0</span> <span>||</span> cols <span>==</span> <span>0</span><span>)</span> <span>return</span> <span>false</span><span>;</span>
    <span>this</span><span>.</span>rows <span>=</span> rows<span>;</span>
    <span>this</span><span>.</span>cols <span>=</span> cols<span>;</span>
    <span>boolean</span><span>[</span><span>]</span><span>[</span><span>]</span> marked <span>=</span> <span>new</span> <span>boolean</span><span>[</span>rows<span>]</span><span>[</span>cols<span>]</span><span>;</span>
    <span>char</span><span>[</span><span>]</span><span>[</span><span>]</span> matrix <span>=</span> <span>buildMatrix</span><span>(</span>array<span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> rows<span>;</span> i<span>++</span><span>)</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> cols<span>;</span> j<span>++</span><span>)</span>
            <span>if</span> <span>(</span><span>backtracking</span><span>(</span>matrix<span>,</span> str<span>,</span> marked<span>,</span> <span>0</span><span>,</span> i<span>,</span> j<span>)</span><span>)</span>
                <span>return</span> <span>true</span><span>;</span>

    <span>return</span> <span>false</span><span>;</span>
<span>}</span>

<span>private</span> <span>boolean</span> <span>backtracking</span><span>(</span><span>char</span><span>[</span><span>]</span><span>[</span><span>]</span> matrix<span>,</span> <span>char</span><span>[</span><span>]</span> str<span>,</span>
                             <span>boolean</span><span>[</span><span>]</span><span>[</span><span>]</span> marked<span>,</span> <span>int</span> pathLen<span>,</span> <span>int</span> r<span>,</span> <span>int</span> c<span>)</span> <span>{</span>

    <span>if</span> <span>(</span>pathLen <span>==</span> str<span>.</span>length<span>)</span> <span>return</span> <span>true</span><span>;</span>
    <span>if</span> <span>(</span>r <span>&lt;</span> <span>0</span> <span>||</span> r <span>>=</span> rows <span>||</span> c <span>&lt;</span> <span>0</span> <span>||</span> c <span>>=</span> cols
            <span>||</span> matrix<span>[</span>r<span>]</span><span>[</span>c<span>]</span> <span>!=</span> str<span>[</span>pathLen<span>]</span> <span>||</span> marked<span>[</span>r<span>]</span><span>[</span>c<span>]</span><span>)</span> <span>{</span>

        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
    marked<span>[</span>r<span>]</span><span>[</span>c<span>]</span> <span>=</span> <span>true</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span><span>[</span><span>]</span> n <span>:</span> next<span>)</span>
        <span>if</span> <span>(</span><span>backtracking</span><span>(</span>matrix<span>,</span> str<span>,</span> marked<span>,</span> pathLen <span>+</span> <span>1</span><span>,</span> r <span>+</span> n<span>[</span><span>0</span><span>]</span><span>,</span> c <span>+</span> n<span>[</span><span>1</span><span>]</span><span>)</span><span>)</span>
            <span>return</span> <span>true</span><span>;</span>
    marked<span>[</span>r<span>]</span><span>[</span>c<span>]</span> <span>=</span> <span>false</span><span>;</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>

<span>private</span> <span>char</span><span>[</span><span>]</span><span>[</span><span>]</span> <span>buildMatrix</span><span>(</span><span>char</span><span>[</span><span>]</span> array<span>)</span> <span>{</span>
    <span>char</span><span>[</span><span>]</span><span>[</span><span>]</span> matrix <span>=</span> <span>new</span> <span>char</span><span>[</span>rows<span>]</span><span>[</span>cols<span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> r <span>=</span> <span>0</span><span>,</span> idx <span>=</span> <span>0</span><span>;</span> r <span>&lt;</span> rows<span>;</span> r<span>++</span><span>)</span>
        <span>for</span> <span>(</span><span>int</span> c <span>=</span> <span>0</span><span>;</span> c <span>&lt;</span> cols<span>;</span> c<span>++</span><span>)</span>
            matrix<span>[</span>r<span>]</span><span>[</span>c<span>]</span> <span>=</span> array<span>[</span>idx<span>++</span><span>]</span><span>;</span>
    <span>return</span> matrix<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h1 id="_13-机器人的运动范围" tabindex="-1"> 13. 机器人的运动范围</h1>
<p><a href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&amp;tqId=11219&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-6" tabindex="-1"> 题目描述</h2>
<p>地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。</p>
<p>例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？</p>
<h2 id="解题思路-6" tabindex="-1"> 解题思路</h2>
<p>使用深度优先搜索（Depth First Search，DFS）方法进行求解。回溯是深度优先搜索的一种特例，它在一次搜索过程中需要设置一些本次搜索过程的局部状态，并在本次搜索结束之后清除状态。而普通的深度优先搜索并不需要使用这些局部状态，虽然还是有可能设置一些全局状态。</p>
<div><pre><code><span>private</span> <span>static</span> <span>final</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> next <span>=</span> <span>{</span><span>{</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>}</span><span>,</span> <span>{</span><span>0</span><span>,</span> <span>1</span><span>}</span><span>,</span> <span>{</span><span>-</span><span>1</span><span>,</span> <span>0</span><span>}</span><span>,</span> <span>{</span><span>1</span><span>,</span> <span>0</span><span>}</span><span>}</span><span>;</span>
<span>private</span> <span>int</span> cnt <span>=</span> <span>0</span><span>;</span>
<span>private</span> <span>int</span> rows<span>;</span>
<span>private</span> <span>int</span> cols<span>;</span>
<span>private</span> <span>int</span> threshold<span>;</span>
<span>private</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> digitSum<span>;</span>

<span>public</span> <span>int</span> <span>movingCount</span><span>(</span><span>int</span> threshold<span>,</span> <span>int</span> rows<span>,</span> <span>int</span> cols<span>)</span> <span>{</span>
    <span>this</span><span>.</span>rows <span>=</span> rows<span>;</span>
    <span>this</span><span>.</span>cols <span>=</span> cols<span>;</span>
    <span>this</span><span>.</span>threshold <span>=</span> threshold<span>;</span>
    <span>initDigitSum</span><span>(</span><span>)</span><span>;</span>
    <span>boolean</span><span>[</span><span>]</span><span>[</span><span>]</span> marked <span>=</span> <span>new</span> <span>boolean</span><span>[</span>rows<span>]</span><span>[</span>cols<span>]</span><span>;</span>
    <span>dfs</span><span>(</span>marked<span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span><span>;</span>
    <span>return</span> cnt<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>dfs</span><span>(</span><span>boolean</span><span>[</span><span>]</span><span>[</span><span>]</span> marked<span>,</span> <span>int</span> r<span>,</span> <span>int</span> c<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>r <span>&lt;</span> <span>0</span> <span>||</span> r <span>>=</span> rows <span>||</span> c <span>&lt;</span> <span>0</span> <span>||</span> c <span>>=</span> cols <span>||</span> marked<span>[</span>r<span>]</span><span>[</span>c<span>]</span><span>)</span>
        <span>return</span><span>;</span>
    marked<span>[</span>r<span>]</span><span>[</span>c<span>]</span> <span>=</span> <span>true</span><span>;</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span>digitSum<span>[</span>r<span>]</span><span>[</span>c<span>]</span> <span>></span> <span>this</span><span>.</span>threshold<span>)</span>
        <span>return</span><span>;</span>
    cnt<span>++</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span><span>[</span><span>]</span> n <span>:</span> next<span>)</span>
        <span>dfs</span><span>(</span>marked<span>,</span> r <span>+</span> n<span>[</span><span>0</span><span>]</span><span>,</span> c <span>+</span> n<span>[</span><span>1</span><span>]</span><span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>initDigitSum</span><span>(</span><span>)</span> <span>{</span>
    <span>int</span><span>[</span><span>]</span> digitSumOne <span>=</span> <span>new</span> <span>int</span><span>[</span><span>Math</span><span>.</span><span>max</span><span>(</span>rows<span>,</span> cols<span>)</span><span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> digitSumOne<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>int</span> n <span>=</span> i<span>;</span>
        <span>while</span> <span>(</span>n <span>></span> <span>0</span><span>)</span> <span>{</span>
            digitSumOne<span>[</span>i<span>]</span> <span>+=</span> n <span>%</span> <span>10</span><span>;</span>
            n <span>/=</span> <span>10</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>this</span><span>.</span>digitSum <span>=</span> <span>new</span> <span>int</span><span>[</span>rows<span>]</span><span>[</span>cols<span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>this</span><span>.</span>rows<span>;</span> i<span>++</span><span>)</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> <span>this</span><span>.</span>cols<span>;</span> j<span>++</span><span>)</span>
            <span>this</span><span>.</span>digitSum<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> digitSumOne<span>[</span>i<span>]</span> <span>+</span> digitSumOne<span>[</span>j<span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h1 id="_14-剪绳子" tabindex="-1"> 14. 剪绳子</h1>
<p><a href="https://leetcode.com/problems/integer-break/description/" target="_blank" rel="noopener noreferrer">Leetcode</a></p>
<h2 id="题目描述-7" tabindex="-1"> 题目描述</h2>
<p>把一根绳子剪成多段，并且使得每段的长度乘积最大。</p>
<div><pre><code>n = 2
return 1 (2 = 1 + 1)

n = 10
return 36 (10 = 3 + 3 + 4)
</code></pre></div><h2 id="解题思路-7" tabindex="-1"> 解题思路</h2>
<h3 id="贪心" tabindex="-1"> 贪心</h3>
<p>尽可能多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。</p>
<p>证明：当 n &gt;= 5 时，3(n - 3) - n = 2n - 9 &gt; 0，且 2(n - 2) - n = n - 4 &gt; 0。因此在 n &gt;= 5 的情况下，将绳子剪成一段为 2 或者 3，得到的乘积会更大。又因为 3(n - 3) - 2(n - 2) = n - 5 &gt;= 0，所以剪成一段长度为 3 比长度为 2 得到的乘积更大。</p>
<div><pre><code><span>public</span> <span>int</span> <span>integerBreak</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>n <span>&lt;</span> <span>2</span><span>)</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>if</span> <span>(</span>n <span>==</span> <span>2</span><span>)</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>if</span> <span>(</span>n <span>==</span> <span>3</span><span>)</span>
        <span>return</span> <span>2</span><span>;</span>
    <span>int</span> timesOf3 <span>=</span> n <span>/</span> <span>3</span><span>;</span>
    <span>if</span> <span>(</span>n <span>-</span> timesOf3 <span>*</span> <span>3</span> <span>==</span> <span>1</span><span>)</span>
        timesOf3<span>--</span><span>;</span>
    <span>int</span> timesOf2 <span>=</span> <span>(</span>n <span>-</span> timesOf3 <span>*</span> <span>3</span><span>)</span> <span>/</span> <span>2</span><span>;</span>
    <span>return</span> <span>(</span><span>int</span><span>)</span> <span>(</span><span>Math</span><span>.</span><span>pow</span><span>(</span><span>3</span><span>,</span> timesOf3<span>)</span><span>)</span> <span>*</span> <span>(</span><span>int</span><span>)</span> <span>(</span><span>Math</span><span>.</span><span>pow</span><span>(</span><span>2</span><span>,</span> timesOf2<span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="动态规划-1" tabindex="-1"> 动态规划</h3>
<div><pre><code><span>public</span> <span>int</span> <span>integerBreak</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>int</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span>n <span>+</span> <span>1</span><span>]</span><span>;</span>
    dp<span>[</span><span>1</span><span>]</span> <span>=</span> <span>1</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>1</span><span>;</span> j <span>&lt;</span> i<span>;</span> j<span>++</span><span>)</span>
            dp<span>[</span>i<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>dp<span>[</span>i<span>]</span><span>,</span> <span>Math</span><span>.</span><span>max</span><span>(</span>j <span>*</span> <span>(</span>i <span>-</span> j<span>)</span><span>,</span> dp<span>[</span>j<span>]</span> <span>*</span> <span>(</span>i <span>-</span> j<span>)</span><span>)</span><span>)</span><span>;</span>
    <span>return</span> dp<span>[</span>n<span>]</span><span>;</span>
<span>}</span>
</code></pre></div><h1 id="_15-二进制中-1-的个数" tabindex="-1"> 15. 二进制中 1 的个数</h1>
<p><a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&amp;tqId=11164&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-8" tabindex="-1"> 题目描述</h2>
<p>输入一个整数，输出该数二进制表示中 1 的个数。</p>
<h3 id="n-n-1" tabindex="-1"> n&amp;(n-1)</h3>
<p>该位运算去除 n 的位级表示中最低的那一位。</p>
<div><pre><code>n       : 10110100
n-1     : 10110011
n&amp;(n-1) : 10110000
</code></pre></div><p>时间复杂度：O(M)，其中 M 表示 1 的个数。</p>
<div><pre><code><span>public</span> <span>int</span> <span>NumberOf1</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>int</span> cnt <span>=</span> <span>0</span><span>;</span>
    <span>while</span> <span>(</span>n <span>!=</span> <span>0</span><span>)</span> <span>{</span>
        cnt<span>++</span><span>;</span>
        n <span>&amp;=</span> <span>(</span>n <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> cnt<span>;</span>
<span>}</span>
</code></pre></div><h3 id="integer-bitcount" tabindex="-1"> Integer.bitCount()</h3>
<div><pre><code><span>public</span> <span>int</span> <span>NumberOf1</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>return</span> <span>Integer</span><span>.</span><span>bitCount</span><span>(</span>n<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h1 id="_16-数值的整数次方" tabindex="-1"> 16. 数值的整数次方</h1>
<p><a href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&amp;tqId=11165&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-9" tabindex="-1"> 题目描述</h2>
<p>给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent，求 base 的 exponent 次方。</p>
<h2 id="解题思路-8" tabindex="-1"> 解题思路</h2>
<p>下面的讨论中 x 代表 base，n 代表 exponent。</p>

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/48b1d459-8832-4e92-938a-728aae730739.jpg" width="330px"> </div><br>
<p>因为 (x*x)<sup>n/2</sup> 可以通过递归求解，并且每次递归 n 都减小一半，因此整个算法的时间复杂度为 O(logN)。</p>
<div><pre><code><span>public</span> <span>double</span> <span>Power</span><span>(</span><span>double</span> base<span>,</span> <span>int</span> exponent<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>exponent <span>==</span> <span>0</span><span>)</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>if</span> <span>(</span>exponent <span>==</span> <span>1</span><span>)</span>
        <span>return</span> base<span>;</span>
    <span>boolean</span> isNegative <span>=</span> <span>false</span><span>;</span>
    <span>if</span> <span>(</span>exponent <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
        exponent <span>=</span> <span>-</span>exponent<span>;</span>
        isNegative <span>=</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>double</span> pow <span>=</span> <span>Power</span><span>(</span>base <span>*</span> base<span>,</span> exponent <span>/</span> <span>2</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>exponent <span>%</span> <span>2</span> <span>!=</span> <span>0</span><span>)</span>
        pow <span>=</span> pow <span>*</span> base<span>;</span>
    <span>return</span> isNegative <span>?</span> <span>1</span> <span>/</span> pow <span>:</span> pow<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h1 id="_17-打印从-1-到最大的-n-位数" tabindex="-1"> 17. 打印从 1 到最大的 n 位数</h1>
<h2 id="题目描述-10" tabindex="-1"> 题目描述</h2>
<p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数即 999。</p>
<h2 id="解题思路-9" tabindex="-1"> 解题思路</h2>
<p>由于 n 可能会非常大，因此不能直接用 int 表示数字，而是用 char 数组进行存储。</p>
<p>使用回溯法得到所有的数。</p>
<div><pre><code><span>public</span> <span>void</span> <span>print1ToMaxOfNDigits</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>n <span>&lt;=</span> <span>0</span><span>)</span>
        <span>return</span><span>;</span>
    <span>char</span><span>[</span><span>]</span> number <span>=</span> <span>new</span> <span>char</span><span>[</span>n<span>]</span><span>;</span>
    <span>print1ToMaxOfNDigits</span><span>(</span>number<span>,</span> <span>0</span><span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>print1ToMaxOfNDigits</span><span>(</span><span>char</span><span>[</span><span>]</span> number<span>,</span> <span>int</span> digit<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>digit <span>==</span> number<span>.</span>length<span>)</span> <span>{</span>
        <span>printNumber</span><span>(</span>number<span>)</span><span>;</span>
        <span>return</span><span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        number<span>[</span>digit<span>]</span> <span>=</span> <span>(</span><span>char</span><span>)</span> <span>(</span>i <span>+</span> <span>'0'</span><span>)</span><span>;</span>
        <span>print1ToMaxOfNDigits</span><span>(</span>number<span>,</span> digit <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>private</span> <span>void</span> <span>printNumber</span><span>(</span><span>char</span><span>[</span><span>]</span> number<span>)</span> <span>{</span>
    <span>int</span> index <span>=</span> <span>0</span><span>;</span>
    <span>while</span> <span>(</span>index <span>&lt;</span> number<span>.</span>length <span>&amp;&amp;</span> number<span>[</span>index<span>]</span> <span>==</span> <span>'0'</span><span>)</span>
        index<span>++</span><span>;</span>
    <span>while</span> <span>(</span>index <span>&lt;</span> number<span>.</span>length<span>)</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>number<span>[</span>index<span>++</span><span>]</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h1 id="_18-1-在-o-1-时间内删除链表节点" tabindex="-1"> 18.1 在 O(1) 时间内删除链表节点</h1>
<h2 id="解题思路-10" tabindex="-1"> 解题思路</h2>
<p>① 如果该节点不是尾节点，那么可以直接将下一个节点的值赋给该节点，然后令该节点指向下下个节点，再删除下一个节点，时间复杂度为 O(1)。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1176f9e1-3442-4808-a47a-76fbaea1b806.png" width="600"/> </div><br>
<p>② 否则，就需要先遍历链表，找到节点的前一个节点，然后让前一个节点指向 null，时间复杂度为 O(N)。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4bf8d0ba-36f0-459e-83a0-f15278a5a157.png" width="600"/> </div><br>
<p>综上，如果进行 N 次操作，那么大约需要操作节点的次数为 N-1+N=2N-1，其中 N-1 表示 N-1 个不是尾节点的每个节点以 O(1) 的时间复杂度操作节点的总次数，N 表示 1 个尾节点以 O(N) 的时间复杂度操作节点的总次数。(2N-1)/N ~ 2，因此该算法的平均时间复杂度为 O(1)。</p>
<div><pre><code><span>public</span> <span>ListNode</span> <span>deleteNode</span><span>(</span><span>ListNode</span> head<span>,</span> <span>ListNode</span> tobeDelete<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>head <span>==</span> <span>null</span> <span>||</span> tobeDelete <span>==</span> <span>null</span><span>)</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>if</span> <span>(</span>tobeDelete<span>.</span>next <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>// 要删除的节点不是尾节点</span>
        <span>ListNode</span> next <span>=</span> tobeDelete<span>.</span>next<span>;</span>
        tobeDelete<span>.</span>val <span>=</span> next<span>.</span>val<span>;</span>
        tobeDelete<span>.</span>next <span>=</span> next<span>.</span>next<span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>if</span> <span>(</span>head <span>==</span> tobeDelete<span>)</span>
             <span>// 只有一个节点</span>
            head <span>=</span> <span>null</span><span>;</span>
        <span>else</span> <span>{</span>
            <span>ListNode</span> cur <span>=</span> head<span>;</span>
            <span>while</span> <span>(</span>cur<span>.</span>next <span>!=</span> tobeDelete<span>)</span>
                cur <span>=</span> cur<span>.</span>next<span>;</span>
            cur<span>.</span>next <span>=</span> <span>null</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> head<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h1 id="_18-2-删除链表中重复的结点" tabindex="-1"> 18.2 删除链表中重复的结点</h1>
<p><a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&amp;tqId=11209&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-11" tabindex="-1"> 题目描述</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/17e301df-52e8-4886-b593-841a16d13e44.png" width="450"/> </div><br>
<h2 id="解题描述" tabindex="-1"> 解题描述</h2>
<div><pre><code><span>public</span> <span>ListNode</span> <span>deleteDuplication</span><span>(</span><span>ListNode</span> pHead<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>pHead <span>==</span> <span>null</span> <span>||</span> pHead<span>.</span>next <span>==</span> <span>null</span><span>)</span>
        <span>return</span> pHead<span>;</span>
    <span>ListNode</span> next <span>=</span> pHead<span>.</span>next<span>;</span>
    <span>if</span> <span>(</span>pHead<span>.</span>val <span>==</span> next<span>.</span>val<span>)</span> <span>{</span>
        <span>while</span> <span>(</span>next <span>!=</span> <span>null</span> <span>&amp;&amp;</span> pHead<span>.</span>val <span>==</span> next<span>.</span>val<span>)</span>
            next <span>=</span> next<span>.</span>next<span>;</span>
        <span>return</span> <span>deleteDuplication</span><span>(</span>next<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        pHead<span>.</span>next <span>=</span> <span>deleteDuplication</span><span>(</span>pHead<span>.</span>next<span>)</span><span>;</span>
        <span>return</span> pHead<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h1 id="_19-正则表达式匹配" tabindex="-1"> 19. 正则表达式匹配</h1>
<p><a href="https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&amp;tqId=11205&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-12" tabindex="-1"> 题目描述</h2>
<p>请实现一个函数用来匹配包括 '.' 和 '*' 的正则表达式。模式中的字符 '.' 表示任意一个字符，而 '*' 表示它前面的字符可以出现任意次（包含 0 次）。</p>
<p>在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 &quot;aaa&quot; 与模式 &quot;a.a&quot; 和 &quot;ab*ac*a&quot; 匹配，但是与 &quot;aa.a&quot; 和 &quot;ab*a&quot; 均不匹配。</p>
<h2 id="解题思路-11" tabindex="-1"> 解题思路</h2>
<p>应该注意到，'.' 是用来当做一个任意字符，而 '*' 是用来重复前面的字符。这两个的作用不同，不能把 '.' 的作用和 '*' 进行类比，从而把它当成重复前面字符一次。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>match</span><span>(</span><span>char</span><span>[</span><span>]</span> str<span>,</span> <span>char</span><span>[</span><span>]</span> pattern<span>)</span> <span>{</span>

    <span>int</span> m <span>=</span> str<span>.</span>length<span>,</span> n <span>=</span> pattern<span>.</span>length<span>;</span>
    <span>boolean</span><span>[</span><span>]</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>boolean</span><span>[</span>m <span>+</span> <span>1</span><span>]</span><span>[</span>n <span>+</span> <span>1</span><span>]</span><span>;</span>

    dp<span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>true</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span>
        <span>if</span> <span>(</span>pattern<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>==</span> <span>'*'</span><span>)</span>
            dp<span>[</span><span>0</span><span>]</span><span>[</span>i<span>]</span> <span>=</span> dp<span>[</span><span>0</span><span>]</span><span>[</span>i <span>-</span> <span>2</span><span>]</span><span>;</span>

    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> m<span>;</span> i<span>++</span><span>)</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>1</span><span>;</span> j <span>&lt;=</span> n<span>;</span> j<span>++</span><span>)</span>
            <span>if</span> <span>(</span>str<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>==</span> pattern<span>[</span>j <span>-</span> <span>1</span><span>]</span> <span>||</span> pattern<span>[</span>j <span>-</span> <span>1</span><span>]</span> <span>==</span> <span>'.'</span><span>)</span>
                dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span><span>;</span>
            <span>else</span> <span>if</span> <span>(</span>pattern<span>[</span>j <span>-</span> <span>1</span><span>]</span> <span>==</span> <span>'*'</span><span>)</span>
                <span>if</span> <span>(</span>pattern<span>[</span>j <span>-</span> <span>2</span><span>]</span> <span>==</span> str<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>||</span> pattern<span>[</span>j <span>-</span> <span>2</span><span>]</span> <span>==</span> <span>'.'</span><span>)</span> <span>{</span>
                    dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>|=</span> dp<span>[</span>i<span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span><span>;</span> <span>// a* counts as single a</span>
                    dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>|=</span> dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j<span>]</span><span>;</span> <span>// a* counts as multiple a</span>
                    dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>|=</span> dp<span>[</span>i<span>]</span><span>[</span>j <span>-</span> <span>2</span><span>]</span><span>;</span> <span>// a* counts as empty</span>
                <span>}</span> <span>else</span>
                    dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> dp<span>[</span>i<span>]</span><span>[</span>j <span>-</span> <span>2</span><span>]</span><span>;</span>   <span>// a* only counts as empty</span>

    <span>return</span> dp<span>[</span>m<span>]</span><span>[</span>n<span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>20. 表示数值的字符串</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-20~29.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-20~29.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">20. 表示数值的字符串</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>

<h1 id="_20-表示数值的字符串" tabindex="-1"> 20. 表示数值的字符串</h1>
<p><a href="https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&amp;tqId=11206&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述" tabindex="-1"> 题目描述</h2>
<div><pre><code>true

"+100"
"5e2"
"-123"
"3.1416"
"-1E-16"
</code></pre></div><div><pre><code>false

"12e"
"1a3.14"
"1.2.3"
"+-5"
"12e+4.3"
</code></pre></div><h2 id="解题思路" tabindex="-1"> 解题思路</h2>
<p>使用正则表达式进行匹配。</p>
<div><pre><code>[]  ： 字符集合
()  ： 分组
?   ： 重复 0 ~ 1 次
+   ： 重复 1 ~ n 次
*   ： 重复 0 ~ n 次
.   ： 任意字符
\\. ： 转义后的 .
\\d ： 数字
</code></pre></div><div><pre><code><span>public</span> <span>boolean</span> <span>isNumeric</span><span>(</span><span>char</span><span>[</span><span>]</span> str<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>str <span>==</span> <span>null</span> <span>||</span> str<span>.</span>length <span>==</span> <span>0</span><span>)</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>return</span> <span>new</span> <span>String</span><span>(</span>str<span>)</span><span>.</span><span>matches</span><span>(</span><span>"[+-]?\\d*(\\.\\d+)?([eE][+-]?\\d+)?"</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h1 id="_21-调整数组顺序使奇数位于偶数前面" tabindex="-1"> 21. 调整数组顺序使奇数位于偶数前面</h1>
<p><a href="https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&amp;tqId=11166&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-1" tabindex="-1"> 题目描述</h2>
<p>需要保证奇数和奇数，偶数和偶数之间的相对位置不变，这和书本不太一样。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d03a2efa-ef19-4c96-97e8-ff61df8061d3.png" width="200px"> </div><br>
<h2 id="解题思路-1" tabindex="-1"> 解题思路</h2>
<p>方法一：创建一个新数组，时间复杂度 O(N)，空间复杂度 O(N)。</p>
<div><pre><code><span>public</span> <span>void</span> <span>reOrderArray</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>// 奇数个数</span>
    <span>int</span> oddCnt <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> x <span>:</span> nums<span>)</span>
        <span>if</span> <span>(</span><span>!</span><span>isEven</span><span>(</span>x<span>)</span><span>)</span>
            oddCnt<span>++</span><span>;</span>
    <span>int</span><span>[</span><span>]</span> copy <span>=</span> nums<span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>
    <span>int</span> i <span>=</span> <span>0</span><span>,</span> j <span>=</span> oddCnt<span>;</span>
    <span>for</span> <span>(</span><span>int</span> num <span>:</span> copy<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>num <span>%</span> <span>2</span> <span>==</span> <span>1</span><span>)</span>
            nums<span>[</span>i<span>++</span><span>]</span> <span>=</span> num<span>;</span>
        <span>else</span>
            nums<span>[</span>j<span>++</span><span>]</span> <span>=</span> num<span>;</span>
    <span>}</span>
<span>}</span>

<span>private</span> <span>boolean</span> <span>isEven</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
    <span>return</span> x <span>%</span> <span>2</span> <span>==</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>方法二：使用冒泡思想，每次都当前偶数上浮到当前最右边。时间复杂度 O(N<sup>2</sup>)，空间复杂度 O(1)，时间换空间。</p>
<div><pre><code><span>public</span> <span>void</span> <span>reOrderArray</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>int</span> <span>N</span> <span>=</span> nums<span>.</span>length<span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>N</span> <span>-</span> <span>1</span><span>;</span> i <span>></span> <span>0</span><span>;</span> i<span>--</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> i<span>;</span> j<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>isEven</span><span>(</span>nums<span>[</span>j<span>]</span><span>)</span> <span>&amp;&amp;</span> <span>!</span><span>isEven</span><span>(</span>nums<span>[</span>j <span>+</span> <span>1</span><span>]</span><span>)</span><span>)</span> <span>{</span>
                <span>swap</span><span>(</span>nums<span>,</span> j<span>,</span> j <span>+</span> <span>1</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>private</span> <span>boolean</span> <span>isEven</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
    <span>return</span> x <span>%</span> <span>2</span> <span>==</span> <span>0</span><span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>
    <span>int</span> t <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
    nums<span>[</span>i<span>]</span> <span>=</span> nums<span>[</span>j<span>]</span><span>;</span>
    nums<span>[</span>j<span>]</span> <span>=</span> t<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h1 id="_22-链表中倒数第-k-个结点" tabindex="-1"> 22. 链表中倒数第 K 个结点</h1>
<p><a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;tqId=11167&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="解题思路-2" tabindex="-1"> 解题思路</h2>
<p>设链表的长度为 N。设置两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到第 N - K 个节点处，该位置就是倒数第 K 个节点。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6b504f1f-bf76-4aab-a146-a9c7a58c2029.png" width="500"/> </div><br>
<div><pre><code><span>public</span> <span>ListNode</span> <span>FindKthToTail</span><span>(</span><span>ListNode</span> head<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>head <span>==</span> <span>null</span><span>)</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>ListNode</span> P1 <span>=</span> head<span>;</span>
    <span>while</span> <span>(</span>P1 <span>!=</span> <span>null</span> <span>&amp;&amp;</span> k<span>--</span> <span>></span> <span>0</span><span>)</span>
        P1 <span>=</span> P1<span>.</span>next<span>;</span>
    <span>if</span> <span>(</span>k <span>></span> <span>0</span><span>)</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>ListNode</span> P2 <span>=</span> head<span>;</span>
    <span>while</span> <span>(</span>P1 <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        P1 <span>=</span> P1<span>.</span>next<span>;</span>
        P2 <span>=</span> P2<span>.</span>next<span>;</span>
    <span>}</span>
    <span>return</span> P2<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h1 id="_23-链表中环的入口结点" tabindex="-1"> 23. 链表中环的入口结点</h1>
<p><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&amp;tqId=11208&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-2" tabindex="-1"> 题目描述</h2>
<p>一个链表中包含环，请找出该链表的环的入口结点。要求不能使用额外的空间。</p>
<h2 id="解题思路-3" tabindex="-1"> 解题思路</h2>
<p>使用双指针，一个指针 fast 每次移动两个节点，一个指针 slow 每次移动一个节点。因为存在环，所以两个指针必定相遇在环中的某个节点上。假设相遇点在下图的 z1 位置，此时 fast 移动的节点数为 x+2y+z，slow 为 x+y，由于 fast 速度比 slow 快一倍，因此 x+2y+z=2(x+y)，得到 x=z。</p>
<p>在相遇点，slow 要到环的入口点还需要移动 z 个节点，如果让 fast 重新从头开始移动，并且速度变为每次移动一个节点，那么它到环入口点还需要移动 x 个节点。在上面已经推导出 x=z，因此 fast 和 slow 将在环入口点相遇。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/bb7fc182-98c2-4860-8ea3-630e27a5f29f.png" width="500"/> </div><br>
<div><pre><code><span>public</span> <span>ListNode</span> <span>EntryNodeOfLoop</span><span>(</span><span>ListNode</span> pHead<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>pHead <span>==</span> <span>null</span> <span>||</span> pHead<span>.</span>next <span>==</span> <span>null</span><span>)</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>ListNode</span> slow <span>=</span> pHead<span>,</span> fast <span>=</span> pHead<span>;</span>
    <span>do</span> <span>{</span>
        fast <span>=</span> fast<span>.</span>next<span>.</span>next<span>;</span>
        slow <span>=</span> slow<span>.</span>next<span>;</span>
    <span>}</span> <span>while</span> <span>(</span>slow <span>!=</span> fast<span>)</span><span>;</span>
    fast <span>=</span> pHead<span>;</span>
    <span>while</span> <span>(</span>slow <span>!=</span> fast<span>)</span> <span>{</span>
        slow <span>=</span> slow<span>.</span>next<span>;</span>
        fast <span>=</span> fast<span>.</span>next<span>;</span>
    <span>}</span>
    <span>return</span> slow<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h1 id="_24-反转链表" tabindex="-1"> 24. 反转链表</h1>
<p><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&amp;tqId=11168&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="解题思路-4" tabindex="-1"> 解题思路</h2>
<h3 id="递归" tabindex="-1"> 递归</h3>
<div><pre><code><span>public</span> <span>ListNode</span> <span>ReverseList</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>head <span>==</span> <span>null</span> <span>||</span> head<span>.</span>next <span>==</span> <span>null</span><span>)</span>
        <span>return</span> head<span>;</span>
    <span>ListNode</span> next <span>=</span> head<span>.</span>next<span>;</span>
    head<span>.</span>next <span>=</span> <span>null</span><span>;</span>
    <span>ListNode</span> newHead <span>=</span> <span>ReverseList</span><span>(</span>next<span>)</span><span>;</span>
    next<span>.</span>next <span>=</span> head<span>;</span>
    <span>return</span> newHead<span>;</span>
<span>}</span>
</code></pre></div><h3 id="迭代" tabindex="-1"> 迭代</h3>
<p>使用头插法。</p>
<div><pre><code><span>public</span> <span>ListNode</span> <span>ReverseList</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>
    <span>ListNode</span> newList <span>=</span> <span>new</span> <span>ListNode</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>
    <span>while</span> <span>(</span>head <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>ListNode</span> next <span>=</span> head<span>.</span>next<span>;</span>
        head<span>.</span>next <span>=</span> newList<span>.</span>next<span>;</span>
        newList<span>.</span>next <span>=</span> head<span>;</span>
        head <span>=</span> next<span>;</span>
    <span>}</span>
    <span>return</span> newList<span>.</span>next<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h1 id="_25-合并两个排序的链表" tabindex="-1"> 25. 合并两个排序的链表</h1>
<p><a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&amp;tqId=11169&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-3" tabindex="-1"> 题目描述</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c094d2bc-ec75-444b-af77-d369dfb6b3b4.png" width="400"/> </div><br>
<h2 id="解题思路-5" tabindex="-1"> 解题思路</h2>
<h3 id="递归-1" tabindex="-1"> 递归</h3>
<div><pre><code><span>public</span> <span>ListNode</span> <span>Merge</span><span>(</span><span>ListNode</span> list1<span>,</span> <span>ListNode</span> list2<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>list1 <span>==</span> <span>null</span><span>)</span>
        <span>return</span> list2<span>;</span>
    <span>if</span> <span>(</span>list2 <span>==</span> <span>null</span><span>)</span>
        <span>return</span> list1<span>;</span>
    <span>if</span> <span>(</span>list1<span>.</span>val <span>&lt;=</span> list2<span>.</span>val<span>)</span> <span>{</span>
        list1<span>.</span>next <span>=</span> <span>Merge</span><span>(</span>list1<span>.</span>next<span>,</span> list2<span>)</span><span>;</span>
        <span>return</span> list1<span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        list2<span>.</span>next <span>=</span> <span>Merge</span><span>(</span>list1<span>,</span> list2<span>.</span>next<span>)</span><span>;</span>
        <span>return</span> list2<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="迭代-1" tabindex="-1"> 迭代</h3>
<div><pre><code><span>public</span> <span>ListNode</span> <span>Merge</span><span>(</span><span>ListNode</span> list1<span>,</span> <span>ListNode</span> list2<span>)</span> <span>{</span>
    <span>ListNode</span> head <span>=</span> <span>new</span> <span>ListNode</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>
    <span>ListNode</span> cur <span>=</span> head<span>;</span>
    <span>while</span> <span>(</span>list1 <span>!=</span> <span>null</span> <span>&amp;&amp;</span> list2 <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>list1<span>.</span>val <span>&lt;=</span> list2<span>.</span>val<span>)</span> <span>{</span>
            cur<span>.</span>next <span>=</span> list1<span>;</span>
            list1 <span>=</span> list1<span>.</span>next<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            cur<span>.</span>next <span>=</span> list2<span>;</span>
            list2 <span>=</span> list2<span>.</span>next<span>;</span>
        <span>}</span>
        cur <span>=</span> cur<span>.</span>next<span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>list1 <span>!=</span> <span>null</span><span>)</span>
        cur<span>.</span>next <span>=</span> list1<span>;</span>
    <span>if</span> <span>(</span>list2 <span>!=</span> <span>null</span><span>)</span>
        cur<span>.</span>next <span>=</span> list2<span>;</span>
    <span>return</span> head<span>.</span>next<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h1 id="_26-树的子结构" tabindex="-1"> 26. 树的子结构</h1>
<p><a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&amp;tqId=11170&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-4" tabindex="-1"> 题目描述</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/84a5b15a-86c5-4d8e-9439-d9fd5a4699a1.jpg" width="450"/> </div><br>
<h2 id="解题思路-6" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>public</span> <span>boolean</span> <span>HasSubtree</span><span>(</span><span>TreeNode</span> root1<span>,</span> <span>TreeNode</span> root2<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root1 <span>==</span> <span>null</span> <span>||</span> root2 <span>==</span> <span>null</span><span>)</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>return</span> <span>isSubtreeWithRoot</span><span>(</span>root1<span>,</span> root2<span>)</span> <span>||</span> <span>HasSubtree</span><span>(</span>root1<span>.</span>left<span>,</span> root2<span>)</span> <span>||</span> <span>HasSubtree</span><span>(</span>root1<span>.</span>right<span>,</span> root2<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>boolean</span> <span>isSubtreeWithRoot</span><span>(</span><span>TreeNode</span> root1<span>,</span> <span>TreeNode</span> root2<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root2 <span>==</span> <span>null</span><span>)</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>if</span> <span>(</span>root1 <span>==</span> <span>null</span><span>)</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>if</span> <span>(</span>root1<span>.</span>val <span>!=</span> root2<span>.</span>val<span>)</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>return</span> <span>isSubtreeWithRoot</span><span>(</span>root1<span>.</span>left<span>,</span> root2<span>.</span>left<span>)</span> <span>&amp;&amp;</span> <span>isSubtreeWithRoot</span><span>(</span>root1<span>.</span>right<span>,</span> root2<span>.</span>right<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h1 id="_27-二叉树的镜像" tabindex="-1"> 27. 二叉树的镜像</h1>
<p><a href="https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&amp;tqId=11171&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-5" tabindex="-1"> 题目描述</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0c12221f-729e-4c22-b0ba-0dfc909f8adf.jpg" width="300"/> </div><br>
<h2 id="解题思路-7" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>public</span> <span>void</span> <span>Mirror</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span>
        <span>return</span><span>;</span>
    <span>swap</span><span>(</span>root<span>)</span><span>;</span>
    <span>Mirror</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>
    <span>Mirror</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>swap</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>TreeNode</span> t <span>=</span> root<span>.</span>left<span>;</span>
    root<span>.</span>left <span>=</span> root<span>.</span>right<span>;</span>
    root<span>.</span>right <span>=</span> t<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h1 id="_28-对称的二叉树" tabindex="-1"> 28 对称的二叉树</h1>
<p><a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&amp;tqId=11211&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-6" tabindex="-1"> 题目描述</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0c12221f-729e-4c22-b0ba-0dfc909f8adf.jpg" width="300"/> </div><br>
<h2 id="解题思路-8" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>boolean</span> <span>isSymmetrical</span><span>(</span><span>TreeNode</span> pRoot<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>pRoot <span>==</span> <span>null</span><span>)</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>return</span> <span>isSymmetrical</span><span>(</span>pRoot<span>.</span>left<span>,</span> pRoot<span>.</span>right<span>)</span><span>;</span>
<span>}</span>

<span>boolean</span> <span>isSymmetrical</span><span>(</span><span>TreeNode</span> t1<span>,</span> <span>TreeNode</span> t2<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>t1 <span>==</span> <span>null</span> <span>&amp;&amp;</span> t2 <span>==</span> <span>null</span><span>)</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>if</span> <span>(</span>t1 <span>==</span> <span>null</span> <span>||</span> t2 <span>==</span> <span>null</span><span>)</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>if</span> <span>(</span>t1<span>.</span>val <span>!=</span> t2<span>.</span>val<span>)</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>return</span> <span>isSymmetrical</span><span>(</span>t1<span>.</span>left<span>,</span> t2<span>.</span>right<span>)</span> <span>&amp;&amp;</span> <span>isSymmetrical</span><span>(</span>t1<span>.</span>right<span>,</span> t2<span>.</span>left<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h1 id="_29-顺时针打印矩阵" tabindex="-1"> 29. 顺时针打印矩阵</h1>
<p><a href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&amp;tqId=11172&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-7" tabindex="-1"> 题目描述</h2>
<p>下图的矩阵顺时针打印结果为：1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/48517227-324c-4664-bd26-a2d2cffe2bfe.png" width="200px"> </div><br>
<h2 id="解题思路-9" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>public</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>printMatrix</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> matrix<span>)</span> <span>{</span>
    <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> ret <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>int</span> r1 <span>=</span> <span>0</span><span>,</span> r2 <span>=</span> matrix<span>.</span>length <span>-</span> <span>1</span><span>,</span> c1 <span>=</span> <span>0</span><span>,</span> c2 <span>=</span> matrix<span>[</span><span>0</span><span>]</span><span>.</span>length <span>-</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span>r1 <span>&lt;=</span> r2 <span>&amp;&amp;</span> c1 <span>&lt;=</span> c2<span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> c1<span>;</span> i <span>&lt;=</span> c2<span>;</span> i<span>++</span><span>)</span>
            ret<span>.</span><span>add</span><span>(</span>matrix<span>[</span>r1<span>]</span><span>[</span>i<span>]</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> r1 <span>+</span> <span>1</span><span>;</span> i <span>&lt;=</span> r2<span>;</span> i<span>++</span><span>)</span>
            ret<span>.</span><span>add</span><span>(</span>matrix<span>[</span>i<span>]</span><span>[</span>c2<span>]</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>r1 <span>!=</span> r2<span>)</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> c2 <span>-</span> <span>1</span><span>;</span> i <span>>=</span> c1<span>;</span> i<span>--</span><span>)</span>
                ret<span>.</span><span>add</span><span>(</span>matrix<span>[</span>r2<span>]</span><span>[</span>i<span>]</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>c1 <span>!=</span> c2<span>)</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> r2 <span>-</span> <span>1</span><span>;</span> i <span>></span> r1<span>;</span> i<span>--</span><span>)</span>
                ret<span>.</span><span>add</span><span>(</span>matrix<span>[</span>i<span>]</span><span>[</span>c1<span>]</span><span>)</span><span>;</span>
        r1<span>++</span><span>;</span> r2<span>--</span><span>;</span> c1<span>++</span><span>;</span> c2<span>--</span><span>;</span>
    <span>}</span>
    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>30. 包含 min 函数的栈</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-30~39.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-30~39.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">30. 包含 min 函数的栈</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
</ul>

<h1 id="_30-包含-min-函数的栈" tabindex="-1"> 30. 包含 min 函数的栈</h1>
<p><a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&amp;tqId=11173&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述" tabindex="-1"> 题目描述</h2>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。</p>
<h2 id="解题思路" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>private</span> <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> dataStack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>private</span> <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> minStack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

<span>public</span> <span>void</span> <span>push</span><span>(</span><span>int</span> node<span>)</span> <span>{</span>
    dataStack<span>.</span><span>push</span><span>(</span>node<span>)</span><span>;</span>
    minStack<span>.</span><span>push</span><span>(</span>minStack<span>.</span><span>isEmpty</span><span>(</span><span>)</span> <span>?</span> node <span>:</span> <span>Math</span><span>.</span><span>min</span><span>(</span>minStack<span>.</span><span>peek</span><span>(</span><span>)</span><span>,</span> node<span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>void</span> <span>pop</span><span>(</span><span>)</span> <span>{</span>
    dataStack<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>
    minStack<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>int</span> <span>top</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> dataStack<span>.</span><span>peek</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>int</span> <span>min</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> minStack<span>.</span><span>peek</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h1 id="_31-栈的压入、弹出序列" tabindex="-1"> 31. 栈的压入、弹出序列</h1>
<p><a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;tqId=11174&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-1" tabindex="-1"> 题目描述</h2>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。</p>
<p>例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。</p>
<h2 id="解题思路-1" tabindex="-1"> 解题思路</h2>
<p>使用一个栈来模拟压入弹出操作。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>IsPopOrder</span><span>(</span><span>int</span><span>[</span><span>]</span> pushSequence<span>,</span> <span>int</span><span>[</span><span>]</span> popSequence<span>)</span> <span>{</span>
    <span>int</span> n <span>=</span> pushSequence<span>.</span>length<span>;</span>
    <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> stack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> pushIndex <span>=</span> <span>0</span><span>,</span> popIndex <span>=</span> <span>0</span><span>;</span> pushIndex <span>&lt;</span> n<span>;</span> pushIndex<span>++</span><span>)</span> <span>{</span>
        stack<span>.</span><span>push</span><span>(</span>pushSequence<span>[</span>pushIndex<span>]</span><span>)</span><span>;</span>
        <span>while</span> <span>(</span>popIndex <span>&lt;</span> n <span>&amp;&amp;</span> <span>!</span>stack<span>.</span><span>isEmpty</span><span>(</span><span>)</span> 
                <span>&amp;&amp;</span> stack<span>.</span><span>peek</span><span>(</span><span>)</span> <span>==</span> popSequence<span>[</span>popIndex<span>]</span><span>)</span> <span>{</span>
            stack<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>
            popIndex<span>++</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> stack<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h1 id="_32-1-从上往下打印二叉树" tabindex="-1"> 32.1 从上往下打印二叉树</h1>
<p><a href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&amp;tqId=11175&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-2" tabindex="-1"> 题目描述</h2>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p>例如，以下二叉树层次遍历的结果为：1,2,3,4,5,6,7</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d5e838cf-d8a2-49af-90df-1b2a714ee676.jpg" width="250"/> </div><br>
<h2 id="解题思路-2" tabindex="-1"> 解题思路</h2>
<p>使用队列来进行层次遍历。</p>
<p>不需要使用两个队列分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。</p>
<div><pre><code><span>public</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>PrintFromTopToBottom</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>Queue</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> ret <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    queue<span>.</span><span>add</span><span>(</span>root<span>)</span><span>;</span>
    <span>while</span> <span>(</span><span>!</span>queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>int</span> cnt <span>=</span> queue<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>
        <span>while</span> <span>(</span>cnt<span>--</span> <span>></span> <span>0</span><span>)</span> <span>{</span>
            <span>TreeNode</span> t <span>=</span> queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>t <span>==</span> <span>null</span><span>)</span>
                <span>continue</span><span>;</span>
            ret<span>.</span><span>add</span><span>(</span>t<span>.</span>val<span>)</span><span>;</span>
            queue<span>.</span><span>add</span><span>(</span>t<span>.</span>left<span>)</span><span>;</span>
            queue<span>.</span><span>add</span><span>(</span>t<span>.</span>right<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h1 id="_32-2-把二叉树打印成多行" tabindex="-1"> 32.2 把二叉树打印成多行</h1>
<p><a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&amp;tqId=11213&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-3" tabindex="-1"> 题目描述</h2>
<p>和上题几乎一样。</p>
<h2 id="解题思路-3" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>ArrayList</span><span><span>&lt;</span><span>ArrayList</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> <span>Print</span><span>(</span><span>TreeNode</span> pRoot<span>)</span> <span>{</span>
    <span>ArrayList</span><span><span>&lt;</span><span>ArrayList</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> ret <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>Queue</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    queue<span>.</span><span>add</span><span>(</span>pRoot<span>)</span><span>;</span>
    <span>while</span> <span>(</span><span>!</span>queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>int</span> cnt <span>=</span> queue<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>
        <span>while</span> <span>(</span>cnt<span>--</span> <span>></span> <span>0</span><span>)</span> <span>{</span>
            <span>TreeNode</span> node <span>=</span> queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span>
                <span>continue</span><span>;</span>
            list<span>.</span><span>add</span><span>(</span>node<span>.</span>val<span>)</span><span>;</span>
            queue<span>.</span><span>add</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
            queue<span>.</span><span>add</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>list<span>.</span><span>size</span><span>(</span><span>)</span> <span>!=</span> <span>0</span><span>)</span>
            ret<span>.</span><span>add</span><span>(</span>list<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h1 id="_32-3-按之字形顺序打印二叉树" tabindex="-1"> 32.3 按之字形顺序打印二叉树</h1>
<p><a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&amp;tqId=11212&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-4" tabindex="-1"> 题目描述</h2>
<p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<h2 id="解题思路-4" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>public</span> <span>ArrayList</span><span><span>&lt;</span><span>ArrayList</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> <span>Print</span><span>(</span><span>TreeNode</span> pRoot<span>)</span> <span>{</span>
    <span>ArrayList</span><span><span>&lt;</span><span>ArrayList</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> ret <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>Queue</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    queue<span>.</span><span>add</span><span>(</span>pRoot<span>)</span><span>;</span>
    <span>boolean</span> reverse <span>=</span> <span>false</span><span>;</span>
    <span>while</span> <span>(</span><span>!</span>queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>int</span> cnt <span>=</span> queue<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>
        <span>while</span> <span>(</span>cnt<span>--</span> <span>></span> <span>0</span><span>)</span> <span>{</span>
            <span>TreeNode</span> node <span>=</span> queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span>
                <span>continue</span><span>;</span>
            list<span>.</span><span>add</span><span>(</span>node<span>.</span>val<span>)</span><span>;</span>
            queue<span>.</span><span>add</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
            queue<span>.</span><span>add</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>reverse<span>)</span>
            <span>Collections</span><span>.</span><span>reverse</span><span>(</span>list<span>)</span><span>;</span>
        reverse <span>=</span> <span>!</span>reverse<span>;</span>
        <span>if</span> <span>(</span>list<span>.</span><span>size</span><span>(</span><span>)</span> <span>!=</span> <span>0</span><span>)</span>
            ret<span>.</span><span>add</span><span>(</span>list<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h1 id="_33-二叉搜索树的后序遍历序列" tabindex="-1"> 33. 二叉搜索树的后序遍历序列</h1>
<p><a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&amp;tqId=11176&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-5" tabindex="-1"> 题目描述</h2>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。假设输入的数组的任意两个数字都互不相同。</p>
<p>例如，下图是后序遍历序列 1,3,2 所对应的二叉搜索树。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/13454fa1-23a8-4578-9663-2b13a6af564a.jpg" width="150"/> </div><br>
<h2 id="解题思路-5" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>public</span> <span>boolean</span> <span>VerifySquenceOfBST</span><span>(</span><span>int</span><span>[</span><span>]</span> sequence<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>sequence <span>==</span> <span>null</span> <span>||</span> sequence<span>.</span>length <span>==</span> <span>0</span><span>)</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>return</span> <span>verify</span><span>(</span>sequence<span>,</span> <span>0</span><span>,</span> sequence<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>boolean</span> <span>verify</span><span>(</span><span>int</span><span>[</span><span>]</span> sequence<span>,</span> <span>int</span> first<span>,</span> <span>int</span> last<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>last <span>-</span> first <span>&lt;=</span> <span>1</span><span>)</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>int</span> rootVal <span>=</span> sequence<span>[</span>last<span>]</span><span>;</span>
    <span>int</span> cutIndex <span>=</span> first<span>;</span>
    <span>while</span> <span>(</span>cutIndex <span>&lt;</span> last <span>&amp;&amp;</span> sequence<span>[</span>cutIndex<span>]</span> <span>&lt;=</span> rootVal<span>)</span>
        cutIndex<span>++</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> cutIndex<span>;</span> i <span>&lt;</span> last<span>;</span> i<span>++</span><span>)</span>
        <span>if</span> <span>(</span>sequence<span>[</span>i<span>]</span> <span>&lt;</span> rootVal<span>)</span>
            <span>return</span> <span>false</span><span>;</span>
    <span>return</span> <span>verify</span><span>(</span>sequence<span>,</span> first<span>,</span> cutIndex <span>-</span> <span>1</span><span>)</span> <span>&amp;&amp;</span> <span>verify</span><span>(</span>sequence<span>,</span> cutIndex<span>,</span> last <span>-</span> <span>1</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h1 id="_34-二叉树中和为某一值的路径" tabindex="-1"> 34. 二叉树中和为某一值的路径</h1>
<p><a href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&amp;tqId=11177&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-6" tabindex="-1"> 题目描述</h2>
<p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<p>下图的二叉树有两条和为 22 的路径：10, 5, 7 和 10, 12</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ed77b0e6-38d9-4a34-844f-724f3ffa2c12.jpg" width="200"/> </div><br>
<h2 id="解题思路-6" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>private</span> <span>ArrayList</span><span><span>&lt;</span><span>ArrayList</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> ret <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

<span>public</span> <span>ArrayList</span><span><span>&lt;</span><span>ArrayList</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> <span>FindPath</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>int</span> target<span>)</span> <span>{</span>
    <span>backtracking</span><span>(</span>root<span>,</span> target<span>,</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>return</span> ret<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>backtracking</span><span>(</span><span>TreeNode</span> node<span>,</span> <span>int</span> target<span>,</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> path<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span>
        <span>return</span><span>;</span>
    path<span>.</span><span>add</span><span>(</span>node<span>.</span>val<span>)</span><span>;</span>
    target <span>-=</span> node<span>.</span>val<span>;</span>
    <span>if</span> <span>(</span>target <span>==</span> <span>0</span> <span>&amp;&amp;</span> node<span>.</span>left <span>==</span> <span>null</span> <span>&amp;&amp;</span> node<span>.</span>right <span>==</span> <span>null</span><span>)</span> <span>{</span>
        ret<span>.</span><span>add</span><span>(</span><span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span>path<span>)</span><span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>backtracking</span><span>(</span>node<span>.</span>left<span>,</span> target<span>,</span> path<span>)</span><span>;</span>
        <span>backtracking</span><span>(</span>node<span>.</span>right<span>,</span> target<span>,</span> path<span>)</span><span>;</span>
    <span>}</span>
    path<span>.</span><span>remove</span><span>(</span>path<span>.</span><span>size</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h1 id="_35-复杂链表的复制" tabindex="-1"> 35. 复杂链表的复制</h1>
<p><a href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&amp;tqId=11178&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-7" tabindex="-1"> 题目描述</h2>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的 head。</p>
<div><pre><code><span>public</span> <span>class</span> <span>RandomListNode</span> <span>{</span>
    <span>int</span> label<span>;</span>
    <span>RandomListNode</span> next <span>=</span> <span>null</span><span>;</span>
    <span>RandomListNode</span> random <span>=</span> <span>null</span><span>;</span>

    <span>RandomListNode</span><span>(</span><span>int</span> label<span>)</span> <span>{</span>
        <span>this</span><span>.</span>label <span>=</span> label<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66a01953-5303-43b1-8646-0c77b825e980.png" width="300"/> </div><br>
<h2 id="解题思路-7" tabindex="-1"> 解题思路</h2>
<p>第一步，在每个节点的后面插入复制的节点。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dfd5d3f8-673c-486b-8ecf-d2082107b67b.png" width="600"/> </div><br>
<p>第二步，对复制节点的 random 链接进行赋值。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cafbfeb8-7dfe-4c0a-a3c9-750eeb824068.png" width="600"/> </div><br>
<p>第三步，拆分。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e151b5df-5390-4365-b66e-b130cd253c12.png" width="600"/> </div><br>
<div><pre><code><span>public</span> <span>RandomListNode</span> <span>Clone</span><span>(</span><span>RandomListNode</span> pHead<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>pHead <span>==</span> <span>null</span><span>)</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>// 插入新节点</span>
    <span>RandomListNode</span> cur <span>=</span> pHead<span>;</span>
    <span>while</span> <span>(</span>cur <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>RandomListNode</span> clone <span>=</span> <span>new</span> <span>RandomListNode</span><span>(</span>cur<span>.</span>label<span>)</span><span>;</span>
        clone<span>.</span>next <span>=</span> cur<span>.</span>next<span>;</span>
        cur<span>.</span>next <span>=</span> clone<span>;</span>
        cur <span>=</span> clone<span>.</span>next<span>;</span>
    <span>}</span>
    <span>// 建立 random 链接</span>
    cur <span>=</span> pHead<span>;</span>
    <span>while</span> <span>(</span>cur <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>RandomListNode</span> clone <span>=</span> cur<span>.</span>next<span>;</span>
        <span>if</span> <span>(</span>cur<span>.</span>random <span>!=</span> <span>null</span><span>)</span>
            clone<span>.</span>random <span>=</span> cur<span>.</span>random<span>.</span>next<span>;</span>
        cur <span>=</span> clone<span>.</span>next<span>;</span>
    <span>}</span>
    <span>// 拆分</span>
    cur <span>=</span> pHead<span>;</span>
    <span>RandomListNode</span> pCloneHead <span>=</span> pHead<span>.</span>next<span>;</span>
    <span>while</span> <span>(</span>cur<span>.</span>next <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>RandomListNode</span> next <span>=</span> cur<span>.</span>next<span>;</span>
        cur<span>.</span>next <span>=</span> next<span>.</span>next<span>;</span>
        cur <span>=</span> next<span>;</span>
    <span>}</span>
    <span>return</span> pCloneHead<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h1 id="_36-二叉搜索树与双向链表" tabindex="-1"> 36. 二叉搜索树与双向链表</h1>
<p><a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&amp;tqId=11179&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-8" tabindex="-1"> 题目描述</h2>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/05a08f2e-9914-4a77-92ef-aebeaecf4f66.jpg" width="400"/> </div><br>
<h2 id="解题思路-8" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>private</span> <span>TreeNode</span> pre <span>=</span> <span>null</span><span>;</span>
<span>private</span> <span>TreeNode</span> head <span>=</span> <span>null</span><span>;</span>

<span>public</span> <span>TreeNode</span> <span>Convert</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>inOrder</span><span>(</span>root<span>)</span><span>;</span>
    <span>return</span> head<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>inOrder</span><span>(</span><span>TreeNode</span> node<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span>
        <span>return</span><span>;</span>
    <span>inOrder</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
    node<span>.</span>left <span>=</span> pre<span>;</span>
    <span>if</span> <span>(</span>pre <span>!=</span> <span>null</span><span>)</span>
        pre<span>.</span>right <span>=</span> node<span>;</span>
    pre <span>=</span> node<span>;</span>
    <span>if</span> <span>(</span>head <span>==</span> <span>null</span><span>)</span>
        head <span>=</span> node<span>;</span>
    <span>inOrder</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h1 id="_37-序列化二叉树" tabindex="-1"> 37. 序列化二叉树</h1>
<p><a href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&amp;tqId=11214&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-9" tabindex="-1"> 题目描述</h2>
<p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<h2 id="解题思路-9" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>private</span> <span>String</span> deserializeStr<span>;</span>

<span>public</span> <span>String</span> <span>Serialize</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span>
        <span>return</span> <span>"#"</span><span>;</span>
    <span>return</span> root<span>.</span>val <span>+</span> <span>" "</span> <span>+</span> <span>Serialize</span><span>(</span>root<span>.</span>left<span>)</span> <span>+</span> <span>" "</span> <span>+</span> <span>Serialize</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>TreeNode</span> <span>Deserialize</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
    deserializeStr <span>=</span> str<span>;</span>
    <span>return</span> <span>Deserialize</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>TreeNode</span> <span>Deserialize</span><span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>deserializeStr<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>int</span> index <span>=</span> deserializeStr<span>.</span><span>indexOf</span><span>(</span><span>" "</span><span>)</span><span>;</span>
    <span>String</span> node <span>=</span> index <span>==</span> <span>-</span><span>1</span> <span>?</span> deserializeStr <span>:</span> deserializeStr<span>.</span><span>substring</span><span>(</span><span>0</span><span>,</span> index<span>)</span><span>;</span>
    deserializeStr <span>=</span> index <span>==</span> <span>-</span><span>1</span> <span>?</span> <span>""</span> <span>:</span> deserializeStr<span>.</span><span>substring</span><span>(</span>index <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>node<span>.</span><span>equals</span><span>(</span><span>"#"</span><span>)</span><span>)</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>int</span> val <span>=</span> <span>Integer</span><span>.</span><span>valueOf</span><span>(</span>node<span>)</span><span>;</span>
    <span>TreeNode</span> t <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span>val<span>)</span><span>;</span>
    t<span>.</span>left <span>=</span> <span>Deserialize</span><span>(</span><span>)</span><span>;</span>
    t<span>.</span>right <span>=</span> <span>Deserialize</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> t<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h1 id="_38-字符串的排列" tabindex="-1"> 38. 字符串的排列</h1>
<p><a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&amp;tqId=11180&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-10" tabindex="-1"> 题目描述</h2>
<p>输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a, b, c 所能排列出来的所有字符串 abc, acb, bac, bca, cab 和 cba。</p>
<h2 id="解题思路-10" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>private</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span> ret <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

<span>public</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>Permutation</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>str<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span>
        <span>return</span> ret<span>;</span>
    <span>char</span><span>[</span><span>]</span> chars <span>=</span> str<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>;</span>
    <span>Arrays</span><span>.</span><span>sort</span><span>(</span>chars<span>)</span><span>;</span>
    <span>backtracking</span><span>(</span>chars<span>,</span> <span>new</span> <span>boolean</span><span>[</span>chars<span>.</span>length<span>]</span><span>,</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>return</span> ret<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>backtracking</span><span>(</span><span>char</span><span>[</span><span>]</span> chars<span>,</span> <span>boolean</span><span>[</span><span>]</span> hasUsed<span>,</span> <span>StringBuilder</span> s<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>s<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> chars<span>.</span>length<span>)</span> <span>{</span>
        ret<span>.</span><span>add</span><span>(</span>s<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>return</span><span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> chars<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>hasUsed<span>[</span>i<span>]</span><span>)</span>
            <span>continue</span><span>;</span>
        <span>if</span> <span>(</span>i <span>!=</span> <span>0</span> <span>&amp;&amp;</span> chars<span>[</span>i<span>]</span> <span>==</span> chars<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>&amp;&amp;</span> <span>!</span>hasUsed<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span> <span>/* 保证不重复 */</span>
            <span>continue</span><span>;</span>
        hasUsed<span>[</span>i<span>]</span> <span>=</span> <span>true</span><span>;</span>
        s<span>.</span><span>append</span><span>(</span>chars<span>[</span>i<span>]</span><span>)</span><span>;</span>
        <span>backtracking</span><span>(</span>chars<span>,</span> hasUsed<span>,</span> s<span>)</span><span>;</span>
        s<span>.</span><span>deleteCharAt</span><span>(</span>s<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
        hasUsed<span>[</span>i<span>]</span> <span>=</span> <span>false</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h1 id="_39-数组中出现次数超过一半的数字" tabindex="-1"> 39. 数组中出现次数超过一半的数字</h1>
<p><a href="https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&amp;tqId=11181&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="解题思路-11" tabindex="-1"> 解题思路</h2>
<p>多数投票问题，可以利用 Boyer-Moore Majority Vote Algorithm 来解决这个问题，使得时间复杂度为 O(N)。</p>
<p>使用 cnt 来统计一个元素出现的次数，当遍历到的元素和统计元素相等时，令 cnt++，否则令 cnt--。如果前面查找了 i 个元素，且 cnt == 0，说明前 i 个元素没有 majority，或者有 majority，但是出现的次数少于 i / 2 ，因为如果多于 i / 2 的话 cnt 就一定不会为 0 。此时剩下的 n - i 个元素中，majority 的数目依然多于 (n - i) / 2，因此继续查找就能找出 majority。</p>
<div><pre><code><span>public</span> <span>int</span> <span>MoreThanHalfNum_Solution</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>int</span> majority <span>=</span> nums<span>[</span><span>0</span><span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>,</span> cnt <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        cnt <span>=</span> nums<span>[</span>i<span>]</span> <span>==</span> majority <span>?</span> cnt <span>+</span> <span>1</span> <span>:</span> cnt <span>-</span> <span>1</span><span>;</span>
        <span>if</span> <span>(</span>cnt <span>==</span> <span>0</span><span>)</span> <span>{</span>
            majority <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
            cnt <span>=</span> <span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>int</span> cnt <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> val <span>:</span> nums<span>)</span>
        <span>if</span> <span>(</span>val <span>==</span> majority<span>)</span>
            cnt<span>++</span><span>;</span>
    <span>return</span> cnt <span>></span> nums<span>.</span>length <span>/</span> <span>2</span> <span>?</span> majority <span>:</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>3. 数组中重复的数字</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-3~9.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-3~9.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">3. 数组中重复的数字</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>

<h1 id="_3-数组中重复的数字" tabindex="-1"> 3. 数组中重复的数字</h1>
<p><a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&amp;tqId=11203&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述" tabindex="-1"> 题目描述</h2>
<p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。</p>
<div><pre><code>Input:
{2, 3, 1, 0, 2, 5}

Output:
2
</code></pre></div><h2 id="解题思路" tabindex="-1"> 解题思路</h2>
<p>要求时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。</p>
<p>对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。</p>
<p>以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/49d2adc1-b28a-44bf-babb-d44993f4a2e3.gif" width="250px"> </div><br>
<div><pre><code><span>public</span> <span>boolean</span> <span>duplicate</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> length<span>,</span> <span>int</span><span>[</span><span>]</span> duplication<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nums <span>==</span> <span>null</span> <span>||</span> length <span>&lt;=</span> <span>0</span><span>)</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>while</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>!=</span> i<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>==</span> nums<span>[</span>nums<span>[</span>i<span>]</span><span>]</span><span>)</span> <span>{</span>
                duplication<span>[</span><span>0</span><span>]</span> <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
                <span>return</span> <span>true</span><span>;</span>
            <span>}</span>
            <span>swap</span><span>(</span>nums<span>,</span> i<span>,</span> nums<span>[</span>i<span>]</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>
    <span>int</span> t <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
    nums<span>[</span>i<span>]</span> <span>=</span> nums<span>[</span>j<span>]</span><span>;</span>
    nums<span>[</span>j<span>]</span> <span>=</span> t<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h1 id="_4-二维数组中的查找" tabindex="-1"> 4. 二维数组中的查找</h1>
<p><a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;tqId=11154&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-1" tabindex="-1"> 题目描述</h2>
<p>给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。</p>
<div><pre><code>Consider the following matrix:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

Given target = 5, return true.
Given target = 20, return false.
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="解题思路-1" tabindex="-1"> 解题思路</h2>
<p>要求时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为 列数。</p>
<p>该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0ad9f7ba-f408-4999-a77a-9b73562c9088.gif" width="200px"> </div><br>
<div><pre><code><span>public</span> <span>boolean</span> <span>Find</span><span>(</span><span>int</span> target<span>,</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> matrix<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>matrix <span>==</span> <span>null</span> <span>||</span> matrix<span>.</span>length <span>==</span> <span>0</span> <span>||</span> matrix<span>[</span><span>0</span><span>]</span><span>.</span>length <span>==</span> <span>0</span><span>)</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>int</span> rows <span>=</span> matrix<span>.</span>length<span>,</span> cols <span>=</span> matrix<span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span>
    <span>int</span> r <span>=</span> <span>0</span><span>,</span> c <span>=</span> cols <span>-</span> <span>1</span><span>;</span> <span>// 从右上角开始</span>
    <span>while</span> <span>(</span>r <span>&lt;=</span> rows <span>-</span> <span>1</span> <span>&amp;&amp;</span> c <span>>=</span> <span>0</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>target <span>==</span> matrix<span>[</span>r<span>]</span><span>[</span>c<span>]</span><span>)</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>else</span> <span>if</span> <span>(</span>target <span>></span> matrix<span>[</span>r<span>]</span><span>[</span>c<span>]</span><span>)</span>
            r<span>++</span><span>;</span>
        <span>else</span>
            c<span>--</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h1 id="_5-替换空格" tabindex="-1"> 5. 替换空格</h1>
<p><a href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&amp;tqId=11155&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-2" tabindex="-1"> 题目描述</h2>
<p>将一个字符串中的空格替换成 &quot;%20&quot;。</p>
<div><pre><code>Input:
"A B"

Output:
"A%20B"
</code></pre></div><h2 id="解题思路-2" tabindex="-1"> 解题思路</h2>
<p>在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），因此当遍历到一个空格时，需要在尾部填充两个任意字符。</p>
<p>令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。</p>
<p>从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6980aef0-debe-4b4b-8da5-8b1befbc1408.gif" width="230px"> </div><br>
<div><pre><code><span>public</span> <span>String</span> <span>replaceSpace</span><span>(</span><span>StringBuffer</span> str<span>)</span> <span>{</span>
    <span>int</span> P1 <span>=</span> str<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;=</span> P1<span>;</span> i<span>++</span><span>)</span>
        <span>if</span> <span>(</span>str<span>.</span><span>charAt</span><span>(</span>i<span>)</span> <span>==</span> <span>' '</span><span>)</span>
            str<span>.</span><span>append</span><span>(</span><span>"  "</span><span>)</span><span>;</span>

    <span>int</span> P2 <span>=</span> str<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span>P1 <span>>=</span> <span>0</span> <span>&amp;&amp;</span> P2 <span>></span> P1<span>)</span> <span>{</span>
        <span>char</span> c <span>=</span> str<span>.</span><span>charAt</span><span>(</span>P1<span>--</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>c <span>==</span> <span>' '</span><span>)</span> <span>{</span>
            str<span>.</span><span>setCharAt</span><span>(</span>P2<span>--</span><span>,</span> <span>'0'</span><span>)</span><span>;</span>
            str<span>.</span><span>setCharAt</span><span>(</span>P2<span>--</span><span>,</span> <span>'2'</span><span>)</span><span>;</span>
            str<span>.</span><span>setCharAt</span><span>(</span>P2<span>--</span><span>,</span> <span>'%'</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            str<span>.</span><span>setCharAt</span><span>(</span>P2<span>--</span><span>,</span> c<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> str<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h1 id="_6-从尾到头打印链表" tabindex="-1"> 6. 从尾到头打印链表</h1>
<p><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;tqId=11156&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-3" tabindex="-1"> 题目描述</h2>
<p>从尾到头反过来打印出每个结点的值。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f5792051-d9b2-4ca4-a234-a4a2de3d5a57.png" width="280px"> </div><br>
<h2 id="解题思路-3" tabindex="-1"> 解题思路</h2>
<h3 id="使用递归" tabindex="-1"> 使用递归</h3>
<p>要逆序打印链表 1-&gt;2-&gt;3（3,2,1)，可以先逆序打印链表 2-&gt;3(3,2)，最后再打印第一个节点 1。而链表 2-&gt;3 可以看成一个新的链表，要逆序打印该链表可以继续使用求解函数，也就是在求解函数中调用自己，这就是递归函数。</p>
<div><pre><code><span>public</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>printListFromTailToHead</span><span>(</span><span>ListNode</span> listNode<span>)</span> <span>{</span>
    <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> ret <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>listNode <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        ret<span>.</span><span>addAll</span><span>(</span><span>printListFromTailToHead</span><span>(</span>listNode<span>.</span>next<span>)</span><span>)</span><span>;</span>
        ret<span>.</span><span>add</span><span>(</span>listNode<span>.</span>val<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre></div><h3 id="使用头插法" tabindex="-1"> 使用头插法</h3>
<p>使用头插法可以得到一个逆序的链表。</p>
<p>头结点和第一个节点的区别：</p>
<ul>
<li>头结点是在头插法中使用的一个额外节点，这个节点不存储值；</li>
<li>第一个节点就是链表的第一个真正存储值的节点。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0dae7e93-cfd1-4bd3-97e8-325b032b716f.gif" width="370px"> </div><br>
<div><pre><code><span>public</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>printListFromTailToHead</span><span>(</span><span>ListNode</span> listNode<span>)</span> <span>{</span>
    <span>// 头插法构建逆序链表</span>
    <span>ListNode</span> head <span>=</span> <span>new</span> <span>ListNode</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>
    <span>while</span> <span>(</span>listNode <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>ListNode</span> memo <span>=</span> listNode<span>.</span>next<span>;</span>
        listNode<span>.</span>next <span>=</span> head<span>.</span>next<span>;</span>
        head<span>.</span>next <span>=</span> listNode<span>;</span>
        listNode <span>=</span> memo<span>;</span>
    <span>}</span>
    <span>// 构建 ArrayList</span>
    <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> ret <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    head <span>=</span> head<span>.</span>next<span>;</span>
    <span>while</span> <span>(</span>head <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        ret<span>.</span><span>add</span><span>(</span>head<span>.</span>val<span>)</span><span>;</span>
        head <span>=</span> head<span>.</span>next<span>;</span>
    <span>}</span>
    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="使用栈" tabindex="-1"> 使用栈</h3>
<p>栈具有后进先出的特点，在遍历链表时将值按顺序放入栈中，最后出栈的顺序即为逆序。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9d1deeba-4ae1-41dc-98f4-47d85b9831bc.gif" width="300px"> </div><br>
<div><pre><code><span>public</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>printListFromTailToHead</span><span>(</span><span>ListNode</span> listNode<span>)</span> <span>{</span>
    <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> stack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>while</span> <span>(</span>listNode <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        stack<span>.</span><span>add</span><span>(</span>listNode<span>.</span>val<span>)</span><span>;</span>
        listNode <span>=</span> listNode<span>.</span>next<span>;</span>
    <span>}</span>
    <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> ret <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>while</span> <span>(</span><span>!</span>stack<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span>
        ret<span>.</span><span>add</span><span>(</span>stack<span>.</span><span>pop</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h1 id="_7-重建二叉树" tabindex="-1"> 7. 重建二叉树</h1>
<p><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;tqId=11157&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-4" tabindex="-1"> 题目描述</h2>
<p>根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/31d9adce-2af8-4754-8386-0aabb4e500b0.png" width="300"/> </div><br>
<h2 id="解题思路-4" tabindex="-1"> 解题思路</h2>
<p>前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c269e362-1128-4212-9cf3-d4c12b363b2f.gif" width="330px"> </div><br>
<div><pre><code><span>// 缓存中序遍历数组每个值对应的索引</span>
<span>private</span> <span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Integer</span><span>></span></span> indexForInOrders <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

<span>public</span> <span>TreeNode</span> <span>reConstructBinaryTree</span><span>(</span><span>int</span><span>[</span><span>]</span> pre<span>,</span> <span>int</span><span>[</span><span>]</span> in<span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> in<span>.</span>length<span>;</span> i<span>++</span><span>)</span>
        indexForInOrders<span>.</span><span>put</span><span>(</span>in<span>[</span>i<span>]</span><span>,</span> i<span>)</span><span>;</span>
    <span>return</span> <span>reConstructBinaryTree</span><span>(</span>pre<span>,</span> <span>0</span><span>,</span> pre<span>.</span>length <span>-</span> <span>1</span><span>,</span> <span>0</span><span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>TreeNode</span> <span>reConstructBinaryTree</span><span>(</span><span>int</span><span>[</span><span>]</span> pre<span>,</span> <span>int</span> preL<span>,</span> <span>int</span> preR<span>,</span> <span>int</span> inL<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>preL <span>></span> preR<span>)</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>TreeNode</span> root <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span>pre<span>[</span>preL<span>]</span><span>)</span><span>;</span>
    <span>int</span> inIndex <span>=</span> indexForInOrders<span>.</span><span>get</span><span>(</span>root<span>.</span>val<span>)</span><span>;</span>
    <span>int</span> leftTreeSize <span>=</span> inIndex <span>-</span> inL<span>;</span>
    root<span>.</span>left <span>=</span> <span>reConstructBinaryTree</span><span>(</span>pre<span>,</span> preL <span>+</span> <span>1</span><span>,</span> preL <span>+</span> leftTreeSize<span>,</span> inL<span>)</span><span>;</span>
    root<span>.</span>right <span>=</span> <span>reConstructBinaryTree</span><span>(</span>pre<span>,</span> preL <span>+</span> leftTreeSize <span>+</span> <span>1</span><span>,</span> preR<span>,</span> inL <span>+</span> leftTreeSize <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>return</span> root<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h1 id="_8-二叉树的下一个结点" tabindex="-1"> 8. 二叉树的下一个结点</h1>
<p><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&amp;tqId=11210&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-5" tabindex="-1"> 题目描述</h2>
<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<div><pre><code><span>public</span> <span>class</span> <span>TreeLinkNode</span> <span>{</span>

    <span>int</span> val<span>;</span>
    <span>TreeLinkNode</span> left <span>=</span> <span>null</span><span>;</span>
    <span>TreeLinkNode</span> right <span>=</span> <span>null</span><span>;</span>
    <span>TreeLinkNode</span> next <span>=</span> <span>null</span><span>;</span>

    <span>TreeLinkNode</span><span>(</span><span>int</span> val<span>)</span> <span>{</span>
        <span>this</span><span>.</span>val <span>=</span> val<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="解题思路-5" tabindex="-1"> 解题思路</h2>
<p>① 如果一个节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点；</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b0611f89-1e5f-4494-a795-3544bf65042a.gif" width="220px"/> </div><br>
<p>② 否则，向上找第一个左链接指向的树包含该节点的祖先节点。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/95080fae-de40-463d-a76e-783a0c677fec.gif" width="200px"/> </div><br>
<div><pre><code><span>public</span> <span>TreeLinkNode</span> <span>GetNext</span><span>(</span><span>TreeLinkNode</span> pNode<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>pNode<span>.</span>right <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>TreeLinkNode</span> node <span>=</span> pNode<span>.</span>right<span>;</span>
        <span>while</span> <span>(</span>node<span>.</span>left <span>!=</span> <span>null</span><span>)</span>
            node <span>=</span> node<span>.</span>left<span>;</span>
        <span>return</span> node<span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>while</span> <span>(</span>pNode<span>.</span>next <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>TreeLinkNode</span> parent <span>=</span> pNode<span>.</span>next<span>;</span>
            <span>if</span> <span>(</span>parent<span>.</span>left <span>==</span> pNode<span>)</span>
                <span>return</span> parent<span>;</span>
            pNode <span>=</span> pNode<span>.</span>next<span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h1 id="_9-用两个栈实现队列" tabindex="-1"> 9. 用两个栈实现队列</h1>
<p><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11158&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-6" tabindex="-1"> 题目描述</h2>
<p>用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。</p>
<h2 id="解题思路-6" tabindex="-1"> 解题思路</h2>
<p>in 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3ea280b5-be7d-471b-ac76-ff020384357c.gif" width="350"/> </div><br>
<div><pre><code><span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> in <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> out <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>

<span>public</span> <span>void</span> <span>push</span><span>(</span><span>int</span> node<span>)</span> <span>{</span>
    in<span>.</span><span>push</span><span>(</span>node<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>int</span> <span>pop</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
    <span>if</span> <span>(</span>out<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span>
        <span>while</span> <span>(</span><span>!</span>in<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span>
            out<span>.</span><span>push</span><span>(</span>in<span>.</span><span>pop</span><span>(</span><span>)</span><span>)</span><span>;</span>

    <span>if</span> <span>(</span>out<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span>
        <span>throw</span> <span>new</span> <span>Exception</span><span>(</span><span>"queue is empty"</span><span>)</span><span>;</span>

    <span>return</span> out<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>40. 最小的 K 个数</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-40~49.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-40~49.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">40. 最小的 K 个数</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>

<h1 id="_40-最小的-k-个数" tabindex="-1"> 40. 最小的 K 个数</h1>
<p><a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&amp;tqId=11182&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="解题思路" tabindex="-1"> 解题思路</h2>
<h3 id="快速选择" tabindex="-1"> 快速选择</h3>
<ul>
<li>复杂度：O(N) + O(1)</li>
<li>只有当允许修改数组元素时才可以使用</li>
</ul>
<p>快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。可以利用这个特性找出数组的第 K 个元素，这种找第 K 个元素的算法称为快速选择算法。</p>
<div><pre><code><span>public</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>GetLeastNumbers_Solution</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
    <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> ret <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>k <span>></span> nums<span>.</span>length <span>||</span> k <span>&lt;=</span> <span>0</span><span>)</span>
        <span>return</span> ret<span>;</span>
    <span>findKthSmallest</span><span>(</span>nums<span>,</span> k <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>/* findKthSmallest 会改变数组，使得前 k 个数都是最小的 k 个数 */</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> k<span>;</span> i<span>++</span><span>)</span>
        ret<span>.</span><span>add</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span><span>;</span>
    <span>return</span> ret<span>;</span>
<span>}</span>

<span>public</span> <span>void</span> <span>findKthSmallest</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
    <span>int</span> l <span>=</span> <span>0</span><span>,</span> h <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span>l <span>&lt;</span> h<span>)</span> <span>{</span>
        <span>int</span> j <span>=</span> <span>partition</span><span>(</span>nums<span>,</span> l<span>,</span> h<span>)</span><span>;</span>
        <span>if</span> <span>(</span>j <span>==</span> k<span>)</span>
            <span>break</span><span>;</span>
        <span>if</span> <span>(</span>j <span>></span> k<span>)</span>
            h <span>=</span> j <span>-</span> <span>1</span><span>;</span>
        <span>else</span>
            l <span>=</span> j <span>+</span> <span>1</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>private</span> <span>int</span> <span>partition</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> l<span>,</span> <span>int</span> h<span>)</span> <span>{</span>
    <span>int</span> p <span>=</span> nums<span>[</span>l<span>]</span><span>;</span>     <span>/* 切分元素 */</span>
    <span>int</span> i <span>=</span> l<span>,</span> j <span>=</span> h <span>+</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
        <span>while</span> <span>(</span>i <span>!=</span> h <span>&amp;&amp;</span> nums<span>[</span><span>++</span>i<span>]</span> <span>&lt;</span> p<span>)</span> <span>;</span>
        <span>while</span> <span>(</span>j <span>!=</span> l <span>&amp;&amp;</span> nums<span>[</span><span>--</span>j<span>]</span> <span>></span> p<span>)</span> <span>;</span>
        <span>if</span> <span>(</span>i <span>>=</span> j<span>)</span>
            <span>break</span><span>;</span>
        <span>swap</span><span>(</span>nums<span>,</span> i<span>,</span> j<span>)</span><span>;</span>
    <span>}</span>
    <span>swap</span><span>(</span>nums<span>,</span> l<span>,</span> j<span>)</span><span>;</span>
    <span>return</span> j<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>
    <span>int</span> t <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
    nums<span>[</span>i<span>]</span> <span>=</span> nums<span>[</span>j<span>]</span><span>;</span>
    nums<span>[</span>j<span>]</span> <span>=</span> t<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><h3 id="大小为-k-的最小堆" tabindex="-1"> 大小为 K 的最小堆</h3>
<ul>
<li>复杂度：O(NlogK) + O(K)</li>
<li>特别适合处理海量数据</li>
</ul>
<p>应该使用大顶堆来维护最小堆，而不能直接创建一个小顶堆并设置一个大小，企图让小顶堆中的元素都是最小元素。</p>
<p>维护一个大小为 K 的最小堆过程如下：在添加一个元素之后，如果大顶堆的大小大于 K，那么需要将大顶堆的堆顶元素去除。</p>
<div><pre><code><span>public</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>GetLeastNumbers_Solution</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>k <span>></span> nums<span>.</span>length <span>||</span> k <span>&lt;=</span> <span>0</span><span>)</span>
        <span>return</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>PriorityQueue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> maxHeap <span>=</span> <span>new</span> <span>PriorityQueue</span><span><span>&lt;</span><span>></span></span><span>(</span><span>(</span>o1<span>,</span> o2<span>)</span> <span>-></span> o2 <span>-</span> o1<span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
        maxHeap<span>.</span><span>add</span><span>(</span>num<span>)</span><span>;</span>
        <span>if</span> <span>(</span>maxHeap<span>.</span><span>size</span><span>(</span><span>)</span> <span>></span> k<span>)</span>
            maxHeap<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span>maxHeap<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h1 id="_41-1-数据流中的中位数" tabindex="-1"> 41.1 数据流中的中位数</h1>
<p><a href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&amp;tqId=11216&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述" tabindex="-1"> 题目描述</h2>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<h2 id="解题思路-1" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>/* 大顶堆，存储左半边元素 */</span>
<span>private</span> <span>PriorityQueue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> left <span>=</span> <span>new</span> <span>PriorityQueue</span><span><span>&lt;</span><span>></span></span><span>(</span><span>(</span>o1<span>,</span> o2<span>)</span> <span>-></span> o2 <span>-</span> o1<span>)</span><span>;</span>
<span>/* 小顶堆，存储右半边元素，并且右半边元素都大于左半边 */</span>
<span>private</span> <span>PriorityQueue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> right <span>=</span> <span>new</span> <span>PriorityQueue</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>/* 当前数据流读入的元素个数 */</span>
<span>private</span> <span>int</span> <span>N</span> <span>=</span> <span>0</span><span>;</span>

<span>public</span> <span>void</span> <span>Insert</span><span>(</span><span>Integer</span> val<span>)</span> <span>{</span>
    <span>/* 插入要保证两个堆存于平衡状态 */</span>
    <span>if</span> <span>(</span><span>N</span> <span>%</span> <span>2</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>/* N 为偶数的情况下插入到右半边。
         * 因为右半边元素都要大于左半边，但是新插入的元素不一定比左半边元素来的大，
         * 因此需要先将元素插入左半边，然后利用左半边为大顶堆的特点，取出堆顶元素即为最大元素，此时插入右半边 */</span>
        left<span>.</span><span>add</span><span>(</span>val<span>)</span><span>;</span>
        right<span>.</span><span>add</span><span>(</span>left<span>.</span><span>poll</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        right<span>.</span><span>add</span><span>(</span>val<span>)</span><span>;</span>
        left<span>.</span><span>add</span><span>(</span>right<span>.</span><span>poll</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
    <span>N</span><span>++</span><span>;</span>
<span>}</span>

<span>public</span> <span>Double</span> <span>GetMedian</span><span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>N</span> <span>%</span> <span>2</span> <span>==</span> <span>0</span><span>)</span>
        <span>return</span> <span>(</span>left<span>.</span><span>peek</span><span>(</span><span>)</span> <span>+</span> right<span>.</span><span>peek</span><span>(</span><span>)</span><span>)</span> <span>/</span> <span>2.0</span><span>;</span>
    <span>else</span>
        <span>return</span> <span>(</span><span>double</span><span>)</span> right<span>.</span><span>peek</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h1 id="_41-2-字符流中第一个不重复的字符" tabindex="-1"> 41.2 字符流中第一个不重复的字符</h1>
<p><a href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&amp;tqId=11207&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-1" tabindex="-1"> 题目描述</h2>
<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 &quot;go&quot; 时，第一个只出现一次的字符是 &quot;g&quot;。当从该字符流中读出前六个字符“google&quot; 时，第一个只出现一次的字符是 &quot;l&quot;。</p>
<h2 id="解题思路-2" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>private</span> <span>int</span><span>[</span><span>]</span> cnts <span>=</span> <span>new</span> <span>int</span><span>[</span><span>256</span><span>]</span><span>;</span>
<span>private</span> <span>Queue</span><span><span>&lt;</span><span>Character</span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

<span>public</span> <span>void</span> <span>Insert</span><span>(</span><span>char</span> ch<span>)</span> <span>{</span>
    cnts<span>[</span>ch<span>]</span><span>++</span><span>;</span>
    queue<span>.</span><span>add</span><span>(</span>ch<span>)</span><span>;</span>
    <span>while</span> <span>(</span><span>!</span>queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span> <span>&amp;&amp;</span> cnts<span>[</span>queue<span>.</span><span>peek</span><span>(</span><span>)</span><span>]</span> <span>></span> <span>1</span><span>)</span>
        queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>char</span> <span>FirstAppearingOnce</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span> <span>?</span> <span>'#'</span> <span>:</span> queue<span>.</span><span>peek</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h1 id="_42-连续子数组的最大和" tabindex="-1"> 42. 连续子数组的最大和</h1>
<p><a href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&amp;tqId=11183&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-2" tabindex="-1"> 题目描述</h2>
<p>{6, -3, -2, 7, -15, 1, 2, 2}，连续子数组的最大和为 8（从第 0 个开始，到第 3 个为止）。</p>
<h2 id="解题思路-3" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>public</span> <span>int</span> <span>FindGreatestSumOfSubArray</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nums <span>==</span> <span>null</span> <span>||</span> nums<span>.</span>length <span>==</span> <span>0</span><span>)</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>int</span> greatestSum <span>=</span> <span>Integer</span><span>.</span>MIN_VALUE<span>;</span>
    <span>int</span> sum <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> val <span>:</span> nums<span>)</span> <span>{</span>
        sum <span>=</span> sum <span>&lt;=</span> <span>0</span> <span>?</span> val <span>:</span> sum <span>+</span> val<span>;</span>
        greatestSum <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>greatestSum<span>,</span> sum<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> greatestSum<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h1 id="_43-从-1-到-n-整数中-1-出现的次数" tabindex="-1"> 43. 从 1 到 n 整数中 1 出现的次数</h1>
<p><a href="https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&amp;tqId=11184&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="解题思路-4" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>public</span> <span>int</span> <span>NumberOf1Between1AndN_Solution</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>int</span> cnt <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> m <span>=</span> <span>1</span><span>;</span> m <span>&lt;=</span> n<span>;</span> m <span>*=</span> <span>10</span><span>)</span> <span>{</span>
        <span>int</span> a <span>=</span> n <span>/</span> m<span>,</span> b <span>=</span> n <span>%</span> m<span>;</span>
        cnt <span>+=</span> <span>(</span>a <span>+</span> <span>8</span><span>)</span> <span>/</span> <span>10</span> <span>*</span> m <span>+</span> <span>(</span>a <span>%</span> <span>10</span> <span>==</span> <span>1</span> <span>?</span> b <span>+</span> <span>1</span> <span>:</span> <span>0</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> cnt<span>;</span>
<span>}</span>
</code></pre></div><blockquote>
<p><a href="https://leetcode.com/problems/number-of-digit-one/discuss/64381/4+-lines-O(log-n)-C++JavaPython" target="_blank" rel="noopener noreferrer">Leetcode : 233. Number of Digit One</a></p>
</blockquote>
<h1 id="_44-数字序列中的某一位数字" tabindex="-1"> 44. 数字序列中的某一位数字</h1>
<h2 id="题目描述-3" tabindex="-1"> 题目描述</h2>
<p>数字以 0123456789101112131415... 的格式序列化到一个字符串中，求这个字符串的第 index 位。</p>
<h2 id="解题思路-5" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>public</span> <span>int</span> <span>getDigitAtIndex</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>index <span>&lt;</span> <span>0</span><span>)</span>
        <span>return</span> <span>-</span><span>1</span><span>;</span>
    <span>int</span> place <span>=</span> <span>1</span><span>;</span>  <span>// 1 表示个位，2 表示 十位...</span>
    <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
        <span>int</span> amount <span>=</span> <span>getAmountOfPlace</span><span>(</span>place<span>)</span><span>;</span>
        <span>int</span> totalAmount <span>=</span> amount <span>*</span> place<span>;</span>
        <span>if</span> <span>(</span>index <span>&lt;</span> totalAmount<span>)</span>
            <span>return</span> <span>getDigitAtIndex</span><span>(</span>index<span>,</span> place<span>)</span><span>;</span>
        index <span>-=</span> totalAmount<span>;</span>
        place<span>++</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>/**
 * place 位数的数字组成的字符串长度
 * 10, 90, 900, ...
 */</span>
<span>private</span> <span>int</span> <span>getAmountOfPlace</span><span>(</span><span>int</span> place<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>place <span>==</span> <span>1</span><span>)</span>
        <span>return</span> <span>10</span><span>;</span>
    <span>return</span> <span>(</span><span>int</span><span>)</span> <span>Math</span><span>.</span><span>pow</span><span>(</span><span>10</span><span>,</span> place <span>-</span> <span>1</span><span>)</span> <span>*</span> <span>9</span><span>;</span>
<span>}</span>

<span>/**
 * place 位数的起始数字
 * 0, 10, 100, ...
 */</span>
<span>private</span> <span>int</span> <span>getBeginNumberOfPlace</span><span>(</span><span>int</span> place<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>place <span>==</span> <span>1</span><span>)</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>return</span> <span>(</span><span>int</span><span>)</span> <span>Math</span><span>.</span><span>pow</span><span>(</span><span>10</span><span>,</span> place <span>-</span> <span>1</span><span>)</span><span>;</span>
<span>}</span>

<span>/**
 * 在 place 位数组成的字符串中，第 index 个数
 */</span>
<span>private</span> <span>int</span> <span>getDigitAtIndex</span><span>(</span><span>int</span> index<span>,</span> <span>int</span> place<span>)</span> <span>{</span>
    <span>int</span> beginNumber <span>=</span> <span>getBeginNumberOfPlace</span><span>(</span>place<span>)</span><span>;</span>
    <span>int</span> shiftNumber <span>=</span> index <span>/</span> place<span>;</span>
    <span>String</span> number <span>=</span> <span>(</span>beginNumber <span>+</span> shiftNumber<span>)</span> <span>+</span> <span>""</span><span>;</span>
    <span>int</span> count <span>=</span> index <span>%</span> place<span>;</span>
    <span>return</span> number<span>.</span><span>charAt</span><span>(</span>count<span>)</span> <span>-</span> <span>'0'</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h1 id="_45-把数组排成最小的数" tabindex="-1"> 45. 把数组排成最小的数</h1>
<p><a href="https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&amp;tqId=11185&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-4" tabindex="-1"> 题目描述</h2>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组 {3，32，321}，则打印出这三个数字能排成的最小数字为 321323。</p>
<h2 id="解题思路-6" tabindex="-1"> 解题思路</h2>
<p>可以看成是一个排序问题，在比较两个字符串 S1 和 S2 的大小时，应该比较的是 S1+S2 和 S2+S1 的大小，如果 S1+S2 &lt; S2+S1，那么应该把 S1 排在前面，否则应该把 S2 排在前面。</p>
<div><pre><code><span>public</span> <span>String</span> <span>PrintMinNumber</span><span>(</span><span>int</span><span>[</span><span>]</span> numbers<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>numbers <span>==</span> <span>null</span> <span>||</span> numbers<span>.</span>length <span>==</span> <span>0</span><span>)</span>
        <span>return</span> <span>""</span><span>;</span>
    <span>int</span> n <span>=</span> numbers<span>.</span>length<span>;</span>
    <span>String</span><span>[</span><span>]</span> nums <span>=</span> <span>new</span> <span>String</span><span>[</span>n<span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span>
        nums<span>[</span>i<span>]</span> <span>=</span> numbers<span>[</span>i<span>]</span> <span>+</span> <span>""</span><span>;</span>
    <span>Arrays</span><span>.</span><span>sort</span><span>(</span>nums<span>,</span> <span>(</span>s1<span>,</span> s2<span>)</span> <span>-></span> <span>(</span>s1 <span>+</span> s2<span>)</span><span>.</span><span>compareTo</span><span>(</span>s2 <span>+</span> s1<span>)</span><span>)</span><span>;</span>
    <span>String</span> ret <span>=</span> <span>""</span><span>;</span>
    <span>for</span> <span>(</span><span>String</span> str <span>:</span> nums<span>)</span>
        ret <span>+=</span> str<span>;</span>
    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h1 id="_46-把数字翻译成字符串" tabindex="-1"> 46. 把数字翻译成字符串</h1>
<p><a href="https://leetcode.com/problems/decode-ways/description/" target="_blank" rel="noopener noreferrer">Leetcode</a></p>
<h2 id="题目描述-5" tabindex="-1"> 题目描述</h2>
<p>给定一个数字，按照如下规则翻译成字符串：1 翻译成“a”，2 翻译成“b”... 26 翻译成“z”。一个数字有多种翻译可能，例如 12258 一共有 5 种，分别是 abbeh，lbeh，aveh，abyh，lyh。实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<h2 id="解题思路-7" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>public</span> <span>int</span> <span>numDecodings</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>s <span>==</span> <span>null</span> <span>||</span> s<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>int</span> n <span>=</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
    <span>int</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span>n <span>+</span> <span>1</span><span>]</span><span>;</span>
    dp<span>[</span><span>0</span><span>]</span> <span>=</span> <span>1</span><span>;</span>
    dp<span>[</span><span>1</span><span>]</span> <span>=</span> s<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span> <span>==</span> <span>'0'</span> <span>?</span> <span>0</span> <span>:</span> <span>1</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>int</span> one <span>=</span> <span>Integer</span><span>.</span><span>valueOf</span><span>(</span>s<span>.</span><span>substring</span><span>(</span>i <span>-</span> <span>1</span><span>,</span> i<span>)</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>one <span>!=</span> <span>0</span><span>)</span>
            dp<span>[</span>i<span>]</span> <span>+=</span> dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>;</span>
        <span>if</span> <span>(</span>s<span>.</span><span>charAt</span><span>(</span>i <span>-</span> <span>2</span><span>)</span> <span>==</span> <span>'0'</span><span>)</span>
            <span>continue</span><span>;</span>
        <span>int</span> two <span>=</span> <span>Integer</span><span>.</span><span>valueOf</span><span>(</span>s<span>.</span><span>substring</span><span>(</span>i <span>-</span> <span>2</span><span>,</span> i<span>)</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>two <span>&lt;=</span> <span>26</span><span>)</span>
            dp<span>[</span>i<span>]</span> <span>+=</span> dp<span>[</span>i <span>-</span> <span>2</span><span>]</span><span>;</span>
    <span>}</span>
    <span>return</span> dp<span>[</span>n<span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h1 id="_47-礼物的最大价值" tabindex="-1"> 47. 礼物的最大价值</h1>
<p><a href="https://www.nowcoder.com/questionTerminal/72a99e28381a407991f2c96d8cb238ab" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-6" tabindex="-1"> 题目描述</h2>
<p>在一个 m*n 的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于 0）。从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。例如，对于如下棋盘</p>
<div><pre><code>1    10   3    8
12   2    9    6
5    7    4    11
3    7    16   5
</code></pre></div><p>礼物的最大价值为 1+12+5+7+7+16+5=53。</p>
<h2 id="解题思路-8" tabindex="-1"> 解题思路</h2>
<p>应该用动态规划求解，而不是深度优先搜索，深度优先搜索过于复杂，不是最优解。</p>
<div><pre><code><span>public</span> <span>int</span> <span>getMost</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> values<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>values <span>==</span> <span>null</span> <span>||</span> values<span>.</span>length <span>==</span> <span>0</span> <span>||</span> values<span>[</span><span>0</span><span>]</span><span>.</span>length <span>==</span> <span>0</span><span>)</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>int</span> n <span>=</span> values<span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span>
    <span>int</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span>n<span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span><span>[</span><span>]</span> value <span>:</span> values<span>)</span> <span>{</span>
        dp<span>[</span><span>0</span><span>]</span> <span>+=</span> value<span>[</span><span>0</span><span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span>
            dp<span>[</span>i<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>dp<span>[</span>i<span>]</span><span>,</span> dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span> <span>+</span> value<span>[</span>i<span>]</span><span>;</span>
    <span>}</span>
    <span>return</span> dp<span>[</span>n <span>-</span> <span>1</span><span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h1 id="_48-最长不含重复字符的子字符串" tabindex="-1"> 48. 最长不含重复字符的子字符串</h1>
<h2 id="题目描述-7" tabindex="-1"> 题目描述</h2>
<p>输入一个字符串（只包含 a~z 的字符），求其最长不含重复字符的子字符串的长度。例如对于 arabcacfr，最长不含重复字符的子字符串为 acfr，长度为 4。</p>
<h2 id="解题思路-9" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>public</span> <span>int</span> <span>longestSubStringWithoutDuplication</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
    <span>int</span> curLen <span>=</span> <span>0</span><span>;</span>
    <span>int</span> maxLen <span>=</span> <span>0</span><span>;</span>
    <span>int</span><span>[</span><span>]</span> preIndexs <span>=</span> <span>new</span> <span>int</span><span>[</span><span>26</span><span>]</span><span>;</span>
    <span>Arrays</span><span>.</span><span>fill</span><span>(</span>preIndexs<span>,</span> <span>-</span><span>1</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> curI <span>=</span> <span>0</span><span>;</span> curI <span>&lt;</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span> curI<span>++</span><span>)</span> <span>{</span>
        <span>int</span> c <span>=</span> str<span>.</span><span>charAt</span><span>(</span>curI<span>)</span> <span>-</span> <span>'a'</span><span>;</span>
        <span>int</span> preI <span>=</span> preIndexs<span>[</span>c<span>]</span><span>;</span>
        <span>if</span> <span>(</span>preI <span>==</span> <span>-</span><span>1</span> <span>||</span> curI <span>-</span> preI <span>></span> curLen<span>)</span> <span>{</span>
            curLen<span>++</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            maxLen <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>maxLen<span>,</span> curLen<span>)</span><span>;</span>
            curLen <span>=</span> curI <span>-</span> preI<span>;</span>
        <span>}</span>
        preIndexs<span>[</span>c<span>]</span> <span>=</span> curI<span>;</span>
    <span>}</span>
    maxLen <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>maxLen<span>,</span> curLen<span>)</span><span>;</span>
    <span>return</span> maxLen<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h1 id="_49-丑数" tabindex="-1"> 49. 丑数</h1>
<p><a href="https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&amp;tqId=11186&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-8" tabindex="-1"> 题目描述</h2>
<p>把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。例如 6、8 都是丑数，但 14 不是，因为它包含因子 7。习惯上我们把 1 当做是第一个丑数。求按从小到大的顺序的第 N 个丑数。</p>
<h2 id="解题思路-10" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>public</span> <span>int</span> <span>GetUglyNumber_Solution</span><span>(</span><span>int</span> <span>N</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>N</span> <span>&lt;=</span> <span>6</span><span>)</span>
        <span>return</span> <span>N</span><span>;</span>
    <span>int</span> i2 <span>=</span> <span>0</span><span>,</span> i3 <span>=</span> <span>0</span><span>,</span> i5 <span>=</span> <span>0</span><span>;</span>
    <span>int</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span><span>N</span><span>]</span><span>;</span>
    dp<span>[</span><span>0</span><span>]</span> <span>=</span> <span>1</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>int</span> next2 <span>=</span> dp<span>[</span>i2<span>]</span> <span>*</span> <span>2</span><span>,</span> next3 <span>=</span> dp<span>[</span>i3<span>]</span> <span>*</span> <span>3</span><span>,</span> next5 <span>=</span> dp<span>[</span>i5<span>]</span> <span>*</span> <span>5</span><span>;</span>
        dp<span>[</span>i<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>next2<span>,</span> <span>Math</span><span>.</span><span>min</span><span>(</span>next3<span>,</span> next5<span>)</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>dp<span>[</span>i<span>]</span> <span>==</span> next2<span>)</span>
            i2<span>++</span><span>;</span>
        <span>if</span> <span>(</span>dp<span>[</span>i<span>]</span> <span>==</span> next3<span>)</span>
            i3<span>++</span><span>;</span>
        <span>if</span> <span>(</span>dp<span>[</span>i<span>]</span> <span>==</span> next5<span>)</span>
            i5<span>++</span><span>;</span>
    <span>}</span>
    <span>return</span> dp<span>[</span><span>N</span> <span>-</span> <span>1</span><span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>50. 第一个只出现一次的字符位置</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-50~59.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-50~59.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">50. 第一个只出现一次的字符位置</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>

<h1 id="_50-第一个只出现一次的字符位置" tabindex="-1"> 50. 第一个只出现一次的字符位置</h1>
<p><a href="https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&amp;tqId=11187&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述" tabindex="-1"> 题目描述</h2>
<p>在一个字符串中找到第一个只出现一次的字符，并返回它的位置。</p>
<div><pre><code>Input: abacc
Output: b
</code></pre></div><h2 id="解题思路" tabindex="-1"> 解题思路</h2>
<p>最直观的解法是使用 HashMap 对出现次数进行统计，但是考虑到要统计的字符范围有限，因此可以使用整型数组代替 HashMap，从而将空间复杂度由 O(N) 降低为 O(1)。</p>
<div><pre><code><span>public</span> <span>int</span> <span>FirstNotRepeatingChar</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
    <span>int</span><span>[</span><span>]</span> cnts <span>=</span> <span>new</span> <span>int</span><span>[</span><span>256</span><span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span>
        cnts<span>[</span>str<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>]</span><span>++</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span>
        <span>if</span> <span>(</span>cnts<span>[</span>str<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>]</span> <span>==</span> <span>1</span><span>)</span>
            <span>return</span> i<span>;</span>
    <span>return</span> <span>-</span><span>1</span><span>;</span>
<span>}</span>
</code></pre></div><p>以上实现的空间复杂度还不是最优的。考虑到只需要找到只出现一次的字符，那么需要统计的次数信息只有 0,1,更大，使用两个比特位就能存储这些信息。</p>
<div><pre><code><span>public</span> <span>int</span> <span>FirstNotRepeatingChar2</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
    <span>BitSet</span> bs1 <span>=</span> <span>new</span> <span>BitSet</span><span>(</span><span>256</span><span>)</span><span>;</span>
    <span>BitSet</span> bs2 <span>=</span> <span>new</span> <span>BitSet</span><span>(</span><span>256</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>char</span> c <span>:</span> str<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span>bs1<span>.</span><span>get</span><span>(</span>c<span>)</span> <span>&amp;&amp;</span> <span>!</span>bs2<span>.</span><span>get</span><span>(</span>c<span>)</span><span>)</span>
            bs1<span>.</span><span>set</span><span>(</span>c<span>)</span><span>;</span>     <span>// 0 0 -> 0 1</span>
        <span>else</span> <span>if</span> <span>(</span>bs1<span>.</span><span>get</span><span>(</span>c<span>)</span> <span>&amp;&amp;</span> <span>!</span>bs2<span>.</span><span>get</span><span>(</span>c<span>)</span><span>)</span>
            bs2<span>.</span><span>set</span><span>(</span>c<span>)</span><span>;</span>     <span>// 0 1 -> 1 1</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>char</span> c <span>=</span> str<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>;</span>
        <span>if</span> <span>(</span>bs1<span>.</span><span>get</span><span>(</span>c<span>)</span> <span>&amp;&amp;</span> <span>!</span>bs2<span>.</span><span>get</span><span>(</span>c<span>)</span><span>)</span>  <span>// 0 1</span>
            <span>return</span> i<span>;</span>
    <span>}</span>
    <span>return</span> <span>-</span><span>1</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h1 id="_51-数组中的逆序对" tabindex="-1"> 51. 数组中的逆序对</h1>
<p><a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&amp;tqId=11188&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-1" tabindex="-1"> 题目描述</h2>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<h2 id="解题思路-1" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>private</span> <span>long</span> cnt <span>=</span> <span>0</span><span>;</span>
<span>private</span> <span>int</span><span>[</span><span>]</span> tmp<span>;</span>  <span>// 在这里声明辅助数组，而不是在 merge() 递归函数中声明</span>

<span>public</span> <span>int</span> <span>InversePairs</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    tmp <span>=</span> <span>new</span> <span>int</span><span>[</span>nums<span>.</span>length<span>]</span><span>;</span>
    <span>mergeSort</span><span>(</span>nums<span>,</span> <span>0</span><span>,</span> nums<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>int</span><span>)</span> <span>(</span>cnt <span>%</span> <span>1000000007</span><span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>mergeSort</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> l<span>,</span> <span>int</span> h<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>h <span>-</span> l <span>&lt;</span> <span>1</span><span>)</span>
        <span>return</span><span>;</span>
    <span>int</span> m <span>=</span> l <span>+</span> <span>(</span>h <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
    <span>mergeSort</span><span>(</span>nums<span>,</span> l<span>,</span> m<span>)</span><span>;</span>
    <span>mergeSort</span><span>(</span>nums<span>,</span> m <span>+</span> <span>1</span><span>,</span> h<span>)</span><span>;</span>
    <span>merge</span><span>(</span>nums<span>,</span> l<span>,</span> m<span>,</span> h<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>merge</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> l<span>,</span> <span>int</span> m<span>,</span> <span>int</span> h<span>)</span> <span>{</span>
    <span>int</span> i <span>=</span> l<span>,</span> j <span>=</span> m <span>+</span> <span>1</span><span>,</span> k <span>=</span> l<span>;</span>
    <span>while</span> <span>(</span>i <span>&lt;=</span> m <span>||</span> j <span>&lt;=</span> h<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>i <span>></span> m<span>)</span>
            tmp<span>[</span>k<span>]</span> <span>=</span> nums<span>[</span>j<span>++</span><span>]</span><span>;</span>
        <span>else</span> <span>if</span> <span>(</span>j <span>></span> h<span>)</span>
            tmp<span>[</span>k<span>]</span> <span>=</span> nums<span>[</span>i<span>++</span><span>]</span><span>;</span>
        <span>else</span> <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>&lt;=</span> nums<span>[</span>j<span>]</span><span>)</span>
            tmp<span>[</span>k<span>]</span> <span>=</span> nums<span>[</span>i<span>++</span><span>]</span><span>;</span>
        <span>else</span> <span>{</span>
            tmp<span>[</span>k<span>]</span> <span>=</span> nums<span>[</span>j<span>++</span><span>]</span><span>;</span>
            <span>this</span><span>.</span>cnt <span>+=</span> m <span>-</span> i <span>+</span> <span>1</span><span>;</span>  <span>// nums[i] > nums[j]，说明 nums[i...mid] 都大于 nums[j]</span>
        <span>}</span>
        k<span>++</span><span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span>k <span>=</span> l<span>;</span> k <span>&lt;=</span> h<span>;</span> k<span>++</span><span>)</span>
        nums<span>[</span>k<span>]</span> <span>=</span> tmp<span>[</span>k<span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><h1 id="_52-两个链表的第一个公共结点" tabindex="-1"> 52. 两个链表的第一个公共结点</h1>
<p><a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&amp;tqId=11189&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-2" tabindex="-1"> 题目描述</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5f1cb999-cb9a-4f6c-a0af-d90377295ab8.png" width="500"/> </div><br>
<h2 id="解题思路-2" tabindex="-1"> 解题思路</h2>
<p>设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。</p>
<p>当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。</p>
<div><pre><code><span>public</span> <span>ListNode</span> <span>FindFirstCommonNode</span><span>(</span><span>ListNode</span> pHead1<span>,</span> <span>ListNode</span> pHead2<span>)</span> <span>{</span>
    <span>ListNode</span> l1 <span>=</span> pHead1<span>,</span> l2 <span>=</span> pHead2<span>;</span>
    <span>while</span> <span>(</span>l1 <span>!=</span> l2<span>)</span> <span>{</span>
        l1 <span>=</span> <span>(</span>l1 <span>==</span> <span>null</span><span>)</span> <span>?</span> pHead2 <span>:</span> l1<span>.</span>next<span>;</span>
        l2 <span>=</span> <span>(</span>l2 <span>==</span> <span>null</span><span>)</span> <span>?</span> pHead1 <span>:</span> l2<span>.</span>next<span>;</span>
    <span>}</span>
    <span>return</span> l1<span>;</span>
<span>}</span>
</code></pre></div><h1 id="_53-数字在排序数组中出现的次数" tabindex="-1"> 53. 数字在排序数组中出现的次数</h1>
<p><a href="https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&amp;tqId=11190&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-3" tabindex="-1"> 题目描述</h2>
<div><pre><code>Input:
nums = 1, 2, 3, 3, 3, 3, 4, 6
K = 3

Output:
4
</code></pre></div><h2 id="解题思路-3" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>public</span> <span>int</span> <span>GetNumberOfK</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> <span>K</span><span>)</span> <span>{</span>
    <span>int</span> first <span>=</span> <span>binarySearch</span><span>(</span>nums<span>,</span> <span>K</span><span>)</span><span>;</span>
    <span>int</span> last <span>=</span> <span>binarySearch</span><span>(</span>nums<span>,</span> <span>K</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span>first <span>==</span> nums<span>.</span>length <span>||</span> nums<span>[</span>first<span>]</span> <span>!=</span> <span>K</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> last <span>-</span> first<span>;</span>
<span>}</span>

<span>private</span> <span>int</span> <span>binarySearch</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> <span>K</span><span>)</span> <span>{</span>
    <span>int</span> l <span>=</span> <span>0</span><span>,</span> h <span>=</span> nums<span>.</span>length<span>;</span>
    <span>while</span> <span>(</span>l <span>&lt;</span> h<span>)</span> <span>{</span>
        <span>int</span> m <span>=</span> l <span>+</span> <span>(</span>h <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
        <span>if</span> <span>(</span>nums<span>[</span>m<span>]</span> <span>>=</span> <span>K</span><span>)</span>
            h <span>=</span> m<span>;</span>
        <span>else</span>
            l <span>=</span> m <span>+</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>return</span> l<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h1 id="_54-二叉查找树的第-k-个结点" tabindex="-1"> 54. 二叉查找树的第 K 个结点</h1>
<p><a href="https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&amp;tqId=11215&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="解题思路-4" tabindex="-1"> 解题思路</h2>
<p>利用二叉查找树中序遍历有序的特点。</p>
<div><pre><code><span>private</span> <span>TreeNode</span> ret<span>;</span>
<span>private</span> <span>int</span> cnt <span>=</span> <span>0</span><span>;</span>

<span>public</span> <span>TreeNode</span> <span>KthNode</span><span>(</span><span>TreeNode</span> pRoot<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
    <span>inOrder</span><span>(</span>pRoot<span>,</span> k<span>)</span><span>;</span>
    <span>return</span> ret<span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>inOrder</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span> <span>||</span> cnt <span>>=</span> k<span>)</span>
        <span>return</span><span>;</span>
    <span>inOrder</span><span>(</span>root<span>.</span>left<span>,</span> k<span>)</span><span>;</span>
    cnt<span>++</span><span>;</span>
    <span>if</span> <span>(</span>cnt <span>==</span> k<span>)</span>
        ret <span>=</span> root<span>;</span>
    <span>inOrder</span><span>(</span>root<span>.</span>right<span>,</span> k<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h1 id="_55-1-二叉树的深度" tabindex="-1"> 55.1 二叉树的深度</h1>
<p><a href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&amp;tqId=11191&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-4" tabindex="-1"> 题目描述</h2>
<p>从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ba355101-4a93-4c71-94fb-1da83639727b.jpg" width="350px"/> </div><br>
<h2 id="解题思路-5" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>public</span> <span>int</span> <span>TreeDepth</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>return</span> root <span>==</span> <span>null</span> <span>?</span> <span>0</span> <span>:</span> <span>1</span> <span>+</span> <span>Math</span><span>.</span><span>max</span><span>(</span><span>TreeDepth</span><span>(</span>root<span>.</span>left<span>)</span><span>,</span> <span>TreeDepth</span><span>(</span>root<span>.</span>right<span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h1 id="_55-2-平衡二叉树" tabindex="-1"> 55.2 平衡二叉树</h1>
<p><a href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&amp;tqId=11192&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-5" tabindex="-1"> 题目描述</h2>
<p>平衡二叉树左右子树高度差不超过 1。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/af1d1166-63af-47b6-9aa3-2bf2bd37bd03.jpg" width="250px"/> </div><br>
<h2 id="解题思路-6" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>private</span> <span>boolean</span> isBalanced <span>=</span> <span>true</span><span>;</span>

<span>public</span> <span>boolean</span> <span>IsBalanced_Solution</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>height</span><span>(</span>root<span>)</span><span>;</span>
    <span>return</span> isBalanced<span>;</span>
<span>}</span>

<span>private</span> <span>int</span> <span>height</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span> <span>||</span> <span>!</span>isBalanced<span>)</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>int</span> left <span>=</span> <span>height</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>
    <span>int</span> right <span>=</span> <span>height</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>
    <span>if</span> <span>(</span><span>Math</span><span>.</span><span>abs</span><span>(</span>left <span>-</span> right<span>)</span> <span>></span> <span>1</span><span>)</span>
        isBalanced <span>=</span> <span>false</span><span>;</span>
    <span>return</span> <span>1</span> <span>+</span> <span>Math</span><span>.</span><span>max</span><span>(</span>left<span>,</span> right<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h1 id="_56-数组中只出现一次的数字" tabindex="-1"> 56. 数组中只出现一次的数字</h1>
<p><a href="https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&amp;tqId=11193&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-6" tabindex="-1"> 题目描述</h2>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次，找出这两个数。</p>
<h2 id="解题思路-7" tabindex="-1"> 解题思路</h2>
<p>两个不相等的元素在位级表示上必定会有一位存在不同，将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果。</p>
<p>diff &amp;= -diff 得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。</p>
<div><pre><code><span>public</span> <span>void</span> <span>FindNumsAppearOnce</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> num1<span>[</span><span>]</span><span>,</span> <span>int</span> num2<span>[</span><span>]</span><span>)</span> <span>{</span>
    <span>int</span> diff <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span>
        diff <span>^=</span> num<span>;</span>
    diff <span>&amp;=</span> <span>-</span>diff<span>;</span>
    <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>(</span>num <span>&amp;</span> diff<span>)</span> <span>==</span> <span>0</span><span>)</span>
            num1<span>[</span><span>0</span><span>]</span> <span>^=</span> num<span>;</span>
        <span>else</span>
            num2<span>[</span><span>0</span><span>]</span> <span>^=</span> num<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h1 id="_57-1-和为-s-的两个数字" tabindex="-1"> 57.1 和为 S 的两个数字</h1>
<p><a href="https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&amp;tqId=11195&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-7" tabindex="-1"> 题目描述</h2>
<p>输入一个递增排序的数组和一个数字 S，在数组中查找两个数，使得他们的和正好是 S。如果有多对数字的和等于 S，输出两个数的乘积最小的。</p>
<h2 id="解题思路-8" tabindex="-1"> 解题思路</h2>
<p>使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。</p>
<ul>
<li>如果两个指针指向元素的和 sum == target，那么得到要求的结果；</li>
<li>如果 sum &gt; target，移动较大的元素，使 sum 变小一些；</li>
<li>如果 sum &lt; target，移动较小的元素，使 sum 变大一些。</li>
</ul>
<div><pre><code><span>public</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>FindNumbersWithSum</span><span>(</span><span>int</span><span>[</span><span>]</span> array<span>,</span> <span>int</span> sum<span>)</span> <span>{</span>
    <span>int</span> i <span>=</span> <span>0</span><span>,</span> j <span>=</span> array<span>.</span>length <span>-</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span>i <span>&lt;</span> j<span>)</span> <span>{</span>
        <span>int</span> cur <span>=</span> array<span>[</span>i<span>]</span> <span>+</span> array<span>[</span>j<span>]</span><span>;</span>
        <span>if</span> <span>(</span>cur <span>==</span> sum<span>)</span>
            <span>return</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>Arrays</span><span>.</span><span>asList</span><span>(</span>array<span>[</span>i<span>]</span><span>,</span> array<span>[</span>j<span>]</span><span>)</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>cur <span>&lt;</span> sum<span>)</span>
            i<span>++</span><span>;</span>
        <span>else</span>
            j<span>--</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h1 id="_57-2-和为-s-的连续正数序列" tabindex="-1"> 57.2 和为 S 的连续正数序列</h1>
<p><a href="https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&amp;tqId=11194&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-8" tabindex="-1"> 题目描述</h2>
<p>输出所有和为 S 的连续正数序列。</p>
<p>例如和为 100 的连续序列有：</p>
<div><pre><code>[9, 10, 11, 12, 13, 14, 15, 16]
[18, 19, 20, 21, 22]。
</code></pre></div><h2 id="解题思路-9" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>public</span> <span>ArrayList</span><span><span>&lt;</span><span>ArrayList</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> <span>FindContinuousSequence</span><span>(</span><span>int</span> sum<span>)</span> <span>{</span>
    <span>ArrayList</span><span><span>&lt;</span><span>ArrayList</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> ret <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>int</span> start <span>=</span> <span>1</span><span>,</span> end <span>=</span> <span>2</span><span>;</span>
    <span>int</span> curSum <span>=</span> <span>3</span><span>;</span>
    <span>while</span> <span>(</span>end <span>&lt;</span> sum<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>curSum <span>></span> sum<span>)</span> <span>{</span>
            curSum <span>-=</span> start<span>;</span>
            start<span>++</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>curSum <span>&lt;</span> sum<span>)</span> <span>{</span>
            end<span>++</span><span>;</span>
            curSum <span>+=</span> end<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> start<span>;</span> i <span>&lt;=</span> end<span>;</span> i<span>++</span><span>)</span>
                list<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>
            ret<span>.</span><span>add</span><span>(</span>list<span>)</span><span>;</span>
            curSum <span>-=</span> start<span>;</span>
            start<span>++</span><span>;</span>
            end<span>++</span><span>;</span>
            curSum <span>+=</span> end<span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h1 id="_58-1-翻转单词顺序列" tabindex="-1"> 58.1 翻转单词顺序列</h1>
<p><a href="https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&amp;tqId=11197&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-9" tabindex="-1"> 题目描述</h2>
<div><pre><code>Input:
"I am a student."

Output:
"student. a am I"
</code></pre></div><h2 id="解题思路-10" tabindex="-1"> 解题思路</h2>
<p>题目应该有一个隐含条件，就是不能用额外的空间。虽然 Java 的题目输入参数为 String 类型，需要先创建一个字符数组使得空间复杂度为 O(N)，但是正确的参数类型应该和原书一样，为字符数组，并且只能使用该字符数组的空间。任何使用了额外空间的解法在面试时都会大打折扣，包括递归解法。</p>
<p>正确的解法应该是和书上一样，先旋转每个单词，再旋转整个字符串。</p>
<div><pre><code><span>public</span> <span>String</span> <span>ReverseSentence</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
    <span>int</span> n <span>=</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
    <span>char</span><span>[</span><span>]</span> chars <span>=</span> str<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>;</span>
    <span>int</span> i <span>=</span> <span>0</span><span>,</span> j <span>=</span> <span>0</span><span>;</span>
    <span>while</span> <span>(</span>j <span>&lt;=</span> n<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>j <span>==</span> n <span>||</span> chars<span>[</span>j<span>]</span> <span>==</span> <span>' '</span><span>)</span> <span>{</span>
            <span>reverse</span><span>(</span>chars<span>,</span> i<span>,</span> j <span>-</span> <span>1</span><span>)</span><span>;</span>
            i <span>=</span> j <span>+</span> <span>1</span><span>;</span>
        <span>}</span>
        j<span>++</span><span>;</span>
    <span>}</span>
    <span>reverse</span><span>(</span>chars<span>,</span> <span>0</span><span>,</span> n <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>return</span> <span>new</span> <span>String</span><span>(</span>chars<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>reverse</span><span>(</span><span>char</span><span>[</span><span>]</span> c<span>,</span> <span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>
    <span>while</span> <span>(</span>i <span>&lt;</span> j<span>)</span>
        <span>swap</span><span>(</span>c<span>,</span> i<span>++</span><span>,</span> j<span>--</span><span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>swap</span><span>(</span><span>char</span><span>[</span><span>]</span> c<span>,</span> <span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>
    <span>char</span> t <span>=</span> c<span>[</span>i<span>]</span><span>;</span>
    c<span>[</span>i<span>]</span> <span>=</span> c<span>[</span>j<span>]</span><span>;</span>
    c<span>[</span>j<span>]</span> <span>=</span> t<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h1 id="_58-2-左旋转字符串" tabindex="-1"> 58.2 左旋转字符串</h1>
<p><a href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&amp;tqId=11196&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-10" tabindex="-1"> 题目描述</h2>
<div><pre><code>Input:
S="abcXYZdef"
K=3

Output:
"XYZdefabc"
</code></pre></div><h2 id="解题思路-11" tabindex="-1"> 解题思路</h2>
<p>先将 &quot;abc&quot; 和 &quot;XYZdef&quot; 分别翻转，得到 &quot;cbafedZYX&quot;，然后再把整个字符串翻转得到 &quot;XYZdefabc&quot;。</p>
<div><pre><code><span>public</span> <span>String</span> <span>LeftRotateString</span><span>(</span><span>String</span> str<span>,</span> <span>int</span> n<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>n <span>>=</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>)</span>
        <span>return</span> str<span>;</span>
    <span>char</span><span>[</span><span>]</span> chars <span>=</span> str<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>;</span>
    <span>reverse</span><span>(</span>chars<span>,</span> <span>0</span><span>,</span> n <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>reverse</span><span>(</span>chars<span>,</span> n<span>,</span> chars<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>reverse</span><span>(</span>chars<span>,</span> <span>0</span><span>,</span> chars<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>return</span> <span>new</span> <span>String</span><span>(</span>chars<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>reverse</span><span>(</span><span>char</span><span>[</span><span>]</span> chars<span>,</span> <span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>
    <span>while</span> <span>(</span>i <span>&lt;</span> j<span>)</span>
        <span>swap</span><span>(</span>chars<span>,</span> i<span>++</span><span>,</span> j<span>--</span><span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>swap</span><span>(</span><span>char</span><span>[</span><span>]</span> chars<span>,</span> <span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>
    <span>char</span> t <span>=</span> chars<span>[</span>i<span>]</span><span>;</span>
    chars<span>[</span>i<span>]</span> <span>=</span> chars<span>[</span>j<span>]</span><span>;</span>
    chars<span>[</span>j<span>]</span> <span>=</span> t<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h1 id="_59-滑动窗口的最大值" tabindex="-1"> 59. 滑动窗口的最大值</h1>
<p><a href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&amp;tqId=11217&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-11" tabindex="-1"> 题目描述</h2>
<p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。</p>
<p>例如，如果输入数组 {2, 3, 4, 2, 6, 2, 5, 1} 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为 {4, 4, 6, 6, 6, 5}。</p>
<h2 id="解题思路-12" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>public</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>maxInWindows</span><span>(</span><span>int</span><span>[</span><span>]</span> num<span>,</span> <span>int</span> size<span>)</span> <span>{</span>
    <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> ret <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>size <span>></span> num<span>.</span>length <span>||</span> size <span>&lt;</span> <span>1</span><span>)</span>
        <span>return</span> ret<span>;</span>
    <span>PriorityQueue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> heap <span>=</span> <span>new</span> <span>PriorityQueue</span><span><span>&lt;</span><span>></span></span><span>(</span><span>(</span>o1<span>,</span> o2<span>)</span> <span>-></span> o2 <span>-</span> o1<span>)</span><span>;</span>  <span>/* 大顶堆 */</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span>
        heap<span>.</span><span>add</span><span>(</span>num<span>[</span>i<span>]</span><span>)</span><span>;</span>
    ret<span>.</span><span>add</span><span>(</span>heap<span>.</span><span>peek</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>,</span> j <span>=</span> i <span>+</span> size<span>;</span> j <span>&lt;</span> num<span>.</span>length<span>;</span> i<span>++</span><span>,</span> j<span>++</span><span>)</span> <span>{</span>            <span>/* 维护一个大小为 size 的大顶堆 */</span>
        heap<span>.</span><span>remove</span><span>(</span>num<span>[</span>i<span>]</span><span>)</span><span>;</span>
        heap<span>.</span><span>add</span><span>(</span>num<span>[</span>j<span>]</span><span>)</span><span>;</span>
        ret<span>.</span><span>add</span><span>(</span>heap<span>.</span><span>peek</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>60. n 个骰子的点数</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-60~68.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-60~68.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">60. n 个骰子的点数</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="_60-n-个骰子的点数" tabindex="-1"> 60. n 个骰子的点数</h1>
<p><a href="https://www.lintcode.com/en/problem/dices-sum/" target="_blank" rel="noopener noreferrer">Lintcode</a></p>
<h2 id="题目描述" tabindex="-1"> 题目描述</h2>
<p>把 n 个骰子扔在地上，求点数和为 s 的概率。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/195f8693-5ec4-4987-8560-f25e365879dd.png" width="300px"> </div><br>
<h2 id="解题思路" tabindex="-1"> 解题思路</h2>
<h3 id="动态规划" tabindex="-1"> 动态规划</h3>
<p>使用一个二维数组 dp 存储点数出现的次数，其中 dp[i][j] 表示前 i 个骰子产生点数 j 的次数。</p>
<p>空间复杂度：O(N<sup>2</sup>)</p>
<div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>Map<span>.</span>Entry</span><span>&lt;</span><span>Integer</span><span>,</span> <span>Double</span><span>></span><span>></span></span> <span>dicesSum</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>final</span> <span>int</span> face <span>=</span> <span>6</span><span>;</span>
    <span>final</span> <span>int</span> pointNum <span>=</span> face <span>*</span> n<span>;</span>
    <span>long</span><span>[</span><span>]</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>long</span><span>[</span>n <span>+</span> <span>1</span><span>]</span><span>[</span>pointNum <span>+</span> <span>1</span><span>]</span><span>;</span>

    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> face<span>;</span> i<span>++</span><span>)</span>
        dp<span>[</span><span>1</span><span>]</span><span>[</span>i<span>]</span> <span>=</span> <span>1</span><span>;</span>

    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> i<span>;</span> j <span>&lt;=</span> pointNum<span>;</span> j<span>++</span><span>)</span>     <span>/* 使用 i 个骰子最小点数为 i */</span>
            <span>for</span> <span>(</span><span>int</span> k <span>=</span> <span>1</span><span>;</span> k <span>&lt;=</span> face <span>&amp;&amp;</span> k <span>&lt;=</span> j<span>;</span> k<span>++</span><span>)</span>
                dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>+=</span> dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j <span>-</span> k<span>]</span><span>;</span>

    <span>final</span> <span>double</span> totalNum <span>=</span> <span>Math</span><span>.</span><span>pow</span><span>(</span><span>6</span><span>,</span> n<span>)</span><span>;</span>
    <span>List</span><span><span>&lt;</span><span>Map<span>.</span>Entry</span><span>&lt;</span><span>Integer</span><span>,</span> <span>Double</span><span>></span><span>></span></span> ret <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> n<span>;</span> i <span>&lt;=</span> pointNum<span>;</span> i<span>++</span><span>)</span>
        ret<span>.</span><span>add</span><span>(</span><span>new</span> <span>AbstractMap<span>.</span>SimpleEntry</span><span><span>&lt;</span><span>></span></span><span>(</span>i<span>,</span> dp<span>[</span>n<span>]</span><span>[</span>i<span>]</span> <span>/</span> totalNum<span>)</span><span>)</span><span>;</span>

    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id="动态规划-旋转数组" tabindex="-1"> 动态规划 + 旋转数组</h3>
<p>空间复杂度：O(N)</p>
<div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>Map<span>.</span>Entry</span><span>&lt;</span><span>Integer</span><span>,</span> <span>Double</span><span>></span><span>></span></span> <span>dicesSum</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>final</span> <span>int</span> face <span>=</span> <span>6</span><span>;</span>
    <span>final</span> <span>int</span> pointNum <span>=</span> face <span>*</span> n<span>;</span>
    <span>long</span><span>[</span><span>]</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>long</span><span>[</span><span>2</span><span>]</span><span>[</span>pointNum <span>+</span> <span>1</span><span>]</span><span>;</span>

    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> face<span>;</span> i<span>++</span><span>)</span>
        dp<span>[</span><span>0</span><span>]</span><span>[</span>i<span>]</span> <span>=</span> <span>1</span><span>;</span>

    <span>int</span> flag <span>=</span> <span>1</span><span>;</span>                                     <span>/* 旋转标记 */</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>,</span> flag <span>=</span> <span>1</span> <span>-</span> flag<span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;=</span> pointNum<span>;</span> j<span>++</span><span>)</span>
            dp<span>[</span>flag<span>]</span><span>[</span>j<span>]</span> <span>=</span> <span>0</span><span>;</span>                          <span>/* 旋转数组清零 */</span>

        <span>for</span> <span>(</span><span>int</span> j <span>=</span> i<span>;</span> j <span>&lt;=</span> pointNum<span>;</span> j<span>++</span><span>)</span>
            <span>for</span> <span>(</span><span>int</span> k <span>=</span> <span>1</span><span>;</span> k <span>&lt;=</span> face <span>&amp;&amp;</span> k <span>&lt;=</span> j<span>;</span> k<span>++</span><span>)</span>
                dp<span>[</span>flag<span>]</span><span>[</span>j<span>]</span> <span>+=</span> dp<span>[</span><span>1</span> <span>-</span> flag<span>]</span><span>[</span>j <span>-</span> k<span>]</span><span>;</span>
    <span>}</span>

    <span>final</span> <span>double</span> totalNum <span>=</span> <span>Math</span><span>.</span><span>pow</span><span>(</span><span>6</span><span>,</span> n<span>)</span><span>;</span>
    <span>List</span><span><span>&lt;</span><span>Map<span>.</span>Entry</span><span>&lt;</span><span>Integer</span><span>,</span> <span>Double</span><span>></span><span>></span></span> ret <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> n<span>;</span> i <span>&lt;=</span> pointNum<span>;</span> i<span>++</span><span>)</span>
        ret<span>.</span><span>add</span><span>(</span><span>new</span> <span>AbstractMap<span>.</span>SimpleEntry</span><span><span>&lt;</span><span>></span></span><span>(</span>i<span>,</span> dp<span>[</span><span>1</span> <span>-</span> flag<span>]</span><span>[</span>i<span>]</span> <span>/</span> totalNum<span>)</span><span>)</span><span>;</span>

    <span>return</span> ret<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h1 id="_61-扑克牌顺子" tabindex="-1"> 61. 扑克牌顺子</h1>
<p><a href="https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&amp;tqId=11198&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-1" tabindex="-1"> 题目描述</h2>
<p>五张牌，其中大小鬼为癞子，牌面为 0。判断这五张牌是否能组成顺子。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eaa506b6-0747-4bee-81f8-3cda795d8154.png" width="350px"> </div><br>
<h2 id="解题思路-1" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>public</span> <span>boolean</span> <span>isContinuous</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>

    <span>if</span> <span>(</span>nums<span>.</span>length <span>&lt;</span> <span>5</span><span>)</span>
        <span>return</span> <span>false</span><span>;</span>

    <span>Arrays</span><span>.</span><span>sort</span><span>(</span>nums<span>)</span><span>;</span>

    <span>// 统计癞子数量</span>
    <span>int</span> cnt <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span>
        <span>if</span> <span>(</span>num <span>==</span> <span>0</span><span>)</span>
            cnt<span>++</span><span>;</span>

    <span>// 使用癞子去补全不连续的顺子</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> cnt<span>;</span> i <span>&lt;</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>nums<span>[</span>i <span>+</span> <span>1</span><span>]</span> <span>==</span> nums<span>[</span>i<span>]</span><span>)</span>
            <span>return</span> <span>false</span><span>;</span>
        cnt <span>-=</span> nums<span>[</span>i <span>+</span> <span>1</span><span>]</span> <span>-</span> nums<span>[</span>i<span>]</span> <span>-</span> <span>1</span><span>;</span>
    <span>}</span>

    <span>return</span> cnt <span>>=</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h1 id="_62-圆圈中最后剩下的数" tabindex="-1"> 62. 圆圈中最后剩下的数</h1>
<p><a href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&amp;tqId=11199&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-2" tabindex="-1"> 题目描述</h2>
<p>让小朋友们围成一个大圈。然后，随机指定一个数 m，让编号为 0 的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续 0...m-1 报数 .... 这样下去 .... 直到剩下最后一个小朋友，可以不用表演。</p>
<h2 id="解题思路-2" tabindex="-1"> 解题思路</h2>
<p>约瑟夫环，圆圈长度为 n 的解可以看成长度为 n-1 的解再加上报数的长度 m。因为是圆圈，所以最后需要对 n 取余。</p>
<div><pre><code><span>public</span> <span>int</span> <span>LastRemaining_Solution</span><span>(</span><span>int</span> n<span>,</span> <span>int</span> m<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>n <span>==</span> <span>0</span><span>)</span>     <span>/* 特殊输入的处理 */</span>
        <span>return</span> <span>-</span><span>1</span><span>;</span>
    <span>if</span> <span>(</span>n <span>==</span> <span>1</span><span>)</span>     <span>/* 递归返回条件 */</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>return</span> <span>(</span><span>LastRemaining_Solution</span><span>(</span>n <span>-</span> <span>1</span><span>,</span> m<span>)</span> <span>+</span> m<span>)</span> <span>%</span> n<span>;</span>
<span>}</span>
</code></pre></div><h1 id="_63-股票的最大利润" tabindex="-1"> 63. 股票的最大利润</h1>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/" target="_blank" rel="noopener noreferrer">Leetcode</a></p>
<h2 id="题目描述-3" tabindex="-1"> 题目描述</h2>
<p>可以有一次买入和一次卖出，买入必须在前。求最大收益。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/42661013-750f-420b-b3c1-437e9a11fb65.png" width="220px"> </div><br>
<h2 id="解题思路-3" tabindex="-1"> 解题思路</h2>
<p>使用贪心策略，假设第 i 轮进行卖出操作，买入操作价格应该在 i 之前并且价格最低。</p>
<div><pre><code><span>public</span> <span>int</span> <span>maxProfit</span><span>(</span><span>int</span><span>[</span><span>]</span> prices<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>prices <span>==</span> <span>null</span> <span>||</span> prices<span>.</span>length <span>==</span> <span>0</span><span>)</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>int</span> soFarMin <span>=</span> prices<span>[</span><span>0</span><span>]</span><span>;</span>
    <span>int</span> maxProfit <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> prices<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        soFarMin <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>soFarMin<span>,</span> prices<span>[</span>i<span>]</span><span>)</span><span>;</span>
        maxProfit <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>maxProfit<span>,</span> prices<span>[</span>i<span>]</span> <span>-</span> soFarMin<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> maxProfit<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h1 id="_64-求-1-2-3-n" tabindex="-1"> 64. 求 1+2+3+...+n</h1>
<p><a href="https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&amp;tqId=11200&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-4" tabindex="-1"> 题目描述</h2>
<p>要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句 A ? B : C。</p>
<h2 id="解题思路-4" tabindex="-1"> 解题思路</h2>
<p>使用递归解法最重要的是指定返回条件，但是本题无法直接使用 if 语句来指定返回条件。</p>
<p>条件与 &amp;&amp; 具有短路原则，即在第一个条件语句为 false 的情况下不会去执行第二个条件语句。利用这一特性，将递归的返回条件取非然后作为 &amp;&amp; 的第一个条件语句，递归的主体转换为第二个条件语句，那么当递归的返回条件为 true 的情况下就不会执行递归的主体部分，递归返回。</p>
<p>本题的递归返回条件为 n &lt;= 0，取非后就是 n &gt; 0；递归的主体部分为 sum += Sum_Solution(n - 1)，转换为条件语句后就是 (sum += Sum_Solution(n - 1)) &gt; 0。</p>
<div><pre><code><span>public</span> <span>int</span> <span>Sum_Solution</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>int</span> sum <span>=</span> n<span>;</span>
    <span>boolean</span> b <span>=</span> <span>(</span>n <span>></span> <span>0</span><span>)</span> <span>&amp;&amp;</span> <span>(</span><span>(</span>sum <span>+=</span> <span>Sum_Solution</span><span>(</span>n <span>-</span> <span>1</span><span>)</span><span>)</span> <span>></span> <span>0</span><span>)</span><span>;</span>
    <span>return</span> sum<span>;</span>
<span>}</span>
</code></pre></div><h1 id="_65-不用加减乘除做加法" tabindex="-1"> 65. 不用加减乘除做加法</h1>
<p><a href="https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&amp;tqId=11201&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-5" tabindex="-1"> 题目描述</h2>
<p>写一个函数，求两个整数之和，要求不得使用 +、-、*、/ 四则运算符号。</p>
<h2 id="解题思路-5" tabindex="-1"> 解题思路</h2>
<p>a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) &lt;&lt; 1 就是进位。</p>
<p>递归会终止的原因是 (a &amp; b) &lt;&lt; 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。</p>
<div><pre><code><span>public</span> <span>int</span> <span>Add</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>
    <span>return</span> b <span>==</span> <span>0</span> <span>?</span> a <span>:</span> <span>Add</span><span>(</span>a <span>^</span> b<span>,</span> <span>(</span>a <span>&amp;</span> b<span>)</span> <span>&lt;&lt;</span> <span>1</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h1 id="_66-构建乘积数组" tabindex="-1"> 66. 构建乘积数组</h1>
<p><a href="https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&amp;tqId=11204&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-6" tabindex="-1"> 题目描述</h2>
<p>给定一个数组 A[0, 1,..., n-1]，请构建一个数组 B[0, 1,..., n-1]，其中 B 中的元素 B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。要求不能使用除法。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4240a69f-4d51-4d16-b797-2dfe110f30bd.png" width="250px"> </div><br>
<h2 id="解题思路-6" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>public</span> <span>int</span><span>[</span><span>]</span> <span>multiply</span><span>(</span><span>int</span><span>[</span><span>]</span> <span>A</span><span>)</span> <span>{</span>
    <span>int</span> n <span>=</span> <span>A</span><span>.</span>length<span>;</span>
    <span>int</span><span>[</span><span>]</span> <span>B</span> <span>=</span> <span>new</span> <span>int</span><span>[</span>n<span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>,</span> product <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> n<span>;</span> product <span>*=</span> <span>A</span><span>[</span>i<span>]</span><span>,</span> i<span>++</span><span>)</span>       <span>/* 从左往右累乘 */</span>
        <span>B</span><span>[</span>i<span>]</span> <span>=</span> product<span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> n <span>-</span> <span>1</span><span>,</span> product <span>=</span> <span>1</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> product <span>*=</span> <span>A</span><span>[</span>i<span>]</span><span>,</span> i<span>--</span><span>)</span>  <span>/* 从右往左累乘 */</span>
        <span>B</span><span>[</span>i<span>]</span> <span>*=</span> product<span>;</span>
    <span>return</span> <span>B</span><span>;</span>
<span>}</span>
</code></pre></div><h1 id="_67-把字符串转换成整数" tabindex="-1"> 67. 把字符串转换成整数</h1>
<p><a href="https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&amp;tqId=11202&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener noreferrer">NowCoder</a></p>
<h2 id="题目描述-7" tabindex="-1"> 题目描述</h2>
<p>将一个字符串转换成一个整数，字符串不是一个合法的数值则返回 0，要求不能使用字符串转换整数的库函数。</p>
<div><pre><code>Iuput:
+2147483647
1a33

Output:
2147483647
0
</code></pre></div><h2 id="解题思路-7" tabindex="-1"> 解题思路</h2>
<div><pre><code><span>public</span> <span>int</span> <span>StrToInt</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>str <span>==</span> <span>null</span> <span>||</span> str<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>boolean</span> isNegative <span>=</span> str<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span> <span>==</span> <span>'-'</span><span>;</span>
    <span>int</span> ret <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>char</span> c <span>=</span> str<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>;</span>
        <span>if</span> <span>(</span>i <span>==</span> <span>0</span> <span>&amp;&amp;</span> <span>(</span>c <span>==</span> <span>'+'</span> <span>||</span> c <span>==</span> <span>'-'</span><span>)</span><span>)</span>  <span>/* 符号判定 */</span>
            <span>continue</span><span>;</span>
        <span>if</span> <span>(</span>c <span>&lt;</span> <span>'0'</span> <span>||</span> c <span>></span> <span>'9'</span><span>)</span>                <span>/* 非法输入 */</span>
            <span>return</span> <span>0</span><span>;</span>
        ret <span>=</span> ret <span>*</span> <span>10</span> <span>+</span> <span>(</span>c <span>-</span> <span>'0'</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> isNegative <span>?</span> <span>-</span>ret <span>:</span> ret<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h1 id="_68-树中两个节点的最低公共祖先" tabindex="-1"> 68. 树中两个节点的最低公共祖先</h1>
<h2 id="解题思路-8" tabindex="-1"> 解题思路</h2>
<h3 id="二叉查找树" tabindex="-1"> 二叉查找树</h3>
<p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/" target="_blank" rel="noopener noreferrer">Leetcode : 235. Lowest Common Ancestor of a Binary Search Tree</a></p>
<p>二叉查找树中，两个节点 p, q 的公共祖先 root 满足 root.val &gt;= p.val &amp;&amp; root.val &lt;= q.val。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/047faac4-a368-4565-8331-2b66253080d3.jpg" width="220"/> </div><br>
<div><pre><code><span>public</span> <span>TreeNode</span> <span>lowestCommonAncestor</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>TreeNode</span> p<span>,</span> <span>TreeNode</span> q<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span>
        <span>return</span> root<span>;</span>
    <span>if</span> <span>(</span>root<span>.</span>val <span>></span> p<span>.</span>val <span>&amp;&amp;</span> root<span>.</span>val <span>></span> q<span>.</span>val<span>)</span>
        <span>return</span> <span>lowestCommonAncestor</span><span>(</span>root<span>.</span>left<span>,</span> p<span>,</span> q<span>)</span><span>;</span>
    <span>if</span> <span>(</span>root<span>.</span>val <span>&lt;</span> p<span>.</span>val <span>&amp;&amp;</span> root<span>.</span>val <span>&lt;</span> q<span>.</span>val<span>)</span>
        <span>return</span> <span>lowestCommonAncestor</span><span>(</span>root<span>.</span>right<span>,</span> p<span>,</span> q<span>)</span><span>;</span>
    <span>return</span> root<span>;</span>
<span>}</span>
</code></pre></div><h3 id="普通二叉树" tabindex="-1"> 普通二叉树</h3>
<p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/" target="_blank" rel="noopener noreferrer">Leetcode : 236. Lowest Common Ancestor of a Binary Tree</a></p>
<p>在左右子树中查找是否存在 p 或者 q，如果 p 和 q 分别在两个子树中，那么就说明根节点就是最低公共祖先。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d27c99f0-7881-4f2d-9675-c75cbdee3acd.jpg" width="250"/> </div><br>
<div><pre><code><span>public</span> <span>TreeNode</span> <span>lowestCommonAncestor</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>TreeNode</span> p<span>,</span> <span>TreeNode</span> q<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span> <span>||</span> root <span>==</span> p <span>||</span> root <span>==</span> q<span>)</span>
        <span>return</span> root<span>;</span>
    <span>TreeNode</span> left <span>=</span> <span>lowestCommonAncestor</span><span>(</span>root<span>.</span>left<span>,</span> p<span>,</span> q<span>)</span><span>;</span>
    <span>TreeNode</span> right <span>=</span> <span>lowestCommonAncestor</span><span>(</span>root<span>.</span>right<span>,</span> p<span>,</span> q<span>)</span><span>;</span>
    <span>return</span> left <span>==</span> <span>null</span> <span>?</span> right <span>:</span> right <span>==</span> <span>null</span> <span>?</span> left <span>:</span> root<span>;</span>
<span>}</span>
</code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>目录</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-%E7%9B%AE%E5%BD%95.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-%E7%9B%AE%E5%BD%95.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">目录</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="目录" tabindex="-1"> 目录</h1>
<ul>
<li><a href="/notes/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%203~9.html">3~9</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%2010~19.html">10~19</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%2020~29.html">20~29</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%2030~39.html">30~39</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%2040~49.html">40~49</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%2050~59.html">50~59</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%2060~68.html">60~68</a></li>
</ul>
<h1 id="参考文献" tabindex="-1"> 参考文献</h1>
<p>何海涛. 剑指 Offer[M]. 电子工业出版社, 2012.</p>
]]></content:encoded>
    </item>
    <item>
      <title>汉诺塔</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E5%85%B6%E5%AE%83.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E5%85%B6%E5%AE%83.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">汉诺塔</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li></li>
</ul>

<h1 id="汉诺塔" tabindex="-1"> 汉诺塔</h1>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/69d6c38d-1dec-4f72-ae60-60dbc10e9d15.png" width="300"/> </div><br>
<p>有三个柱子，分别为 from、buffer、to。需要将 from 上的圆盘全部移动到 to 上，并且要保证小圆盘始终在大圆盘上。</p>
<p>这是一个经典的递归问题，分为三步求解：</p>
<p>① 将 n-1 个圆盘从 from -&gt; buffer</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f9240aa1-8d48-4959-b28a-7ca45c3e4d91.png" width="300"/> </div><br>
<p>② 将 1 个圆盘从 from -&gt; to</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f579cab0-3d49-4d00-8e14-e9e1669d0f9f.png" width="300"/> </div><br>
<p>③ 将 n-1 个圆盘从 buffer -&gt; to</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d02f74dd-8e33-4f3c-bf29-53203a06695a.png" width="300"/> </div><br>
<p>如果只有一个圆盘，那么只需要进行一次移动操作。</p>
<p>从上面的讨论可以知道，a<sub>n</sub> = 2 * a<sub>n-1</sub> + 1，显然 a<sub>n</sub> = 2<sup>n</sup> - 1，n 个圆盘需要移动 2<sup>n</sup> - 1 次。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Hanoi</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>move</span><span>(</span><span>int</span> n<span>,</span> <span>String</span> from<span>,</span> <span>String</span> buffer<span>,</span> <span>String</span> <span>to</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>n <span>==</span> <span>1</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"from "</span> <span>+</span> from <span>+</span> <span>" to "</span> <span>+</span> <span>to</span><span>)</span><span>;</span>
            <span>return</span><span>;</span>
        <span>}</span>
        <span>move</span><span>(</span>n <span>-</span> <span>1</span><span>,</span> from<span>,</span> <span>to</span><span>,</span> buffer<span>)</span><span>;</span>
        <span>move</span><span>(</span><span>1</span><span>,</span> from<span>,</span> buffer<span>,</span> <span>to</span><span>)</span><span>;</span>
        <span>move</span><span>(</span>n <span>-</span> <span>1</span><span>,</span> buffer<span>,</span> from<span>,</span> <span>to</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Hanoi</span><span>.</span><span>move</span><span>(</span><span>3</span><span>,</span> <span>"H1"</span><span>,</span> <span>"H2"</span><span>,</span> <span>"H3"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><pre><code>from H1 to H3
from H1 to H2
from H3 to H2
from H1 to H3
from H2 to H1
from H2 to H3
from H1 to H3
</code></pre></div><h1 id="哈夫曼编码" tabindex="-1"> 哈夫曼编码</h1>
<p>根据数据出现的频率对数据进行编码，从而压缩原始数据。</p>
<p>例如对于一个文本文件，其中各种字符出现的次数如下：</p>
<ul>
<li>a : 10</li>
<li>b : 20</li>
<li>c : 40</li>
<li>d : 80</li>
</ul>
<p>可以将每种字符转换成二进制编码，例如将 a 转换为 00，b 转换为 01，c 转换为 10，d 转换为 11。这是最简单的一种编码方式，没有考虑各个字符的权值（出现频率）。而哈夫曼编码采用了贪心策略，使出现频率最高的字符的编码最短，从而保证整体的编码长度最短。</p>
<p>首先生成一颗哈夫曼树，每次生成过程中选取频率最少的两个节点，生成一个新节点作为它们的父节点，并且新节点的频率为两个节点的和。选取频率最少的原因是，生成过程使得先选取的节点位于树的更低层，那么需要的编码长度更长，频率更少可以使得总编码长度更少。</p>
<p>生成编码时，从根节点出发，向左遍历则添加二进制位 0，向右则添加二进制位 1，直到遍历到叶子节点，叶子节点代表的字符的编码就是这个路径编码。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8edc5164-810b-4cc5-bda8-2a2c98556377.jpg" width="300"/> </div><br>
<div><pre><code><span>public</span> <span>class</span> <span>Huffman</span> <span>{</span>

    <span>private</span> <span>class</span> <span>Node</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Node</span><span>></span></span> <span>{</span>
        <span>char</span> ch<span>;</span>
        <span>int</span> freq<span>;</span>
        <span>boolean</span> isLeaf<span>;</span>
        <span>Node</span> left<span>,</span> right<span>;</span>

        <span>public</span> <span>Node</span><span>(</span><span>char</span> ch<span>,</span> <span>int</span> freq<span>)</span> <span>{</span>
            <span>this</span><span>.</span>ch <span>=</span> ch<span>;</span>
            <span>this</span><span>.</span>freq <span>=</span> freq<span>;</span>
            isLeaf <span>=</span> <span>true</span><span>;</span>
        <span>}</span>

        <span>public</span> <span>Node</span><span>(</span><span>Node</span> left<span>,</span> <span>Node</span> right<span>,</span> <span>int</span> freq<span>)</span> <span>{</span>
            <span>this</span><span>.</span>left <span>=</span> left<span>;</span>
            <span>this</span><span>.</span>right <span>=</span> right<span>;</span>
            <span>this</span><span>.</span>freq <span>=</span> freq<span>;</span>
            isLeaf <span>=</span> <span>false</span><span>;</span>
        <span>}</span>

        <span>@Override</span>
        <span>public</span> <span>int</span> <span>compareTo</span><span>(</span><span>Node</span> o<span>)</span> <span>{</span>
            <span>return</span> <span>this</span><span>.</span>freq <span>-</span> o<span>.</span>freq<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>Map</span><span><span>&lt;</span><span>Character</span><span>,</span> <span>String</span><span>></span></span> <span>encode</span><span>(</span><span>Map</span><span><span>&lt;</span><span>Character</span><span>,</span> <span>Integer</span><span>></span></span> frequencyForChar<span>)</span> <span>{</span>
        <span>PriorityQueue</span><span><span>&lt;</span><span>Node</span><span>></span></span> priorityQueue <span>=</span> <span>new</span> <span>PriorityQueue</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>Character</span> c <span>:</span> frequencyForChar<span>.</span><span>keySet</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            priorityQueue<span>.</span><span>add</span><span>(</span><span>new</span> <span>Node</span><span>(</span>c<span>,</span> frequencyForChar<span>.</span><span>get</span><span>(</span>c<span>)</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
        <span>while</span> <span>(</span>priorityQueue<span>.</span><span>size</span><span>(</span><span>)</span> <span>!=</span> <span>1</span><span>)</span> <span>{</span>
            <span>Node</span> node1 <span>=</span> priorityQueue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
            <span>Node</span> node2 <span>=</span> priorityQueue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
            priorityQueue<span>.</span><span>add</span><span>(</span><span>new</span> <span>Node</span><span>(</span>node1<span>,</span> node2<span>,</span> node1<span>.</span>freq <span>+</span> node2<span>.</span>freq<span>)</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>encode</span><span>(</span>priorityQueue<span>.</span><span>poll</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>Map</span><span><span>&lt;</span><span>Character</span><span>,</span> <span>String</span><span>></span></span> <span>encode</span><span>(</span><span>Node</span> root<span>)</span> <span>{</span>
        <span>Map</span><span><span>&lt;</span><span>Character</span><span>,</span> <span>String</span><span>></span></span> encodingForChar <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>encode</span><span>(</span>root<span>,</span> <span>""</span><span>,</span> encodingForChar<span>)</span><span>;</span>
        <span>return</span> encodingForChar<span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>encode</span><span>(</span><span>Node</span> node<span>,</span> <span>String</span> encoding<span>,</span> <span>Map</span><span><span>&lt;</span><span>Character</span><span>,</span> <span>String</span><span>></span></span> encodingForChar<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>node<span>.</span>isLeaf<span>)</span> <span>{</span>
            encodingForChar<span>.</span><span>put</span><span>(</span>node<span>.</span>ch<span>,</span> encoding<span>)</span><span>;</span>
            <span>return</span><span>;</span>
        <span>}</span>
        <span>encode</span><span>(</span>node<span>.</span>left<span>,</span> encoding <span>+</span> <span>'0'</span><span>,</span> encodingForChar<span>)</span><span>;</span>
        <span>encode</span><span>(</span>node<span>.</span>right<span>,</span> encoding <span>+</span> <span>'1'</span><span>,</span> encodingForChar<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>前言</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">前言</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<h1 id="前言" tabindex="-1"> 前言</h1>
<p>用于解决动态连通性问题，能动态连接两个点，并且判断两个点是否连通。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/02943a90-7dd4-4e9a-9325-f8217d3cc54d.jpg" width="350"/> </div><br>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">UF(int N)</td>
<td style="text-align:center">构造一个大小为 N 的并查集</td>
</tr>
<tr>
<td style="text-align:center">void union(int p, int q)</td>
<td style="text-align:center">连接 p 和 q 节点</td>
</tr>
<tr>
<td style="text-align:center">int find(int p)</td>
<td style="text-align:center">查找 p 所在的连通分量编号</td>
</tr>
<tr>
<td style="text-align:center">boolean connected(int p, int q)</td>
<td style="text-align:center">判断 p 和 q 节点是否连通</td>
</tr>
</tbody>
</table>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>UF</span> <span>{</span>

    <span>protected</span> <span>int</span><span>[</span><span>]</span> id<span>;</span>

    <span>public</span> <span>UF</span><span>(</span><span>int</span> <span>N</span><span>)</span> <span>{</span>
        id <span>=</span> <span>new</span> <span>int</span><span>[</span><span>N</span><span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            id<span>[</span>i<span>]</span> <span>=</span> i<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>boolean</span> <span>connected</span><span>(</span><span>int</span> p<span>,</span> <span>int</span> q<span>)</span> <span>{</span>
        <span>return</span> <span>find</span><span>(</span>p<span>)</span> <span>==</span> <span>find</span><span>(</span>q<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>abstract</span> <span>int</span> <span>find</span><span>(</span><span>int</span> p<span>)</span><span>;</span>

    <span>public</span> <span>abstract</span> <span>void</span> <span>union</span><span>(</span><span>int</span> p<span>,</span> <span>int</span> q<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h1 id="quick-find" tabindex="-1"> Quick Find</h1>
<p>可以快速进行 find 操作，也就是可以快速判断两个节点是否连通。</p>
<p>需要保证同一连通分量的所有节点的 id 值相等，就可以通过判断两个节点的 id 值是否相等从而判断其连通性。</p>
<p>但是 union 操作代价却很高，需要将其中一个连通分量中的所有节点 id 值都修改为另一个节点的 id 值。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0972501d-f854-4d26-8fce-babb27c267f6.jpg" width="320"/> </div><br>
<div><pre><code><span>public</span> <span>class</span> <span>QuickFindUF</span> <span>extends</span> <span>UF</span> <span>{</span>

    <span>public</span> <span>QuickFindUF</span><span>(</span><span>int</span> <span>N</span><span>)</span> <span>{</span>
        <span>super</span><span>(</span><span>N</span><span>)</span><span>;</span>
    <span>}</span>


    <span>@Override</span>
    <span>public</span> <span>int</span> <span>find</span><span>(</span><span>int</span> p<span>)</span> <span>{</span>
        <span>return</span> id<span>[</span>p<span>]</span><span>;</span>
    <span>}</span>


    <span>@Override</span>
    <span>public</span> <span>void</span> <span>union</span><span>(</span><span>int</span> p<span>,</span> <span>int</span> q<span>)</span> <span>{</span>
        <span>int</span> pID <span>=</span> <span>find</span><span>(</span>p<span>)</span><span>;</span>
        <span>int</span> qID <span>=</span> <span>find</span><span>(</span>q<span>)</span><span>;</span>

        <span>if</span> <span>(</span>pID <span>==</span> qID<span>)</span> <span>{</span>
            <span>return</span><span>;</span>
        <span>}</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> id<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>id<span>[</span>i<span>]</span> <span>==</span> pID<span>)</span> <span>{</span>
                id<span>[</span>i<span>]</span> <span>=</span> qID<span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h1 id="quick-union" tabindex="-1"> Quick Union</h1>
<p>可以快速进行 union 操作，只需要修改一个节点的 id 值即可。</p>
<p>但是 find 操作开销很大，因为同一个连通分量的节点 id 值不同，id 值只是用来指向另一个节点。因此需要一直向上查找操作，直到找到最上层的节点。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/11b27de5-5a9d-45e4-95cc-417fa3ad1d38.jpg" width="280"/> </div><br>
<div><pre><code><span>public</span> <span>class</span> <span>QuickUnionUF</span> <span>extends</span> <span>UF</span> <span>{</span>

    <span>public</span> <span>QuickUnionUF</span><span>(</span><span>int</span> <span>N</span><span>)</span> <span>{</span>
        <span>super</span><span>(</span><span>N</span><span>)</span><span>;</span>
    <span>}</span>


    <span>@Override</span>
    <span>public</span> <span>int</span> <span>find</span><span>(</span><span>int</span> p<span>)</span> <span>{</span>
        <span>while</span> <span>(</span>p <span>!=</span> id<span>[</span>p<span>]</span><span>)</span> <span>{</span>
            p <span>=</span> id<span>[</span>p<span>]</span><span>;</span>
        <span>}</span>
        <span>return</span> p<span>;</span>
    <span>}</span>


    <span>@Override</span>
    <span>public</span> <span>void</span> <span>union</span><span>(</span><span>int</span> p<span>,</span> <span>int</span> q<span>)</span> <span>{</span>
        <span>int</span> pRoot <span>=</span> <span>find</span><span>(</span>p<span>)</span><span>;</span>
        <span>int</span> qRoot <span>=</span> <span>find</span><span>(</span>q<span>)</span><span>;</span>

        <span>if</span> <span>(</span>pRoot <span>!=</span> qRoot<span>)</span> <span>{</span>
            id<span>[</span>pRoot<span>]</span> <span>=</span> qRoot<span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>这种方法可以快速进行 union 操作，但是 find 操作和树高成正比，最坏的情况下树的高度为节点的数目。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23e4462b-263f-4d15-8805-529e0ca7a4d1.jpg" width="100"/> </div><br>
<h1 id="加权-quick-union" tabindex="-1"> 加权 Quick Union</h1>
<p>为了解决 quick-union 的树通常会很高的问题，加权 quick-union 在 union 操作时会让较小的树连接较大的树上面。</p>
<p>理论研究证明，加权 quick-union 算法构造的树深度最多不超过 logN。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a9f18f8a-c1ea-422e-aa56-d91716b0f755.jpg" width="150"/> </div><br>
<div><pre><code><span>public</span> <span>class</span> <span>WeightedQuickUnionUF</span> <span>extends</span> <span>UF</span> <span>{</span>

    <span>// 保存节点的数量信息</span>
    <span>private</span> <span>int</span><span>[</span><span>]</span> sz<span>;</span>


    <span>public</span> <span>WeightedQuickUnionUF</span><span>(</span><span>int</span> <span>N</span><span>)</span> <span>{</span>
        <span>super</span><span>(</span><span>N</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>sz <span>=</span> <span>new</span> <span>int</span><span>[</span><span>N</span><span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>this</span><span>.</span>sz<span>[</span>i<span>]</span> <span>=</span> <span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>


    <span>@Override</span>
    <span>public</span> <span>int</span> <span>find</span><span>(</span><span>int</span> p<span>)</span> <span>{</span>
        <span>while</span> <span>(</span>p <span>!=</span> id<span>[</span>p<span>]</span><span>)</span> <span>{</span>
            p <span>=</span> id<span>[</span>p<span>]</span><span>;</span>
        <span>}</span>
        <span>return</span> p<span>;</span>
    <span>}</span>


    <span>@Override</span>
    <span>public</span> <span>void</span> <span>union</span><span>(</span><span>int</span> p<span>,</span> <span>int</span> q<span>)</span> <span>{</span>

        <span>int</span> i <span>=</span> <span>find</span><span>(</span>p<span>)</span><span>;</span>
        <span>int</span> j <span>=</span> <span>find</span><span>(</span>q<span>)</span><span>;</span>

        <span>if</span> <span>(</span>i <span>==</span> j<span>)</span> <span>return</span><span>;</span>

        <span>if</span> <span>(</span>sz<span>[</span>i<span>]</span> <span>&lt;</span> sz<span>[</span>j<span>]</span><span>)</span> <span>{</span>
            id<span>[</span>i<span>]</span> <span>=</span> j<span>;</span>
            sz<span>[</span>j<span>]</span> <span>+=</span> sz<span>[</span>i<span>]</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            id<span>[</span>j<span>]</span> <span>=</span> i<span>;</span>
            sz<span>[</span>i<span>]</span> <span>+=</span> sz<span>[</span>j<span>]</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h1 id="路径压缩的加权-quick-union" tabindex="-1"> 路径压缩的加权 Quick Union</h1>
<p>在检查节点的同时将它们直接链接到根节点，只需要在 find 中添加一个循环即可。</p>
<h1 id="比较" tabindex="-1"> 比较</h1>
<table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th style="text-align:center">union</th>
<th style="text-align:center">find</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Quick Find</td>
<td style="text-align:center">N</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">Quick Union</td>
<td style="text-align:center">树高</td>
<td style="text-align:center">树高</td>
</tr>
<tr>
<td style="text-align:center">加权 Quick Union</td>
<td style="text-align:center">logN</td>
<td style="text-align:center">logN</td>
</tr>
<tr>
<td style="text-align:center">路径压缩的加权 Quick Union</td>
<td style="text-align:center">非常接近 1</td>
<td style="text-align:center">非常接近 1</td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    <item>
      <title>约定</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">约定</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>

<h1 id="约定" tabindex="-1"> 约定</h1>
<p>待排序的元素需要实现 Java 的 Comparable 接口，该接口有 compareTo() 方法，可以用它来判断两个元素的大小关系。</p>
<p>使用辅助函数 less() 和 swap() 来进行比较和交换的操作，使得代码的可读性和可移植性更好。</p>
<p>排序算法的成本模型是比较和交换的次数。</p>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>Sort</span><span><span>&lt;</span><span>T</span> <span>extends</span> <span>Comparable</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> <span>{</span>

    <span>public</span> <span>abstract</span> <span>void</span> <span>sort</span><span>(</span><span>T</span><span>[</span><span>]</span> nums<span>)</span><span>;</span>

    <span>protected</span> <span>boolean</span> <span>less</span><span>(</span><span>T</span> v<span>,</span> <span>T</span> w<span>)</span> <span>{</span>
        <span>return</span> v<span>.</span><span>compareTo</span><span>(</span>w<span>)</span> <span>&lt;</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>protected</span> <span>void</span> <span>swap</span><span>(</span><span>T</span><span>[</span><span>]</span> a<span>,</span> <span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>
        <span>T</span> t <span>=</span> a<span>[</span>i<span>]</span><span>;</span>
        a<span>[</span>i<span>]</span> <span>=</span> a<span>[</span>j<span>]</span><span>;</span>
        a<span>[</span>j<span>]</span> <span>=</span> t<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h1 id="选择排序" tabindex="-1"> 选择排序</h1>
<p>从数组中选择最小元素，将它与数组的第一个元素交换位置。再从数组剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。</p>
<p>选择排序需要 ~N<sup>2</sup>/2 次比较和 ~N 次交换，它的运行时间与输入无关，这个特点使得它对一个已经排序的数组也需要这么多的比较和交换操作。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/bc6be2d0-ed5e-4def-89e5-3ada9afa811a.gif" width="230px"> </div><br>
<div><pre><code><span>public</span> <span>class</span> <span>Selection</span><span><span>&lt;</span><span>T</span> <span>extends</span> <span>Comparable</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> <span>extends</span> <span>Sort</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>sort</span><span>(</span><span>T</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> <span>N</span> <span>=</span> nums<span>.</span>length<span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span> <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>int</span> min <span>=</span> i<span>;</span>
            <span>for</span> <span>(</span><span>int</span> j <span>=</span> i <span>+</span> <span>1</span><span>;</span> j <span>&lt;</span> <span>N</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span><span>less</span><span>(</span>nums<span>[</span>j<span>]</span><span>,</span> nums<span>[</span>min<span>]</span><span>)</span><span>)</span> <span>{</span>
                    min <span>=</span> j<span>;</span>
                <span>}</span>
            <span>}</span>
            <span>swap</span><span>(</span>nums<span>,</span> i<span>,</span> min<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h1 id="冒泡排序" tabindex="-1"> 冒泡排序</h1>
<p>从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。</p>
<p>在一轮循环中，如果没有发生交换，那么说明数组已经是有序的，此时可以直接退出。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0f8d178b-52d8-491b-9dfd-41e05a952578.gif" width="200px"> </div><br>
<div><pre><code><span>public</span> <span>class</span> <span>Bubble</span><span><span>&lt;</span><span>T</span> <span>extends</span> <span>Comparable</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> <span>extends</span> <span>Sort</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>sort</span><span>(</span><span>T</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> <span>N</span> <span>=</span> nums<span>.</span>length<span>;</span>
        <span>boolean</span> isSorted <span>=</span> <span>false</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>N</span> <span>-</span> <span>1</span><span>;</span> i <span>></span> <span>0</span> <span>&amp;&amp;</span> <span>!</span>isSorted<span>;</span> i<span>--</span><span>)</span> <span>{</span>
            isSorted <span>=</span> <span>true</span><span>;</span>
            <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> i<span>;</span> j<span>++</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span><span>less</span><span>(</span>nums<span>[</span>j <span>+</span> <span>1</span><span>]</span><span>,</span> nums<span>[</span>j<span>]</span><span>)</span><span>)</span> <span>{</span>
                    isSorted <span>=</span> <span>false</span><span>;</span>
                    <span>swap</span><span>(</span>nums<span>,</span> j<span>,</span> j <span>+</span> <span>1</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h1 id="插入排序" tabindex="-1"> 插入排序</h1>
<p>每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。</p>
<p>对于数组 {3, 5, 2, 4, 1}，它具有以下逆序：(3, 2), (3, 1), (5, 2), (5, 4), (5, 1), (2, 1), (4, 1)，插入排序每次只能交换相邻元素，令逆序数量减少 1，因此插入排序需要交换的次数为逆序数量。</p>
<p>插入排序的时间复杂度取决于数组的初始顺序，如果数组已经部分有序了，那么逆序较少，需要的交换次数也就较少，时间复杂度较低。</p>
<ul>
<li>平均情况下插入排序需要 ~N<sup>2</sup>/4 比较以及 ~N<sup>2</sup>/4 次交换；</li>
<li>最坏的情况下需要 ~N<sup>2</sup>/2 比较以及 ~N<sup>2</sup>/2 次交换，最坏的情况是数组是倒序的；</li>
<li>最好的情况下需要 N-1 次比较和 0 次交换，最好的情况就是数组已经有序了。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/35253fa4-f60a-4e3b-aaec-8fc835aabdac.gif" width="200px"> </div><br>
<div><pre><code><span>public</span> <span>class</span> <span>Insertion</span><span><span>&lt;</span><span>T</span> <span>extends</span> <span>Comparable</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> <span>extends</span> <span>Sort</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>sort</span><span>(</span><span>T</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> <span>N</span> <span>=</span> nums<span>.</span>length<span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> j <span>=</span> i<span>;</span> j <span>></span> <span>0</span> <span>&amp;&amp;</span> <span>less</span><span>(</span>nums<span>[</span>j<span>]</span><span>,</span> nums<span>[</span>j <span>-</span> <span>1</span><span>]</span><span>)</span><span>;</span> j<span>--</span><span>)</span> <span>{</span>
                <span>swap</span><span>(</span>nums<span>,</span> j<span>,</span> j <span>-</span> <span>1</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h1 id="希尔排序" tabindex="-1"> 希尔排序</h1>
<p>对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了解决插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。</p>
<p>希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7818c574-97a8-48db-8e62-8bfb030b02ba.png" width="450px"> </div><br>
<div><pre><code><span>public</span> <span>class</span> <span>Shell</span><span><span>&lt;</span><span>T</span> <span>extends</span> <span>Comparable</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> <span>extends</span> <span>Sort</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>sort</span><span>(</span><span>T</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>

        <span>int</span> <span>N</span> <span>=</span> nums<span>.</span>length<span>;</span>
        <span>int</span> h <span>=</span> <span>1</span><span>;</span>

        <span>while</span> <span>(</span>h <span>&lt;</span> <span>N</span> <span>/</span> <span>3</span><span>)</span> <span>{</span>
            h <span>=</span> <span>3</span> <span>*</span> h <span>+</span> <span>1</span><span>;</span> <span>// 1, 4, 13, 40, ...</span>
        <span>}</span>

        <span>while</span> <span>(</span>h <span>>=</span> <span>1</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> h<span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
                <span>for</span> <span>(</span><span>int</span> j <span>=</span> i<span>;</span> j <span>>=</span> h <span>&amp;&amp;</span> <span>less</span><span>(</span>nums<span>[</span>j<span>]</span><span>,</span> nums<span>[</span>j <span>-</span> h<span>]</span><span>)</span><span>;</span> j <span>-=</span> h<span>)</span> <span>{</span>
                    <span>swap</span><span>(</span>nums<span>,</span> j<span>,</span> j <span>-</span> h<span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
            h <span>=</span> h <span>/</span> <span>3</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>希尔排序的运行时间达不到平方级别，使用递增序列 1, 4, 13, 40, ...  的希尔排序所需要的比较次数不会超过 N 的若干倍乘于递增序列的长度。后面介绍的高级排序算法只会比希尔排序快两倍左右。</p>
<h1 id="归并排序" tabindex="-1"> 归并排序</h1>
<p>归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ec840967-d127-4da3-b6bb-186996c56746.png" width="300px"> </div><br>
<h2 id="_1-归并方法" tabindex="-1"> 1. 归并方法</h2>
<p>归并方法将数组中两个已经排序的部分归并成一个。</p>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>MergeSort</span><span><span>&lt;</span><span>T</span> <span>extends</span> <span>Comparable</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> <span>extends</span> <span>Sort</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>

    <span>protected</span> <span>T</span><span>[</span><span>]</span> aux<span>;</span>


    <span>protected</span> <span>void</span> <span>merge</span><span>(</span><span>T</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> l<span>,</span> <span>int</span> m<span>,</span> <span>int</span> h<span>)</span> <span>{</span>

        <span>int</span> i <span>=</span> l<span>,</span> j <span>=</span> m <span>+</span> <span>1</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> k <span>=</span> l<span>;</span> k <span>&lt;=</span> h<span>;</span> k<span>++</span><span>)</span> <span>{</span>
            aux<span>[</span>k<span>]</span> <span>=</span> nums<span>[</span>k<span>]</span><span>;</span> <span>// 将数据复制到辅助数组</span>
        <span>}</span>

        <span>for</span> <span>(</span><span>int</span> k <span>=</span> l<span>;</span> k <span>&lt;=</span> h<span>;</span> k<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>i <span>></span> m<span>)</span> <span>{</span>
                nums<span>[</span>k<span>]</span> <span>=</span> aux<span>[</span>j<span>++</span><span>]</span><span>;</span>

            <span>}</span> <span>else</span> <span>if</span> <span>(</span>j <span>></span> h<span>)</span> <span>{</span>
                nums<span>[</span>k<span>]</span> <span>=</span> aux<span>[</span>i<span>++</span><span>]</span><span>;</span>

            <span>}</span> <span>else</span> <span>if</span> <span>(</span>aux<span>[</span>i<span>]</span><span>.</span><span>compareTo</span><span>(</span>aux<span>[</span>j<span>]</span><span>)</span> <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>
                nums<span>[</span>k<span>]</span> <span>=</span> aux<span>[</span>i<span>++</span><span>]</span><span>;</span> <span>// 先进行这一步，保证稳定性</span>

            <span>}</span> <span>else</span> <span>{</span>
                nums<span>[</span>k<span>]</span> <span>=</span> aux<span>[</span>j<span>++</span><span>]</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h2 id="_2-自顶向下归并排序" tabindex="-1"> 2. 自顶向下归并排序</h2>
<p>将一个大数组分成两个小数组去求解。</p>
<p>因为每次都将问题对半分成两个子问题，这种对半分的算法复杂度一般为 O(NlogN)。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Up2DownMergeSort</span><span><span>&lt;</span><span>T</span> <span>extends</span> <span>Comparable</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> <span>extends</span> <span>MergeSort</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>sort</span><span>(</span><span>T</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        aux <span>=</span> <span>(</span><span>T</span><span>[</span><span>]</span><span>)</span> <span>new</span> <span>Comparable</span><span>[</span>nums<span>.</span>length<span>]</span><span>;</span>
        <span>sort</span><span>(</span>nums<span>,</span> <span>0</span><span>,</span> nums<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>sort</span><span>(</span><span>T</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> l<span>,</span> <span>int</span> h<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>h <span>&lt;=</span> l<span>)</span> <span>{</span>
            <span>return</span><span>;</span>
        <span>}</span>
        <span>int</span> mid <span>=</span> l <span>+</span> <span>(</span>h <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
        <span>sort</span><span>(</span>nums<span>,</span> l<span>,</span> mid<span>)</span><span>;</span>
        <span>sort</span><span>(</span>nums<span>,</span> mid <span>+</span> <span>1</span><span>,</span> h<span>)</span><span>;</span>
        <span>merge</span><span>(</span>nums<span>,</span> l<span>,</span> mid<span>,</span> h<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id="_3-自底向上归并排序" tabindex="-1"> 3. 自底向上归并排序</h2>
<p>先归并那些微型数组，然后成对归并得到的微型数组。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Down2UpMergeSort</span><span><span>&lt;</span><span>T</span> <span>extends</span> <span>Comparable</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> <span>extends</span> <span>MergeSort</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>sort</span><span>(</span><span>T</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>

        <span>int</span> <span>N</span> <span>=</span> nums<span>.</span>length<span>;</span>
        aux <span>=</span> <span>(</span><span>T</span><span>[</span><span>]</span><span>)</span> <span>new</span> <span>Comparable</span><span>[</span><span>N</span><span>]</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> sz <span>=</span> <span>1</span><span>;</span> sz <span>&lt;</span> <span>N</span><span>;</span> sz <span>+=</span> sz<span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> lo <span>=</span> <span>0</span><span>;</span> lo <span>&lt;</span> <span>N</span> <span>-</span> sz<span>;</span> lo <span>+=</span> sz <span>+</span> sz<span>)</span> <span>{</span>
                <span>merge</span><span>(</span>nums<span>,</span> lo<span>,</span> lo <span>+</span> sz <span>-</span> <span>1</span><span>,</span> <span>Math</span><span>.</span><span>min</span><span>(</span>lo <span>+</span> sz <span>+</span> sz <span>-</span> <span>1</span><span>,</span> <span>N</span> <span>-</span> <span>1</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h1 id="快速排序" tabindex="-1"> 快速排序</h1>
<h2 id="_1-基本算法" tabindex="-1"> 1. 基本算法</h2>
<ul>
<li>归并排序将数组分为两个子数组分别排序，并将有序的子数组归并使得整个数组排序；</li>
<li>快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6234eb3d-ccf2-4987-a724-235aef6957b1.png" width="280px"> </div><br>
<div><pre><code><span>public</span> <span>class</span> <span>QuickSort</span><span><span>&lt;</span><span>T</span> <span>extends</span> <span>Comparable</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> <span>extends</span> <span>Sort</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>sort</span><span>(</span><span>T</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>shuffle</span><span>(</span>nums<span>)</span><span>;</span>
        <span>sort</span><span>(</span>nums<span>,</span> <span>0</span><span>,</span> nums<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>sort</span><span>(</span><span>T</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> l<span>,</span> <span>int</span> h<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>h <span>&lt;=</span> l<span>)</span>
            <span>return</span><span>;</span>
        <span>int</span> j <span>=</span> <span>partition</span><span>(</span>nums<span>,</span> l<span>,</span> h<span>)</span><span>;</span>
        <span>sort</span><span>(</span>nums<span>,</span> l<span>,</span> j <span>-</span> <span>1</span><span>)</span><span>;</span>
        <span>sort</span><span>(</span>nums<span>,</span> j <span>+</span> <span>1</span><span>,</span> h<span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>shuffle</span><span>(</span><span>T</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>List</span><span><span>&lt;</span><span>Comparable</span><span>></span></span> list <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span>nums<span>)</span><span>;</span>
        <span>Collections</span><span>.</span><span>shuffle</span><span>(</span>list<span>)</span><span>;</span>
        list<span>.</span><span>toArray</span><span>(</span>nums<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id="_2-切分" tabindex="-1"> 2. 切分</h2>
<p>取 a[l] 作为切分元素，然后从数组的左端向右扫描直到找到第一个大于等于它的元素，再从数组的右端向左扫描找到第一个小于它的元素，交换这两个元素。不断进行这个过程，就可以保证左指针 i 的左侧元素都不大于切分元素，右指针 j 的右侧元素都不小于切分元素。当两个指针相遇时，将切分元素 a[l] 和 a[j] 交换位置。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c4859290-e27d-4f12-becf-e2a5c1f3a275.gif" width="320px"> </div><br>
<div><pre><code><span>private</span> <span>int</span> <span>partition</span><span>(</span><span>T</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> l<span>,</span> <span>int</span> h<span>)</span> <span>{</span>
    <span>int</span> i <span>=</span> l<span>,</span> j <span>=</span> h <span>+</span> <span>1</span><span>;</span>
    <span>T</span> v <span>=</span> nums<span>[</span>l<span>]</span><span>;</span>
    <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
        <span>while</span> <span>(</span><span>less</span><span>(</span>nums<span>[</span><span>++</span>i<span>]</span><span>,</span> v<span>)</span> <span>&amp;&amp;</span> i <span>!=</span> h<span>)</span> <span>;</span>
        <span>while</span> <span>(</span><span>less</span><span>(</span>v<span>,</span> nums<span>[</span><span>--</span>j<span>]</span><span>)</span> <span>&amp;&amp;</span> j <span>!=</span> l<span>)</span> <span>;</span>
        <span>if</span> <span>(</span>i <span>>=</span> j<span>)</span>
            <span>break</span><span>;</span>
        <span>swap</span><span>(</span>nums<span>,</span> i<span>,</span> j<span>)</span><span>;</span>
    <span>}</span>
    <span>swap</span><span>(</span>nums<span>,</span> l<span>,</span> j<span>)</span><span>;</span>
    <span>return</span> j<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="_3-性能分析" tabindex="-1"> 3. 性能分析</h2>
<p>快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈。</p>
<p>快速排序最好的情况下是每次都正好将数组对半分，这样递归调用次数才是最少的。这种情况下比较次数为 C<sub>N</sub>=2C<sub>N/2</sub>+N，复杂度为 O(NlogN)。</p>
<p>最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 N<sup>2</sup>/2。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。</p>
<h2 id="_4-算法改进" tabindex="-1"> 4. 算法改进</h2>
<h4 id="_4-1-切换到插入排序" tabindex="-1"> 4.1 切换到插入排序</h4>
<p>因为快速排序在小数组中也会递归调用自己，对于小数组，插入排序比快速排序的性能更好，因此在小数组中可以切换到插入排序。</p>
<h4 id="_4-2-三数取中" tabindex="-1"> 4.2 三数取中</h4>
<p>最好的情况下是每次都能取数组的中位数作为切分元素，但是计算中位数的代价很高。一种折中方法是取 3 个元素，并将大小居中的元素作为切分元素。</p>
<h4 id="_4-3-三向切分" tabindex="-1"> 4.3 三向切分</h4>
<p>对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。</p>
<p>三向切分快速排序对于有大量重复元素的随机数组可以在线性时间内完成排序。</p>
<div><pre><code><span>public</span> <span>class</span> <span>ThreeWayQuickSort</span><span><span>&lt;</span><span>T</span> <span>extends</span> <span>Comparable</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> <span>extends</span> <span>QuickSort</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>

    <span>@Override</span>
    <span>protected</span> <span>void</span> <span>sort</span><span>(</span><span>T</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> l<span>,</span> <span>int</span> h<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>h <span>&lt;=</span> l<span>)</span> <span>{</span>
            <span>return</span><span>;</span>
        <span>}</span>
        <span>int</span> lt <span>=</span> l<span>,</span> i <span>=</span> l <span>+</span> <span>1</span><span>,</span> gt <span>=</span> h<span>;</span>
        <span>T</span> v <span>=</span> nums<span>[</span>l<span>]</span><span>;</span>
        <span>while</span> <span>(</span>i <span>&lt;=</span> gt<span>)</span> <span>{</span>
            <span>int</span> cmp <span>=</span> nums<span>[</span>i<span>]</span><span>.</span><span>compareTo</span><span>(</span>v<span>)</span><span>;</span>
            <span>if</span> <span>(</span>cmp <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
                <span>swap</span><span>(</span>nums<span>,</span> lt<span>++</span><span>,</span> i<span>++</span><span>)</span><span>;</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span>cmp <span>></span> <span>0</span><span>)</span> <span>{</span>
                <span>swap</span><span>(</span>nums<span>,</span> i<span>,</span> gt<span>--</span><span>)</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                i<span>++</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>sort</span><span>(</span>nums<span>,</span> l<span>,</span> lt <span>-</span> <span>1</span><span>)</span><span>;</span>
        <span>sort</span><span>(</span>nums<span>,</span> gt <span>+</span> <span>1</span><span>,</span> h<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id="_5-基于切分的快速选择算法" tabindex="-1"> 5. 基于切分的快速选择算法</h2>
<p>快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。</p>
<p>可以利用这个特性找出数组的第 k 个元素。</p>
<p>该算法是线性级别的，假设每次能将数组二分，那么比较的总次数为 (N+N/2+N/4+..)，直到找到第 k 个元素，这个和显然小于 2N。</p>
<div><pre><code><span>public</span> <span>T</span> <span>select</span><span>(</span><span>T</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>)</span> <span>{</span>
    <span>int</span> l <span>=</span> <span>0</span><span>,</span> h <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>
    <span>while</span> <span>(</span>h <span>></span> l<span>)</span> <span>{</span>
        <span>int</span> j <span>=</span> <span>partition</span><span>(</span>nums<span>,</span> l<span>,</span> h<span>)</span><span>;</span>

        <span>if</span> <span>(</span>j <span>==</span> k<span>)</span> <span>{</span>
            <span>return</span> nums<span>[</span>k<span>]</span><span>;</span>

        <span>}</span> <span>else</span> <span>if</span> <span>(</span>j <span>></span> k<span>)</span> <span>{</span>
            h <span>=</span> j <span>-</span> <span>1</span><span>;</span>

        <span>}</span> <span>else</span> <span>{</span>
            l <span>=</span> j <span>+</span> <span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> nums<span>[</span>k<span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h1 id="堆排序" tabindex="-1"> 堆排序</h1>
<h2 id="_1-堆" tabindex="-1"> 1. 堆</h2>
<p>堆中某个节点的值总是大于等于其子节点的值，并且堆是一颗完全二叉树。</p>
<p>堆可以用数组来表示，这是因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。这里不使用数组索引为 0 的位置，是为了更清晰地描述节点的位置关系。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f48883c8-9d8a-494e-99a4-317d8ddb8552.png" width="170px"> </div><br>
<div><pre><code><span>public</span> <span>class</span> <span>Heap</span><span><span>&lt;</span><span>T</span> <span>extends</span> <span>Comparable</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> <span>{</span>

    <span>private</span> <span>T</span><span>[</span><span>]</span> heap<span>;</span>
    <span>private</span> <span>int</span> <span>N</span> <span>=</span> <span>0</span><span>;</span>

    <span>public</span> <span>Heap</span><span>(</span><span>int</span> maxN<span>)</span> <span>{</span>
        <span>this</span><span>.</span>heap <span>=</span> <span>(</span><span>T</span><span>[</span><span>]</span><span>)</span> <span>new</span> <span>Comparable</span><span>[</span>maxN <span>+</span> <span>1</span><span>]</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>N</span> <span>==</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>size</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>N</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>boolean</span> <span>less</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>
        <span>return</span> heap<span>[</span>i<span>]</span><span>.</span><span>compareTo</span><span>(</span>heap<span>[</span>j<span>]</span><span>)</span> <span>&lt;</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>swap</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>
        <span>T</span> t <span>=</span> heap<span>[</span>i<span>]</span><span>;</span>
        heap<span>[</span>i<span>]</span> <span>=</span> heap<span>[</span>j<span>]</span><span>;</span>
        heap<span>[</span>j<span>]</span> <span>=</span> t<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id="_2-上浮和下沉" tabindex="-1"> 2. 上浮和下沉</h2>
<p>在堆中，当一个节点比父节点大，那么需要交换这个两个节点。交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，把这种操作称为上浮。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/99d5e84e-fc2a-49a3-8259-8de274617756.gif" width="270px"> </div><br>
<div><pre><code><span>private</span> <span>void</span> <span>swim</span><span>(</span><span>int</span> k<span>)</span> <span>{</span>
    <span>while</span> <span>(</span>k <span>></span> <span>1</span> <span>&amp;&amp;</span> <span>less</span><span>(</span>k <span>/</span> <span>2</span><span>,</span> k<span>)</span><span>)</span> <span>{</span>
        <span>swap</span><span>(</span>k <span>/</span> <span>2</span><span>,</span> k<span>)</span><span>;</span>
        k <span>=</span> k <span>/</span> <span>2</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><p>类似地，当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉。一个节点如果有两个子节点，应当与两个子节点中最大那个节点进行交换。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4bf5e3fb-a285-4138-b3b6-780956eb1df1.gif" width="270px"> </div><br>
<div><pre><code><span>private</span> <span>void</span> <span>sink</span><span>(</span><span>int</span> k<span>)</span> <span>{</span>
    <span>while</span> <span>(</span><span>2</span> <span>*</span> k <span>&lt;=</span> <span>N</span><span>)</span> <span>{</span>
        <span>int</span> j <span>=</span> <span>2</span> <span>*</span> k<span>;</span>
        <span>if</span> <span>(</span>j <span>&lt;</span> <span>N</span> <span>&amp;&amp;</span> <span>less</span><span>(</span>j<span>,</span> j <span>+</span> <span>1</span><span>)</span><span>)</span>
            j<span>++</span><span>;</span>
        <span>if</span> <span>(</span><span>!</span><span>less</span><span>(</span>k<span>,</span> j<span>)</span><span>)</span>
            <span>break</span><span>;</span>
        <span>swap</span><span>(</span>k<span>,</span> j<span>)</span><span>;</span>
        k <span>=</span> j<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="_3-插入元素" tabindex="-1"> 3. 插入元素</h2>
<p>将新元素放到数组末尾，然后上浮到合适的位置。</p>
<div><pre><code><span>public</span> <span>void</span> <span>insert</span><span>(</span><span>Comparable</span> v<span>)</span> <span>{</span>
    heap<span>[</span><span>++</span><span>N</span><span>]</span> <span>=</span> v<span>;</span>
    <span>swim</span><span>(</span><span>N</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h2 id="_4-删除最大元素" tabindex="-1"> 4. 删除最大元素</h2>
<p>从数组顶端删除最大的元素，并将数组的最后一个元素放到顶端，并让这个元素下沉到合适的位置。</p>
<div><pre><code><span>public</span> <span>T</span> <span>delMax</span><span>(</span><span>)</span> <span>{</span>
    <span>T</span> max <span>=</span> heap<span>[</span><span>1</span><span>]</span><span>;</span>
    <span>swap</span><span>(</span><span>1</span><span>,</span> <span>N</span><span>--</span><span>)</span><span>;</span>
    heap<span>[</span><span>N</span> <span>+</span> <span>1</span><span>]</span> <span>=</span> <span>null</span><span>;</span>
    <span>sink</span><span>(</span><span>1</span><span>)</span><span>;</span>
    <span>return</span> max<span>;</span>
<span>}</span>
</code></pre></div><h2 id="_5-堆排序" tabindex="-1"> 5. 堆排序</h2>
<p>把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列，这就是堆排序。</p>
<h4 id="_5-1-构建堆" tabindex="-1"> 5.1 构建堆</h4>
<p>无序数组建立堆最直接的方法是从左到右遍历数组进行上浮操作。一个更高效的方法是从右至左进行下沉操作，如果一个节点的两个节点都已经是堆有序，那么进行下沉操作可以使得这个节点为根节点的堆有序。叶子节点不需要进行下沉操作，可以忽略叶子节点的元素，因此只需要遍历一半的元素即可。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c2ca8dd2-8d00-4a3e-bece-db7849ac9cfd.gif" width="210px"> </div><br>
<h4 id="_5-2-交换堆顶元素与最后一个元素" tabindex="-1"> 5.2 交换堆顶元素与最后一个元素</h4>
<p>交换之后需要进行下沉操作维持堆的有序状态。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d156bcda-ac8d-4324-95e0-0c8df41567c9.gif" width="250px"> </div><br>
<div><pre><code><span>public</span> <span>class</span> <span>HeapSort</span><span><span>&lt;</span><span>T</span> <span>extends</span> <span>Comparable</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> <span>extends</span> <span>Sort</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>
    <span>/**
     * 数组第 0 个位置不能有元素
     */</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>sort</span><span>(</span><span>T</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> <span>N</span> <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> k <span>=</span> <span>N</span> <span>/</span> <span>2</span><span>;</span> k <span>>=</span> <span>1</span><span>;</span> k<span>--</span><span>)</span>
            <span>sink</span><span>(</span>nums<span>,</span> k<span>,</span> <span>N</span><span>)</span><span>;</span>

        <span>while</span> <span>(</span><span>N</span> <span>></span> <span>1</span><span>)</span> <span>{</span>
            <span>swap</span><span>(</span>nums<span>,</span> <span>1</span><span>,</span> <span>N</span><span>--</span><span>)</span><span>;</span>
            <span>sink</span><span>(</span>nums<span>,</span> <span>1</span><span>,</span> <span>N</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>sink</span><span>(</span><span>T</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> k<span>,</span> <span>int</span> <span>N</span><span>)</span> <span>{</span>
        <span>while</span> <span>(</span><span>2</span> <span>*</span> k <span>&lt;=</span> <span>N</span><span>)</span> <span>{</span>
            <span>int</span> j <span>=</span> <span>2</span> <span>*</span> k<span>;</span>
            <span>if</span> <span>(</span>j <span>&lt;</span> <span>N</span> <span>&amp;&amp;</span> <span>less</span><span>(</span>nums<span>,</span> j<span>,</span> j <span>+</span> <span>1</span><span>)</span><span>)</span>
                j<span>++</span><span>;</span>
            <span>if</span> <span>(</span><span>!</span><span>less</span><span>(</span>nums<span>,</span> k<span>,</span> j<span>)</span><span>)</span>
                <span>break</span><span>;</span>
            <span>swap</span><span>(</span>nums<span>,</span> k<span>,</span> j<span>)</span><span>;</span>
            k <span>=</span> j<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>private</span> <span>boolean</span> <span>less</span><span>(</span><span>T</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>
        <span>return</span> nums<span>[</span>i<span>]</span><span>.</span><span>compareTo</span><span>(</span>nums<span>[</span>j<span>]</span><span>)</span> <span>&lt;</span> <span>0</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h2 id="_6-分析" tabindex="-1"> 6. 分析</h2>
<p>一个堆的高度为 logN，因此在堆中插入元素和删除最大元素的复杂度都为 logN。</p>
<p>对于堆排序，由于要对 N 个节点进行下沉操作，因此复杂度为 NlogN。</p>
<p>堆排序是一种原地排序，没有利用额外的空间。</p>
<p>现代操作系统很少使用堆排序，因为它无法利用局部性原理进行缓存，也就是数组元素很少和相邻的元素进行比较和交换。</p>
<h1 id="小结" tabindex="-1"> 小结</h1>
<h2 id="_1-排序算法的比较" tabindex="-1"> 1. 排序算法的比较</h2>
<table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th style="text-align:center">稳定性</th>
<th style="text-align:center">平均时间复杂度</th>
<th style="text-align:center">最好</th>
<th style="text-align:center">最坏</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">排序方式</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">选择排序</td>
<td style="text-align:center">×</td>
<td style="text-align:center">N<sup>2</sup></td>
<td style="text-align:center">N<sup>2</sup></td>
<td style="text-align:center">N<sup>2</sup></td>
<td style="text-align:center">1</td>
<td style="text-align:center">in palce</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">√</td>
<td style="text-align:center">N<sup>2</sup></td>
<td style="text-align:center">N</td>
<td style="text-align:center">N<sup>2</sup></td>
<td style="text-align:center">1</td>
<td style="text-align:center">in palce</td>
<td style="text-align:center">排序趟数和初始顺序有关</td>
</tr>
<tr>
<td style="text-align:center">插入排序</td>
<td style="text-align:center">√</td>
<td style="text-align:center">N ~ N<sup>2</sup></td>
<td style="text-align:center">N</td>
<td style="text-align:center">N<sup>2</sup></td>
<td style="text-align:center">1</td>
<td style="text-align:center">in palce</td>
<td style="text-align:center">时间复杂度和初始顺序有关</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center">×</td>
<td style="text-align:center">N 的若干倍乘于递增序列长度</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:center">in palce</td>
<td style="text-align:center">改进版插入排序(复杂度和增量序列有关)</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">×</td>
<td style="text-align:center">NlogN</td>
<td style="text-align:center">NlogN</td>
<td style="text-align:center">N<sup>2</sup></td>
<td style="text-align:center">logN</td>
<td style="text-align:center">in palce</td>
<td style="text-align:center">排序趟数和初始顺序有关</td>
</tr>
<tr>
<td style="text-align:center">三路快排</td>
<td style="text-align:center">×</td>
<td style="text-align:center">N ~ NlogN</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">logN</td>
<td style="text-align:center">in palce</td>
<td style="text-align:center">适用于有大量重复主键</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">√</td>
<td style="text-align:center">NlogN</td>
<td style="text-align:center">NlogN</td>
<td style="text-align:center">NlogN</td>
<td style="text-align:center">N</td>
<td style="text-align:center">out place</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">×</td>
<td style="text-align:center">NlogN</td>
<td style="text-align:center">NlogN</td>
<td style="text-align:center">NlogN</td>
<td style="text-align:center">1</td>
<td style="text-align:center">in palce</td>
<td style="text-align:center">无法利用局部性原理</td>
</tr>
<tr>
<td style="text-align:center">计数排序</td>
<td style="text-align:center">√</td>
<td style="text-align:center">N+k</td>
<td style="text-align:center">N+k</td>
<td style="text-align:center">N+k</td>
<td style="text-align:center">k</td>
<td style="text-align:center">out place</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">桶排序</td>
<td style="text-align:center">√</td>
<td style="text-align:center">N+k</td>
<td style="text-align:center">N+k</td>
<td style="text-align:center">N<sup>2</sup></td>
<td style="text-align:center">N+k</td>
<td style="text-align:center">out place</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">基数排序</td>
<td style="text-align:center">√</td>
<td style="text-align:center">N*k</td>
<td style="text-align:center">N*k</td>
<td style="text-align:center">N*k</td>
<td style="text-align:center">N+k</td>
<td style="text-align:center">out place</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>快速排序是最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为 cNlogN，这里的 c 比其它线性对数级别的排序算法都要小。</p>
<p>使用三向切分快速排序(三路快排)，实际应用中可能出现的某些分布的输入能够达到线性级别，而其它排序算法仍然需要线性对数时间。</p>
<h2 id="_2-算法分类" tabindex="-1"> 2. 算法分类</h2>
<p>内部外部排序</p>
<ul>
<li>内部排序：所有排序操作都在内存中完成</li>
<li>外部排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行</li>
</ul>
<p>内部排序分类</p>
<ul>
<li>插入排序
<ul>
<li>直接插入排序</li>
<li>希尔排序</li>
</ul>
</li>
<li>选择排序
<ul>
<li>简单选择排序</li>
<li>堆排序</li>
</ul>
</li>
<li>交换排序
<ul>
<li>冒泡排序</li>
<li>快速排序</li>
</ul>
</li>
<li>归并排序</li>
<li>基数排序</li>
</ul>
<p>比较非比较</p>
<ul>
<li>比较排序：在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。</li>
<li>非比较排序：通过确定每个元素之前，应该有多少个元素来排序。</li>
</ul>
<h2 id="_3-java-的排序算法实现" tabindex="-1"> 3. Java 的排序算法实现</h2>
<p>Java 主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序。</p>
]]></content:encoded>
    </item>
    <item>
      <title>栈</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">栈</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>

<h1 id="栈" tabindex="-1"> 栈</h1>
<div><pre><code><span>public</span> <span>interface</span> <span>MyStack</span><span><span>&lt;</span><span>Item</span><span>></span></span> <span>extends</span> <span>Iterable</span><span><span>&lt;</span><span>Item</span><span>></span></span> <span>{</span>

    <span>MyStack</span><span><span>&lt;</span><span>Item</span><span>></span></span> <span>push</span><span>(</span><span>Item</span> item<span>)</span><span>;</span>

    <span>Item</span> <span>pop</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span><span>;</span>

    <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span><span>;</span>

    <span>int</span> <span>size</span><span>(</span><span>)</span><span>;</span>

<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="_1-数组实现" tabindex="-1"> 1. 数组实现</h2>
<div><pre><code><span>public</span> <span>class</span> <span>ArrayStack</span><span><span>&lt;</span><span>Item</span><span>></span></span> <span>implements</span> <span>MyStack</span><span><span>&lt;</span><span>Item</span><span>></span></span> <span>{</span>

    <span>// 栈元素数组，只能通过转型来创建泛型数组</span>
    <span>private</span> <span>Item</span><span>[</span><span>]</span> a <span>=</span> <span>(</span><span>Item</span><span>[</span><span>]</span><span>)</span> <span>new</span> <span>Object</span><span>[</span><span>1</span><span>]</span><span>;</span>

    <span>// 元素数量</span>
    <span>private</span> <span>int</span> <span>N</span> <span>=</span> <span>0</span><span>;</span>


    <span>@Override</span>
    <span>public</span> <span>MyStack</span><span><span>&lt;</span><span>Item</span><span>></span></span> <span>push</span><span>(</span><span>Item</span> item<span>)</span> <span>{</span>
        <span>check</span><span>(</span><span>)</span><span>;</span>
        a<span>[</span><span>N</span><span>++</span><span>]</span> <span>=</span> item<span>;</span>
        <span>return</span> <span>this</span><span>;</span>
    <span>}</span>


    <span>@Override</span>
    <span>public</span> <span>Item</span> <span>pop</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>

        <span>if</span> <span>(</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>throw</span> <span>new</span> <span>Exception</span><span>(</span><span>"stack is empty"</span><span>)</span><span>;</span>
        <span>}</span>

        <span>Item</span> item <span>=</span> a<span>[</span><span>--</span><span>N</span><span>]</span><span>;</span>

        <span>check</span><span>(</span><span>)</span><span>;</span>

        <span>// 避免对象游离</span>
        a<span>[</span><span>N</span><span>]</span> <span>=</span> <span>null</span><span>;</span>

        <span>return</span> item<span>;</span>
    <span>}</span>


    <span>private</span> <span>void</span> <span>check</span><span>(</span><span>)</span> <span>{</span>

        <span>if</span> <span>(</span><span>N</span> <span>>=</span> a<span>.</span>length<span>)</span> <span>{</span>
            <span>resize</span><span>(</span><span>2</span> <span>*</span> a<span>.</span>length<span>)</span><span>;</span>

        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>N</span> <span>></span> <span>0</span> <span>&amp;&amp;</span> <span>N</span> <span>&lt;=</span> a<span>.</span>length <span>/</span> <span>4</span><span>)</span> <span>{</span>
            <span>resize</span><span>(</span>a<span>.</span>length <span>/</span> <span>2</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>


    <span>/**
     * 调整数组大小，使得栈具有伸缩性
     */</span>
    <span>private</span> <span>void</span> <span>resize</span><span>(</span><span>int</span> size<span>)</span> <span>{</span>

        <span>Item</span><span>[</span><span>]</span> tmp <span>=</span> <span>(</span><span>Item</span><span>[</span><span>]</span><span>)</span> <span>new</span> <span>Object</span><span>[</span>size<span>]</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            tmp<span>[</span>i<span>]</span> <span>=</span> a<span>[</span>i<span>]</span><span>;</span>
        <span>}</span>

        a <span>=</span> tmp<span>;</span>
    <span>}</span>


    <span>@Override</span>
    <span>public</span> <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>N</span> <span>==</span> <span>0</span><span>;</span>
    <span>}</span>


    <span>@Override</span>
    <span>public</span> <span>int</span> <span>size</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>N</span><span>;</span>
    <span>}</span>


    <span>@Override</span>
    <span>public</span> <span>Iterator</span><span><span>&lt;</span><span>Item</span><span>></span></span> <span>iterator</span><span>(</span><span>)</span> <span>{</span>

        <span>// 返回逆序遍历的迭代器</span>
        <span>return</span> <span>new</span> <span>Iterator</span><span><span>&lt;</span><span>Item</span><span>></span></span><span>(</span><span>)</span> <span>{</span>

            <span>private</span> <span>int</span> i <span>=</span> <span>N</span><span>;</span>

            <span>@Override</span>
            <span>public</span> <span>boolean</span> <span>hasNext</span><span>(</span><span>)</span> <span>{</span>
                <span>return</span> i <span>></span> <span>0</span><span>;</span>
            <span>}</span>

            <span>@Override</span>
            <span>public</span> <span>Item</span> <span>next</span><span>(</span><span>)</span> <span>{</span>
                <span>return</span> a<span>[</span><span>--</span>i<span>]</span><span>;</span>
            <span>}</span>
        <span>}</span><span>;</span>

    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br></div></div><h2 id="_2-链表实现" tabindex="-1"> 2. 链表实现</h2>
<p>需要使用链表的头插法来实现，因为头插法中最后压入栈的元素在链表的开头，它的 next 指针指向前一个压入栈的元素，在弹出元素时就可以通过 next 指针遍历到前一个压入栈的元素从而让这个元素成为新的栈顶元素。</p>
<div><pre><code><span>public</span> <span>class</span> <span>ListStack</span><span><span>&lt;</span><span>Item</span><span>></span></span> <span>implements</span> <span>MyStack</span><span><span>&lt;</span><span>Item</span><span>></span></span> <span>{</span>

    <span>private</span> <span>Node</span> top <span>=</span> <span>null</span><span>;</span>
    <span>private</span> <span>int</span> <span>N</span> <span>=</span> <span>0</span><span>;</span>


    <span>private</span> <span>class</span> <span>Node</span> <span>{</span>
        <span>Item</span> item<span>;</span>
        <span>Node</span> next<span>;</span>
    <span>}</span>


    <span>@Override</span>
    <span>public</span> <span>MyStack</span><span><span>&lt;</span><span>Item</span><span>></span></span> <span>push</span><span>(</span><span>Item</span> item<span>)</span> <span>{</span>

        <span>Node</span> newTop <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>)</span><span>;</span>

        newTop<span>.</span>item <span>=</span> item<span>;</span>
        newTop<span>.</span>next <span>=</span> top<span>;</span>

        top <span>=</span> newTop<span>;</span>

        <span>N</span><span>++</span><span>;</span>

        <span>return</span> <span>this</span><span>;</span>
    <span>}</span>


    <span>@Override</span>
    <span>public</span> <span>Item</span> <span>pop</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>

        <span>if</span> <span>(</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>throw</span> <span>new</span> <span>Exception</span><span>(</span><span>"stack is empty"</span><span>)</span><span>;</span>
        <span>}</span>

        <span>Item</span> item <span>=</span> top<span>.</span>item<span>;</span>

        top <span>=</span> top<span>.</span>next<span>;</span>
        <span>N</span><span>--</span><span>;</span>

        <span>return</span> item<span>;</span>
    <span>}</span>


    <span>@Override</span>
    <span>public</span> <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>N</span> <span>==</span> <span>0</span><span>;</span>
    <span>}</span>


    <span>@Override</span>
    <span>public</span> <span>int</span> <span>size</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>N</span><span>;</span>
    <span>}</span>


    <span>@Override</span>
    <span>public</span> <span>Iterator</span><span><span>&lt;</span><span>Item</span><span>></span></span> <span>iterator</span><span>(</span><span>)</span> <span>{</span>

        <span>return</span> <span>new</span> <span>Iterator</span><span><span>&lt;</span><span>Item</span><span>></span></span><span>(</span><span>)</span> <span>{</span>

            <span>private</span> <span>Node</span> cur <span>=</span> top<span>;</span>


            <span>@Override</span>
            <span>public</span> <span>boolean</span> <span>hasNext</span><span>(</span><span>)</span> <span>{</span>
                <span>return</span> cur <span>!=</span> <span>null</span><span>;</span>
            <span>}</span>


            <span>@Override</span>
            <span>public</span> <span>Item</span> <span>next</span><span>(</span><span>)</span> <span>{</span>
                <span>Item</span> item <span>=</span> cur<span>.</span>item<span>;</span>
                cur <span>=</span> cur<span>.</span>next<span>;</span>
                <span>return</span> item<span>;</span>
            <span>}</span>
        <span>}</span><span>;</span>

    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br></div></div><h1 id="队列" tabindex="-1"> 队列</h1>
<p>下面是队列的链表实现，需要维护 first 和 last 节点指针，分别指向队首和队尾。</p>
<p>这里需要考虑 first 和 last 指针哪个作为链表的开头。因为出队列操作需要让队首元素的下一个元素成为队首，所以需要容易获取下一个元素，而链表的头部节点的 next 指针指向下一个元素，因此可以让 first 指针链表的开头。</p>
<div><pre><code><span>public</span> <span>interface</span> <span>MyQueue</span><span><span>&lt;</span><span>Item</span><span>></span></span> <span>extends</span> <span>Iterable</span><span><span>&lt;</span><span>Item</span><span>></span></span> <span>{</span>

    <span>int</span> <span>size</span><span>(</span><span>)</span><span>;</span>

    <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span><span>;</span>

    <span>MyQueue</span><span><span>&lt;</span><span>Item</span><span>></span></span> <span>add</span><span>(</span><span>Item</span> item<span>)</span><span>;</span>

    <span>Item</span> <span>remove</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>ListQueue</span><span><span>&lt;</span><span>Item</span><span>></span></span> <span>implements</span> <span>MyQueue</span><span><span>&lt;</span><span>Item</span><span>></span></span> <span>{</span>

    <span>private</span> <span>Node</span> first<span>;</span>
    <span>private</span> <span>Node</span> last<span>;</span>
    <span>int</span> <span>N</span> <span>=</span> <span>0</span><span>;</span>


    <span>private</span> <span>class</span> <span>Node</span> <span>{</span>
        <span>Item</span> item<span>;</span>
        <span>Node</span> next<span>;</span>
    <span>}</span>


    <span>@Override</span>
    <span>public</span> <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>N</span> <span>==</span> <span>0</span><span>;</span>
    <span>}</span>


    <span>@Override</span>
    <span>public</span> <span>int</span> <span>size</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>N</span><span>;</span>
    <span>}</span>


    <span>@Override</span>
    <span>public</span> <span>MyQueue</span><span><span>&lt;</span><span>Item</span><span>></span></span> <span>add</span><span>(</span><span>Item</span> item<span>)</span> <span>{</span>

        <span>Node</span> newNode <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>)</span><span>;</span>
        newNode<span>.</span>item <span>=</span> item<span>;</span>
        newNode<span>.</span>next <span>=</span> <span>null</span><span>;</span>

        <span>if</span> <span>(</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            last <span>=</span> newNode<span>;</span>
            first <span>=</span> newNode<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            last<span>.</span>next <span>=</span> newNode<span>;</span>
            last <span>=</span> newNode<span>;</span>
        <span>}</span>

        <span>N</span><span>++</span><span>;</span>
        <span>return</span> <span>this</span><span>;</span>
    <span>}</span>


    <span>@Override</span>
    <span>public</span> <span>Item</span> <span>remove</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>

        <span>if</span> <span>(</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>throw</span> <span>new</span> <span>Exception</span><span>(</span><span>"queue is empty"</span><span>)</span><span>;</span>
        <span>}</span>

        <span>Node</span> node <span>=</span> first<span>;</span>
        first <span>=</span> first<span>.</span>next<span>;</span>
        <span>N</span><span>--</span><span>;</span>

        <span>if</span> <span>(</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            last <span>=</span> <span>null</span><span>;</span>
        <span>}</span>

        <span>return</span> node<span>.</span>item<span>;</span>
    <span>}</span>


    <span>@Override</span>
    <span>public</span> <span>Iterator</span><span><span>&lt;</span><span>Item</span><span>></span></span> <span>iterator</span><span>(</span><span>)</span> <span>{</span>

        <span>return</span> <span>new</span> <span>Iterator</span><span><span>&lt;</span><span>Item</span><span>></span></span><span>(</span><span>)</span> <span>{</span>

            <span>Node</span> cur <span>=</span> first<span>;</span>


            <span>@Override</span>
            <span>public</span> <span>boolean</span> <span>hasNext</span><span>(</span><span>)</span> <span>{</span>
                <span>return</span> cur <span>!=</span> <span>null</span><span>;</span>
            <span>}</span>


            <span>@Override</span>
            <span>public</span> <span>Item</span> <span>next</span><span>(</span><span>)</span> <span>{</span>
                <span>Item</span> item <span>=</span> cur<span>.</span>item<span>;</span>
                cur <span>=</span> cur<span>.</span>next<span>;</span>
                <span>return</span> item<span>;</span>
            <span>}</span>
        <span>}</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>目录</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E7%9B%AE%E5%BD%95.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E7%9B%AE%E5%BD%95.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">目录</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="目录" tabindex="-1"> 目录</h1>
<ul>
<li><a href="/notes/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%20-%20%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90.html">算法分析</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%20-%20%E6%8E%92%E5%BA%8F.html">排序</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%20-%20%E5%B9%B6%E6%9F%A5%E9%9B%86.html">并查集</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%20-%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.html">栈和队列</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8.html">符号表</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%20-%20%E5%85%B6%E5%AE%83.html">其它</a></li>
</ul>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li>Sedgewick, Robert, and Kevin Wayne. <em>Algorithms</em>. Addison-Wesley Professional, 2011.</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>前言</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E7%AC%A6%E5%8F%B7%E8%A1%A8.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E7%AC%A6%E5%8F%B7%E8%A1%A8.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">前言</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>

<h1 id="前言" tabindex="-1"> 前言</h1>
<p>符号表（Symbol Table）是一种存储键值对的数据结构，可以支持快速查找操作。</p>
<p>符号表分为有序和无序两种，有序符号表主要指支持 min()、max() 等根据键的大小关系来实现的操作。</p>
<p>有序符号表的键需要实现 Comparable 接口。</p>
<div><pre><code><span>public</span> <span>interface</span> <span>UnorderedST</span><span><span>&lt;</span><span>Key</span><span>,</span> <span>Value</span><span>></span></span> <span>{</span>

    <span>int</span> <span>size</span><span>(</span><span>)</span><span>;</span>

    <span>Value</span> <span>get</span><span>(</span><span>Key</span> key<span>)</span><span>;</span>

    <span>void</span> <span>put</span><span>(</span><span>Key</span> key<span>,</span> <span>Value</span> value<span>)</span><span>;</span>

    <span>void</span> <span>delete</span><span>(</span><span>Key</span> key<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>public</span> <span>interface</span> <span>OrderedST</span><span><span>&lt;</span><span>Key</span> <span>extends</span> <span>Comparable</span><span>&lt;</span><span>Key</span><span>></span><span>,</span> <span>Value</span><span>></span></span> <span>{</span>

    <span>int</span> <span>size</span><span>(</span><span>)</span><span>;</span>

    <span>void</span> <span>put</span><span>(</span><span>Key</span> key<span>,</span> <span>Value</span> value<span>)</span><span>;</span>

    <span>Value</span> <span>get</span><span>(</span><span>Key</span> key<span>)</span><span>;</span>

    <span>Key</span> <span>min</span><span>(</span><span>)</span><span>;</span>

    <span>Key</span> <span>max</span><span>(</span><span>)</span><span>;</span>

    <span>int</span> <span>rank</span><span>(</span><span>Key</span> key<span>)</span><span>;</span>

    <span>List</span><span><span>&lt;</span><span>Key</span><span>></span></span> <span>keys</span><span>(</span><span>Key</span> l<span>,</span> <span>Key</span> h<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h1 id="初级实现" tabindex="-1"> 初级实现</h1>
<h2 id="_1-链表实现无序符号表" tabindex="-1"> 1. 链表实现无序符号表</h2>
<div><pre><code><span>public</span> <span>class</span> <span>ListUnorderedST</span><span><span>&lt;</span><span>Key</span><span>,</span> <span>Value</span><span>></span></span> <span>implements</span> <span>UnorderedST</span><span><span>&lt;</span><span>Key</span><span>,</span> <span>Value</span><span>></span></span> <span>{</span>

    <span>private</span> <span>Node</span> first<span>;</span>

    <span>private</span> <span>class</span> <span>Node</span> <span>{</span>
        <span>Key</span> key<span>;</span>
        <span>Value</span> value<span>;</span>
        <span>Node</span> next<span>;</span>

        <span>Node</span><span>(</span><span>Key</span> key<span>,</span> <span>Value</span> value<span>,</span> <span>Node</span> next<span>)</span> <span>{</span>
            <span>this</span><span>.</span>key <span>=</span> key<span>;</span>
            <span>this</span><span>.</span>value <span>=</span> value<span>;</span>
            <span>this</span><span>.</span>next <span>=</span> next<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>int</span> <span>size</span><span>(</span><span>)</span> <span>{</span>
        <span>int</span> cnt <span>=</span> <span>0</span><span>;</span>
        <span>Node</span> cur <span>=</span> first<span>;</span>
        <span>while</span> <span>(</span>cur <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            cnt<span>++</span><span>;</span>
            cur <span>=</span> cur<span>.</span>next<span>;</span>
        <span>}</span>
        <span>return</span> cnt<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>put</span><span>(</span><span>Key</span> key<span>,</span> <span>Value</span> value<span>)</span> <span>{</span>
        <span>Node</span> cur <span>=</span> first<span>;</span>
        <span>// 如果在链表中找到节点的键等于 key 就更新这个节点的值为 value</span>
        <span>while</span> <span>(</span>cur <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>cur<span>.</span>key<span>.</span><span>equals</span><span>(</span>key<span>)</span><span>)</span> <span>{</span>
                cur<span>.</span>value <span>=</span> value<span>;</span>
                <span>return</span><span>;</span>
            <span>}</span>
            cur <span>=</span> cur<span>.</span>next<span>;</span>
        <span>}</span>
        <span>// 否则使用头插法插入一个新节点</span>
        first <span>=</span> <span>new</span> <span>Node</span><span>(</span>key<span>,</span> value<span>,</span> first<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>delete</span><span>(</span><span>Key</span> key<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>first <span>==</span> <span>null</span><span>)</span>
            <span>return</span><span>;</span>
        <span>if</span> <span>(</span>first<span>.</span>key<span>.</span><span>equals</span><span>(</span>key<span>)</span><span>)</span>
            first <span>=</span> first<span>.</span>next<span>;</span>
        <span>Node</span> pre <span>=</span> first<span>,</span> cur <span>=</span> first<span>.</span>next<span>;</span>
        <span>while</span> <span>(</span>cur <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>cur<span>.</span>key<span>.</span><span>equals</span><span>(</span>key<span>)</span><span>)</span> <span>{</span>
                pre<span>.</span>next <span>=</span> cur<span>.</span>next<span>;</span>
                <span>return</span><span>;</span>
            <span>}</span>
            pre <span>=</span> pre<span>.</span>next<span>;</span>
            cur <span>=</span> cur<span>.</span>next<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>Value</span> <span>get</span><span>(</span><span>Key</span> key<span>)</span> <span>{</span>
        <span>Node</span> cur <span>=</span> first<span>;</span>
        <span>while</span> <span>(</span>cur <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>cur<span>.</span>key<span>.</span><span>equals</span><span>(</span>key<span>)</span><span>)</span>
                <span>return</span> cur<span>.</span>value<span>;</span>
            cur <span>=</span> cur<span>.</span>next<span>;</span>
        <span>}</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br></div></div><h2 id="_2-二分查找实现有序符号表" tabindex="-1"> 2. 二分查找实现有序符号表</h2>
<p>使用一对平行数组，一个存储键一个存储值。</p>
<p>二分查找的 rank() 方法至关重要，当键在表中时，它能够知道该键的位置；当键不在表中时，它也能知道在何处插入新键。</p>
<p>二分查找最多需要 logN+1 次比较，使用二分查找实现的符号表的查找操作所需要的时间最多是对数级别的。但是插入操作需要移动数组元素，是线性级别的。</p>
<div><pre><code><span>public</span> <span>class</span> <span>BinarySearchOrderedST</span><span><span>&lt;</span><span>Key</span> <span>extends</span> <span>Comparable</span><span>&lt;</span><span>Key</span><span>></span><span>,</span> <span>Value</span><span>></span></span> <span>implements</span> <span>OrderedST</span><span><span>&lt;</span><span>Key</span><span>,</span> <span>Value</span><span>></span></span> <span>{</span>

    <span>private</span> <span>Key</span><span>[</span><span>]</span> keys<span>;</span>
    <span>private</span> <span>Value</span><span>[</span><span>]</span> values<span>;</span>
    <span>private</span> <span>int</span> <span>N</span> <span>=</span> <span>0</span><span>;</span>

    <span>public</span> <span>BinarySearchOrderedST</span><span>(</span><span>int</span> capacity<span>)</span> <span>{</span>
        keys <span>=</span> <span>(</span><span>Key</span><span>[</span><span>]</span><span>)</span> <span>new</span> <span>Comparable</span><span>[</span>capacity<span>]</span><span>;</span>
        values <span>=</span> <span>(</span><span>Value</span><span>[</span><span>]</span><span>)</span> <span>new</span> <span>Object</span><span>[</span>capacity<span>]</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>int</span> <span>size</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>N</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>int</span> <span>rank</span><span>(</span><span>Key</span> key<span>)</span> <span>{</span>
        <span>int</span> l <span>=</span> <span>0</span><span>,</span> h <span>=</span> <span>N</span> <span>-</span> <span>1</span><span>;</span>
        <span>while</span> <span>(</span>l <span>&lt;=</span> h<span>)</span> <span>{</span>
            <span>int</span> m <span>=</span> l <span>+</span> <span>(</span>h <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
            <span>int</span> cmp <span>=</span> key<span>.</span><span>compareTo</span><span>(</span>keys<span>[</span>m<span>]</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>cmp <span>==</span> <span>0</span><span>)</span>
                <span>return</span> m<span>;</span>
            <span>else</span> <span>if</span> <span>(</span>cmp <span>&lt;</span> <span>0</span><span>)</span>
                h <span>=</span> m <span>-</span> <span>1</span><span>;</span>
            <span>else</span>
                l <span>=</span> m <span>+</span> <span>1</span><span>;</span>
        <span>}</span>
        <span>return</span> l<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>List</span><span><span>&lt;</span><span>Key</span><span>></span></span> <span>keys</span><span>(</span><span>Key</span> l<span>,</span> <span>Key</span> h<span>)</span> <span>{</span>
        <span>int</span> index <span>=</span> <span>rank</span><span>(</span>l<span>)</span><span>;</span>
        <span>List</span><span><span>&lt;</span><span>Key</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>while</span> <span>(</span>keys<span>[</span>index<span>]</span><span>.</span><span>compareTo</span><span>(</span>h<span>)</span> <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>
            list<span>.</span><span>add</span><span>(</span>keys<span>[</span>index<span>]</span><span>)</span><span>;</span>
            index<span>++</span><span>;</span>
        <span>}</span>
        <span>return</span> list<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>put</span><span>(</span><span>Key</span> key<span>,</span> <span>Value</span> value<span>)</span> <span>{</span>
        <span>int</span> index <span>=</span> <span>rank</span><span>(</span>key<span>)</span><span>;</span>
        <span>// 如果找到已经存在的节点键为 key，就更新这个节点的值为 value</span>
        <span>if</span> <span>(</span>index <span>&lt;</span> <span>N</span> <span>&amp;&amp;</span> keys<span>[</span>index<span>]</span><span>.</span><span>compareTo</span><span>(</span>key<span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
            values<span>[</span>index<span>]</span> <span>=</span> value<span>;</span>
            <span>return</span><span>;</span>
        <span>}</span>
        <span>// 否则在数组中插入新的节点，需要先将插入位置之后的元素都向后移动一个位置</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>N</span><span>;</span> j <span>></span> index<span>;</span> j<span>--</span><span>)</span> <span>{</span>
            keys<span>[</span>j<span>]</span> <span>=</span> keys<span>[</span>j <span>-</span> <span>1</span><span>]</span><span>;</span>
            values<span>[</span>j<span>]</span> <span>=</span> values<span>[</span>j <span>-</span> <span>1</span><span>]</span><span>;</span>
        <span>}</span>
        keys<span>[</span>index<span>]</span> <span>=</span> key<span>;</span>
        values<span>[</span>index<span>]</span> <span>=</span> value<span>;</span>
        <span>N</span><span>++</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>Value</span> <span>get</span><span>(</span><span>Key</span> key<span>)</span> <span>{</span>
        <span>int</span> index <span>=</span> <span>rank</span><span>(</span>key<span>)</span><span>;</span>
        <span>if</span> <span>(</span>index <span>&lt;</span> <span>N</span> <span>&amp;&amp;</span> keys<span>[</span>index<span>]</span><span>.</span><span>compareTo</span><span>(</span>key<span>)</span> <span>==</span> <span>0</span><span>)</span>
            <span>return</span> values<span>[</span>index<span>]</span><span>;</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>Key</span> <span>min</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> keys<span>[</span><span>0</span><span>]</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>Key</span> <span>max</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> keys<span>[</span><span>N</span> <span>-</span> <span>1</span><span>]</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br></div></div><h1 id="二叉查找树" tabindex="-1"> 二叉查找树</h1>
<p><strong>二叉树</strong>  是一个空链接，或者是一个有左右两个链接的节点，每个链接都指向一颗子二叉树。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c11528f6-fc71-4a2b-8d2f-51b8954c38f1.jpg" width="180"/> </div><br>
<p><strong>二叉查找树</strong> （BST）是一颗二叉树，并且每个节点的值都大于等于其左子树中的所有节点的值而小于等于右子树的所有节点的值。</p>
<p>BST 有一个重要性质，就是它的中序遍历结果递增排序。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ef552ae3-ae0d-4217-88e6-99cbe8163f0c.jpg" width="200"/> </div><br>
<p>基本数据结构：</p>
<div><pre><code><span>public</span> <span>class</span> <span>BST</span><span><span>&lt;</span><span>Key</span> <span>extends</span> <span>Comparable</span><span>&lt;</span><span>Key</span><span>></span><span>,</span> <span>Value</span><span>></span></span> <span>implements</span> <span>OrderedST</span><span><span>&lt;</span><span>Key</span><span>,</span> <span>Value</span><span>></span></span> <span>{</span>

    <span>protected</span> <span>Node</span> root<span>;</span>

    <span>protected</span> <span>class</span> <span>Node</span> <span>{</span>
        <span>Key</span> key<span>;</span>
        <span>Value</span> val<span>;</span>
        <span>Node</span> left<span>;</span>
        <span>Node</span> right<span>;</span>
        <span>// 以该节点为根的子树节点总数</span>
        <span>int</span> <span>N</span><span>;</span>
        <span>// 红黑树中使用</span>
        <span>boolean</span> color<span>;</span>

        <span>Node</span><span>(</span><span>Key</span> key<span>,</span> <span>Value</span> val<span>,</span> <span>int</span> <span>N</span><span>)</span> <span>{</span>
            <span>this</span><span>.</span>key <span>=</span> key<span>;</span>
            <span>this</span><span>.</span>val <span>=</span> val<span>;</span>
            <span><span>this<span>.</span></span>N</span> <span>=</span> <span>N</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>int</span> <span>size</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>size</span><span>(</span>root<span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>int</span> <span>size</span><span>(</span><span>Node</span> x<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>x <span>==</span> <span>null</span><span>)</span>
            <span>return</span> <span>0</span><span>;</span>
        <span>return</span> <span><span>x<span>.</span></span>N</span><span>;</span>
    <span>}</span>

    <span>protected</span> <span>void</span> <span>recalculateSize</span><span>(</span><span>Node</span> x<span>)</span> <span>{</span>
        <span><span>x<span>.</span></span>N</span> <span>=</span> <span>size</span><span>(</span>x<span>.</span>left<span>)</span> <span>+</span> <span>size</span><span>(</span>x<span>.</span>right<span>)</span> <span>+</span> <span>1</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>为了方便绘图，下文中二叉树的空链接不画出来。</p>
<h2 id="_1-get" tabindex="-1"> 1. get()</h2>
<ul>
<li>如果树是空的，则查找未命中；</li>
<li>如果被查找的键和根节点的键相等，查找命中；</li>
<li>否则递归地在子树中查找：如果被查找的键较小就在左子树中查找，较大就在右子树中查找。</li>
</ul>
<div><pre><code><span>@Override</span>
<span>public</span> <span>Value</span> <span>get</span><span>(</span><span>Key</span> key<span>)</span> <span>{</span>
    <span>return</span> <span>get</span><span>(</span>root<span>,</span> key<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>Value</span> <span>get</span><span>(</span><span>Node</span> x<span>,</span> <span>Key</span> key<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>x <span>==</span> <span>null</span><span>)</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>int</span> cmp <span>=</span> key<span>.</span><span>compareTo</span><span>(</span>x<span>.</span>key<span>)</span><span>;</span>
    <span>if</span> <span>(</span>cmp <span>==</span> <span>0</span><span>)</span>
        <span>return</span> x<span>.</span>val<span>;</span>
    <span>else</span> <span>if</span> <span>(</span>cmp <span>&lt;</span> <span>0</span><span>)</span>
        <span>return</span> <span>get</span><span>(</span>x<span>.</span>left<span>,</span> key<span>)</span><span>;</span>
    <span>else</span>
        <span>return</span> <span>get</span><span>(</span>x<span>.</span>right<span>,</span> key<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="_2-put" tabindex="-1"> 2. put()</h2>
<p>当插入的键不存在于树中，需要创建一个新节点，并且更新上层节点的链接指向该节点，使得该节点正确地链接到树中。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/58b70113-3876-49af-85a9-68eb00a72d59.jpg" width="200"/> </div><br>
<div><pre><code> <span>@Override</span>
<span>public</span> <span>void</span> <span>put</span><span>(</span><span>Key</span> key<span>,</span> <span>Value</span> value<span>)</span> <span>{</span>
    root <span>=</span> <span>put</span><span>(</span>root<span>,</span> key<span>,</span> value<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>Node</span> <span>put</span><span>(</span><span>Node</span> x<span>,</span> <span>Key</span> key<span>,</span> <span>Value</span> value<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>x <span>==</span> <span>null</span><span>)</span>
        <span>return</span> <span>new</span> <span>Node</span><span>(</span>key<span>,</span> value<span>,</span> <span>1</span><span>)</span><span>;</span>
    <span>int</span> cmp <span>=</span> key<span>.</span><span>compareTo</span><span>(</span>x<span>.</span>key<span>)</span><span>;</span>
    <span>if</span> <span>(</span>cmp <span>==</span> <span>0</span><span>)</span>
        x<span>.</span>val <span>=</span> value<span>;</span>
    <span>else</span> <span>if</span> <span>(</span>cmp <span>&lt;</span> <span>0</span><span>)</span>
        x<span>.</span>left <span>=</span> <span>put</span><span>(</span>x<span>.</span>left<span>,</span> key<span>,</span> value<span>)</span><span>;</span>
    <span>else</span>
        x<span>.</span>right <span>=</span> <span>put</span><span>(</span>x<span>.</span>right<span>,</span> key<span>,</span> value<span>)</span><span>;</span>
    <span>recalculateSize</span><span>(</span>x<span>)</span><span>;</span>
    <span>return</span> x<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id="_3-分析" tabindex="-1"> 3. 分析</h2>
<p>二叉查找树的算法运行时间取决于树的形状，而树的形状又取决于键被插入的先后顺序。</p>
<p>最好的情况下树是完全平衡的，每条空链接和根节点的距离都为 logN。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c395a428-827c-405b-abd7-8a069316f583.jpg" width="200"/> </div><br>
<p>在最坏的情况下，树的高度为 N。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5ea609cb-8ad4-4c4c-aee6-45a40a81794a.jpg" width="200"/> </div><br>
<h2 id="_4-floor" tabindex="-1"> 4. floor()</h2>
<p>floor(key)：小于等于键的最大键</p>
<ul>
<li>如果键小于根节点的键，那么 floor(key) 一定在左子树中；</li>
<li>如果键大于根节点的键，需要先判断右子树中是否存在 floor(key)，如果存在就返回，否则根节点就是 floor(key)。</li>
</ul>
<div><pre><code><span>public</span> <span>Key</span> <span>floor</span><span>(</span><span>Key</span> key<span>)</span> <span>{</span>
    <span>Node</span> x <span>=</span> <span>floor</span><span>(</span>root<span>,</span> key<span>)</span><span>;</span>
    <span>if</span> <span>(</span>x <span>==</span> <span>null</span><span>)</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>return</span> x<span>.</span>key<span>;</span>
<span>}</span>

<span>private</span> <span>Node</span> <span>floor</span><span>(</span><span>Node</span> x<span>,</span> <span>Key</span> key<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>x <span>==</span> <span>null</span><span>)</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>int</span> cmp <span>=</span> key<span>.</span><span>compareTo</span><span>(</span>x<span>.</span>key<span>)</span><span>;</span>
    <span>if</span> <span>(</span>cmp <span>==</span> <span>0</span><span>)</span>
        <span>return</span> x<span>;</span>
    <span>if</span> <span>(</span>cmp <span>&lt;</span> <span>0</span><span>)</span>
        <span>return</span> <span>floor</span><span>(</span>x<span>.</span>left<span>,</span> key<span>)</span><span>;</span>
    <span>Node</span> t <span>=</span> <span>floor</span><span>(</span>x<span>.</span>right<span>,</span> key<span>)</span><span>;</span>
    <span>return</span> t <span>!=</span> <span>null</span> <span>?</span> t <span>:</span> x<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id="_5-rank" tabindex="-1"> 5. rank()</h2>
<p>rank(key) 返回 key 的排名。</p>
<ul>
<li>如果键和根节点的键相等，返回左子树的节点数；</li>
<li>如果小于，递归计算在左子树中的排名；</li>
<li>如果大于，递归计算在右子树中的排名，加上左子树的节点数，再加上 1（根节点）。</li>
</ul>
<div><pre><code><span>@Override</span>
<span>public</span> <span>int</span> <span>rank</span><span>(</span><span>Key</span> key<span>)</span> <span>{</span>
    <span>return</span> <span>rank</span><span>(</span>key<span>,</span> root<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>int</span> <span>rank</span><span>(</span><span>Key</span> key<span>,</span> <span>Node</span> x<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>x <span>==</span> <span>null</span><span>)</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>int</span> cmp <span>=</span> key<span>.</span><span>compareTo</span><span>(</span>x<span>.</span>key<span>)</span><span>;</span>
    <span>if</span> <span>(</span>cmp <span>==</span> <span>0</span><span>)</span>
        <span>return</span> <span>size</span><span>(</span>x<span>.</span>left<span>)</span><span>;</span>
    <span>else</span> <span>if</span> <span>(</span>cmp <span>&lt;</span> <span>0</span><span>)</span>
        <span>return</span> <span>rank</span><span>(</span>key<span>,</span> x<span>.</span>left<span>)</span><span>;</span>
    <span>else</span>
        <span>return</span> <span>1</span> <span>+</span> <span>size</span><span>(</span>x<span>.</span>left<span>)</span> <span>+</span> <span>rank</span><span>(</span>key<span>,</span> x<span>.</span>right<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="_6-min" tabindex="-1"> 6. min()</h2>
<div><pre><code><span>@Override</span>
<span>public</span> <span>Key</span> <span>min</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>min</span><span>(</span>root<span>)</span><span>.</span>key<span>;</span>
<span>}</span>

<span>private</span> <span>Node</span> <span>min</span><span>(</span><span>Node</span> x<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>x <span>==</span> <span>null</span><span>)</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>if</span> <span>(</span>x<span>.</span>left <span>==</span> <span>null</span><span>)</span>
        <span>return</span> x<span>;</span>
    <span>return</span> <span>min</span><span>(</span>x<span>.</span>left<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="_7-deletemin" tabindex="-1"> 7. deleteMin()</h2>
<p>令指向最小节点的链接指向最小节点的右子树。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/31b7e8de-ed11-4f69-b5fd-ba454120ac31.jpg" width="450"/> </div><br>
<div><pre><code><span>public</span> <span>void</span> <span>deleteMin</span><span>(</span><span>)</span> <span>{</span>
    root <span>=</span> <span>deleteMin</span><span>(</span>root<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>Node</span> <span>deleteMin</span><span>(</span><span>Node</span> x<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>x<span>.</span>left <span>==</span> <span>null</span><span>)</span>
        <span>return</span> x<span>.</span>right<span>;</span>
    x<span>.</span>left <span>=</span> <span>deleteMin</span><span>(</span>x<span>.</span>left<span>)</span><span>;</span>
    <span>recalculateSize</span><span>(</span>x<span>)</span><span>;</span>
    <span>return</span> x<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="_8-delete" tabindex="-1"> 8. delete()</h2>
<ul>
<li>如果待删除的节点只有一个子树，  那么只需要让指向待删除节点的链接指向唯一的子树即可；</li>
<li>否则，让右子树的最小节点替换该节点。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23b9d625-ef28-42b5-bb22-d7aedd007e16.jpg" width="400"/> </div><br>
<div><pre><code><span>public</span> <span>void</span> <span>delete</span><span>(</span><span>Key</span> key<span>)</span> <span>{</span>
    root <span>=</span> <span>delete</span><span>(</span>root<span>,</span> key<span>)</span><span>;</span>
<span>}</span>
<span>private</span> <span>Node</span> <span>delete</span><span>(</span><span>Node</span> x<span>,</span> <span>Key</span> key<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>x <span>==</span> <span>null</span><span>)</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>int</span> cmp <span>=</span> key<span>.</span><span>compareTo</span><span>(</span>x<span>.</span>key<span>)</span><span>;</span>
    <span>if</span> <span>(</span>cmp <span>&lt;</span> <span>0</span><span>)</span>
        x<span>.</span>left <span>=</span> <span>delete</span><span>(</span>x<span>.</span>left<span>,</span> key<span>)</span><span>;</span>
    <span>else</span> <span>if</span> <span>(</span>cmp <span>></span> <span>0</span><span>)</span>
        x<span>.</span>right <span>=</span> <span>delete</span><span>(</span>x<span>.</span>right<span>,</span> key<span>)</span><span>;</span>
    <span>else</span> <span>{</span>
        <span>if</span> <span>(</span>x<span>.</span>right <span>==</span> <span>null</span><span>)</span>
            <span>return</span> x<span>.</span>left<span>;</span>
        <span>if</span> <span>(</span>x<span>.</span>left <span>==</span> <span>null</span><span>)</span>
            <span>return</span> x<span>.</span>right<span>;</span>
        <span>Node</span> t <span>=</span> x<span>;</span>
        x <span>=</span> <span>min</span><span>(</span>t<span>.</span>right<span>)</span><span>;</span>
        x<span>.</span>right <span>=</span> <span>deleteMin</span><span>(</span>t<span>.</span>right<span>)</span><span>;</span>
        x<span>.</span>left <span>=</span> t<span>.</span>left<span>;</span>
    <span>}</span>
    <span>recalculateSize</span><span>(</span>x<span>)</span><span>;</span>
    <span>return</span> x<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h2 id="_9-keys" tabindex="-1"> 9. keys()</h2>
<p>利用二叉查找树中序遍历的结果为递增的特点。</p>
<div><pre><code><span>@Override</span>
<span>public</span> <span>List</span><span><span>&lt;</span><span>Key</span><span>></span></span> <span>keys</span><span>(</span><span>Key</span> l<span>,</span> <span>Key</span> h<span>)</span> <span>{</span>
    <span>return</span> <span>keys</span><span>(</span>root<span>,</span> l<span>,</span> h<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>List</span><span><span>&lt;</span><span>Key</span><span>></span></span> <span>keys</span><span>(</span><span>Node</span> x<span>,</span> <span>Key</span> l<span>,</span> <span>Key</span> h<span>)</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>Key</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>x <span>==</span> <span>null</span><span>)</span>
        <span>return</span> list<span>;</span>
    <span>int</span> cmpL <span>=</span> l<span>.</span><span>compareTo</span><span>(</span>x<span>.</span>key<span>)</span><span>;</span>
    <span>int</span> cmpH <span>=</span> h<span>.</span><span>compareTo</span><span>(</span>x<span>.</span>key<span>)</span><span>;</span>
    <span>if</span> <span>(</span>cmpL <span>&lt;</span> <span>0</span><span>)</span>
        list<span>.</span><span>addAll</span><span>(</span><span>keys</span><span>(</span>x<span>.</span>left<span>,</span> l<span>,</span> h<span>)</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>cmpL <span>&lt;=</span> <span>0</span> <span>&amp;&amp;</span> cmpH <span>>=</span> <span>0</span><span>)</span>
        list<span>.</span><span>add</span><span>(</span>x<span>.</span>key<span>)</span><span>;</span>
    <span>if</span> <span>(</span>cmpH <span>></span> <span>0</span><span>)</span>
        list<span>.</span><span>addAll</span><span>(</span><span>keys</span><span>(</span>x<span>.</span>right<span>,</span> l<span>,</span> h<span>)</span><span>)</span><span>;</span>
    <span>return</span> list<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="_10-分析" tabindex="-1"> 10. 分析</h2>
<p>二叉查找树所有操作在最坏的情况下所需要的时间都和树的高度成正比。</p>
<h1 id="_2-3-查找树" tabindex="-1"> 2-3 查找树</h1>
<p>2-3 查找树引入了 2- 节点和 3- 节点，目的是为了让树平衡。一颗完美平衡的 2-3 查找树的所有空链接到根节点的距离应该是相同的。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1097658b-c0e6-4821-be9b-25304726a11c.jpg" width="160px"/> </div><br>
<h2 id="_1-插入操作" tabindex="-1"> 1. 插入操作</h2>
<p>插入操作和 BST 的插入操作有很大区别，BST 的插入操作是先进行一次未命中的查找，然后再将节点插入到对应的空链接上。但是 2-3 查找树如果也这么做的话，那么就会破坏了平衡性。它是将新节点插入到叶子节点上。</p>
<p>根据叶子节点的类型不同，有不同的处理方式：</p>
<ul>
<li>如果插入到 2- 节点上，那么直接将新节点和原来的节点组成 3- 节点即可。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0c6f9930-8704-4a54-af23-19f9ca3e48b0.jpg" width="350"/> </div><br>
<ul>
<li>如果是插入到 3- 节点上，就会产生一个临时 4- 节点时，需要将 4- 节点分裂成 3 个 2- 节点，并将中间的 2- 节点移到上层节点中。如果上移操作继续产生临时 4- 节点则一直进行分裂上移，直到不存在临时 4- 节点。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7002c01b-1ed5-475a-9e5f-5fc8a4cdbcc0.jpg" width="460"/> </div><br>
<h2 id="_2-性质" tabindex="-1"> 2. 性质</h2>
<p>2-3 查找树插入操作的变换都是局部的，除了相关的节点和链接之外不必修改或者检查树的其它部分，而这些局部变换不会影响树的全局有序性和平衡性。</p>
<p>2-3 查找树的查找和插入操作复杂度和插入顺序无关，在最坏的情况下查找和插入操作访问的节点必然不超过 logN 个，含有 10 亿个节点的 2-3 查找树最多只需要访问 30 个节点就能进行任意的查找和插入操作。</p>
<h1 id="红黑树" tabindex="-1"> 红黑树</h1>
<p>红黑树是 2-3 查找树，但它不需要分别定义 2- 节点和 3- 节点，而是在普通的二叉查找树之上，为节点添加颜色。指向一个节点的链接颜色如果为红色，那么这个节点和上层节点表示的是一个 3- 节点，而黑色则是普通链接。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f1912ba6-6402-4321-9aa8-13d32fd121d1.jpg" width="240"/> </div><br>
<p>红黑树具有以下性质：</p>
<ul>
<li>红链接都为左链接；</li>
<li>完美黑色平衡，即任意空链接到根节点的路径上的黑链接数量相同。</li>
</ul>
<p>画红黑树时可以将红链接画平。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f5cb6028-425d-4939-91eb-cca9dd6b6c6c.jpg" width="220"/> </div><br>
<div><pre><code><span>public</span> <span>class</span> <span>RedBlackBST</span><span><span>&lt;</span><span>Key</span> <span>extends</span> <span>Comparable</span><span>&lt;</span><span>Key</span><span>></span><span>,</span> <span>Value</span><span>></span></span> <span>extends</span> <span>BST</span><span><span>&lt;</span><span>Key</span><span>,</span> <span>Value</span><span>></span></span> <span>{</span>

    <span>private</span> <span>static</span> <span>final</span> <span>boolean</span> RED <span>=</span> <span>true</span><span>;</span>
    <span>private</span> <span>static</span> <span>final</span> <span>boolean</span> BLACK <span>=</span> <span>false</span><span>;</span>

    <span>private</span> <span>boolean</span> <span>isRed</span><span>(</span><span>Node</span> x<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>x <span>==</span> <span>null</span><span>)</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>return</span> x<span>.</span>color <span>==</span> RED<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="_1-左旋转" tabindex="-1"> 1. 左旋转</h2>
<p>因为合法的红链接都为左链接，如果出现右链接为红链接，那么就需要进行左旋转操作。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f4d534ab-0092-4a81-9e5b-ae889b9a72be.jpg" width="480"/> </div><br>
<div><pre><code><span>public</span> <span>Node</span> <span>rotateLeft</span><span>(</span><span>Node</span> h<span>)</span> <span>{</span>
    <span>Node</span> x <span>=</span> h<span>.</span>right<span>;</span>
    h<span>.</span>right <span>=</span> x<span>.</span>left<span>;</span>
    x<span>.</span>left <span>=</span> h<span>;</span>
    x<span>.</span>color <span>=</span> h<span>.</span>color<span>;</span>
    h<span>.</span>color <span>=</span> RED<span>;</span>
    <span><span>x<span>.</span></span>N</span> <span>=</span> <span><span>h<span>.</span></span>N</span><span>;</span>
    <span>recalculateSize</span><span>(</span>h<span>)</span><span>;</span>
    <span>return</span> x<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="_2-右旋转" tabindex="-1"> 2. 右旋转</h2>
<p>进行右旋转是为了转换两个连续的左红链接，这会在之后的插入过程中探讨。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/63c8ffea-a9f2-4ebe-97d1-d71be71246f9.jpg" width="480"/> </div><br>
<div><pre><code><span>public</span> <span>Node</span> <span>rotateRight</span><span>(</span><span>Node</span> h<span>)</span> <span>{</span>
    <span>Node</span> x <span>=</span> h<span>.</span>left<span>;</span>
    h<span>.</span>left <span>=</span> x<span>.</span>right<span>;</span>
    x<span>.</span>right <span>=</span> h<span>;</span>
    x<span>.</span>color <span>=</span> h<span>.</span>color<span>;</span>
    h<span>.</span>color <span>=</span> RED<span>;</span>
    <span><span>x<span>.</span></span>N</span> <span>=</span> <span><span>h<span>.</span></span>N</span><span>;</span>
    <span>recalculateSize</span><span>(</span>h<span>)</span><span>;</span>
    <span>return</span> x<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="_3-颜色转换" tabindex="-1"> 3. 颜色转换</h2>
<p>一个 4- 节点在红黑树中表现为一个节点的左右子节点都是红色的。分裂 4- 节点除了需要将子节点的颜色由红变黑之外，同时需要将父节点的颜色由黑变红，从 2-3 树的角度看就是将中间节点移到上层节点。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/094b279a-b2db-4be7-87a3-b2a039c7448e.jpg" width="270"/> </div><br>
<div><pre><code><span>void</span> <span>flipColors</span><span>(</span><span>Node</span> h<span>)</span> <span>{</span>
    h<span>.</span>color <span>=</span> RED<span>;</span>
    h<span>.</span>left<span>.</span>color <span>=</span> BLACK<span>;</span>
    h<span>.</span>right<span>.</span>color <span>=</span> BLACK<span>;</span>
<span>}</span>
</code></pre></div><h2 id="_4-插入" tabindex="-1"> 4. 插入</h2>
<p>先将一个节点按二叉查找树的方法插入到正确位置，然后再进行如下颜色操作：</p>
<ul>
<li>如果右子节点是红色的而左子节点是黑色的，进行左旋转；</li>
<li>如果左子节点是红色的，而且左子节点的左子节点也是红色的，进行右旋转；</li>
<li>如果左右子节点均为红色的，进行颜色转换。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4c457532-550b-4eca-b881-037b84b4934b.jpg" width="430"/> </div><br>
<div><pre><code><span>@Override</span>
<span>public</span> <span>void</span> <span>put</span><span>(</span><span>Key</span> key<span>,</span> <span>Value</span> value<span>)</span> <span>{</span>
    root <span>=</span> <span>put</span><span>(</span>root<span>,</span> key<span>,</span> value<span>)</span><span>;</span>
    root<span>.</span>color <span>=</span> BLACK<span>;</span>
<span>}</span>

<span>private</span> <span>Node</span> <span>put</span><span>(</span><span>Node</span> x<span>,</span> <span>Key</span> key<span>,</span> <span>Value</span> value<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>x <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>Node</span> node <span>=</span> <span>new</span> <span>Node</span><span>(</span>key<span>,</span> value<span>,</span> <span>1</span><span>)</span><span>;</span>
        node<span>.</span>color <span>=</span> RED<span>;</span>
        <span>return</span> node<span>;</span>
    <span>}</span>
    <span>int</span> cmp <span>=</span> key<span>.</span><span>compareTo</span><span>(</span>x<span>.</span>key<span>)</span><span>;</span>
    <span>if</span> <span>(</span>cmp <span>==</span> <span>0</span><span>)</span>
        x<span>.</span>val <span>=</span> value<span>;</span>
    <span>else</span> <span>if</span> <span>(</span>cmp <span>&lt;</span> <span>0</span><span>)</span>
        x<span>.</span>left <span>=</span> <span>put</span><span>(</span>x<span>.</span>left<span>,</span> key<span>,</span> value<span>)</span><span>;</span>
    <span>else</span>
        x<span>.</span>right <span>=</span> <span>put</span><span>(</span>x<span>.</span>right<span>,</span> key<span>,</span> value<span>)</span><span>;</span>

    <span>if</span> <span>(</span><span>isRed</span><span>(</span>x<span>.</span>right<span>)</span> <span>&amp;&amp;</span> <span>!</span><span>isRed</span><span>(</span>x<span>.</span>left<span>)</span><span>)</span>
        x <span>=</span> <span>rotateLeft</span><span>(</span>x<span>)</span><span>;</span>
    <span>if</span> <span>(</span><span>isRed</span><span>(</span>x<span>.</span>left<span>)</span> <span>&amp;&amp;</span> <span>isRed</span><span>(</span>x<span>.</span>left<span>.</span>left<span>)</span><span>)</span>
        x <span>=</span> <span>rotateRight</span><span>(</span>x<span>)</span><span>;</span>
    <span>if</span> <span>(</span><span>isRed</span><span>(</span>x<span>.</span>left<span>)</span> <span>&amp;&amp;</span> <span>isRed</span><span>(</span>x<span>.</span>right<span>)</span><span>)</span>
        <span>flipColors</span><span>(</span>x<span>)</span><span>;</span>

    <span>recalculateSize</span><span>(</span>x<span>)</span><span>;</span>
    <span>return</span> x<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>可以看到该插入操作和二叉查找树的插入操作类似，只是在最后加入了旋转和颜色变换操作即可。</p>
<p>根节点一定为黑色，因为根节点没有上层节点，也就没有上层节点的左链接指向根节点。flipColors() 有可能会使得根节点的颜色变为红色，每当根节点由红色变成黑色时树的黑链接高度加 1.</p>
<h2 id="_5-分析" tabindex="-1"> 5. 分析</h2>
<p>一颗大小为 N 的红黑树的高度不会超过 2logN。最坏的情况下是它所对应的 2-3 树，构成最左边的路径节点全部都是 3- 节点而其余都是 2- 节点。</p>
<p>红黑树大多数的操作所需要的时间都是对数级别的。</p>
<h1 id="散列表" tabindex="-1"> 散列表</h1>
<p>散列表类似于数组，可以把散列表的散列值看成数组的索引值。访问散列表和访问数组元素一样快速，它可以在常数时间内实现查找和插入操作。</p>
<p>由于无法通过散列值知道键的大小关系，因此散列表无法实现有序性操作。</p>
<h2 id="_1-散列函数" tabindex="-1"> 1. 散列函数</h2>
<p>对于一个大小为 M 的散列表，散列函数能够把任意键转换为 [0, M-1] 内的正整数，该正整数即为 hash 值。</p>
<p>散列表存在冲突，也就是两个不同的键可能有相同的 hash 值。</p>
<p>散列函数应该满足以下三个条件：</p>
<ul>
<li>一致性：相等的键应当有相等的 hash 值，两个键相等表示调用 equals() 返回的值相等。</li>
<li>高效性：计算应当简便，有必要的话可以把 hash 值缓存起来，在调用 hash 函数时直接返回。</li>
<li>均匀性：所有键的 hash 值应当均匀地分布到 [0, M-1] 之间，如果不能满足这个条件，有可能产生很多冲突，从而导致散列表的性能下降。</li>
</ul>
<p>除留余数法可以将整数散列到 [0, M-1] 之间，例如一个正整数 k，计算 k%M 既可得到一个 [0, M-1] 之间的 hash 值。注意 M 最好是一个素数，否则无法利用键包含的所有信息。例如 M 为 10<sup>k</sup>，那么只能利用键的后 k 位。</p>
<p>对于其它数，可以将其转换成整数的形式，然后利用除留余数法。例如对于浮点数，可以将其的二进制形式转换成整数。</p>
<p>对于多部分组合的类型，每个部分都需要计算 hash 值，这些 hash 值都具有同等重要的地位。为了达到这个目的，可以将该类型看成 R 进制的整数，每个部分都具有不同的权值。</p>
<p>例如，字符串的散列函数实现如下：</p>
<div><pre><code><span>int</span> hash <span>=</span> <span>0</span><span>;</span>
<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span>
    hash <span>=</span> <span>(</span><span>R</span> <span>*</span> hash <span>+</span> s<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>)</span> <span>%</span> <span>M</span><span>;</span>
</code></pre></div><p>再比如，拥有多个成员的自定义类的哈希函数如下：</p>
<div><pre><code><span>int</span> hash <span>=</span> <span>(</span><span>(</span><span>(</span>day <span>*</span> <span>R</span> <span>+</span> month<span>)</span> <span>%</span> <span>M</span><span>)</span> <span>*</span> <span>R</span> <span>+</span> year<span>)</span> <span>%</span> <span>M</span><span>;</span>
</code></pre></div><p>R 通常取 31。</p>
<p>Java 中的 hashCode() 实现了哈希函数，但是默认使用对象的内存地址值。在使用 hashCode() 时，应当结合除留余数法来使用。因为内存地址是 32 位整数，我们只需要 31 位的非负整数，因此应当屏蔽符号位之后再使用除留余数法。</p>
<div><pre><code><span>int</span> hash <span>=</span> <span>(</span>x<span>.</span><span>hashCode</span><span>(</span><span>)</span> <span>&amp;</span> <span>0x7fffffff</span><span>)</span> <span>%</span> <span>M</span><span>;</span>
</code></pre></div><p>使用 Java 的 HashMap 等自带的哈希表实现时，只需要去实现 Key 类型的 hashCode() 函数即可。Java 规定 hashCode() 能够将键均匀分布于所有的 32 位整数，Java 中的 String、Integer 等对象的 hashCode() 都能实现这一点。以下展示了自定义类型如何实现 hashCode()：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Transaction</span> <span>{</span>

    <span>private</span> <span>final</span> <span>String</span> who<span>;</span>
    <span>private</span> <span>final</span> <span>Date</span> when<span>;</span>
    <span>private</span> <span>final</span> <span>double</span> amount<span>;</span>

    <span>public</span> <span>Transaction</span><span>(</span><span>String</span> who<span>,</span> <span>Date</span> when<span>,</span> <span>double</span> amount<span>)</span> <span>{</span>
        <span>this</span><span>.</span>who <span>=</span> who<span>;</span>
        <span>this</span><span>.</span>when <span>=</span> when<span>;</span>
        <span>this</span><span>.</span>amount <span>=</span> amount<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>hashCode</span><span>(</span><span>)</span> <span>{</span>
        <span>int</span> hash <span>=</span> <span>17</span><span>;</span>
        <span>int</span> <span>R</span> <span>=</span> <span>31</span><span>;</span>
        hash <span>=</span> <span>R</span> <span>*</span> hash <span>+</span> who<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>;</span>
        hash <span>=</span> <span>R</span> <span>*</span> hash <span>+</span> when<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>;</span>
        hash <span>=</span> <span>R</span> <span>*</span> hash <span>+</span> <span>(</span><span>(</span><span>Double</span><span>)</span> amount<span>)</span><span>.</span><span>hashCode</span><span>(</span><span>)</span><span>;</span>
        <span>return</span> hash<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id="_2-拉链法" tabindex="-1"> 2. 拉链法</h2>
<p>拉链法使用链表来存储 hash 值相同的键，从而解决冲突。</p>
<p>查找需要分两步，首先查找 Key 所在的链表，然后在链表中顺序查找。</p>
<p>对于 N 个键，M 条链表 (N&gt;M)，如果哈希函数能够满足均匀性的条件，每条链表的大小趋向于 N/M，因此未命中的查找和插入操作所需要的比较次数为 ~N/M。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cbbfe06c-f0cb-47c4-bf7b-2780aebd98b2.png" width="330px"> </div><br>
<h2 id="_3-线性探测法" tabindex="-1"> 3. 线性探测法</h2>
<p>线性探测法使用空位来解决冲突，当冲突发生时，向前探测一个空位来存储冲突的键。</p>
<p>使用线性探测法，数组的大小 M 应当大于键的个数 N（M&gt;N)。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0dbc4f7d-05c9-4aae-8065-7b7ea7e9709e.gif" width="350px"> </div><br>
<div><pre><code><span>public</span> <span>class</span> <span>LinearProbingHashST</span><span><span>&lt;</span><span>Key</span><span>,</span> <span>Value</span><span>></span></span> <span>implements</span> <span>UnorderedST</span><span><span>&lt;</span><span>Key</span><span>,</span> <span>Value</span><span>></span></span> <span>{</span>

    <span>private</span> <span>int</span> <span>N</span> <span>=</span> <span>0</span><span>;</span>
    <span>private</span> <span>int</span> <span>M</span> <span>=</span> <span>16</span><span>;</span>
    <span>private</span> <span>Key</span><span>[</span><span>]</span> keys<span>;</span>
    <span>private</span> <span>Value</span><span>[</span><span>]</span> values<span>;</span>

    <span>public</span> <span>LinearProbingHashST</span><span>(</span><span>)</span> <span>{</span>
        <span>init</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>LinearProbingHashST</span><span>(</span><span>int</span> <span>M</span><span>)</span> <span>{</span>
        <span><span>this<span>.</span></span>M</span> <span>=</span> <span>M</span><span>;</span>
        <span>init</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>init</span><span>(</span><span>)</span> <span>{</span>
        keys <span>=</span> <span>(</span><span>Key</span><span>[</span><span>]</span><span>)</span> <span>new</span> <span>Object</span><span>[</span><span>M</span><span>]</span><span>;</span>
        values <span>=</span> <span>(</span><span>Value</span><span>[</span><span>]</span><span>)</span> <span>new</span> <span>Object</span><span>[</span><span>M</span><span>]</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>int</span> <span>hash</span><span>(</span><span>Key</span> key<span>)</span> <span>{</span>
        <span>return</span> <span>(</span>key<span>.</span><span>hashCode</span><span>(</span><span>)</span> <span>&amp;</span> <span>0x7fffffff</span><span>)</span> <span>%</span> <span>M</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h4 id="_3-1-查找" tabindex="-1"> 3.1 查找</h4>
<div><pre><code><span>public</span> <span>Value</span> <span>get</span><span>(</span><span>Key</span> key<span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>hash</span><span>(</span>key<span>)</span><span>;</span> keys<span>[</span>i<span>]</span> <span>!=</span> <span>null</span><span>;</span> i <span>=</span> <span>(</span>i <span>+</span> <span>1</span><span>)</span> <span>%</span> <span>M</span><span>)</span>
        <span>if</span> <span>(</span>keys<span>[</span>i<span>]</span><span>.</span><span>equals</span><span>(</span>key<span>)</span><span>)</span>
            <span>return</span> values<span>[</span>i<span>]</span><span>;</span>

    <span>return</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre></div><h4 id="_3-2-插入" tabindex="-1"> 3.2 插入</h4>
<div><pre><code><span>public</span> <span>void</span> <span>put</span><span>(</span><span>Key</span> key<span>,</span> <span>Value</span> value<span>)</span> <span>{</span>
    <span>resize</span><span>(</span><span>)</span><span>;</span>
    <span>putInternal</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>putInternal</span><span>(</span><span>Key</span> key<span>,</span> <span>Value</span> value<span>)</span> <span>{</span>
    <span>int</span> i<span>;</span>
    <span>for</span> <span>(</span>i <span>=</span> <span>hash</span><span>(</span>key<span>)</span><span>;</span> keys<span>[</span>i<span>]</span> <span>!=</span> <span>null</span><span>;</span> i <span>=</span> <span>(</span>i <span>+</span> <span>1</span><span>)</span> <span>%</span> <span>M</span><span>)</span>
        <span>if</span> <span>(</span>keys<span>[</span>i<span>]</span><span>.</span><span>equals</span><span>(</span>key<span>)</span><span>)</span> <span>{</span>
            values<span>[</span>i<span>]</span> <span>=</span> value<span>;</span>
            <span>return</span><span>;</span>
        <span>}</span>

    keys<span>[</span>i<span>]</span> <span>=</span> key<span>;</span>
    values<span>[</span>i<span>]</span> <span>=</span> value<span>;</span>
    <span>N</span><span>++</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h4 id="_3-3-删除" tabindex="-1"> 3.3 删除</h4>
<p>删除操作应当将右侧所有相邻的键值对重新插入散列表中。</p>
<div><pre><code><span>public</span> <span>void</span> <span>delete</span><span>(</span><span>Key</span> key<span>)</span> <span>{</span>
    <span>int</span> i <span>=</span> <span>hash</span><span>(</span>key<span>)</span><span>;</span>
    <span>while</span> <span>(</span>keys<span>[</span>i<span>]</span> <span>!=</span> <span>null</span> <span>&amp;&amp;</span> <span>!</span>key<span>.</span><span>equals</span><span>(</span>keys<span>[</span>i<span>]</span><span>)</span><span>)</span>
        i <span>=</span> <span>(</span>i <span>+</span> <span>1</span><span>)</span> <span>%</span> <span>M</span><span>;</span>

    <span>// 不存在，直接返回</span>
    <span>if</span> <span>(</span>keys<span>[</span>i<span>]</span> <span>==</span> <span>null</span><span>)</span>
        <span>return</span><span>;</span>

    keys<span>[</span>i<span>]</span> <span>=</span> <span>null</span><span>;</span>
    values<span>[</span>i<span>]</span> <span>=</span> <span>null</span><span>;</span>

    <span>// 将之后相连的键值对重新插入</span>
    i <span>=</span> <span>(</span>i <span>+</span> <span>1</span><span>)</span> <span>%</span> <span>M</span><span>;</span>
    <span>while</span> <span>(</span>keys<span>[</span>i<span>]</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>Key</span> keyToRedo <span>=</span> keys<span>[</span>i<span>]</span><span>;</span>
        <span>Value</span> valToRedo <span>=</span> values<span>[</span>i<span>]</span><span>;</span>
        keys<span>[</span>i<span>]</span> <span>=</span> <span>null</span><span>;</span>
        values<span>[</span>i<span>]</span> <span>=</span> <span>null</span><span>;</span>
        <span>N</span><span>--</span><span>;</span>
        <span>putInternal</span><span>(</span>keyToRedo<span>,</span> valToRedo<span>)</span><span>;</span>
        i <span>=</span> <span>(</span>i <span>+</span> <span>1</span><span>)</span> <span>%</span> <span>M</span><span>;</span>
    <span>}</span>
    <span>N</span><span>--</span><span>;</span>
    <span>resize</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h4 id="_3-5-调整数组大小" tabindex="-1"> 3.5 调整数组大小</h4>
<p>线性探测法的成本取决于连续条目的长度，连续条目也叫聚簇。当聚簇很长时，在查找和插入时也需要进行很多次探测。例如下图中 2~4 位置就是一个聚簇。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ace20410-f053-4c4a-aca4-2c603ff11bbe.png" width="340px"> </div><br>
<p>α = N/M，把 α 称为使用率。理论证明，当 α 小于 1/2 时探测的预计次数只在 1.5 到 2.5 之间。为了保证散列表的性能，应当调整数组的大小，使得 α 在 [1/4, 1/2] 之间。</p>
<div><pre><code><span>private</span> <span>void</span> <span>resize</span><span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>N</span> <span>>=</span> <span>M</span> <span>/</span> <span>2</span><span>)</span>
        <span>resize</span><span>(</span><span>2</span> <span>*</span> <span>M</span><span>)</span><span>;</span>
    <span>else</span> <span>if</span> <span>(</span><span>N</span> <span>&lt;=</span> <span>M</span> <span>/</span> <span>8</span><span>)</span>
        <span>resize</span><span>(</span><span>M</span> <span>/</span> <span>2</span><span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>resize</span><span>(</span><span>int</span> cap<span>)</span> <span>{</span>
    <span>LinearProbingHashST</span><span><span>&lt;</span><span>Key</span><span>,</span> <span>Value</span><span>></span></span> t <span>=</span> <span>new</span> <span>LinearProbingHashST</span><span><span>&lt;</span><span>Key</span><span>,</span> <span>Value</span><span>></span></span><span>(</span>cap<span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>M</span><span>;</span> i<span>++</span><span>)</span>
        <span>if</span> <span>(</span>keys<span>[</span>i<span>]</span> <span>!=</span> <span>null</span><span>)</span>
            t<span>.</span><span>putInternal</span><span>(</span>keys<span>[</span>i<span>]</span><span>,</span> values<span>[</span>i<span>]</span><span>)</span><span>;</span>

    keys <span>=</span> t<span>.</span>keys<span>;</span>
    values <span>=</span> t<span>.</span>values<span>;</span>
    <span>M</span> <span>=</span> <span><span>t<span>.</span></span>M</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h1 id="小结" tabindex="-1"> 小结</h1>
<h2 id="_1-符号表算法比较" tabindex="-1"> 1. 符号表算法比较</h2>
<table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th style="text-align:center">插入</th>
<th style="text-align:center">查找</th>
<th style="text-align:center">是否有序</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">链表实现的无序符号表</td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">二分查找实现的有序符号表</td>
<td style="text-align:center">N</td>
<td style="text-align:center">logN</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">二叉查找树</td>
<td style="text-align:center">logN</td>
<td style="text-align:center">logN</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">2-3 查找树</td>
<td style="text-align:center">logN</td>
<td style="text-align:center">logN</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">拉链法实现的散列表</td>
<td style="text-align:center">N/M</td>
<td style="text-align:center">N/M</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center">线性探测法实现的散列表</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">no</td>
</tr>
</tbody>
</table>
<p>应当优先考虑散列表，当需要有序性操作时使用红黑树。</p>
<h2 id="_2-java-的符号表实现" tabindex="-1"> 2. Java 的符号表实现</h2>
<ul>
<li>java.util.TreeMap：红黑树</li>
<li>java.util.HashMap：拉链法的散列表</li>
</ul>
<h2 id="_3-稀疏向量乘法" tabindex="-1"> 3. 稀疏向量乘法</h2>
<p>当向量为稀疏向量时，可以使用符号表来存储向量中的非 0 索引和值，使得乘法运算只需要对那些非 0 元素进行即可。</p>
<div><pre><code><span>public</span> <span>class</span> <span>SparseVector</span> <span>{</span>
    <span>private</span> <span>HashMap</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Double</span><span>></span></span> hashMap<span>;</span>

    <span>public</span> <span>SparseVector</span><span>(</span><span>double</span><span>[</span><span>]</span> vector<span>)</span> <span>{</span>
        hashMap <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> vector<span>.</span>length<span>;</span> i<span>++</span><span>)</span>
            <span>if</span> <span>(</span>vector<span>[</span>i<span>]</span> <span>!=</span> <span>0</span><span>)</span>
                hashMap<span>.</span><span>put</span><span>(</span>i<span>,</span> vector<span>[</span>i<span>]</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>double</span> <span>get</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>
        <span>return</span> hashMap<span>.</span><span>getOrDefault</span><span>(</span>i<span>,</span> <span>0.0</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>double</span> <span>dot</span><span>(</span><span>SparseVector</span> other<span>)</span> <span>{</span>
        <span>double</span> sum <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>:</span> hashMap<span>.</span><span>keySet</span><span>(</span><span>)</span><span>)</span>
            sum <span>+=</span> <span>this</span><span>.</span><span>get</span><span>(</span>i<span>)</span> <span>*</span> other<span>.</span><span>get</span><span>(</span>i<span>)</span><span>;</span>
        <span>return</span> sum<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>数学模型</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">数学模型</source>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>

<h1 id="数学模型" tabindex="-1"> 数学模型</h1>
<h2 id="_1-近似" tabindex="-1"> 1. 近似</h2>
<p>N<sup>3</sup>/6-N<sup>2</sup>/2+N/3 ~ N<sup>3</sup>/6。使用 ~f(N) 来表示所有随着 N 的增大除以 f(N) 的结果趋近于 1 的函数。</p>
<h2 id="_2-增长数量级" tabindex="-1"> 2. 增长数量级</h2>
<p>N<sup>3</sup>/6-N<sup>2</sup>/2+N/3 的增长数量级为 O(N<sup>3</sup>)。增长数量级将算法与它的具体实现隔离开来，一个算法的增长数量级为 O(N<sup>3</sup>) 与它是否用 Java 实现，是否运行于特定计算机上无关。</p>
<h2 id="_3-内循环" tabindex="-1"> 3. 内循环</h2>
<p>执行最频繁的指令决定了程序执行的总时间，把这些指令称为程序的内循环。</p>
<h2 id="_4-成本模型" tabindex="-1"> 4. 成本模型</h2>
<p>使用成本模型来评估算法，例如数组的访问次数就是一种成本模型。</p>
<h1 id="注意事项" tabindex="-1"> 注意事项</h1>
<h2 id="_1-大常数" tabindex="-1"> 1. 大常数</h2>
<p>在求近似时，如果低级项的常数系数很大，那么近似的结果是错误的。</p>
<h2 id="_2-缓存" tabindex="-1"> 2. 缓存</h2>
<p>计算机系统会使用缓存技术来组织内存，访问数组相邻的元素会比访问不相邻的元素快很多。</p>
<h2 id="_3-对最坏情况下的性能的保证" tabindex="-1"> 3. 对最坏情况下的性能的保证</h2>
<p>在核反应堆、心脏起搏器或者刹车控制器中的软件，最坏情况下的性能是十分重要的。</p>
<h2 id="_4-随机化算法" tabindex="-1"> 4. 随机化算法</h2>
<p>通过打乱输入，去除算法对输入的依赖。</p>
<h2 id="_5-均摊分析" tabindex="-1"> 5. 均摊分析</h2>
<p>将所有操作的总成本除于操作总数来将成本均摊。例如对一个空栈进行 N 次连续的 push() 调用需要访问数组的次数为 N+4+8+16+...+2N=5N-4（N 是向数组写入元素的次数，其余都是调整数组大小时进行复制需要的访问数组次数），均摊后访问数组的平均次数为常数。</p>
<h1 id="threesum" tabindex="-1"> ThreeSum</h1>
<p>ThreeSum 用于统计一个数组中和为 0 的三元组数量。</p>
<div><pre><code><span>public</span> <span>interface</span> <span>ThreeSum</span> <span>{</span>
    <span>int</span> <span>count</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h2 id="_1-threesumslow" tabindex="-1"> 1. ThreeSumSlow</h2>
<p>该算法的内循环为 <code>if (nums[i] + nums[j] + nums[k] == 0)</code> 语句，总共执行的次数为 N(N-1)(N-2) = N<sup>3</sup>/6-N<sup>2</sup>/2+N/3，因此它的近似执行次数为 ~N<sup>3</sup>/6，增长数量级为 O(N<sup>3</sup>)。</p>
<div><pre><code><span>public</span> <span>class</span> <span>ThreeSumSlow</span> <span>implements</span> <span>ThreeSum</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>int</span> <span>count</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> <span>N</span> <span>=</span> nums<span>.</span>length<span>;</span>
        <span>int</span> cnt <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> j <span>=</span> i <span>+</span> <span>1</span><span>;</span> j <span>&lt;</span> <span>N</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>
                <span>for</span> <span>(</span><span>int</span> k <span>=</span> j <span>+</span> <span>1</span><span>;</span> k <span>&lt;</span> <span>N</span><span>;</span> k<span>++</span><span>)</span> <span>{</span>
                    <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>+</span> nums<span>[</span>j<span>]</span> <span>+</span> nums<span>[</span>k<span>]</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
                        cnt<span>++</span><span>;</span>
                    <span>}</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> cnt<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="_2-threesumbinarysearch" tabindex="-1"> 2. ThreeSumBinarySearch</h2>
<p>将数组进行排序，对两个元素求和，并用二分查找方法查找是否存在该和的相反数，如果存在，就说明存在和为 0 的三元组。</p>
<p>应该注意的是，只有数组不含有相同元素才能使用这种解法，否则二分查找的结果会出错。</p>
<p>该方法可以将 ThreeSum 算法增长数量级降低为 O(N<sup>2</sup>logN)。</p>
<div><pre><code><span>public</span> <span>class</span> <span>ThreeSumBinarySearch</span> <span>implements</span> <span>ThreeSum</span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>int</span> <span>count</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>Arrays</span><span>.</span><span>sort</span><span>(</span>nums<span>)</span><span>;</span>
        <span>int</span> <span>N</span> <span>=</span> nums<span>.</span>length<span>;</span>
        <span>int</span> cnt <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> j <span>=</span> i <span>+</span> <span>1</span><span>;</span> j <span>&lt;</span> <span>N</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>
                <span>int</span> target <span>=</span> <span>-</span>nums<span>[</span>i<span>]</span> <span>-</span> nums<span>[</span>j<span>]</span><span>;</span>
                <span>int</span> index <span>=</span> <span>BinarySearch</span><span>.</span><span>search</span><span>(</span>nums<span>,</span> target<span>)</span><span>;</span>
                <span>// 应该注意这里的下标必须大于 j，否则会重复统计。</span>
                <span>if</span> <span>(</span>index <span>></span> j<span>)</span> <span>{</span>
                    cnt<span>++</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> cnt<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>BinarySearch</span> <span>{</span>

    <span>public</span> <span>static</span> <span>int</span> <span>search</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> target<span>)</span> <span>{</span>
        <span>int</span> l <span>=</span> <span>0</span><span>,</span> h <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>
        <span>while</span> <span>(</span>l <span>&lt;=</span> h<span>)</span> <span>{</span>
            <span>int</span> m <span>=</span> l <span>+</span> <span>(</span>h <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
            <span>if</span> <span>(</span>target <span>==</span> nums<span>[</span>m<span>]</span><span>)</span> <span>{</span>
                <span>return</span> m<span>;</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span>target <span>></span> nums<span>[</span>m<span>]</span><span>)</span> <span>{</span>
                l <span>=</span> m <span>+</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                h <span>=</span> m <span>-</span> <span>1</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> <span>-</span><span>1</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="_3-threesumtwopointer" tabindex="-1"> 3. ThreeSumTwoPointer</h2>
<p>更有效的方法是先将数组排序，然后使用双指针进行查找，时间复杂度为 O(N<sup>2</sup>)。</p>
<p>同样不适用与数组存在重复元素的情况。</p>
<div><pre><code><span>public</span> <span>class</span> <span>ThreeSumTwoPointer</span> <span>implements</span> <span>ThreeSum</span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>int</span> <span>count</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> <span>N</span> <span>=</span> nums<span>.</span>length<span>;</span>
        <span>int</span> cnt <span>=</span> <span>0</span><span>;</span>
        <span>Arrays</span><span>.</span><span>sort</span><span>(</span>nums<span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span> <span>-</span> <span>2</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>int</span> l <span>=</span> i <span>+</span> <span>1</span><span>,</span> h <span>=</span> <span>N</span> <span>-</span> <span>1</span><span>,</span> target <span>=</span> <span>-</span>nums<span>[</span>i<span>]</span><span>;</span>
            <span>while</span> <span>(</span>l <span>&lt;</span> h<span>)</span> <span>{</span>
                <span>int</span> sum <span>=</span> nums<span>[</span>l<span>]</span> <span>+</span> nums<span>[</span>h<span>]</span><span>;</span>
                <span>if</span> <span>(</span>sum <span>==</span> target<span>)</span> <span>{</span>
                    cnt<span>++</span><span>;</span>
                    l<span>++</span><span>;</span>
                    h<span>--</span><span>;</span>
                <span>}</span> <span>else</span> <span>if</span> <span>(</span>sum <span>&lt;</span> target<span>)</span> <span>{</span>
                    l<span>++</span><span>;</span>
                <span>}</span> <span>else</span> <span>{</span>
                    h<span>--</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> cnt<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h1 id="倍率实验" tabindex="-1"> 倍率实验</h1>
<p>如果 T(N) ~ aN<sup>b</sup>logN，那么 T(2N)/T(N) ~ 2<sup>b</sup>。</p>
<p>例如对于暴力的 ThreeSum 算法，近似时间为 ~N<sup>3</sup>/6。进行如下实验：多次运行该算法，每次取的 N 值为前一次的两倍，统计每次执行的时间，并统计本次运行时间与前一次运行时间的比值，得到如下结果：</p>
<table>
<thead>
<tr>
<th style="text-align:center">N</th>
<th style="text-align:center">Time(ms)</th>
<th style="text-align:center">Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">500</td>
<td style="text-align:center">48</td>
<td style="text-align:center">/</td>
</tr>
<tr>
<td style="text-align:center">1000</td>
<td style="text-align:center">320</td>
<td style="text-align:center">6.7</td>
</tr>
<tr>
<td style="text-align:center">2000</td>
<td style="text-align:center">555</td>
<td style="text-align:center">1.7</td>
</tr>
<tr>
<td style="text-align:center">4000</td>
<td style="text-align:center">4105</td>
<td style="text-align:center">7.4</td>
</tr>
<tr>
<td style="text-align:center">8000</td>
<td style="text-align:center">33575</td>
<td style="text-align:center">8.2</td>
</tr>
<tr>
<td style="text-align:center">16000</td>
<td style="text-align:center">268909</td>
<td style="text-align:center">8.0</td>
</tr>
</tbody>
</table>
<p>可以看到，T(2N)/T(N) ~ 2<sup>3</sup>，因此可以确定 T(N) ~ aN<sup>3</sup>logN。</p>
<div><pre><code><span>public</span> <span>class</span> <span>RatioTest</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span> <span>N</span> <span>=</span> <span>500</span><span>;</span>
        <span>int</span> loopTimes <span>=</span> <span>7</span><span>;</span>
        <span>double</span> preTime <span>=</span> <span>-</span><span>1</span><span>;</span>
        <span>while</span> <span>(</span>loopTimes<span>--</span> <span>></span> <span>0</span><span>)</span> <span>{</span>
            <span>int</span><span>[</span><span>]</span> nums <span>=</span> <span>new</span> <span>int</span><span>[</span><span>N</span><span>]</span><span>;</span>
            <span>StopWatch</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
            <span>ThreeSum</span> threeSum <span>=</span> <span>new</span> <span>ThreeSumSlow</span><span>(</span><span>)</span><span>;</span>
            <span>int</span> cnt <span>=</span> threeSum<span>.</span><span>count</span><span>(</span>nums<span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>cnt<span>)</span><span>;</span>
            <span>double</span> elapsedTime <span>=</span> <span>StopWatch</span><span>.</span><span>elapsedTime</span><span>(</span><span>)</span><span>;</span>
            <span>double</span> ratio <span>=</span> preTime <span>==</span> <span>-</span><span>1</span> <span>?</span> <span>0</span> <span>:</span> elapsedTime <span>/</span> preTime<span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>N</span> <span>+</span> <span>"  "</span> <span>+</span> elapsedTime <span>+</span> <span>"  "</span> <span>+</span> ratio<span>)</span><span>;</span>
            preTime <span>=</span> elapsedTime<span>;</span>
            <span>N</span> <span>*=</span> <span>2</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>StopWatch</span> <span>{</span>

    <span>private</span> <span>static</span> <span>long</span> start<span>;</span>


    <span>public</span> <span>static</span> <span>void</span> <span>start</span><span>(</span><span>)</span> <span>{</span>
        start <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>


    <span>public</span> <span>static</span> <span>double</span> <span>elapsedTime</span><span>(</span><span>)</span> <span>{</span>
        <span>long</span> now <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
        <span>return</span> <span>(</span>now <span>-</span> start<span>)</span> <span>/</span> <span>1000.0</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>计算机网络-传输层</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">计算机网络-传输层</source>
      <category>网络</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>

<p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p>
<h1 id="udp-和-tcp-的特点" tabindex="-1"> UDP 和 TCP 的特点</h1>
<ul>
<li>
<p>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</p>
</li>
<li>
<p>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</p>
</li>
</ul>
<h1 id="udp-首部格式" tabindex="-1"> UDP 首部格式</h1>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg" width="600"/> </div><br>
<p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p>
<h1 id="tcp-首部格式" tabindex="-1"> TCP 首部格式</h1>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" width="700"/> </div><br>
<ul>
<li>
<p><strong>序号</strong>  ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p>
</li>
<li>
<p><strong>确认号</strong>  ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p>
</li>
<li>
<p><strong>数据偏移</strong>  ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p>
</li>
<li>
<p><strong>确认 ACK</strong>  ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p>
</li>
<li>
<p><strong>同步 SYN</strong>  ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p>
</li>
<li>
<p><strong>终止 FIN</strong>  ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p>
</li>
<li>
<p><strong>复位 RST</strong> 当RST=1时，表示出现连接错误，必须释放连接，然后再重建传输连接。复位比特还用来拒绝一个不法的报文段或拒绝打开一个连接；</p>
</li>
<li>
<p><strong>窗口</strong>  ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p>
</li>
</ul>
<h1 id="tcp-的三次握手" tabindex="-1"> TCP 的三次握手</h1>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e92d0ebc-7d46-413b-aec1-34a39602f787.png" width="600"/> </div><br>
<p>假设 A 为客户端，B 为服务器端。</p>
<ul>
<li>
<p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p>
</li>
<li>
<p>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</p>
</li>
<li>
<p>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</p>
</li>
<li>
<p>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</p>
</li>
<li>
<p>B 收到 A 的确认后，连接建立。</p>
</li>
</ul>
<p><strong>三次握手的原因</strong></p>
<p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>
<h1 id="tcp-的四次挥手" tabindex="-1"> TCP 的四次挥手</h1>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" width="600"/> </div><br>
<p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p>
<ul>
<li>
<p>A 发送连接释放报文，FIN=1。</p>
</li>
<li>
<p>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</p>
</li>
<li>
<p>当 B 不再需要连接时，发送连接释放报文，FIN=1。</p>
</li>
<li>
<p>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</p>
</li>
<li>
<p>B 收到 A 的确认后释放连接。</p>
</li>
</ul>
<p><strong>四次挥手的原因</strong></p>
<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>
<p><strong>TIME_WAIT</strong></p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<ul>
<li>
<p>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</p>
</li>
<li>
<p>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p>
<ul>
<li>主要是一些超时的但是又没有被丢弃的数据包，这些数据包在前面的传输中被检测到超时了，于是tcp启动了超时重传机制，而且还走了新的、更不拥塞的链路，于是导致这些重传的数据包反而更快被对端确认。这些姗姗来迟的旧数据包如果在TIME_WAIT阶段到达，就会被丢弃掉。然而，如果这个主动的关闭的socket 没有等待足够长的时间，而是又用着相同的端口号去建立一个新的TCP连接，那么这些旧的数据包就干扰新的连接。</li>
</ul>
</li>
</ul>
<h1 id="tcp-协议保证可靠传输" tabindex="-1"> TCP 协议保证可靠传输</h1>
<ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li>校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li>流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li>拥塞控制： 当网络拥塞时，减少数据的发送。</li>
<li>ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li>超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h1 id="tcp-可靠传输" tabindex="-1"> TCP 可靠传输</h1>
<p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p>
<p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：</p>
<div align="center"><img src="https://latex.codecogs.com/gif.latex?RTTs=(1-a)*(RTTs)+a*RTT"/></div> <br>
<p>其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。</p>
<p>超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：</p>
<div align="center"><img src="https://latex.codecogs.com/gif.latex?RTO=RTTs+4*RTT_d"/></div> <br>
<p>其中 RTT<sub>d</sub> 为偏差的加权平均值。</p>
<h1 id="tcp-滑动窗口" tabindex="-1"> TCP 滑动窗口</h1>
<p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg" width="800"/> </div><br>
<h1 id="tcp-流量控制" tabindex="-1"> TCP 流量控制</h1>
<p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p>
<p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h1 id="tcp-拥塞控制" tabindex="-1"> TCP 拥塞控制</h1>
<p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/51e2ed95-65b8-4ae9-8af3-65602d452a25.jpg" width="500"/> </div><br>
<p>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p>
<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p>
<p>为了便于讨论，做如下假设：</p>
<ul>
<li>接收方有足够大的接收缓存，因此不会发生流量控制；</li>
<li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/910f613f-514f-4534-87dd-9b4699d59d31.png" width="800"/> </div><br>
<h2 id="_1-慢开始与拥塞避免" tabindex="-1"> 1. 慢开始与拥塞避免</h2>
<p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...</p>
<p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p>
<p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p>
<h2 id="_2-快重传与快恢复" tabindex="-1"> 2. 快重传与快恢复</h2>
<p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M<sub>1</sub> 和 M<sub>2</sub>，此时收到 M<sub>4</sub>，应当发送对 M<sub>2</sub> 的确认。</p>
<p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M<sub>2</sub>，则 M<sub>3</sub> 丢失，立即重传 M<sub>3</sub>。</p>
<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p>
<p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5.png" width="600"/> </div><br>
]]></content:encoded>
    </item>
    <item>
      <title>计算机网络-应用层</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">计算机网络-应用层</source>
      <category>网络</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>

<h1 id="域名系统" tabindex="-1"> 域名系统</h1>
<p>DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。</p>
<p>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b54eeb16-0b0e-484c-be62-306f57c40d77.jpg"/> </div><br>
<p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：</p>
<ul>
<li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li>
<li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li>
</ul>
<h1 id="文件传送协议" tabindex="-1"> 文件传送协议</h1>
<p>FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：</p>
<ul>
<li>控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li>
<li>数据连接：用来传送一个文件数据。</li>
</ul>
<p>根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：</p>
<ul>
<li>主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/03f47940-3843-4b51-9e42-5dcaff44858b.jpg"/> </div><br>
<ul>
<li>被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/be5c2c61-86d2-4dba-a289-b48ea23219de.jpg"/> </div><br>
<p>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</p>
<h1 id="动态主机配置协议" tabindex="-1"> 动态主机配置协议</h1>
<p>DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</p>
<p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p>
<p>DHCP 工作过程如下：</p>
<ol>
<li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。</li>
<li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</li>
<li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</li>
<li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li>
</ol>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23219e4c-9fc0-4051-b33a-2bd95bf054ab.jpg"/> </div><br>
<h1 id="远程登录协议" tabindex="-1"> 远程登录协议</h1>
<p>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。</p>
<p>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p>
<h1 id="电子邮件协议" tabindex="-1"> 电子邮件协议</h1>
<p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。</p>
<p>邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7b3efa99-d306-4982-8cfb-e7153c33aab4.png" width="700"/> </div><br>
<h2 id="_1-smtp" tabindex="-1"> 1. SMTP</h2>
<p>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ed5522bb-3a60-481c-8654-43e7195a48fe.png" width=""/> </div><br>
<h2 id="_2-pop3" tabindex="-1"> 2. POP3</h2>
<p>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。</p>
<h2 id="_3-imap" tabindex="-1"> 3. IMAP</h2>
<p>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</p>
<h1 id="常用端口" tabindex="-1"> 常用端口</h1>
<table>
<thead>
<tr>
<th style="text-align:center">应用</th>
<th style="text-align:center">应用层协议</th>
<th style="text-align:center">端口号</th>
<th style="text-align:center">传输层协议</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">域名解析</td>
<td style="text-align:center">DNS</td>
<td style="text-align:center">53</td>
<td style="text-align:center">UDP/TCP</td>
<td style="text-align:center">长度超过 512 字节时使用 TCP</td>
</tr>
<tr>
<td style="text-align:center">动态主机配置协议</td>
<td style="text-align:center">DHCP</td>
<td style="text-align:center">67/68</td>
<td style="text-align:center">UDP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">简单网络管理协议</td>
<td style="text-align:center">SNMP</td>
<td style="text-align:center">161/162</td>
<td style="text-align:center">UDP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">文件传送协议</td>
<td style="text-align:center">FTP</td>
<td style="text-align:center">20/21</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center">控制连接 21，数据连接 20</td>
</tr>
<tr>
<td style="text-align:center">远程终端协议</td>
<td style="text-align:center">TELNET</td>
<td style="text-align:center">23</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">超文本传送协议</td>
<td style="text-align:center">HTTP</td>
<td style="text-align:center">80</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">简单邮件传送协议</td>
<td style="text-align:center">SMTP</td>
<td style="text-align:center">25</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">邮件读取协议</td>
<td style="text-align:center">POP3</td>
<td style="text-align:center">110</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">网际报文存取协议</td>
<td style="text-align:center">IMAP</td>
<td style="text-align:center">143</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h1 id="web-页面请求过程" tabindex="-1"> Web 页面请求过程</h1>
<h2 id="_1-dhcp-配置主机信息" tabindex="-1"> 1. DHCP 配置主机信息</h2>
<ul>
<li>
<p>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</p>
</li>
<li>
<p>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</p>
</li>
<li>
<p>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。</p>
</li>
<li>
<p>该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。</p>
</li>
<li>
<p>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</p>
</li>
<li>
<p>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</p>
</li>
<li>
<p>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</p>
</li>
</ul>
<h2 id="_2-arp-解析-mac-地址" tabindex="-1"> 2. ARP 解析 MAC 地址</h2>
<ul>
<li>
<p>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</p>
</li>
<li>
<p>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</p>
</li>
<li>
<p>该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</p>
</li>
<li>
<p>该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。</p>
</li>
<li>
<p>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</p>
</li>
<li>
<p>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</p>
</li>
<li>
<p>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</p>
</li>
</ul>
<h2 id="_3-dns-解析域名" tabindex="-1"> 3. DNS 解析域名</h2>
<ul>
<li>
<p>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</p>
</li>
<li>
<p>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</p>
</li>
<li>
<p>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</p>
</li>
<li>
<p>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</p>
</li>
<li>
<p>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</p>
</li>
</ul>
<h2 id="_4-http-请求页面" tabindex="-1"> 4. HTTP 请求页面</h2>
<ul>
<li>
<p>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</p>
</li>
<li>
<p>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</p>
</li>
<li>
<p>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</p>
</li>
<li>
<p>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</p>
</li>
<li>
<p>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</p>
</li>
<li>
<p>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>计算机网络-概述</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">计算机网络-概述</source>
      <category>网络</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>

<h1 id="网络的网络" tabindex="-1"> 网络的网络</h1>
<p>网络把主机连接起来，而互联网是把多种不同的网络连接起来，因此互联网是网络的网络。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/network-of-networks.gif" width="450"/> </div><br>
<h1 id="isp" tabindex="-1"> ISP</h1>
<p>互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/72be01cd-41ae-45f7-99b9-a8d284e44dd4.png" width="500"/> </div><br>
<p>目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3be42601-9d33-4d29-8358-a9d16453af93.png" width="500"/> </div><br>
<h1 id="主机之间的通信方式" tabindex="-1"> 主机之间的通信方式</h1>
<ul>
<li>客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/914894c2-0bc4-46b5-bef9-0316a69ef521.jpg" width="240px"> </div><br>
<ul>
<li>对等（P2P）：不区分客户和服务器。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/42430e94-3137-48c0-bdb6-3cebaf9102e3.jpg" width="200px"> </div><br>
<h1 id="电路交换与分组交换" tabindex="-1"> 电路交换与分组交换</h1>
<h2 id="_1-电路交换" tabindex="-1"> 1. 电路交换</h2>
<p>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p>
<h2 id="_2-分组交换" tabindex="-1"> 2. 分组交换</h2>
<p>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。</p>
<p>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。</p>
<h1 id="时延" tabindex="-1"> 时延</h1>
<p>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4b2ae78c-e254-44df-9e37-578e2f2bef52.jpg" width="380"/> </div><br>
<h2 id="_1-排队时延" tabindex="-1"> 1. 排队时延</h2>
<p>分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</p>
<h2 id="_2-处理时延" tabindex="-1"> 2. 处理时延</h2>
<p>主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。</p>
<h2 id="_3-传输时延" tabindex="-1"> 3. 传输时延</h2>
<p>主机或路由器传输数据帧所需要的时间。</p>

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dcdbb96c-9077-4121-aeb8-743e54ac02a4.png" width="150px"> </div><br>
<p>其中 l 表示数据帧的长度，v 表示传输速率。</p>
<h2 id="_4-传播时延" tabindex="-1"> 4. 传播时延</h2>
<p>电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。</p>

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a1616dac-0e12-40b2-827d-9e3f7f0b940d.png" width="150"> </div><br>
<p>其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。</p>
<h1 id="计算机网络体系结构" tabindex="-1"> 计算机网络体系结构</h1>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png" width="450"/> </div><br>
<h2 id="_1-五层协议" tabindex="-1"> 1. 五层协议</h2>
<ul>
<li>
<p><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</p>
</li>
<li>
<p><strong>传输层</strong> ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</p>
</li>
<li>
<p><strong>网络层</strong> ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</p>
</li>
<li>
<p><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</p>
</li>
<li>
<p><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p>
</li>
</ul>
<h2 id="_2-osi" tabindex="-1"> 2. OSI</h2>
<p>其中表示层和会话层用途如下：</p>
<ul>
<li>
<p><strong>表示层</strong> ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</p>
</li>
<li>
<p><strong>会话层</strong> ：建立及管理会话。</p>
</li>
</ul>
<p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p>
<h2 id="_3-tcp-ip" tabindex="-1"> 3. TCP/IP</h2>
<p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p>
<p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/48d79be8-085b-4862-8a9d-18402eb93b31.png" width="250"/> </div><br>
<h2 id="_4-数据在各层之间的传递过程" tabindex="-1"> 4. 数据在各层之间的传递过程</h2>
<p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p>
<p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p>
]]></content:encoded>
    </item>
    <item>
      <title>计算机网络-物理层</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">计算机网络-物理层</source>
      <category>网络</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li></li>
</ul>

<h1 id="通信方式" tabindex="-1"> 通信方式</h1>
<p>根据信息在传输线上的传送方向，分为以下三种通信方式：</p>
<ul>
<li>单工通信：单向传输</li>
<li>半双工通信：双向交替传输</li>
<li>全双工通信：双向同时传输</li>
</ul>
<h1 id="带通调制" tabindex="-1"> 带通调制</h1>
<p>模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c34f4503-f62c-4043-9dc6-3e03288657df.jpg" width="500"/> </div><br>
]]></content:encoded>
    </item>
    <item>
      <title>计算机网络-目录</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%9B%AE%E5%BD%95.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%9B%AE%E5%BD%95.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">计算机网络-目录</source>
      <category>网络</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="目录" tabindex="-1"> 目录</h1>
<ul>
<li><a href="/notes/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0.html">概述</a></li>
<li><a href="/notes/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82.html">物理层</a></li>
<li><a href="/notes/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html">链路层</a></li>
<li><a href="/notes/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html">网络层</a></li>
<li><a href="/notes/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82.html">传输层</a></li>
<li><a href="/notes/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82.html">应用层</a></li>
</ul>
<h1 id="参考链接" tabindex="-1"> 参考链接</h1>
<ul>
<li>计算机网络, 谢希仁</li>
<li>JamesF.Kurose, KeithW.Ross, 库罗斯, 等. 计算机网络: 自顶向下方法 [M]. 机械工业出版社, 2014.</li>
<li>W.RichardStevens. TCP/IP 详解. 卷 1, 协议 [M]. 机械工业出版社, 2006.</li>
<li><a href="https://securitywing.com/active-vs-passive-ftp-mode/" target="_blank" rel="noopener noreferrer">Active vs Passive FTP Mode: Which One is More Secure?</a></li>
<li><a href="http://www.serv-u.com/kb/1138/active-and-passive-ftp-transfers-defined" target="_blank" rel="noopener noreferrer">Active and Passive FTP Transfers Defined - KB Article #1138</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Traceroute" target="_blank" rel="noopener noreferrer">Traceroute</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Ping" target="_blank" rel="noopener noreferrer">ping</a></li>
<li><a href="http://webcache.googleusercontent.com/search?q=cache:http://anandgiria.blogspot.com/2013/09/windows-dhcp-interview-questions-and.html" target="_blank" rel="noopener noreferrer">How DHCP works and DHCP Interview Questions and Answers</a></li>
<li><a href="https://www.quora.com/What-is-process-of-DORA-in-DHCP" target="_blank" rel="noopener noreferrer">What is process of DORA in DHCP?</a></li>
<li><a href="https://tecadmin.net/what-is-dhcp-server/" target="_blank" rel="noopener noreferrer">What is DHCP Server ?</a></li>
<li><a href="http://www.climatechangenews.com/2011/html/university-tokyo.html" target="_blank" rel="noopener noreferrer">Tackling emissions targets in Tokyo</a></li>
<li><a href="http://www.climatechangenews.com/2011/html/university-tokyo.html" target="_blank" rel="noopener noreferrer">What does my ISP know when I use Tor?</a></li>
<li><a href="http://www.linyibin.cn/2017/02/12/technology-ComputerNetworking-Internet/" target="_blank" rel="noopener noreferrer">Technology-Computer Networking[1]-Computer Networks and the Internet</a></li>
<li><a href="http://slidesplayer.com/slide/11616167/" target="_blank" rel="noopener noreferrer">P2P 网络概述.</a></li>
<li><a href="http://slideplayer.com/slide/5115386/" target="_blank" rel="noopener noreferrer">Circuit Switching (a) Circuit switching. (b) Packet switching.</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>计算机网络-目录</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">计算机网络-目录</source>
      <category>网络</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>

<h1 id="概述" tabindex="-1"> 概述</h1>
<p>因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。</p>
<p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8d779ab7-ffcc-47c6-90ec-ede8260b2368.png" width="800"/> </div><br>
<p>与 IP 协议配套使用的还有三个协议：</p>
<ul>
<li>地址解析协议 ARP（Address Resolution Protocol）</li>
<li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li>
<li>网际组管理协议 IGMP（Internet Group Management Protocol）</li>
</ul>
<h1 id="ip-数据报格式" tabindex="-1"> IP 数据报格式</h1>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" width="700"/> </div><br>
<ul>
<li>
<p><strong>版本</strong>  : 有 4（IPv4）和 6（IPv6）两个值；</p>
</li>
<li>
<p><strong>首部长度</strong>  : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</p>
</li>
<li>
<p><strong>区分服务</strong>  : 用来获得更好的服务，一般情况下不使用。</p>
</li>
<li>
<p><strong>总长度</strong>  : 包括首部长度和数据部分长度。</p>
</li>
<li>
<p><strong>生存时间</strong>  ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</p>
</li>
<li>
<p><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</p>
</li>
<li>
<p><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</p>
</li>
<li>
<p><strong>标识</strong>  : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</p>
</li>
<li>
<p><strong>片偏移</strong>  : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</p>
</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23ba890e-e11c-45e2-a20c-64d217f83430.png" width="700"/> </div><br>
<h1 id="ip-地址编址方式" tabindex="-1"> IP 地址编址方式</h1>
<p>IP 地址的编址方式经历了三个历史阶段：</p>
<ul>
<li>分类</li>
<li>子网划分</li>
<li>无分类</li>
</ul>
<h2 id="_1-分类" tabindex="-1"> 1. 分类</h2>
<p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cbf50eb8-22b4-4528-a2e7-d187143d57f7.png" width="500"/> </div><br>
<h2 id="_2-子网划分" tabindex="-1"> 2. 子网划分</h2>
<p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p>
<p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p>
<p>注意，外部网络看不到子网的存在。</p>
<h2 id="_3-无分类" tabindex="-1"> 3. 无分类</h2>
<p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p>
<p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p>
<p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p>
<p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p>
<p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为  <strong>构成超网</strong> 。</p>
<p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p>
<h1 id="地址解析协议-arp" tabindex="-1"> 地址解析协议 ARP</h1>
<p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66192382-558b-4b05-a35d-ac4a2b1a9811.jpg" width="700"/> </div><br>
<p>ARP 实现由 IP 地址得到 MAC 地址。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b9d79a5a-e7af-499b-b989-f10483e71b8b.jpg" width="500"/> </div><br>
<p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p>
<p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8006a450-6c2f-498c-a928-c927f758b1d0.png" width="700"/> </div><br>
<h1 id="网际控制报文协议-icmp" tabindex="-1"> 网际控制报文协议 ICMP</h1>
<p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e3124763-f75e-46c3-ba82-341e6c98d862.jpg" width="500"/> </div><br>
<p>ICMP 报文分为差错报告报文和询问报文。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/aa29cc88-7256-4399-8c7f-3cf4a6489559.png" width="600"/> </div><br>
<h2 id="_1-ping" tabindex="-1"> 1. Ping</h2>
<p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p>
<p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p>
<h2 id="_2-traceroute" tabindex="-1"> 2. Traceroute</h2>
<p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p>
<p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p>
<ul>
<li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li>
<li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li>
<li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li>
<li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li>
</ul>
<h1 id="虚拟专用网-vpn" tabindex="-1"> 虚拟专用网 VPN</h1>
<p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p>
<p>有三个专用地址块：</p>
<ul>
<li>10.0.0.0 ~ 10.255.255.255</li>
<li>172.16.0.0 ~ 172.31.255.255</li>
<li>192.168.0.0 ~ 192.168.255.255</li>
</ul>
<p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。</p>
<p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1556770b-8c01-4681-af10-46f1df69202c.jpg" width="800"/> </div><br>
<h1 id="网络地址转换-nat" tabindex="-1"> 网络地址转换 NAT</h1>
<p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p>
<p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2719067e-b299-4639-9065-bed6729dbf0b.png" width=""/> </div><br>
<h1 id="路由器的结构" tabindex="-1"> 路由器的结构</h1>
<p>路由器从功能上可以划分为：路由选择和分组转发。</p>
<p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c3369072-c740-43b0-b276-202bd1d3960d.jpg" width="600"/> </div><br>
<h1 id="路由器分组转发流程" tabindex="-1"> 路由器分组转发流程</h1>
<ul>
<li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li>
<li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li>
<li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li>
<li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li>
<li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li>
<li>报告转发分组出错。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1ab49e39-012b-4383-8284-26570987e3c4.jpg" width="800"/> </div><br>
<h1 id="路由选择协议" tabindex="-1"> 路由选择协议</h1>
<p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p>
<p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p>
<p>可以把路由选择协议划分为两大类：</p>
<ul>
<li>自治系统内部的路由选择：RIP 和 OSPF</li>
<li>自治系统间的路由选择：BGP</li>
</ul>
<h2 id="_1-内部网关协议-rip" tabindex="-1"> 1. 内部网关协议 RIP</h2>
<p>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p>
<p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p>
<p>距离向量算法：</p>
<ul>
<li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li>
<li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：</li>
<li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li>
<li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li>
<li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li>
</ul>
<p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p>
<h2 id="_2-内部网关协议-ospf" tabindex="-1"> 2. 内部网关协议 OSPF</h2>
<p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p>
<p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p>
<p>OSPF 具有以下特点：</p>
<ul>
<li>向本自治系统中的所有路由器发送信息，这种方法是泛洪法。</li>
<li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li>
<li>只有当链路状态发生变化时，路由器才会发送信息。</li>
</ul>
<p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p>
<h2 id="_3-外部网关协议-bgp" tabindex="-1"> 3. 外部网关协议 BGP</h2>
<p>BGP（Border Gateway Protocol，边界网关协议）</p>
<p>AS 之间的路由选择很困难，主要是由于：</p>
<ul>
<li>互联网规模很大；</li>
<li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li>
<li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li>
</ul>
<p>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p>
<p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9cd0ae20-4fb5-4017-a000-f7d3a0eb3529.png" width="600"/> </div><br>
]]></content:encoded>
    </item>
    <item>
      <title>计算机网络-链路层</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">计算机网络-链路层</source>
      <category>网络</category>
      <pubDate>Mon, 16 May 2022 12:07:59 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<h1 id="基本问题" tabindex="-1"> 基本问题</h1>
<h2 id="_1-封装成帧" tabindex="-1"> 1. 封装成帧</h2>
<p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/29a14735-e154-4f60-9a04-c9628e5d09f4.png" width="300"/> </div><br>
<h2 id="_2-透明传输" tabindex="-1"> 2. 透明传输</h2>
<p>透明表示一个实际存在的事物看起来好像不存在一样。</p>
<p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e738a3d2-f42e-4755-ae13-ca23497e7a97.png" width="500"/> </div><br>
<h2 id="_3-差错检测" tabindex="-1"> 3. 差错检测</h2>
<p>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</p>
<h1 id="信道分类" tabindex="-1"> 信道分类</h1>
<h2 id="_1-广播信道" tabindex="-1"> 1. 广播信道</h2>
<p>一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。</p>
<p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p>
<p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。</p>
<h2 id="_2-点对点信道" tabindex="-1"> 2. 点对点信道</h2>
<p>一对一通信。</p>
<p>因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</p>
<h1 id="信道复用技术" tabindex="-1"> 信道复用技术</h1>
<h2 id="_1-频分复用" tabindex="-1"> 1. 频分复用</h2>
<p>频分复用的所有主机在相同的时间占用不同的频率带宽资源。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4aa5e057-bc57-4719-ab57-c6fbc861c505.png" width="350"/> </div><br>
<h2 id="_2-时分复用" tabindex="-1"> 2. 时分复用</h2>
<p>时分复用的所有主机在不同的时间占用相同的频率带宽资源。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/67582ade-d44a-46a6-8757-3c1296cc1ef9.png" width="350"/> </div><br>
<p>使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。</p>
<h2 id="_3-统计时分复用" tabindex="-1"> 3. 统计时分复用</h2>
<p>是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6283be2a-814a-4a10-84bf-9592533fe6bc.png" width="350"/> </div><br>
<h2 id="_4-波分复用" tabindex="-1"> 4. 波分复用</h2>
<p>光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</p>
<h2 id="_5-码分复用" tabindex="-1"> 5. 码分复用</h2>
<p>为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片 <img src="https://latex.codecogs.com/gif.latex?\vec{S}"/> 和 <img src="https://latex.codecogs.com/gif.latex?\vec{T}"/> 有</p>

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/308a02e9-3346-4251-8c41-bd5536dab491.png" width="100px"> </div><br>
<p>为了讨论方便，取 m=8，设码片 <img src="https://latex.codecogs.com/gif.latex?\vec{S}"/> 为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。</p>
<p>在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到</p>


<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6fda1dc7-5c74-49c1-bb79-237a77e43a43.png" width="100px"> </div><br>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e325a903-f0b1-4fbd-82bf-88913dc2f290.png" width="125px"> </div><br>
<p>其中 <img src="https://latex.codecogs.com/gif.latex?\vec{S'}"/> 为 <img src="https://latex.codecogs.com/gif.latex?\vec{S}"/> 的反码。</p>
<p>利用上面的式子我们知道，当接收端使用码片 <img src="https://latex.codecogs.com/gif.latex?\vec{S}"/> 对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。</p>
<p>码分复用需要发送的数据量为原先的 m 倍。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/99b6060e-099d-4201-8e86-f8ab3768a7cf.png" width="500px"> </div><br>
<h1 id="csma-cd-协议" tabindex="-1"> CSMA/CD 协议</h1>
<p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p>
<ul>
<li><strong>多点接入</strong> ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li>
<li><strong>载波监听</strong> ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li>
<li><strong>碰撞检测</strong> ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li>
</ul>
<p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为  <strong>争用期</strong> 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p>
<p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用  <strong>截断二进制指数退避算法</strong>  来确定。从离散的整数集合 {0, 1, .., (2<sup>k</sup>-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/19d423e9-74f7-4c2b-9b97-55890e0d5193.png" width="400"/> </div><br>
<h1 id="ppp-协议" tabindex="-1"> PPP 协议</h1>
<p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e1ab9f28-cb15-4178-84b2-98aad87f9bc8.jpg" width="300"/> </div><br>
<p>PPP 的帧格式：</p>
<ul>
<li>F 字段为帧的定界符</li>
<li>A 和 C 字段暂时没有意义</li>
<li>FCS 字段是使用 CRC 的检验序列</li>
<li>信息部分的长度不超过 1500</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/759013d7-61d8-4509-897a-d75af598a236.png" width="400"/> </div><br>
<h1 id="mac-地址" tabindex="-1"> MAC 地址</h1>
<p>MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p>
<p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p>
<h1 id="局域网" tabindex="-1"> 局域网</h1>
<p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。</p>
<p>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。</p>
<p>可以按照网络拓扑结构对局域网进行分类：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/807f4258-dba8-4c54-9c3c-a707c7ccffa2.jpg" width="800"/> </div><br>
<h1 id="以太网" tabindex="-1"> 以太网</h1>
<p>以太网是一种星型拓扑结构局域网。</p>
<p>早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。</p>
<p>目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。</p>
<p>以太网帧格式：</p>
<ul>
<li><strong>类型</strong> ：标记上层使用的协议；</li>
<li><strong>数据</strong> ：长度在 46-1500 之间，如果太小则需要填充；</li>
<li><strong>FCS</strong> ：帧检验序列，使用的是 CRC 检验方法；</li>
</ul>
<p>要保证以太网的重传，必须保证A收到碰撞信号的时候，数据包没有传完，要实现这一要求，A和B之间的距离很关键，也就是说信号在A和B之间传输 的来回时间必须控制在一定范围之内。IEEE定义了这个标准，一个碰撞域内，最远的两台机器之间的round-trip time 要小于512bit time.(来回时间小于512位时，所谓位时就是传输一个比特需要的时间）。这也是我们常说的一个碰撞域的直径。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/164944d3-bbd2-4bb2-924b-e62199c51b90.png" width="500"/> </div><br>
<h1 id="交换机" tabindex="-1"> 交换机</h1>
<p>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。</p>
<p>正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。</p>
<p>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a4444545-0d68-4015-9a3d-19209dc436b3.png" width="800"/> </div><br>
<h1 id="虚拟局域网" tabindex="-1"> 虚拟局域网</h1>
<p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。</p>
<p>例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。</p>
<p>使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e98e9d20-206b-4533-bacf-3448d0096f38.png" width="500"/> </div><br>
]]></content:encoded>
    </item>
    <item>
      <title>幻灯片页</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/slide.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/slide.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">幻灯片页</source>
      <pubDate>Mon, 16 May 2022 04:59:52 GMT</pubDate>
      <content:encoded><![CDATA[
<i>Content not supported</i>]]></content:encoded>
      <enclosure url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/logo.svg" type="image/svg+xml"/>
    </item>
    <item>
      <title>计算机Note</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">计算机Note</source>
      <category>计算机</category>
      <pubDate>Mon, 16 May 2022 04:59:52 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="" tabindex="-1"> </h1>
<h1 id="✏️-算法" tabindex="-1"> ✏️ 算法</h1>
<ul>
<li><a href="/notes/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-%E7%9B%AE%E5%BD%95.html">剑指 Offer 题解</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E7%9B%AE%E5%BD%95.html">Leetcode 题解</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E7%9B%AE%E5%BD%95.html">算法</a></li>
<li><a href="https://xiaozhuanlan.com/CyC2018" target="_blank" rel="noopener noreferrer">后端面试进阶指南</a></li>
</ul>
<h1 id="💻-操作系统" tabindex="-1"> 💻 操作系统</h1>
<ul>
<li><a href="/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%9B%AE%E5%BD%95.html">计算机操作系统</a></li>
<li><a href="/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html">Linux</a></li>
</ul>
<h1 id="☁️-网络" tabindex="-1"> ☁️ 网络</h1>
<ul>
<li><a href="/notes/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%9B%AE%E5%BD%95.html">计算机网络</a></li>
<li><a href="/notes/%E7%BD%91%E7%BB%9C/HTTP.html">HTTP</a></li>
<li><a href="/notes/%E7%BD%91%E7%BB%9C/Socket.html">Socket</a></li>
<li><a href="/notes/%E7%BD%91%E7%BB%9C/Netty.html">Netty</a></li>
</ul>
<h1 id="🎨-面向对象" tabindex="-1"> 🎨 面向对象</h1>
<ul>
<li><a href="/notes/OOP/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html">面向对象思想</a></li>
<li><a href="/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%9B%AE%E5%BD%95.html">设计模式</a></li>
</ul>
<h1 id="💾-数据库" tabindex="-1"> 💾 数据库</h1>
<ul>
<li><a href="/notes/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html">数据库系统原理</a></li>
<li><a href="/notes/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL.html">SQL</a></li>
<li><a href="/notes/%E6%95%B0%E6%8D%AE%E5%BA%93/Leetcode-Database%E9%A2%98%E8%A7%A3.html">Leetcode-Database 题解</a></li>
<li><a href="/notes/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html">MySQL</a></li>
<li><a href="/notes/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis.html">Redis</a></li>
</ul>
<h1 id="☕️-java" tabindex="-1"> ☕️ Java</h1>
<ul>
<li><a href="/notes/Java/Java%E5%9F%BA%E7%A1%80.html">Java 基础</a></li>
<li><a href="/notes/Java/Java%E9%AB%98%E7%BA%A7.html">Java 高级</a></li>
<li><a href="/notes/Java/Java%E5%AE%B9%E5%99%A8.html">Java 容器</a></li>
<li><a href="/notes/Java/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80.html">Java 并发基础</a></li>
<li><a href="/notes/Java/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6.html">Java 并发进阶</a></li>
<li><a href="/notes/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">Java 虚拟机-内存管理</a></li>
<li><a href="/notes/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F.html">Java 虚拟机-执行系统</a></li>
<li><a href="/notes/Java/JavaIO.html">Java I/O</a></li>
<li><a href="/notes/Java/JavaEE.html">Java EE</a></li>
<li><a href="/notes/Java/Java%E7%89%B9%E6%80%A7.html">Java 特性</a></li>
</ul>
<h1 id="💡-系统设计" tabindex="-1"> 💡 系统设计</h1>
<ul>
<li><a href="/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html">系统设计基础</a></li>
<li><a href="/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F.html">分布式</a></li>
<li><a href="/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%9B%86%E7%BE%A4.html">集群</a></li>
<li><a href="/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.html">攻击技术</a></li>
<li><a href="/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%BC%93%E5%AD%98.html">缓存</a></li>
<li><a href="/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html">消息队列</a></li>
</ul>
<h1 id="🔧-分布式中间件" tabindex="-1"> 🔧 分布式中间件</h1>
<ul>
<li><a href="/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6.html">分布式中间件</a></li>
<li><a href="/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF.html">分布式消息</a></li>
<li><a href="/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1.html">分布式服务</a></li>
<li><a href="/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.html">分布式缓存</a></li>
<li><a href="/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.html">分布式事务</a></li>
<li><a href="/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93.html">分布式数据库</a></li>
<li><a href="/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E5%BA%A6.html">分布式调度</a></li>
<li><a href="/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97.html">分布式计算</a></li>
<li><a href="/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83.html">配置中心</a></li>
</ul>
<h1 id="🔨-常用框架和软件" tabindex="-1"> 🔨 常用框架和软件</h1>
<ul>
<li><a href="/notes/%E6%A1%86%E6%9E%B6/Spring.html">Spring</a></li>
<li><a href="/notes/%E6%A1%86%E6%9E%B6/Spring-MVC.html">Spring MVC</a></li>
<li><a href="/notes/%E6%A1%86%E6%9E%B6/SpringBoot.html">SpringBoot</a></li>
<li><a href="/notes/%E6%A1%86%E6%9E%B6/PandoraBoot.html">PandoraBoot</a></li>
<li><a href="/notes/%E6%A1%86%E6%9E%B6/Dubbo.html">Dubbo</a></li>
<li><a href="/notes/%E6%A1%86%E6%9E%B6/Zookeeper.html">Zookeeper</a></li>
<li><a href="/notes/%E6%A1%86%E6%9E%B6/RabbitMQ.html">RabbitMQ</a></li>
<li><a href="/notes/%E6%A1%86%E6%9E%B6/RocketMQ.html">RocketMQ</a></li>
<li><a href="/notes/%E6%A1%86%E6%9E%B6/Kafka.html">Kafka</a></li>
</ul>
<h1 id="📈-前端" tabindex="-1"> 📈 前端</h1>
<ul>
<li><a href="/notes/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80.html">前端基础</a></li>
<li><a href="/notes/%E5%89%8D%E7%AB%AF/JavaScript.html">JavaScript</a></li>
<li><a href="/notes/%E5%89%8D%E7%AB%AF/JS-%E8%BF%9B%E9%98%B6.html">JS 进阶</a></li>
</ul>
<h1 id="🔧-工具" tabindex="-1"> 🔧 工具</h1>
<ul>
<li><a href="/notes/%E5%B7%A5%E5%85%B7/Git.html">Git</a></li>
<li><a href="/notes/%E5%B7%A5%E5%85%B7/Docker.html">Docker</a></li>
<li><a href="/notes/%E5%B7%A5%E5%85%B7/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html">正则表达式</a></li>
<li><a href="/notes/%E5%B7%A5%E5%85%B7/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html">构建工具</a></li>
<li><a href="/notes/%E5%B7%A5%E5%85%B7/IDEA.html">IDEA</a></li>
<li><a href="/notes/%E5%B7%A5%E5%85%B7/VSCode.html">VSCode</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">Java</source>
      <pubDate>Mon, 16 May 2022 04:59:52 GMT</pubDate>
    </item>
    <item>
      <title>面向对象编程</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">面向对象编程</source>
      <pubDate>Mon, 16 May 2022 04:59:52 GMT</pubDate>
    </item>
    <item>
      <title>设计模式</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">设计模式</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 04:59:52 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>

<h1 id="一、概述" tabindex="-1"> 一、概述</h1>
<p>设计模式是解决问题的方案，学习现有的设计模式可以做到经验复用。</p>
<p>拥有设计模式词汇，在沟通时就能用更少的词汇来讨论，并且不需要了解底层细节。</p>
<h1 id="二、创建型" tabindex="-1"> 二、创建型</h1>
<h2 id="_1-单例-singleton" tabindex="-1"> 1. 单例（Singleton）</h2>
<h3 id="intent" tabindex="-1"> Intent</h3>
<p>确保一个类只有一个实例，并提供该实例的全局访问点。</p>
<h3 id="class-diagram" tabindex="-1"> Class Diagram</h3>
<p>使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。</p>
<p>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eca1f422-8381-409b-ad04-98ef39ae38ba.png"/> </div><br>
<h3 id="implementation" tabindex="-1"> Implementation</h3>
<h4 id="i-懒汉式-线程不安全" tabindex="-1"> Ⅰ 懒汉式-线程不安全</h4>
<p>以下实现中，私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。</p>
<p>这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 <code>if (uniqueInstance == null)</code> ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 <code>uniqueInstance = new Singleton();</code> 语句，这将导致实例化多次 uniqueInstance。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>

    <span>private</span> <span>static</span> <span>Singleton</span> uniqueInstance<span>;</span>

    <span>private</span> <span>Singleton</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>Singleton</span> <span>getUniqueInstance</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>uniqueInstance <span>==</span> <span>null</span><span>)</span> <span>{</span>
            uniqueInstance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> uniqueInstance<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h4 id="ii-饿汉式-线程安全" tabindex="-1"> Ⅱ 饿汉式-线程安全</h4>
<p>线程不安全问题主要是由于 uniqueInstance 被实例化多次，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。</p>
<p>但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。</p>
<div><pre><code><span>private</span> <span>static</span> <span>Singleton</span> uniqueInstance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>
</code></pre></div><h4 id="iii-懒汉式-线程安全" tabindex="-1"> Ⅲ 懒汉式-线程安全</h4>
<p>只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次 uniqueInstance。</p>
<p>但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。</p>
<div><pre><code><span>public</span> <span>static</span> <span>synchronized</span> <span>Singleton</span> <span>getUniqueInstance</span><span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>uniqueInstance <span>==</span> <span>null</span><span>)</span> <span>{</span>
        uniqueInstance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> uniqueInstance<span>;</span>
<span>}</span>
</code></pre></div><h4 id="iv-双重校验锁-线程安全" tabindex="-1"> Ⅳ 双重校验锁-线程安全</h4>
<p>uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。</p>
<p>双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>

    <span>private</span> <span>volatile</span> <span>static</span> <span>Singleton</span> uniqueInstance<span>;</span>

    <span>private</span> <span>Singleton</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>Singleton</span> <span>getUniqueInstance</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>uniqueInstance <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>synchronized</span> <span>(</span><span>Singleton</span><span>.</span><span>class</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span>uniqueInstance <span>==</span> <span>null</span><span>)</span> <span>{</span>
                    uniqueInstance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> uniqueInstance<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>考虑下面的实现，也就是只使用了一个 if 语句。在 uniqueInstance == null 的情况下，如果两个线程都执行了 if 语句，那么两个线程都会进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 <code>uniqueInstance = new Singleton();</code> 这条语句，只是先后的问题，那么就会进行两次实例化。因此必须使用双重校验锁，也就是需要使用两个 if 语句：第一个 if 语句用来避免 uniqueInstance 已经被实例化之后的加锁操作，而第二个 if 语句进行了加锁，所以只能有一个线程进入，就不会出现 uniqueInstance == null 时两个线程同时进行实例化操作。</p>
<div><pre><code><span>if</span> <span>(</span>uniqueInstance <span>==</span> <span>null</span><span>)</span> <span>{</span>
    <span>synchronized</span> <span>(</span><span>Singleton</span><span>.</span><span>class</span><span>)</span> <span>{</span>
        uniqueInstance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p>
<ol>
<li>为 uniqueInstance 分配内存空间</li>
<li>初始化 uniqueInstance</li>
<li>将 uniqueInstance 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T<sub>1</sub> 执行了 1 和 3，此时 T<sub>2</sub> 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p>
<p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<h4 id="v-静态内部类实现" tabindex="-1"> Ⅴ 静态内部类实现</h4>
<p>当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 <code>getUniqueInstance()</code> 方法从而触发 <code>SingletonHolder.INSTANCE</code> 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。</p>
<p>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>

    <span>private</span> <span>Singleton</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>

    <span>private</span> <span>static</span> <span>class</span> <span>SingletonHolder</span> <span>{</span>
        <span>private</span> <span>static</span> <span>final</span> <span>Singleton</span> INSTANCE <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>Singleton</span> <span>getUniqueInstance</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>SingletonHolder</span><span>.</span>INSTANCE<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h4 id="vi-枚举实现" tabindex="-1"> Ⅵ 枚举实现</h4>
<div><pre><code><span>public</span> <span>enum</span> <span>Singleton</span> <span>{</span>

    INSTANCE<span>;</span>

    <span>private</span> <span>String</span> objName<span>;</span>


    <span>public</span> <span>String</span> <span>getObjName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> objName<span>;</span>
    <span>}</span>


    <span>public</span> <span>void</span> <span>setObjName</span><span>(</span><span>String</span> objName<span>)</span> <span>{</span>
        <span>this</span><span>.</span>objName <span>=</span> objName<span>;</span>
    <span>}</span>


    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>

        <span>// 单例测试</span>
        <span>Singleton</span> firstSingleton <span>=</span> <span>Singleton</span><span>.</span>INSTANCE<span>;</span>
        firstSingleton<span>.</span><span>setObjName</span><span>(</span><span>"firstName"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>firstSingleton<span>.</span><span>getObjName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>Singleton</span> secondSingleton <span>=</span> <span>Singleton</span><span>.</span>INSTANCE<span>;</span>
        secondSingleton<span>.</span><span>setObjName</span><span>(</span><span>"secondName"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>firstSingleton<span>.</span><span>getObjName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>secondSingleton<span>.</span><span>getObjName</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>// 反射获取实例测试</span>
        <span>try</span> <span>{</span>
            <span>Singleton</span><span>[</span><span>]</span> enumConstants <span>=</span> <span>Singleton</span><span>.</span><span>class</span><span>.</span><span>getEnumConstants</span><span>(</span><span>)</span><span>;</span>
            <span>for</span> <span>(</span><span>Singleton</span> enumConstant <span>:</span> enumConstants<span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>enumConstant<span>.</span><span>getObjName</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><div><pre><code>firstName
secondName
secondName
secondName
</code></pre></div><p>该实现可以防止反射攻击。在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。</p>
<p>该实现在多次序列化和序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。</p>
<h3 id="examples" tabindex="-1"> Examples</h3>
<ul>
<li>Logger Classes</li>
<li>Configuration Classes</li>
<li>Accesing resources in shared mode</li>
<li>Factories implemented as Singletons</li>
</ul>
<h3 id="jdk" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#getRuntime%28%29" target="_blank" rel="noopener noreferrer">java.lang.Runtime#getRuntime()</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/awt/Desktop.html#getDesktop--" target="_blank" rel="noopener noreferrer">java.awt.Desktop#getDesktop()</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getSecurityManager--" target="_blank" rel="noopener noreferrer">java.lang.System#getSecurityManager()</a></li>
</ul>
<h2 id="_2-简单工厂-simple-factory" tabindex="-1"> 2. 简单工厂（Simple Factory）</h2>
<h3 id="intent-1" tabindex="-1"> Intent</h3>
<p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</p>
<h3 id="class-diagram-1" tabindex="-1"> Class Diagram</h3>
<p>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。</p>
<p>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/40c0c17e-bba6-4493-9857-147c0044a018.png"/> </div><br>
<h3 id="implementation-1" tabindex="-1"> Implementation</h3>
<div><pre><code><span>public</span> <span>interface</span> <span>Product</span> <span>{</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteProduct</span> <span>implements</span> <span>Product</span> <span>{</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteProduct1</span> <span>implements</span> <span>Product</span> <span>{</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteProduct2</span> <span>implements</span> <span>Product</span> <span>{</span>
<span>}</span>
</code></pre></div><p>以下的 Client 类包含了实例化的代码，这是一种错误的实现。如果在客户类中存在这种实例化代码，就需要考虑将代码放到简单工厂中。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span> type <span>=</span> <span>1</span><span>;</span>
        <span>Product</span> product<span>;</span>
        <span>if</span> <span>(</span>type <span>==</span> <span>1</span><span>)</span> <span>{</span>
            product <span>=</span> <span>new</span> <span>ConcreteProduct1</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>type <span>==</span> <span>2</span><span>)</span> <span>{</span>
            product <span>=</span> <span>new</span> <span>ConcreteProduct2</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            product <span>=</span> <span>new</span> <span>ConcreteProduct</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>// do something with the product</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>以下的 SimpleFactory 是简单工厂实现，它被所有需要进行实例化的客户类调用。</p>
<div><pre><code><span>public</span> <span>class</span> <span>SimpleFactory</span> <span>{</span>

    <span>public</span> <span>Product</span> <span>createProduct</span><span>(</span><span>int</span> type<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>type <span>==</span> <span>1</span><span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>ConcreteProduct1</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>type <span>==</span> <span>2</span><span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>ConcreteProduct2</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>new</span> <span>ConcreteProduct</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>SimpleFactory</span> simpleFactory <span>=</span> <span>new</span> <span>SimpleFactory</span><span>(</span><span>)</span><span>;</span>
        <span>Product</span> product <span>=</span> simpleFactory<span>.</span><span>createProduct</span><span>(</span><span>1</span><span>)</span><span>;</span>
        <span>// do something with the product</span>
    <span>}</span>
<span>}</span>
</code></pre></div><h2 id="_3-工厂方法-factory-method" tabindex="-1"> 3. 工厂方法（Factory Method）</h2>
<h3 id="intent-2" tabindex="-1"> Intent</h3>
<p>定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</p>
<h3 id="class-diagram-2" tabindex="-1"> Class Diagram</h3>
<p>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。</p>
<p>下图中，Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f4d0afd0-8e78-4914-9e60-4366eaf065b5.png"/> </div><br>
<h3 id="implementation-2" tabindex="-1"> Implementation</h3>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>Factory</span> <span>{</span>
    <span>abstract</span> <span>public</span> <span>Product</span> <span>factoryMethod</span><span>(</span><span>)</span><span>;</span>
    <span>public</span> <span>void</span> <span>doSomething</span><span>(</span><span>)</span> <span>{</span>
        <span>Product</span> product <span>=</span> <span>factoryMethod</span><span>(</span><span>)</span><span>;</span>
        <span>// do something with the product</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteFactory</span> <span>extends</span> <span>Factory</span> <span>{</span>
    <span>public</span> <span>Product</span> <span>factoryMethod</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ConcreteProduct</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteFactory1</span> <span>extends</span> <span>Factory</span> <span>{</span>
    <span>public</span> <span>Product</span> <span>factoryMethod</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ConcreteProduct1</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteFactory2</span> <span>extends</span> <span>Factory</span> <span>{</span>
    <span>public</span> <span>Product</span> <span>factoryMethod</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ConcreteProduct2</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><h3 id="jdk-1" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html#getInstance--" target="_blank" rel="noopener noreferrer">java.util.Calendar</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html#getBundle-java.lang.String-" target="_blank" rel="noopener noreferrer">java.util.ResourceBundle</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/text/NumberFormat.html#getInstance--" target="_blank" rel="noopener noreferrer">java.text.NumberFormat</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html#forName-java.lang.String-" target="_blank" rel="noopener noreferrer">java.nio.charset.Charset</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/net/URLStreamHandlerFactory.html#createURLStreamHandler-java.lang.String-" target="_blank" rel="noopener noreferrer">java.net.URLStreamHandlerFactory</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/EnumSet.html#of-E-" target="_blank" rel="noopener noreferrer">java.util.EnumSet</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/JAXBContext.html#createMarshaller--" target="_blank" rel="noopener noreferrer">javax.xml.bind.JAXBContext</a></li>
</ul>
<h2 id="_4-抽象工厂-abstract-factory" tabindex="-1"> 4. 抽象工厂（Abstract Factory）</h2>
<h3 id="intent-3" tabindex="-1"> Intent</h3>
<p>提供一个接口，用于创建   <strong>相关的对象家族</strong>  。</p>
<h3 id="class-diagram-3" tabindex="-1"> Class Diagram</h3>
<p>抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。</p>
<p>抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。</p>
<p>至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。</p>
<p>从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e2190c36-8b27-4690-bde5-9911020a1294.png"/> </div><br>
<h3 id="implementation-3" tabindex="-1"> Implementation</h3>
<div><pre><code><span>public</span> <span>class</span> <span>AbstractProductA</span> <span>{</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>AbstractProductB</span> <span>{</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ProductA1</span> <span>extends</span> <span>AbstractProductA</span> <span>{</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ProductA2</span> <span>extends</span> <span>AbstractProductA</span> <span>{</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ProductB1</span> <span>extends</span> <span>AbstractProductB</span> <span>{</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ProductB2</span> <span>extends</span> <span>AbstractProductB</span> <span>{</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>AbstractFactory</span> <span>{</span>
    <span>abstract</span> <span>AbstractProductA</span> <span>createProductA</span><span>(</span><span>)</span><span>;</span>
    <span>abstract</span> <span>AbstractProductB</span> <span>createProductB</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteFactory1</span> <span>extends</span> <span>AbstractFactory</span> <span>{</span>
    <span>AbstractProductA</span> <span>createProductA</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ProductA1</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>AbstractProductB</span> <span>createProductB</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ProductB1</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteFactory2</span> <span>extends</span> <span>AbstractFactory</span> <span>{</span>
    <span>AbstractProductA</span> <span>createProductA</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ProductA2</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>AbstractProductB</span> <span>createProductB</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ProductB2</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>AbstractFactory</span> abstractFactory <span>=</span> <span>new</span> <span>ConcreteFactory1</span><span>(</span><span>)</span><span>;</span>
        <span>AbstractProductA</span> productA <span>=</span> abstractFactory<span>.</span><span>createProductA</span><span>(</span><span>)</span><span>;</span>
        <span>AbstractProductB</span> productB <span>=</span> abstractFactory<span>.</span><span>createProductB</span><span>(</span><span>)</span><span>;</span>
        <span>// do something with productA and productB</span>
    <span>}</span>
<span>}</span>
</code></pre></div><h3 id="jdk-2" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/parsers/DocumentBuilderFactory.html" target="_blank" rel="noopener noreferrer">javax.xml.parsers.DocumentBuilderFactory</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/transform/TransformerFactory.html#newInstance--" target="_blank" rel="noopener noreferrer">javax.xml.transform.TransformerFactory</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/xpath/XPathFactory.html#newInstance--" target="_blank" rel="noopener noreferrer">javax.xml.xpath.XPathFactory</a></li>
</ul>
<h2 id="_5-生成器-builder" tabindex="-1"> 5. 生成器（Builder）</h2>
<h3 id="intent-4" tabindex="-1"> Intent</h3>
<p>封装一个对象的构造过程，并允许按步骤构造。</p>
<h3 id="class-diagram-4" tabindex="-1"> Class Diagram</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/db5e376d-0b3e-490e-a43a-3231914b6668.png"/> </div><br>
<h3 id="implementation-4" tabindex="-1"> Implementation</h3>
<p>以下是一个简易的 StringBuilder 实现，参考了 JDK 1.8 源码。</p>
<div><pre><code><span>public</span> <span>class</span> <span>AbstractStringBuilder</span> <span>{</span>
    <span>protected</span> <span>char</span><span>[</span><span>]</span> value<span>;</span>

    <span>protected</span> <span>int</span> count<span>;</span>

    <span>public</span> <span>AbstractStringBuilder</span><span>(</span><span>int</span> capacity<span>)</span> <span>{</span>
        count <span>=</span> <span>0</span><span>;</span>
        value <span>=</span> <span>new</span> <span>char</span><span>[</span>capacity<span>]</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>AbstractStringBuilder</span> <span>append</span><span>(</span><span>char</span> c<span>)</span> <span>{</span>
        <span>ensureCapacityInternal</span><span>(</span>count <span>+</span> <span>1</span><span>)</span><span>;</span>
        value<span>[</span>count<span>++</span><span>]</span> <span>=</span> c<span>;</span>
        <span>return</span> <span>this</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>ensureCapacityInternal</span><span>(</span><span>int</span> minimumCapacity<span>)</span> <span>{</span>
        <span>// overflow-conscious code</span>
        <span>if</span> <span>(</span>minimumCapacity <span>-</span> value<span>.</span>length <span>></span> <span>0</span><span>)</span>
            <span>expandCapacity</span><span>(</span>minimumCapacity<span>)</span><span>;</span>
    <span>}</span>

    <span>void</span> <span>expandCapacity</span><span>(</span><span>int</span> minimumCapacity<span>)</span> <span>{</span>
        <span>int</span> newCapacity <span>=</span> value<span>.</span>length <span>*</span> <span>2</span> <span>+</span> <span>2</span><span>;</span>
        <span>if</span> <span>(</span>newCapacity <span>-</span> minimumCapacity <span>&lt;</span> <span>0</span><span>)</span>
            newCapacity <span>=</span> minimumCapacity<span>;</span>
        <span>if</span> <span>(</span>newCapacity <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>minimumCapacity <span>&lt;</span> <span>0</span><span>)</span> <span>// overflow</span>
                <span>throw</span> <span>new</span> <span>OutOfMemoryError</span><span>(</span><span>)</span><span>;</span>
            newCapacity <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>;</span>
        <span>}</span>
        value <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>value<span>,</span> newCapacity<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>StringBuilder</span> <span>extends</span> <span>AbstractStringBuilder</span> <span>{</span>
    <span>public</span> <span>StringBuilder</span><span>(</span><span>)</span> <span>{</span>
        <span>super</span><span>(</span><span>16</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>
        <span>// Create a copy, don't share the array</span>
        <span>return</span> <span>new</span> <span>String</span><span>(</span>value<span>,</span> <span>0</span><span>,</span> count<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>StringBuilder</span> sb <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
        <span>final</span> <span>int</span> count <span>=</span> <span>26</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> count<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            sb<span>.</span><span>append</span><span>(</span><span>(</span><span>char</span><span>)</span> <span>(</span><span>'a'</span> <span>+</span> i<span>)</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>sb<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code>abcdefghijklmnopqrstuvwxyz
</code></pre></div><h3 id="jdk-3" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" target="_blank" rel="noopener noreferrer">java.lang.StringBuilder</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html#put-byte-" target="_blank" rel="noopener noreferrer">java.nio.ByteBuffer</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#append-boolean-" target="_blank" rel="noopener noreferrer">java.lang.StringBuffer</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Appendable.html" target="_blank" rel="noopener noreferrer">java.lang.Appendable</a></li>
<li><a href="https://github.com/apache/camel/tree/0e195428ee04531be27a0b659005e3aa8d159d23/camel-core/src/main/java/org/apache/camel/builder" target="_blank" rel="noopener noreferrer">Apache Camel builders</a></li>
</ul>
<h2 id="_6-原型模式-prototype" tabindex="-1"> 6. 原型模式（Prototype）</h2>
<h3 id="intent-5" tabindex="-1"> Intent</h3>
<p>使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。</p>
<h3 id="class-diagram-5" tabindex="-1"> Class Diagram</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b8922f8c-95e6-4187-be85-572a509afb71.png"/> </div><br>
<h3 id="implementation-5" tabindex="-1"> Implementation</h3>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>Prototype</span> <span>{</span>
    <span>abstract</span> <span>Prototype</span> <span>myClone</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcretePrototype</span> <span>extends</span> <span>Prototype</span> <span>{</span>

    <span>private</span> <span>String</span> filed<span>;</span>

    <span>public</span> <span>ConcretePrototype</span><span>(</span><span>String</span> filed<span>)</span> <span>{</span>
        <span>this</span><span>.</span>filed <span>=</span> filed<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>Prototype</span> <span>myClone</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ConcretePrototype</span><span>(</span>filed<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> filed<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Prototype</span> prototype <span>=</span> <span>new</span> <span>ConcretePrototype</span><span>(</span><span>"abc"</span><span>)</span><span>;</span>
        <span>Prototype</span> clone <span>=</span> prototype<span>.</span><span>myClone</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>clone<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code>abc
</code></pre></div><h3 id="jdk-4" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone%28%29" target="_blank" rel="noopener noreferrer">java.lang.Object#clone()</a></li>
</ul>
<h1 id="三、行为型" tabindex="-1"> 三、行为型</h1>
<h2 id="_1-责任链-chain-of-responsibility" tabindex="-1"> 1. 责任链（Chain Of Responsibility）</h2>
<h3 id="intent-6" tabindex="-1"> Intent</h3>
<p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。</p>
<h3 id="class-diagram-6" tabindex="-1"> Class Diagram</h3>
<ul>
<li>Handler：定义处理请求的接口，并且实现后继链（successor）</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ca9f23bf-55a4-47b2-9534-a28e35397988.png"/> </div><br>
<h3 id="implementation-6" tabindex="-1"> Implementation</h3>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>Handler</span> <span>{</span>

    <span>protected</span> <span>Handler</span> successor<span>;</span>


    <span>public</span> <span>Handler</span><span>(</span><span>Handler</span> successor<span>)</span> <span>{</span>
        <span>this</span><span>.</span>successor <span>=</span> successor<span>;</span>
    <span>}</span>


    <span>protected</span> <span>abstract</span> <span>void</span> <span>handleRequest</span><span>(</span><span>Request</span> request<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteHandler1</span> <span>extends</span> <span>Handler</span> <span>{</span>

    <span>public</span> <span>ConcreteHandler1</span><span>(</span><span>Handler</span> successor<span>)</span> <span>{</span>
        <span>super</span><span>(</span>successor<span>)</span><span>;</span>
    <span>}</span>


    <span>@Override</span>
    <span>protected</span> <span>void</span> <span>handleRequest</span><span>(</span><span>Request</span> request<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>request<span>.</span><span>getType</span><span>(</span><span>)</span> <span>==</span> <span>RequestType</span><span>.</span>TYPE1<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>request<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>" is handle by ConcreteHandler1"</span><span>)</span><span>;</span>
            <span>return</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>successor <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            successor<span>.</span><span>handleRequest</span><span>(</span>request<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteHandler2</span> <span>extends</span> <span>Handler</span> <span>{</span>

    <span>public</span> <span>ConcreteHandler2</span><span>(</span><span>Handler</span> successor<span>)</span> <span>{</span>
        <span>super</span><span>(</span>successor<span>)</span><span>;</span>
    <span>}</span>


    <span>@Override</span>
    <span>protected</span> <span>void</span> <span>handleRequest</span><span>(</span><span>Request</span> request<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>request<span>.</span><span>getType</span><span>(</span><span>)</span> <span>==</span> <span>RequestType</span><span>.</span>TYPE2<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>request<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>" is handle by ConcreteHandler2"</span><span>)</span><span>;</span>
            <span>return</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>successor <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            successor<span>.</span><span>handleRequest</span><span>(</span>request<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Request</span> <span>{</span>

    <span>private</span> <span>RequestType</span> type<span>;</span>
    <span>private</span> <span>String</span> name<span>;</span>


    <span>public</span> <span>Request</span><span>(</span><span>RequestType</span> type<span>,</span> <span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>type <span>=</span> type<span>;</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>


    <span>public</span> <span>RequestType</span> <span>getType</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> type<span>;</span>
    <span>}</span>


    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>
<span>}</span>

</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><div><pre><code><span>public</span> <span>enum</span> <span>RequestType</span> <span>{</span>
    TYPE1<span>,</span> TYPE2
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>

        <span>Handler</span> handler1 <span>=</span> <span>new</span> <span>ConcreteHandler1</span><span>(</span><span>null</span><span>)</span><span>;</span>
        <span>Handler</span> handler2 <span>=</span> <span>new</span> <span>ConcreteHandler2</span><span>(</span>handler1<span>)</span><span>;</span>

        <span>Request</span> request1 <span>=</span> <span>new</span> <span>Request</span><span>(</span><span>RequestType</span><span>.</span>TYPE1<span>,</span> <span>"request1"</span><span>)</span><span>;</span>
        handler2<span>.</span><span>handleRequest</span><span>(</span>request1<span>)</span><span>;</span>

        <span>Request</span> request2 <span>=</span> <span>new</span> <span>Request</span><span>(</span><span>RequestType</span><span>.</span>TYPE2<span>,</span> <span>"request2"</span><span>)</span><span>;</span>
        handler2<span>.</span><span>handleRequest</span><span>(</span>request2<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code>request1 is handle by ConcreteHandler1
request2 is handle by ConcreteHandler2
</code></pre></div><h3 id="jdk-5" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/logging/Logger.html#log%28java.util.logging.Level,%20java.lang.String%29" target="_blank" rel="noopener noreferrer">java.util.logging.Logger#log()</a></li>
<li><a href="https://commons.apache.org/proper/commons-chain/index.html" target="_blank" rel="noopener noreferrer">Apache Commons Chain</a></li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/Filter.html#doFilter-javax.servlet.ServletRequest-javax.servlet.ServletResponse-javax.servlet.FilterChain-" target="_blank" rel="noopener noreferrer">javax.servlet.Filter#doFilter()</a></li>
</ul>
<h2 id="_2-命令-command" tabindex="-1"> 2. 命令（Command）</h2>
<h3 id="intent-7" tabindex="-1"> Intent</h3>
<p>将命令封装成对象中，具有以下作用：</p>
<ul>
<li>使用命令来参数化其它对象</li>
<li>将命令放入队列中进行排队</li>
<li>将命令的操作记录到日志中</li>
<li>支持可撤销的操作</li>
</ul>
<h3 id="class-diagram-7" tabindex="-1"> Class Diagram</h3>
<ul>
<li>Command：命令</li>
<li>Receiver：命令接收者，也就是命令真正的执行者</li>
<li>Invoker：通过它来调用命令</li>
<li>Client：可以设置命令与命令的接收者</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c44a0342-f405-4f17-b750-e27cf4aadde2.png"/> </div><br>
<h3 id="implementation-7" tabindex="-1"> Implementation</h3>
<p>设计一个遥控器，可以控制电灯开关。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e6bded8e-41a0-489a-88a6-638e88ab7666.jpg"/> </div><br>
<div><pre><code><span>public</span> <span>interface</span> <span>Command</span> <span>{</span>
    <span>void</span> <span>execute</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>LightOnCommand</span> <span>implements</span> <span>Command</span> <span>{</span>
    <span>Light</span> light<span>;</span>

    <span>public</span> <span>LightOnCommand</span><span>(</span><span>Light</span> light<span>)</span> <span>{</span>
        <span>this</span><span>.</span>light <span>=</span> light<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>execute</span><span>(</span><span>)</span> <span>{</span>
        light<span>.</span><span>on</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>LightOffCommand</span> <span>implements</span> <span>Command</span> <span>{</span>
    <span>Light</span> light<span>;</span>

    <span>public</span> <span>LightOffCommand</span><span>(</span><span>Light</span> light<span>)</span> <span>{</span>
        <span>this</span><span>.</span>light <span>=</span> light<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>execute</span><span>(</span><span>)</span> <span>{</span>
        light<span>.</span><span>off</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Light</span> <span>{</span>

    <span>public</span> <span>void</span> <span>on</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Light is on!"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>off</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Light is off!"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>/**
 * 遥控器
 */</span>
<span>public</span> <span>class</span> <span>Invoker</span> <span>{</span>
    <span>private</span> <span>Command</span><span>[</span><span>]</span> onCommands<span>;</span>
    <span>private</span> <span>Command</span><span>[</span><span>]</span> offCommands<span>;</span>
    <span>private</span> <span>final</span> <span>int</span> slotNum <span>=</span> <span>7</span><span>;</span>

    <span>public</span> <span>Invoker</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>onCommands <span>=</span> <span>new</span> <span>Command</span><span>[</span>slotNum<span>]</span><span>;</span>
        <span>this</span><span>.</span>offCommands <span>=</span> <span>new</span> <span>Command</span><span>[</span>slotNum<span>]</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setOnCommand</span><span>(</span><span>Command</span> command<span>,</span> <span>int</span> slot<span>)</span> <span>{</span>
        onCommands<span>[</span>slot<span>]</span> <span>=</span> command<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setOffCommand</span><span>(</span><span>Command</span> command<span>,</span> <span>int</span> slot<span>)</span> <span>{</span>
        offCommands<span>[</span>slot<span>]</span> <span>=</span> command<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>onButtonWasPushed</span><span>(</span><span>int</span> slot<span>)</span> <span>{</span>
        onCommands<span>[</span>slot<span>]</span><span>.</span><span>execute</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>offButtonWasPushed</span><span>(</span><span>int</span> slot<span>)</span> <span>{</span>
        offCommands<span>[</span>slot<span>]</span><span>.</span><span>execute</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Invoker</span> invoker <span>=</span> <span>new</span> <span>Invoker</span><span>(</span><span>)</span><span>;</span>
        <span>Light</span> light <span>=</span> <span>new</span> <span>Light</span><span>(</span><span>)</span><span>;</span>
        <span>Command</span> lightOnCommand <span>=</span> <span>new</span> <span>LightOnCommand</span><span>(</span>light<span>)</span><span>;</span>
        <span>Command</span> lightOffCommand <span>=</span> <span>new</span> <span>LightOffCommand</span><span>(</span>light<span>)</span><span>;</span>
        invoker<span>.</span><span>setOnCommand</span><span>(</span>lightOnCommand<span>,</span> <span>0</span><span>)</span><span>;</span>
        invoker<span>.</span><span>setOffCommand</span><span>(</span>lightOffCommand<span>,</span> <span>0</span><span>)</span><span>;</span>
        invoker<span>.</span><span>onButtonWasPushed</span><span>(</span><span>0</span><span>)</span><span>;</span>
        invoker<span>.</span><span>offButtonWasPushed</span><span>(</span><span>0</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="jdk-6" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html" target="_blank" rel="noopener noreferrer">java.lang.Runnable</a></li>
<li><a href="https://github.com/Netflix/Hystrix/wiki" target="_blank" rel="noopener noreferrer">Netflix Hystrix</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/swing/Action.html" target="_blank" rel="noopener noreferrer">javax.swing.Action</a></li>
</ul>
<h2 id="_3-解释器-interpreter" tabindex="-1"> 3. 解释器（Interpreter）</h2>
<h3 id="intent-8" tabindex="-1"> Intent</h3>
<p>为语言创建解释器，通常由语言的语法和语法分析来定义。</p>
<h3 id="class-diagram-8" tabindex="-1"> Class Diagram</h3>
<ul>
<li>TerminalExpression：终结符表达式，每个终结符都需要一个 TerminalExpression。</li>
<li>Context：上下文，包含解释器之外的一些全局信息。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2b125bcd-1b36-43be-9b78-d90b076be549.png"/> </div><br>
<h3 id="implementation-8" tabindex="-1"> Implementation</h3>
<p>以下是一个规则检验器实现，具有 and 和 or 规则，通过规则可以构建一颗解析树，用来检验一个文本是否满足解析树定义的规则。</p>
<p>例如一颗解析树为 D And (A Or (B C))，文本 &quot;D A&quot; 满足该解析树定义的规则。</p>
<p>这里的 Context 指的是 String。</p>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>Expression</span> <span>{</span>
    <span>public</span> <span>abstract</span> <span>boolean</span> <span>interpret</span><span>(</span><span>String</span> str<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>TerminalExpression</span> <span>extends</span> <span>Expression</span> <span>{</span>

    <span>private</span> <span>String</span> literal <span>=</span> <span>null</span><span>;</span>

    <span>public</span> <span>TerminalExpression</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
        literal <span>=</span> str<span>;</span>
    <span>}</span>

    <span>public</span> <span>boolean</span> <span>interpret</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
        <span>StringTokenizer</span> st <span>=</span> <span>new</span> <span>StringTokenizer</span><span>(</span>str<span>)</span><span>;</span>
        <span>while</span> <span>(</span>st<span>.</span><span>hasMoreTokens</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>String</span> test <span>=</span> st<span>.</span><span>nextToken</span><span>(</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>test<span>.</span><span>equals</span><span>(</span>literal<span>)</span><span>)</span> <span>{</span>
                <span>return</span> <span>true</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>AndExpression</span> <span>extends</span> <span>Expression</span> <span>{</span>

    <span>private</span> <span>Expression</span> expression1 <span>=</span> <span>null</span><span>;</span>
    <span>private</span> <span>Expression</span> expression2 <span>=</span> <span>null</span><span>;</span>

    <span>public</span> <span>AndExpression</span><span>(</span><span>Expression</span> expression1<span>,</span> <span>Expression</span> expression2<span>)</span> <span>{</span>
        <span>this</span><span>.</span>expression1 <span>=</span> expression1<span>;</span>
        <span>this</span><span>.</span>expression2 <span>=</span> expression2<span>;</span>
    <span>}</span>

    <span>public</span> <span>boolean</span> <span>interpret</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
        <span>return</span> expression1<span>.</span><span>interpret</span><span>(</span>str<span>)</span> <span>&amp;&amp;</span> expression2<span>.</span><span>interpret</span><span>(</span>str<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>OrExpression</span> <span>extends</span> <span>Expression</span> <span>{</span>
    <span>private</span> <span>Expression</span> expression1 <span>=</span> <span>null</span><span>;</span>
    <span>private</span> <span>Expression</span> expression2 <span>=</span> <span>null</span><span>;</span>

    <span>public</span> <span>OrExpression</span><span>(</span><span>Expression</span> expression1<span>,</span> <span>Expression</span> expression2<span>)</span> <span>{</span>
        <span>this</span><span>.</span>expression1 <span>=</span> expression1<span>;</span>
        <span>this</span><span>.</span>expression2 <span>=</span> expression2<span>;</span>
    <span>}</span>

    <span>public</span> <span>boolean</span> <span>interpret</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
        <span>return</span> expression1<span>.</span><span>interpret</span><span>(</span>str<span>)</span> <span>||</span> expression2<span>.</span><span>interpret</span><span>(</span>str<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>/**
     * 构建解析树
     */</span>
    <span>public</span> <span>static</span> <span>Expression</span> <span>buildInterpreterTree</span><span>(</span><span>)</span> <span>{</span>
        <span>// Literal</span>
        <span>Expression</span> terminal1 <span>=</span> <span>new</span> <span>TerminalExpression</span><span>(</span><span>"A"</span><span>)</span><span>;</span>
        <span>Expression</span> terminal2 <span>=</span> <span>new</span> <span>TerminalExpression</span><span>(</span><span>"B"</span><span>)</span><span>;</span>
        <span>Expression</span> terminal3 <span>=</span> <span>new</span> <span>TerminalExpression</span><span>(</span><span>"C"</span><span>)</span><span>;</span>
        <span>Expression</span> terminal4 <span>=</span> <span>new</span> <span>TerminalExpression</span><span>(</span><span>"D"</span><span>)</span><span>;</span>
        <span>// B C</span>
        <span>Expression</span> alternation1 <span>=</span> <span>new</span> <span>OrExpression</span><span>(</span>terminal2<span>,</span> terminal3<span>)</span><span>;</span>
        <span>// A Or (B C)</span>
        <span>Expression</span> alternation2 <span>=</span> <span>new</span> <span>OrExpression</span><span>(</span>terminal1<span>,</span> alternation1<span>)</span><span>;</span>
        <span>// D And (A Or (B C))</span>
        <span>return</span> <span>new</span> <span>AndExpression</span><span>(</span>terminal4<span>,</span> alternation2<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Expression</span> define <span>=</span> <span>buildInterpreterTree</span><span>(</span><span>)</span><span>;</span>
        <span>String</span> context1 <span>=</span> <span>"D A"</span><span>;</span>
        <span>String</span> context2 <span>=</span> <span>"A B"</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>define<span>.</span><span>interpret</span><span>(</span>context1<span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>define<span>.</span><span>interpret</span><span>(</span>context2<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><div><pre><code>true
false
</code></pre></div><h3 id="jdk-7" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html" target="_blank" rel="noopener noreferrer">java.util.Pattern</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/text/Normalizer.html" target="_blank" rel="noopener noreferrer">java.text.Normalizer</a></li>
<li>All subclasses of <a href="http://docs.oracle.com/javase/8/docs/api/java/text/Format.html" target="_blank" rel="noopener noreferrer">java.text.Format</a></li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/el/ELResolver.html" target="_blank" rel="noopener noreferrer">javax.el.ELResolver</a></li>
</ul>
<h2 id="_4-迭代器-iterator" tabindex="-1"> 4. 迭代器（Iterator）</h2>
<h3 id="intent-9" tabindex="-1"> Intent</h3>
<p>提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。</p>
<h3 id="class-diagram-9" tabindex="-1"> Class Diagram</h3>
<ul>
<li>Aggregate 是聚合类，其中 createIterator() 方法可以产生一个 Iterator；</li>
<li>Iterator 主要定义了 hasNext() 和 next() 方法。</li>
<li>Client 组合了 Aggregate，为了迭代遍历 Aggregate，也需要组合 Iterator。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/89292ae1-5f13-44dc-b508-3f035e80bf89.png"/> </div><br>
<h3 id="implementation-9" tabindex="-1"> Implementation</h3>
<div><pre><code><span>public</span> <span>interface</span> <span>Aggregate</span> <span>{</span>
    <span>Iterator</span> <span>createIterator</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteAggregate</span> <span>implements</span> <span>Aggregate</span> <span>{</span>

    <span>private</span> <span>Integer</span><span>[</span><span>]</span> items<span>;</span>

    <span>public</span> <span>ConcreteAggregate</span><span>(</span><span>)</span> <span>{</span>
        items <span>=</span> <span>new</span> <span>Integer</span><span>[</span><span>10</span><span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> items<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            items<span>[</span>i<span>]</span> <span>=</span> i<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>Iterator</span> <span>createIterator</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ConcreteIterator</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span>items<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><div><pre><code><span>public</span> <span>interface</span> <span>Iterator</span><span><span>&lt;</span><span>Item</span><span>></span></span> <span>{</span>

    <span>Item</span> <span>next</span><span>(</span><span>)</span><span>;</span>

    <span>boolean</span> <span>hasNext</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteIterator</span><span><span>&lt;</span><span>Item</span><span>></span></span> <span>implements</span> <span>Iterator</span> <span>{</span>

    <span>private</span> <span>Item</span><span>[</span><span>]</span> items<span>;</span>
    <span>private</span> <span>int</span> position <span>=</span> <span>0</span><span>;</span>

    <span>public</span> <span>ConcreteIterator</span><span>(</span><span>Item</span><span>[</span><span>]</span> items<span>)</span> <span>{</span>
        <span>this</span><span>.</span>items <span>=</span> items<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>Object</span> <span>next</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> items<span>[</span>position<span>++</span><span>]</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>boolean</span> <span>hasNext</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> position <span>&lt;</span> items<span>.</span>length<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Aggregate</span> aggregate <span>=</span> <span>new</span> <span>ConcreteAggregate</span><span>(</span><span>)</span><span>;</span>
        <span>Iterator</span><span><span>&lt;</span><span>Integer</span><span>></span></span> iterator <span>=</span> aggregate<span>.</span><span>createIterator</span><span>(</span><span>)</span><span>;</span>
        <span>while</span> <span>(</span>iterator<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="jdk-8" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html" target="_blank" rel="noopener noreferrer">java.util.Iterator</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html" target="_blank" rel="noopener noreferrer">java.util.Enumeration</a></li>
</ul>
<h2 id="_5-中介者-mediator" tabindex="-1"> 5. 中介者（Mediator）</h2>
<h3 id="intent-10" tabindex="-1"> Intent</h3>
<p>集中相关对象之间复杂的沟通和控制方式。</p>
<h3 id="class-diagram-10" tabindex="-1"> Class Diagram</h3>
<ul>
<li>Mediator：中介者，定义一个接口用于与各同事（Colleague）对象通信。</li>
<li>Colleague：同事，相关对象</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/30d6e95c-2e3c-4d32-bf4f-68128a70bc05.png"/> </div><br>
<h3 id="implementation-10" tabindex="-1"> Implementation</h3>
<p>Alarm（闹钟）、CoffeePot（咖啡壶）、Calendar（日历）、Sprinkler（喷头）是一组相关的对象，在某个对象的事件产生时需要去操作其它对象，形成了下面这种依赖结构：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/82cfda3b-b53b-4c89-9fdb-26dd2db0cd02.jpg"/> </div><br>
<p>使用中介者模式可以将复杂的依赖结构变成星形结构：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5359cbf5-5a79-4874-9b17-f23c53c2cb80.jpg"/> </div><br>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>Colleague</span> <span>{</span>
    <span>public</span> <span>abstract</span> <span>void</span> <span>onEvent</span><span>(</span><span>Mediator</span> mediator<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Alarm</span> <span>extends</span> <span>Colleague</span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>onEvent</span><span>(</span><span>Mediator</span> mediator<span>)</span> <span>{</span>
        mediator<span>.</span><span>doEvent</span><span>(</span><span>"alarm"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>doAlarm</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"doAlarm()"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>CoffeePot</span> <span>extends</span> <span>Colleague</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>onEvent</span><span>(</span><span>Mediator</span> mediator<span>)</span> <span>{</span>
        mediator<span>.</span><span>doEvent</span><span>(</span><span>"coffeePot"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>doCoffeePot</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"doCoffeePot()"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Calender</span> <span>extends</span> <span>Colleague</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>onEvent</span><span>(</span><span>Mediator</span> mediator<span>)</span> <span>{</span>
        mediator<span>.</span><span>doEvent</span><span>(</span><span>"calender"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>doCalender</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"doCalender()"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Sprinkler</span> <span>extends</span> <span>Colleague</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>onEvent</span><span>(</span><span>Mediator</span> mediator<span>)</span> <span>{</span>
        mediator<span>.</span><span>doEvent</span><span>(</span><span>"sprinkler"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>doSprinkler</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"doSprinkler()"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>Mediator</span> <span>{</span>
    <span>public</span> <span>abstract</span> <span>void</span> <span>doEvent</span><span>(</span><span>String</span> eventType<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteMediator</span> <span>extends</span> <span>Mediator</span> <span>{</span>
    <span>private</span> <span>Alarm</span> alarm<span>;</span>
    <span>private</span> <span>CoffeePot</span> coffeePot<span>;</span>
    <span>private</span> <span>Calender</span> calender<span>;</span>
    <span>private</span> <span>Sprinkler</span> sprinkler<span>;</span>

    <span>public</span> <span>ConcreteMediator</span><span>(</span><span>Alarm</span> alarm<span>,</span> <span>CoffeePot</span> coffeePot<span>,</span> <span>Calender</span> calender<span>,</span> <span>Sprinkler</span> sprinkler<span>)</span> <span>{</span>
        <span>this</span><span>.</span>alarm <span>=</span> alarm<span>;</span>
        <span>this</span><span>.</span>coffeePot <span>=</span> coffeePot<span>;</span>
        <span>this</span><span>.</span>calender <span>=</span> calender<span>;</span>
        <span>this</span><span>.</span>sprinkler <span>=</span> sprinkler<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>doEvent</span><span>(</span><span>String</span> eventType<span>)</span> <span>{</span>
        <span>switch</span> <span>(</span>eventType<span>)</span> <span>{</span>
            <span>case</span> <span>"alarm"</span><span>:</span>
                <span>doAlarmEvent</span><span>(</span><span>)</span><span>;</span>
                <span>break</span><span>;</span>
            <span>case</span> <span>"coffeePot"</span><span>:</span>
                <span>doCoffeePotEvent</span><span>(</span><span>)</span><span>;</span>
                <span>break</span><span>;</span>
            <span>case</span> <span>"calender"</span><span>:</span>
                <span>doCalenderEvent</span><span>(</span><span>)</span><span>;</span>
                <span>break</span><span>;</span>
            <span>default</span><span>:</span>
                <span>doSprinklerEvent</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>doAlarmEvent</span><span>(</span><span>)</span> <span>{</span>
        alarm<span>.</span><span>doAlarm</span><span>(</span><span>)</span><span>;</span>
        coffeePot<span>.</span><span>doCoffeePot</span><span>(</span><span>)</span><span>;</span>
        calender<span>.</span><span>doCalender</span><span>(</span><span>)</span><span>;</span>
        sprinkler<span>.</span><span>doSprinkler</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>doCoffeePotEvent</span><span>(</span><span>)</span> <span>{</span>
        <span>// ...</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>doCalenderEvent</span><span>(</span><span>)</span> <span>{</span>
        <span>// ...</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>doSprinklerEvent</span><span>(</span><span>)</span> <span>{</span>
        <span>// ...</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Alarm</span> alarm <span>=</span> <span>new</span> <span>Alarm</span><span>(</span><span>)</span><span>;</span>
        <span>CoffeePot</span> coffeePot <span>=</span> <span>new</span> <span>CoffeePot</span><span>(</span><span>)</span><span>;</span>
        <span>Calender</span> calender <span>=</span> <span>new</span> <span>Calender</span><span>(</span><span>)</span><span>;</span>
        <span>Sprinkler</span> sprinkler <span>=</span> <span>new</span> <span>Sprinkler</span><span>(</span><span>)</span><span>;</span>
        <span>Mediator</span> mediator <span>=</span> <span>new</span> <span>ConcreteMediator</span><span>(</span>alarm<span>,</span> coffeePot<span>,</span> calender<span>,</span> sprinkler<span>)</span><span>;</span>
        <span>// 闹钟事件到达，调用中介者就可以操作相关对象</span>
        alarm<span>.</span><span>onEvent</span><span>(</span>mediator<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>doAlarm</span><span>(</span><span>)</span>
<span>doCoffeePot</span><span>(</span><span>)</span>
<span>doCalender</span><span>(</span><span>)</span>
<span>doSprinkler</span><span>(</span><span>)</span>
</code></pre></div><h3 id="jdk-9" tabindex="-1"> JDK</h3>
<ul>
<li>All scheduleXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Timer.html" target="_blank" rel="noopener noreferrer">java.util.Timer</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html#execute-java.lang.Runnable-" target="_blank" rel="noopener noreferrer">java.util.concurrent.Executor#execute()</a></li>
<li>submit() and invokeXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html" target="_blank" rel="noopener noreferrer">java.util.concurrent.ExecutorService</a></li>
<li>scheduleXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html" target="_blank" rel="noopener noreferrer">java.util.concurrent.ScheduledExecutorService</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-" target="_blank" rel="noopener noreferrer">java.lang.reflect.Method#invoke()</a></li>
</ul>
<h2 id="_6-备忘录-memento" tabindex="-1"> 6. 备忘录（Memento）</h2>
<h3 id="intent-11" tabindex="-1"> Intent</h3>
<p>在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。</p>
<h3 id="class-diagram-11" tabindex="-1"> Class Diagram</h3>
<ul>
<li>Originator：原始对象</li>
<li>Caretaker：负责保存好备忘录</li>
<li>Menento：备忘录，存储原始对象的的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许 Originator 访问本备忘录的内部状态。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/50678f34-694f-45a4-91c6-34d985c83fee.png"/> </div><br>
<h3 id="implementation-11" tabindex="-1"> Implementation</h3>
<p>以下实现了一个简单计算器程序，可以输入两个值，然后计算这两个值的和。备忘录模式允许将这两个值存储起来，然后在某个时刻用存储的状态进行恢复。</p>
<p>实现参考：<a href="https://www.oodesign.com/memento-pattern-calculator-example-java-sourcecode.html" target="_blank" rel="noopener noreferrer">Memento Pattern - Calculator Example - Java Sourcecode</a></p>
<div><pre><code><span>/**
 * Originator Interface
 */</span>
<span>public</span> <span>interface</span> <span>Calculator</span> <span>{</span>

    <span>// Create Memento</span>
    <span>PreviousCalculationToCareTaker</span> <span>backupLastCalculation</span><span>(</span><span>)</span><span>;</span>

    <span>// setMemento</span>
    <span>void</span> <span>restorePreviousCalculation</span><span>(</span><span>PreviousCalculationToCareTaker</span> memento<span>)</span><span>;</span>

    <span>int</span> <span>getCalculationResult</span><span>(</span><span>)</span><span>;</span>

    <span>void</span> <span>setFirstNumber</span><span>(</span><span>int</span> firstNumber<span>)</span><span>;</span>

    <span>void</span> <span>setSecondNumber</span><span>(</span><span>int</span> secondNumber<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><pre><code><span>/**
 * Originator Implementation
 */</span>
<span>public</span> <span>class</span> <span>CalculatorImp</span> <span>implements</span> <span>Calculator</span> <span>{</span>

    <span>private</span> <span>int</span> firstNumber<span>;</span>
    <span>private</span> <span>int</span> secondNumber<span>;</span>

    <span>@Override</span>
    <span>public</span> <span>PreviousCalculationToCareTaker</span> <span>backupLastCalculation</span><span>(</span><span>)</span> <span>{</span>
        <span>// create a memento object used for restoring two numbers</span>
        <span>return</span> <span>new</span> <span>PreviousCalculationImp</span><span>(</span>firstNumber<span>,</span> secondNumber<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>restorePreviousCalculation</span><span>(</span><span>PreviousCalculationToCareTaker</span> memento<span>)</span> <span>{</span>
        <span>this</span><span>.</span>firstNumber <span>=</span> <span>(</span><span>(</span><span>PreviousCalculationToOriginator</span><span>)</span> memento<span>)</span><span>.</span><span>getFirstNumber</span><span>(</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>secondNumber <span>=</span> <span>(</span><span>(</span><span>PreviousCalculationToOriginator</span><span>)</span> memento<span>)</span><span>.</span><span>getSecondNumber</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>int</span> <span>getCalculationResult</span><span>(</span><span>)</span> <span>{</span>
        <span>// result is adding two numbers</span>
        <span>return</span> firstNumber <span>+</span> secondNumber<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>setFirstNumber</span><span>(</span><span>int</span> firstNumber<span>)</span> <span>{</span>
        <span>this</span><span>.</span>firstNumber <span>=</span> firstNumber<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>setSecondNumber</span><span>(</span><span>int</span> secondNumber<span>)</span> <span>{</span>
        <span>this</span><span>.</span>secondNumber <span>=</span> secondNumber<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><div><pre><code><span>/**
 * Memento Interface to Originator
 *
 * This interface allows the originator to restore its state
 */</span>
<span>public</span> <span>interface</span> <span>PreviousCalculationToOriginator</span> <span>{</span>
    <span>int</span> <span>getFirstNumber</span><span>(</span><span>)</span><span>;</span>
    <span>int</span> <span>getSecondNumber</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>/**
 *  Memento interface to CalculatorOperator (Caretaker)
 */</span>
<span>public</span> <span>interface</span> <span>PreviousCalculationToCareTaker</span> <span>{</span>
    <span>// no operations permitted for the caretaker</span>
<span>}</span>
</code></pre></div><div><pre><code><span>/**
 * Memento Object Implementation
 * <span><span><span>&lt;</span>p</span><span>></span></span>
 * Note that this object implements both interfaces to Originator and CareTaker
 */</span>
<span>public</span> <span>class</span> <span>PreviousCalculationImp</span> <span>implements</span> <span>PreviousCalculationToCareTaker</span><span>,</span>
        <span>PreviousCalculationToOriginator</span> <span>{</span>

    <span>private</span> <span>int</span> firstNumber<span>;</span>
    <span>private</span> <span>int</span> secondNumber<span>;</span>

    <span>public</span> <span>PreviousCalculationImp</span><span>(</span><span>int</span> firstNumber<span>,</span> <span>int</span> secondNumber<span>)</span> <span>{</span>
        <span>this</span><span>.</span>firstNumber <span>=</span> firstNumber<span>;</span>
        <span>this</span><span>.</span>secondNumber <span>=</span> secondNumber<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>int</span> <span>getFirstNumber</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> firstNumber<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>int</span> <span>getSecondNumber</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> secondNumber<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><div><pre><code><span>/**
 * CareTaker object
 */</span>
<span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// program starts</span>
        <span>Calculator</span> calculator <span>=</span> <span>new</span> <span>CalculatorImp</span><span>(</span><span>)</span><span>;</span>

        <span>// assume user enters two numbers</span>
        calculator<span>.</span><span>setFirstNumber</span><span>(</span><span>10</span><span>)</span><span>;</span>
        calculator<span>.</span><span>setSecondNumber</span><span>(</span><span>100</span><span>)</span><span>;</span>

        <span>// find result</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>calculator<span>.</span><span>getCalculationResult</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>// Store result of this calculation in case of error</span>
        <span>PreviousCalculationToCareTaker</span> memento <span>=</span> calculator<span>.</span><span>backupLastCalculation</span><span>(</span><span>)</span><span>;</span>

        <span>// user enters a number</span>
        calculator<span>.</span><span>setFirstNumber</span><span>(</span><span>17</span><span>)</span><span>;</span>

        <span>// user enters a wrong second number and calculates result</span>
        calculator<span>.</span><span>setSecondNumber</span><span>(</span><span>-</span><span>290</span><span>)</span><span>;</span>

        <span>// calculate result</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>calculator<span>.</span><span>getCalculationResult</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>// user hits CTRL + Z to undo last operation and see last result</span>
        calculator<span>.</span><span>restorePreviousCalculation</span><span>(</span>memento<span>)</span><span>;</span>

        <span>// result restored</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>calculator<span>.</span><span>getCalculationResult</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><div><pre><code>110
-273
110
</code></pre></div><h3 id="jdk-10" tabindex="-1"> JDK</h3>
<ul>
<li>java.io.Serializable</li>
</ul>
<h2 id="_7-观察者-observer" tabindex="-1"> 7. 观察者（Observer）</h2>
<h3 id="intent-12" tabindex="-1"> Intent</h3>
<p>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p>
<p>主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7a3c6a30-c735-4edb-8115-337288a4f0f2.jpg" width="600"/> </div><br>
<h3 id="class-diagram-12" tabindex="-1"> Class Diagram</h3>
<p>主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。</p>
<p>观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a8c8f894-a712-447c-9906-5caef6a016e3.png"/> </div><br>
<h3 id="implementation-12" tabindex="-1"> Implementation</h3>
<p>天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1df9732-86ce-4d69-9f06-fba1db7b3b5a.jpg"/> </div><br>
<div><pre><code><span>public</span> <span>interface</span> <span>Subject</span> <span>{</span>
    <span>void</span> <span>registerObserver</span><span>(</span><span>Observer</span> o<span>)</span><span>;</span>

    <span>void</span> <span>removeObserver</span><span>(</span><span>Observer</span> o<span>)</span><span>;</span>

    <span>void</span> <span>notifyObserver</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>WeatherData</span> <span>implements</span> <span>Subject</span> <span>{</span>
    <span>private</span> <span>List</span><span><span>&lt;</span><span>Observer</span><span>></span></span> observers<span>;</span>
    <span>private</span> <span>float</span> temperature<span>;</span>
    <span>private</span> <span>float</span> humidity<span>;</span>
    <span>private</span> <span>float</span> pressure<span>;</span>

    <span>public</span> <span>WeatherData</span><span>(</span><span>)</span> <span>{</span>
        observers <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setMeasurements</span><span>(</span><span>float</span> temperature<span>,</span> <span>float</span> humidity<span>,</span> <span>float</span> pressure<span>)</span> <span>{</span>
        <span>this</span><span>.</span>temperature <span>=</span> temperature<span>;</span>
        <span>this</span><span>.</span>humidity <span>=</span> humidity<span>;</span>
        <span>this</span><span>.</span>pressure <span>=</span> pressure<span>;</span>
        <span>notifyObserver</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>registerObserver</span><span>(</span><span>Observer</span> o<span>)</span> <span>{</span>
        observers<span>.</span><span>add</span><span>(</span>o<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>removeObserver</span><span>(</span><span>Observer</span> o<span>)</span> <span>{</span>
        <span>int</span> i <span>=</span> observers<span>.</span><span>indexOf</span><span>(</span>o<span>)</span><span>;</span>
        <span>if</span> <span>(</span>i <span>>=</span> <span>0</span><span>)</span> <span>{</span>
            observers<span>.</span><span>remove</span><span>(</span>i<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>notifyObserver</span><span>(</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>Observer</span> o <span>:</span> observers<span>)</span> <span>{</span>
            o<span>.</span><span>update</span><span>(</span>temperature<span>,</span> humidity<span>,</span> pressure<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><div><pre><code><span>public</span> <span>interface</span> <span>Observer</span> <span>{</span>
    <span>void</span> <span>update</span><span>(</span><span>float</span> temp<span>,</span> <span>float</span> humidity<span>,</span> <span>float</span> pressure<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>StatisticsDisplay</span> <span>implements</span> <span>Observer</span> <span>{</span>

    <span>public</span> <span>StatisticsDisplay</span><span>(</span><span>Subject</span> weatherData<span>)</span> <span>{</span>
        weatherData<span>.</span><span>reisterObserver</span><span>(</span><span>this</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>update</span><span>(</span><span>float</span> temp<span>,</span> <span>float</span> humidity<span>,</span> <span>float</span> pressure<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"StatisticsDisplay.update: "</span> <span>+</span> temp <span>+</span> <span>" "</span> <span>+</span> humidity <span>+</span> <span>" "</span> <span>+</span> pressure<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>CurrentConditionsDisplay</span> <span>implements</span> <span>Observer</span> <span>{</span>

    <span>public</span> <span>CurrentConditionsDisplay</span><span>(</span><span>Subject</span> weatherData<span>)</span> <span>{</span>
        weatherData<span>.</span><span>registerObserver</span><span>(</span><span>this</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>update</span><span>(</span><span>float</span> temp<span>,</span> <span>float</span> humidity<span>,</span> <span>float</span> pressure<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"CurrentConditionsDisplay.update: "</span> <span>+</span> temp <span>+</span> <span>" "</span> <span>+</span> humidity <span>+</span> <span>" "</span> <span>+</span> pressure<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>WeatherStation</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>WeatherData</span> weatherData <span>=</span> <span>new</span> <span>WeatherData</span><span>(</span><span>)</span><span>;</span>
        <span>CurrentConditionsDisplay</span> currentConditionsDisplay <span>=</span> <span>new</span> <span>CurrentConditionsDisplay</span><span>(</span>weatherData<span>)</span><span>;</span>
        <span>StatisticsDisplay</span> statisticsDisplay <span>=</span> <span>new</span> <span>StatisticsDisplay</span><span>(</span>weatherData<span>)</span><span>;</span>

        weatherData<span>.</span><span>setMeasurements</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span><span>;</span>
        weatherData<span>.</span><span>setMeasurements</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code>CurrentConditionsDisplay.update: 0.0 0.0 0.0
StatisticsDisplay.update: 0.0 0.0 0.0
CurrentConditionsDisplay.update: 1.0 1.0 1.0
StatisticsDisplay.update: 1.0 1.0 1.0
</code></pre></div><h3 id="jdk-11" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Observer.html" target="_blank" rel="noopener noreferrer">java.util.Observer</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/EventListener.html" target="_blank" rel="noopener noreferrer">java.util.EventListener</a></li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionBindingListener.html" target="_blank" rel="noopener noreferrer">javax.servlet.http.HttpSessionBindingListener</a></li>
<li><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener noreferrer">RxJava</a></li>
</ul>
<h2 id="_8-状态-state" tabindex="-1"> 8. 状态（State）</h2>
<h3 id="intent-13" tabindex="-1"> Intent</h3>
<p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。</p>
<h3 id="class-diagram-13" tabindex="-1"> Class Diagram</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/79df886f-fdc3-4020-a07f-c991bb58e0d8.png"/> </div><br>
<h3 id="implementation-13" tabindex="-1"> Implementation</h3>
<p>糖果销售机有多种状态，每种状态下销售机有不同的行为，状态可以发生转移，使得销售机的行为也发生改变。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/396be981-3f2c-4fd9-8101-dbf9c841504b.jpg" width="600"/> </div><br>
<div><pre><code><span>public</span> <span>interface</span> <span>State</span> <span>{</span>
    <span>/**
     * 投入 25 分钱
     */</span>
    <span>void</span> <span>insertQuarter</span><span>(</span><span>)</span><span>;</span>

    <span>/**
     * 退回 25 分钱
     */</span>
    <span>void</span> <span>ejectQuarter</span><span>(</span><span>)</span><span>;</span>

    <span>/**
     * 转动曲柄
     */</span>
    <span>void</span> <span>turnCrank</span><span>(</span><span>)</span><span>;</span>

    <span>/**
     * 发放糖果
     */</span>
    <span>void</span> <span>dispense</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>HasQuarterState</span> <span>implements</span> <span>State</span> <span>{</span>

    <span>private</span> <span>GumballMachine</span> gumballMachine<span>;</span>

    <span>public</span> <span>HasQuarterState</span><span>(</span><span>GumballMachine</span> gumballMachine<span>)</span> <span>{</span>
        <span>this</span><span>.</span>gumballMachine <span>=</span> gumballMachine<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>insertQuarter</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You can't insert another quarter"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>ejectQuarter</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Quarter returned"</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>setState</span><span>(</span>gumballMachine<span>.</span><span>getNoQuarterState</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>turnCrank</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You turned..."</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>setState</span><span>(</span>gumballMachine<span>.</span><span>getSoldState</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>dispense</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"No gumball dispensed"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>NoQuarterState</span> <span>implements</span> <span>State</span> <span>{</span>

    <span>GumballMachine</span> gumballMachine<span>;</span>

    <span>public</span> <span>NoQuarterState</span><span>(</span><span>GumballMachine</span> gumballMachine<span>)</span> <span>{</span>
        <span>this</span><span>.</span>gumballMachine <span>=</span> gumballMachine<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>insertQuarter</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You insert a quarter"</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>setState</span><span>(</span>gumballMachine<span>.</span><span>getHasQuarterState</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>ejectQuarter</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You haven't insert a quarter"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>turnCrank</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You turned, but there's no quarter"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>dispense</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You need to pay first"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>SoldOutState</span> <span>implements</span> <span>State</span> <span>{</span>

    <span>GumballMachine</span> gumballMachine<span>;</span>

    <span>public</span> <span>SoldOutState</span><span>(</span><span>GumballMachine</span> gumballMachine<span>)</span> <span>{</span>
        <span>this</span><span>.</span>gumballMachine <span>=</span> gumballMachine<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>insertQuarter</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You can't insert a quarter, the machine is sold out"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>ejectQuarter</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You can't eject, you haven't inserted a quarter yet"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>turnCrank</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You turned, but there are no gumballs"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>dispense</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"No gumball dispensed"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>SoldState</span> <span>implements</span> <span>State</span> <span>{</span>

    <span>GumballMachine</span> gumballMachine<span>;</span>

    <span>public</span> <span>SoldState</span><span>(</span><span>GumballMachine</span> gumballMachine<span>)</span> <span>{</span>
        <span>this</span><span>.</span>gumballMachine <span>=</span> gumballMachine<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>insertQuarter</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Please wait, we're already giving you a gumball"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>ejectQuarter</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Sorry, you already turned the crank"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>turnCrank</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Turning twice doesn't get you another gumball!"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>dispense</span><span>(</span><span>)</span> <span>{</span>
        gumballMachine<span>.</span><span>releaseBall</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>gumballMachine<span>.</span><span>getCount</span><span>(</span><span>)</span> <span>></span> <span>0</span><span>)</span> <span>{</span>
            gumballMachine<span>.</span><span>setState</span><span>(</span>gumballMachine<span>.</span><span>getNoQuarterState</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Oops, out of gumballs"</span><span>)</span><span>;</span>
            gumballMachine<span>.</span><span>setState</span><span>(</span>gumballMachine<span>.</span><span>getSoldOutState</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>GumballMachine</span> <span>{</span>

    <span>private</span> <span>State</span> soldOutState<span>;</span>
    <span>private</span> <span>State</span> noQuarterState<span>;</span>
    <span>private</span> <span>State</span> hasQuarterState<span>;</span>
    <span>private</span> <span>State</span> soldState<span>;</span>

    <span>private</span> <span>State</span> state<span>;</span>
    <span>private</span> <span>int</span> count <span>=</span> <span>0</span><span>;</span>

    <span>public</span> <span>GumballMachine</span><span>(</span><span>int</span> numberGumballs<span>)</span> <span>{</span>
        count <span>=</span> numberGumballs<span>;</span>
        soldOutState <span>=</span> <span>new</span> <span>SoldOutState</span><span>(</span><span>this</span><span>)</span><span>;</span>
        noQuarterState <span>=</span> <span>new</span> <span>NoQuarterState</span><span>(</span><span>this</span><span>)</span><span>;</span>
        hasQuarterState <span>=</span> <span>new</span> <span>HasQuarterState</span><span>(</span><span>this</span><span>)</span><span>;</span>
        soldState <span>=</span> <span>new</span> <span>SoldState</span><span>(</span><span>this</span><span>)</span><span>;</span>

        <span>if</span> <span>(</span>numberGumballs <span>></span> <span>0</span><span>)</span> <span>{</span>
            state <span>=</span> noQuarterState<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            state <span>=</span> soldOutState<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>insertQuarter</span><span>(</span><span>)</span> <span>{</span>
        state<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>ejectQuarter</span><span>(</span><span>)</span> <span>{</span>
        state<span>.</span><span>ejectQuarter</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>turnCrank</span><span>(</span><span>)</span> <span>{</span>
        state<span>.</span><span>turnCrank</span><span>(</span><span>)</span><span>;</span>
        state<span>.</span><span>dispense</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setState</span><span>(</span><span>State</span> state<span>)</span> <span>{</span>
        <span>this</span><span>.</span>state <span>=</span> state<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>releaseBall</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"A gumball comes rolling out the slot..."</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>count <span>!=</span> <span>0</span><span>)</span> <span>{</span>
            count <span>-=</span> <span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>State</span> <span>getSoldOutState</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> soldOutState<span>;</span>
    <span>}</span>

    <span>public</span> <span>State</span> <span>getNoQuarterState</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> noQuarterState<span>;</span>
    <span>}</span>

    <span>public</span> <span>State</span> <span>getHasQuarterState</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> hasQuarterState<span>;</span>
    <span>}</span>

    <span>public</span> <span>State</span> <span>getSoldState</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> soldState<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getCount</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> count<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>GumballMachine</span> gumballMachine <span>=</span> <span>new</span> <span>GumballMachine</span><span>(</span><span>5</span><span>)</span><span>;</span>

        gumballMachine<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>turnCrank</span><span>(</span><span>)</span><span>;</span>

        gumballMachine<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>ejectQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>turnCrank</span><span>(</span><span>)</span><span>;</span>

        gumballMachine<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>turnCrank</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>turnCrank</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>ejectQuarter</span><span>(</span><span>)</span><span>;</span>

        gumballMachine<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>turnCrank</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>turnCrank</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>turnCrank</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><div><pre><code>You insert a quarter
You turned...
A gumball comes rolling out the slot...
You insert a quarter
Quarter returned
You turned, but there's no quarter
You need to pay first
You insert a quarter
You turned...
A gumball comes rolling out the slot...
You insert a quarter
You turned...
A gumball comes rolling out the slot...
You haven't insert a quarter
You insert a quarter
You can't insert another quarter
You turned...
A gumball comes rolling out the slot...
You insert a quarter
You turned...
A gumball comes rolling out the slot...
Oops, out of gumballs
You can't insert a quarter, the machine is sold out
You turned, but there are no gumballs
No gumball dispensed
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h2 id="_9-策略-strategy" tabindex="-1"> 9. 策略（Strategy）</h2>
<h3 id="intent-14" tabindex="-1"> Intent</h3>
<p>定义一系列算法，封装每个算法，并使它们可以互换。</p>
<p>策略模式可以让算法独立于使用它的客户端。</p>
<h3 id="class-diagram-14" tabindex="-1"> Class Diagram</h3>
<ul>
<li>Strategy 接口定义了一个算法族，它们都实现了  behavior() 方法。</li>
<li>Context 是使用到该算法族的类，其中的 doSomething() 方法会调用 behavior()，setStrategy(Strategy) 方法可以动态地改变 strategy 对象，也就是说能动态地改变 Context 所使用的算法。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cd1be8c2-755a-4a66-ad92-2e30f8f47922.png"/> </div><br>
<h3 id="与状态模式的比较" tabindex="-1"> 与状态模式的比较</h3>
<p>状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。</p>
<p>状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。</p>
<h3 id="implementation-14" tabindex="-1"> Implementation</h3>
<p>设计一个鸭子，它可以动态地改变叫声。这里的算法族是鸭子的叫声行为。</p>
<div><pre><code><span>public</span> <span>interface</span> <span>QuackBehavior</span> <span>{</span>
    <span>void</span> <span>quack</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Quack</span> <span>implements</span> <span>QuackBehavior</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>quack</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"quack!"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Squeak</span> <span>implements</span> <span>QuackBehavior</span><span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>quack</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"squeak!"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Duck</span> <span>{</span>

    <span>private</span> <span>QuackBehavior</span> quackBehavior<span>;</span>

    <span>public</span> <span>void</span> <span>performQuack</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>quackBehavior <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            quackBehavior<span>.</span><span>quack</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setQuackBehavior</span><span>(</span><span>QuackBehavior</span> quackBehavior<span>)</span> <span>{</span>
        <span>this</span><span>.</span>quackBehavior <span>=</span> quackBehavior<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Duck</span> duck <span>=</span> <span>new</span> <span>Duck</span><span>(</span><span>)</span><span>;</span>
        duck<span>.</span><span>setQuackBehavior</span><span>(</span><span>new</span> <span>Squeak</span><span>(</span><span>)</span><span>)</span><span>;</span>
        duck<span>.</span><span>performQuack</span><span>(</span><span>)</span><span>;</span>
        duck<span>.</span><span>setQuackBehavior</span><span>(</span><span>new</span> <span>Quack</span><span>(</span><span>)</span><span>)</span><span>;</span>
        duck<span>.</span><span>performQuack</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code>squeak!
quack!
</code></pre></div><h3 id="jdk-12" tabindex="-1"> JDK</h3>
<ul>
<li>java.util.Comparator#compare()</li>
<li>javax.servlet.http.HttpServlet</li>
<li>javax.servlet.Filter#doFilter()</li>
</ul>
<h2 id="_10-模板方法-template-method" tabindex="-1"> 10. 模板方法（Template Method）</h2>
<h3 id="intent-15" tabindex="-1"> Intent</h3>
<p>定义算法框架，并将一些步骤的实现延迟到子类。</p>
<p>通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。</p>
<h3 id="class-diagram-15" tabindex="-1"> Class Diagram</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac6a794b-68c0-486c-902f-8d988eee5766.png"/> </div><br>
<h3 id="implementation-15" tabindex="-1"> Implementation</h3>
<p>冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/11236498-1417-46ce-a1b0-e10054256955.png"/> </div><br>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>CaffeineBeverage</span> <span>{</span>

    <span>final</span> <span>void</span> <span>prepareRecipe</span><span>(</span><span>)</span> <span>{</span>
        <span>boilWater</span><span>(</span><span>)</span><span>;</span>
        <span>brew</span><span>(</span><span>)</span><span>;</span>
        <span>pourInCup</span><span>(</span><span>)</span><span>;</span>
        <span>addCondiments</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>abstract</span> <span>void</span> <span>brew</span><span>(</span><span>)</span><span>;</span>

    <span>abstract</span> <span>void</span> <span>addCondiments</span><span>(</span><span>)</span><span>;</span>

    <span>void</span> <span>boilWater</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"boilWater"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>void</span> <span>pourInCup</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"pourInCup"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Coffee</span> <span>extends</span> <span>CaffeineBeverage</span> <span>{</span>
    <span>@Override</span>
    <span>void</span> <span>brew</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Coffee.brew"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>void</span> <span>addCondiments</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Coffee.addCondiments"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Tea</span> <span>extends</span> <span>CaffeineBeverage</span> <span>{</span>
    <span>@Override</span>
    <span>void</span> <span>brew</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Tea.brew"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>void</span> <span>addCondiments</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Tea.addCondiments"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>CaffeineBeverage</span> caffeineBeverage <span>=</span> <span>new</span> <span>Coffee</span><span>(</span><span>)</span><span>;</span>
        caffeineBeverage<span>.</span><span>prepareRecipe</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"-----------"</span><span>)</span><span>;</span>
        caffeineBeverage <span>=</span> <span>new</span> <span>Tea</span><span>(</span><span>)</span><span>;</span>
        caffeineBeverage<span>.</span><span>prepareRecipe</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code>boilWater
Coffee.brew
pourInCup
Coffee.addCondiments
-----------
boilWater
Tea.brew
pourInCup
Tea.addCondiments
</code></pre></div><h3 id="jdk-13" tabindex="-1"> JDK</h3>
<ul>
<li>java.util.Collections#sort()</li>
<li>java.io.InputStream#skip()</li>
<li>java.io.InputStream#read()</li>
<li>java.util.AbstractList#indexOf()</li>
</ul>
<h2 id="_11-访问者-visitor" tabindex="-1"> 11. 访问者（Visitor）</h2>
<h3 id="intent-16" tabindex="-1"> Intent</h3>
<p>为一个对象结构（比如组合结构）增加新能力。</p>
<h3 id="class-diagram-16" tabindex="-1"> Class Diagram</h3>
<ul>
<li>Visitor：访问者，为每一个 ConcreteElement 声明一个 visit 操作</li>
<li>ConcreteVisitor：具体访问者，存储遍历过程中的累计结果</li>
<li>ObjectStructure：对象结构，可以是组合结构，或者是一个集合。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/79c6f036-bde6-4393-85a3-ef36a0327bd2.png"/> </div><br>
<h3 id="implementation-16" tabindex="-1"> Implementation</h3>
<div><pre><code><span>public</span> <span>interface</span> <span>Element</span> <span>{</span>
    <span>void</span> <span>accept</span><span>(</span><span>Visitor</span> visitor<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>class</span> <span>CustomerGroup</span> <span>{</span>

    <span>private</span> <span>List</span><span><span>&lt;</span><span>Customer</span><span>></span></span> customers <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

    <span>void</span> <span>accept</span><span>(</span><span>Visitor</span> visitor<span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>Customer</span> customer <span>:</span> customers<span>)</span> <span>{</span>
            customer<span>.</span><span>accept</span><span>(</span>visitor<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>void</span> <span>addCustomer</span><span>(</span><span>Customer</span> customer<span>)</span> <span>{</span>
        customers<span>.</span><span>add</span><span>(</span>customer<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Customer</span> <span>implements</span> <span>Element</span> <span>{</span>

    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>List</span><span><span>&lt;</span><span>Order</span><span>></span></span> orders <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

    <span>Customer</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>void</span> <span>addOrder</span><span>(</span><span>Order</span> order<span>)</span> <span>{</span>
        orders<span>.</span><span>add</span><span>(</span>order<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>accept</span><span>(</span><span>Visitor</span> visitor<span>)</span> <span>{</span>
        visitor<span>.</span><span>visit</span><span>(</span><span>this</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>Order</span> order <span>:</span> orders<span>)</span> <span>{</span>
            order<span>.</span><span>accept</span><span>(</span>visitor<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Order</span> <span>implements</span> <span>Element</span> <span>{</span>

    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>List</span><span><span>&lt;</span><span>Item</span><span>></span></span> items <span>=</span> <span>new</span> <span>ArrayList</span><span>(</span><span>)</span><span>;</span>

    <span>Order</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>Order</span><span>(</span><span>String</span> name<span>,</span> <span>String</span> itemName<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>this</span><span>.</span><span>addItem</span><span>(</span><span>new</span> <span>Item</span><span>(</span>itemName<span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>void</span> <span>addItem</span><span>(</span><span>Item</span> item<span>)</span> <span>{</span>
        items<span>.</span><span>add</span><span>(</span>item<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>accept</span><span>(</span><span>Visitor</span> visitor<span>)</span> <span>{</span>
        visitor<span>.</span><span>visit</span><span>(</span><span>this</span><span>)</span><span>;</span>

        <span>for</span> <span>(</span><span>Item</span> item <span>:</span> items<span>)</span> <span>{</span>
            item<span>.</span><span>accept</span><span>(</span>visitor<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Item</span> <span>implements</span> <span>Element</span> <span>{</span>

    <span>private</span> <span>String</span> name<span>;</span>

    <span>Item</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>accept</span><span>(</span><span>Visitor</span> visitor<span>)</span> <span>{</span>
        visitor<span>.</span><span>visit</span><span>(</span><span>this</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><div><pre><code><span>public</span> <span>interface</span> <span>Visitor</span> <span>{</span>
    <span>void</span> <span>visit</span><span>(</span><span>Customer</span> customer<span>)</span><span>;</span>

    <span>void</span> <span>visit</span><span>(</span><span>Order</span> order<span>)</span><span>;</span>

    <span>void</span> <span>visit</span><span>(</span><span>Item</span> item<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>GeneralReport</span> <span>implements</span> <span>Visitor</span> <span>{</span>

    <span>private</span> <span>int</span> customersNo<span>;</span>
    <span>private</span> <span>int</span> ordersNo<span>;</span>
    <span>private</span> <span>int</span> itemsNo<span>;</span>

    <span>public</span> <span>void</span> <span>visit</span><span>(</span><span>Customer</span> customer<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>customer<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        customersNo<span>++</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>visit</span><span>(</span><span>Order</span> order<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>order<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        ordersNo<span>++</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>visit</span><span>(</span><span>Item</span> item<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>item<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        itemsNo<span>++</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>displayResults</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Number of customers: "</span> <span>+</span> customersNo<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Number of orders:    "</span> <span>+</span> ordersNo<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Number of items:     "</span> <span>+</span> itemsNo<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Customer</span> customer1 <span>=</span> <span>new</span> <span>Customer</span><span>(</span><span>"customer1"</span><span>)</span><span>;</span>
        customer1<span>.</span><span>addOrder</span><span>(</span><span>new</span> <span>Order</span><span>(</span><span>"order1"</span><span>,</span> <span>"item1"</span><span>)</span><span>)</span><span>;</span>
        customer1<span>.</span><span>addOrder</span><span>(</span><span>new</span> <span>Order</span><span>(</span><span>"order2"</span><span>,</span> <span>"item1"</span><span>)</span><span>)</span><span>;</span>
        customer1<span>.</span><span>addOrder</span><span>(</span><span>new</span> <span>Order</span><span>(</span><span>"order3"</span><span>,</span> <span>"item1"</span><span>)</span><span>)</span><span>;</span>

        <span>Order</span> order <span>=</span> <span>new</span> <span>Order</span><span>(</span><span>"order_a"</span><span>)</span><span>;</span>
        order<span>.</span><span>addItem</span><span>(</span><span>new</span> <span>Item</span><span>(</span><span>"item_a1"</span><span>)</span><span>)</span><span>;</span>
        order<span>.</span><span>addItem</span><span>(</span><span>new</span> <span>Item</span><span>(</span><span>"item_a2"</span><span>)</span><span>)</span><span>;</span>
        order<span>.</span><span>addItem</span><span>(</span><span>new</span> <span>Item</span><span>(</span><span>"item_a3"</span><span>)</span><span>)</span><span>;</span>
        <span>Customer</span> customer2 <span>=</span> <span>new</span> <span>Customer</span><span>(</span><span>"customer2"</span><span>)</span><span>;</span>
        customer2<span>.</span><span>addOrder</span><span>(</span>order<span>)</span><span>;</span>

        <span>CustomerGroup</span> customers <span>=</span> <span>new</span> <span>CustomerGroup</span><span>(</span><span>)</span><span>;</span>
        customers<span>.</span><span>addCustomer</span><span>(</span>customer1<span>)</span><span>;</span>
        customers<span>.</span><span>addCustomer</span><span>(</span>customer2<span>)</span><span>;</span>

        <span>GeneralReport</span> visitor <span>=</span> <span>new</span> <span>GeneralReport</span><span>(</span><span>)</span><span>;</span>
        customers<span>.</span><span>accept</span><span>(</span>visitor<span>)</span><span>;</span>
        visitor<span>.</span><span>displayResults</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><div><pre><code>customer1
order1
item1
order2
item1
order3
item1
customer2
order_a
item_a1
item_a2
item_a3
Number of customers: 2
Number of orders:    4
Number of items:     6
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="jdk-14" tabindex="-1"> JDK</h3>
<ul>
<li>javax.lang.model.element.Element and javax.lang.model.element.ElementVisitor</li>
<li>javax.lang.model.type.TypeMirror and javax.lang.model.type.TypeVisitor</li>
</ul>
<h2 id="_12-空对象-null" tabindex="-1"> 12. 空对象（Null）</h2>
<h3 id="intent-17" tabindex="-1"> Intent</h3>
<p>使用什么都不做的空对象来代替 NULL。</p>
<p>一个方法返回 NULL，意味着方法的调用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。</p>
<h3 id="class-diagram-17" tabindex="-1"> Class Diagram</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/22870bbe-898f-4c17-a31a-d7c5ee5d1c10.png"/> </div><br>
<h3 id="implementation-17" tabindex="-1"> Implementation</h3>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>AbstractOperation</span> <span>{</span>
    <span>abstract</span> <span>void</span> <span>request</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>RealOperation</span> <span>extends</span> <span>AbstractOperation</span> <span>{</span>
    <span>@Override</span>
    <span>void</span> <span>request</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"do something"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>NullOperation</span> <span>extends</span> <span>AbstractOperation</span><span>{</span>
    <span>@Override</span>
    <span>void</span> <span>request</span><span>(</span><span>)</span> <span>{</span>
        <span>// do nothing</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>AbstractOperation</span> abstractOperation <span>=</span> <span>func</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>
        abstractOperation<span>.</span><span>request</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>AbstractOperation</span> <span>func</span><span>(</span><span>int</span> para<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>para <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>NullOperation</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>new</span> <span>RealOperation</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h1 id="四、结构型" tabindex="-1"> 四、结构型</h1>
<h2 id="_1-适配器-adapter" tabindex="-1"> 1. 适配器（Adapter）</h2>
<h3 id="intent-18" tabindex="-1"> Intent</h3>
<p>把一个类接口转换成另一个用户需要的接口。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3d5b828e-5c4d-48d8-a440-281e4a8e1c92.png"/> </div><br>
<h3 id="class-diagram-18" tabindex="-1"> Class Diagram</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ff5152fc-4ff3-44c4-95d6-1061002c364a.png"/> </div><br>
<h3 id="implementation-18" tabindex="-1"> Implementation</h3>
<p>鸭子（Duck）和火鸡（Turkey）拥有不同的叫声，Duck 的叫声调用 quack() 方法，而 Turkey 调用 gobble() 方法。</p>
<p>要求将 Turkey 的 gobble() 方法适配成 Duck 的 quack() 方法，从而让火鸡冒充鸭子！</p>
<div><pre><code><span>public</span> <span>interface</span> <span>Duck</span> <span>{</span>
    <span>void</span> <span>quack</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>interface</span> <span>Turkey</span> <span>{</span>
    <span>void</span> <span>gobble</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>WildTurkey</span> <span>implements</span> <span>Turkey</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>gobble</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"gobble!"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>TurkeyAdapter</span> <span>implements</span> <span>Duck</span> <span>{</span>
    <span>Turkey</span> turkey<span>;</span>

    <span>public</span> <span>TurkeyAdapter</span><span>(</span><span>Turkey</span> turkey<span>)</span> <span>{</span>
        <span>this</span><span>.</span>turkey <span>=</span> turkey<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>quack</span><span>(</span><span>)</span> <span>{</span>
        turkey<span>.</span><span>gobble</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Turkey</span> turkey <span>=</span> <span>new</span> <span>WildTurkey</span><span>(</span><span>)</span><span>;</span>
        <span>Duck</span> duck <span>=</span> <span>new</span> <span>TurkeyAdapter</span><span>(</span>turkey<span>)</span><span>;</span>
        duck<span>.</span><span>quack</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><h3 id="jdk-15" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList%28T...%29" target="_blank" rel="noopener noreferrer">java.util.Arrays#asList()</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#list-java.util.Enumeration-" target="_blank" rel="noopener noreferrer">java.util.Collections#list()</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#enumeration-java.util.Collection-" target="_blank" rel="noopener noreferrer">java.util.Collections#enumeration()</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/adapters/XmlAdapter.html#marshal-BoundType-" target="_blank" rel="noopener noreferrer">javax.xml.bind.annotation.adapters.XMLAdapter</a></li>
</ul>
<h2 id="_2-桥接-bridge" tabindex="-1"> 2. 桥接（Bridge）</h2>
<h3 id="intent-19" tabindex="-1"> Intent</h3>
<p>将抽象与实现分离开来，使它们可以独立变化。</p>
<h3 id="class-diagram-19" tabindex="-1"> Class Diagram</h3>
<ul>
<li>Abstraction：定义抽象类的接口</li>
<li>Implementor：定义实现类接口</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2a1f8b0f-1dd7-4409-b177-a381c58066ad.png"/> </div><br>
<h3 id="implementation-19" tabindex="-1"> Implementation</h3>
<p>RemoteControl 表示遥控器，指代 Abstraction。</p>
<p>TV 表示电视，指代 Implementor。</p>
<p>桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。</p>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>TV</span> <span>{</span>
    <span>public</span> <span>abstract</span> <span>void</span> <span>on</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>abstract</span> <span>void</span> <span>off</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>abstract</span> <span>void</span> <span>tuneChannel</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Sony</span> <span>extends</span> <span>TV</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>on</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Sony.on()"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>off</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Sony.off()"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>tuneChannel</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Sony.tuneChannel()"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>RCA</span> <span>extends</span> <span>TV</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>on</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"RCA.on()"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>off</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"RCA.off()"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>tuneChannel</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"RCA.tuneChannel()"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>RemoteControl</span> <span>{</span>
    <span>protected</span> <span>TV</span> tv<span>;</span>

    <span>public</span> <span>RemoteControl</span><span>(</span><span>TV</span> tv<span>)</span> <span>{</span>
        <span>this</span><span>.</span>tv <span>=</span> tv<span>;</span>
    <span>}</span>

    <span>public</span> <span>abstract</span> <span>void</span> <span>on</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>abstract</span> <span>void</span> <span>off</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>abstract</span> <span>void</span> <span>tuneChannel</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteRemoteControl1</span> <span>extends</span> <span>RemoteControl</span> <span>{</span>
    <span>public</span> <span>ConcreteRemoteControl1</span><span>(</span><span>TV</span> tv<span>)</span> <span>{</span>
        <span>super</span><span>(</span>tv<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>on</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ConcreteRemoteControl1.on()"</span><span>)</span><span>;</span>
        tv<span>.</span><span>on</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>off</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ConcreteRemoteControl1.off()"</span><span>)</span><span>;</span>
        tv<span>.</span><span>off</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>tuneChannel</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ConcreteRemoteControl1.tuneChannel()"</span><span>)</span><span>;</span>
        tv<span>.</span><span>tuneChannel</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteRemoteControl2</span> <span>extends</span> <span>RemoteControl</span> <span>{</span>
    <span>public</span> <span>ConcreteRemoteControl2</span><span>(</span><span>TV</span> tv<span>)</span> <span>{</span>
        <span>super</span><span>(</span>tv<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>on</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ConcreteRemoteControl2.on()"</span><span>)</span><span>;</span>
        tv<span>.</span><span>on</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>off</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ConcreteRemoteControl2.off()"</span><span>)</span><span>;</span>
        tv<span>.</span><span>off</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>tuneChannel</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ConcreteRemoteControl2.tuneChannel()"</span><span>)</span><span>;</span>
        tv<span>.</span><span>tuneChannel</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>RemoteControl</span> remoteControl1 <span>=</span> <span>new</span> <span>ConcreteRemoteControl1</span><span>(</span><span>new</span> <span>RCA</span><span>(</span><span>)</span><span>)</span><span>;</span>
        remoteControl1<span>.</span><span>on</span><span>(</span><span>)</span><span>;</span>
        remoteControl1<span>.</span><span>off</span><span>(</span><span>)</span><span>;</span>
        remoteControl1<span>.</span><span>tuneChannel</span><span>(</span><span>)</span><span>;</span>
        <span>RemoteControl</span> remoteControl2 <span>=</span> <span>new</span> <span>ConcreteRemoteControl2</span><span>(</span><span>new</span> <span>Sony</span><span>(</span><span>)</span><span>)</span><span>;</span>
         remoteControl2<span>.</span><span>on</span><span>(</span><span>)</span><span>;</span>
         remoteControl2<span>.</span><span>off</span><span>(</span><span>)</span><span>;</span>
         remoteControl2<span>.</span><span>tuneChannel</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="jdk-16" tabindex="-1"> JDK</h3>
<ul>
<li>AWT (It provides an abstraction layer which maps onto the native OS the windowing support.)</li>
<li>JDBC</li>
</ul>
<h2 id="_3-组合-composite" tabindex="-1"> 3. 组合（Composite）</h2>
<h3 id="intent-20" tabindex="-1"> Intent</h3>
<p>将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。</p>
<h3 id="class-diagram-20" tabindex="-1"> Class Diagram</h3>
<p>组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。</p>
<p>组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2b8bfd57-b4d1-4a75-bfb0-bcf1fba4014a.png"/> </div><br>
<h3 id="implementation-20" tabindex="-1"> Implementation</h3>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>Component</span> <span>{</span>
    <span>protected</span> <span>String</span> name<span>;</span>

    <span>public</span> <span>Component</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>print</span><span>(</span><span>)</span> <span>{</span>
        <span>print</span><span>(</span><span>0</span><span>)</span><span>;</span>
    <span>}</span>

    <span>abstract</span> <span>void</span> <span>print</span><span>(</span><span>int</span> level<span>)</span><span>;</span>

    <span>abstract</span> <span>public</span> <span>void</span> <span>add</span><span>(</span><span>Component</span> component<span>)</span><span>;</span>

    <span>abstract</span> <span>public</span> <span>void</span> <span>remove</span><span>(</span><span>Component</span> component<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Composite</span> <span>extends</span> <span>Component</span> <span>{</span>

    <span>private</span> <span>List</span><span><span>&lt;</span><span>Component</span><span>></span></span> child<span>;</span>

    <span>public</span> <span>Composite</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>super</span><span>(</span>name<span>)</span><span>;</span>
        child <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>void</span> <span>print</span><span>(</span><span>int</span> level<span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> level<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"--"</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Composite:"</span> <span>+</span> name<span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>Component</span> component <span>:</span> child<span>)</span> <span>{</span>
            component<span>.</span><span>print</span><span>(</span>level <span>+</span> <span>1</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>add</span><span>(</span><span>Component</span> component<span>)</span> <span>{</span>
        child<span>.</span><span>add</span><span>(</span>component<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>remove</span><span>(</span><span>Component</span> component<span>)</span> <span>{</span>
        child<span>.</span><span>remove</span><span>(</span>component<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Leaf</span> <span>extends</span> <span>Component</span> <span>{</span>
    <span>public</span> <span>Leaf</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>super</span><span>(</span>name<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>void</span> <span>print</span><span>(</span><span>int</span> level<span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> level<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"--"</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"left:"</span> <span>+</span> name<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>add</span><span>(</span><span>Component</span> component<span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>UnsupportedOperationException</span><span>(</span><span>)</span><span>;</span> <span>// 牺牲透明性换取单一职责原则，这样就不用考虑是叶子节点还是组合节点</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>remove</span><span>(</span><span>Component</span> component<span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>UnsupportedOperationException</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Composite</span> root <span>=</span> <span>new</span> <span>Composite</span><span>(</span><span>"root"</span><span>)</span><span>;</span>
        <span>Component</span> node1 <span>=</span> <span>new</span> <span>Leaf</span><span>(</span><span>"1"</span><span>)</span><span>;</span>
        <span>Component</span> node2 <span>=</span> <span>new</span> <span>Composite</span><span>(</span><span>"2"</span><span>)</span><span>;</span>
        <span>Component</span> node3 <span>=</span> <span>new</span> <span>Leaf</span><span>(</span><span>"3"</span><span>)</span><span>;</span>
        root<span>.</span><span>add</span><span>(</span>node1<span>)</span><span>;</span>
        root<span>.</span><span>add</span><span>(</span>node2<span>)</span><span>;</span>
        root<span>.</span><span>add</span><span>(</span>node3<span>)</span><span>;</span>
        <span>Component</span> node21 <span>=</span> <span>new</span> <span>Leaf</span><span>(</span><span>"21"</span><span>)</span><span>;</span>
        <span>Component</span> node22 <span>=</span> <span>new</span> <span>Composite</span><span>(</span><span>"22"</span><span>)</span><span>;</span>
        node2<span>.</span><span>add</span><span>(</span>node21<span>)</span><span>;</span>
        node2<span>.</span><span>add</span><span>(</span>node22<span>)</span><span>;</span>
        <span>Component</span> node221 <span>=</span> <span>new</span> <span>Leaf</span><span>(</span><span>"221"</span><span>)</span><span>;</span>
        node22<span>.</span><span>add</span><span>(</span>node221<span>)</span><span>;</span>
        root<span>.</span><span>print</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><div><pre><code>Composite:root
--left:1
--Composite:2
----left:21
----Composite:22
------left:221
--left:3
</code></pre></div><h3 id="jdk-17" tabindex="-1"> JDK</h3>
<ul>
<li>javax.swing.JComponent#add(Component)</li>
<li>java.awt.Container#add(Component)</li>
<li>java.util.Map#putAll(Map)</li>
<li>java.util.List#addAll(Collection)</li>
<li>java.util.Set#addAll(Collection)</li>
</ul>
<h2 id="_4-装饰-decorator" tabindex="-1"> 4. 装饰（Decorator）</h2>
<h3 id="intent-21" tabindex="-1"> Intent</h3>
<p>为对象动态添加功能。</p>
<h3 id="class-diagram-21" tabindex="-1"> Class Diagram</h3>
<p>装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component），具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6b833bc2-517a-4270-8a5e-0a5f6df8cd96.png"/> </div><br>
<h3 id="implementation-21" tabindex="-1"> Implementation</h3>
<p>设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。</p>
<p>下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c9cfd600-bc91-4f3a-9f99-b42f88a5bb24.jpg" width="600"/> </div><br>
<div><pre><code><span>public</span> <span>interface</span> <span>Beverage</span> <span>{</span>
    <span>double</span> <span>cost</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>DarkRoast</span> <span>implements</span> <span>Beverage</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>double</span> <span>cost</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>HouseBlend</span> <span>implements</span> <span>Beverage</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>double</span> <span>cost</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>CondimentDecorator</span> <span>implements</span> <span>Beverage</span> <span>{</span>
    <span>protected</span> <span>Beverage</span> beverage<span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Milk</span> <span>extends</span> <span>CondimentDecorator</span> <span>{</span>

    <span>public</span> <span>Milk</span><span>(</span><span>Beverage</span> beverage<span>)</span> <span>{</span>
        <span>this</span><span>.</span>beverage <span>=</span> beverage<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>double</span> <span>cost</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>1</span> <span>+</span> beverage<span>.</span><span>cost</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Mocha</span> <span>extends</span> <span>CondimentDecorator</span> <span>{</span>

    <span>public</span> <span>Mocha</span><span>(</span><span>Beverage</span> beverage<span>)</span> <span>{</span>
        <span>this</span><span>.</span>beverage <span>=</span> beverage<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>double</span> <span>cost</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>1</span> <span>+</span> beverage<span>.</span><span>cost</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Beverage</span> beverage <span>=</span> <span>new</span> <span>HouseBlend</span><span>(</span><span>)</span><span>;</span>
        beverage <span>=</span> <span>new</span> <span>Mocha</span><span>(</span>beverage<span>)</span><span>;</span>
        beverage <span>=</span> <span>new</span> <span>Milk</span><span>(</span>beverage<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>beverage<span>.</span><span>cost</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code>3.0
</code></pre></div><h3 id="设计原则" tabindex="-1"> 设计原则</h3>
<p>类应该对扩展开放，对修改关闭：也就是添加新功能时不需要修改代码。饮料可以动态添加新的配料，而不需要去修改饮料的代码。</p>
<p>不可能把所有的类设计成都满足这一原则，应当把该原则应用于最有可能发生改变的地方。</p>
<h3 id="jdk-18" tabindex="-1"> JDK</h3>
<ul>
<li>java.io.BufferedInputStream(InputStream)</li>
<li>java.io.DataInputStream(InputStream)</li>
<li>java.io.BufferedOutputStream(OutputStream)</li>
<li>java.util.zip.ZipOutputStream(OutputStream)</li>
<li>java.util.Collections#checked<a href="">List|Map|Set|SortedSet|SortedMap</a></li>
</ul>
<h2 id="_5-外观-facade" tabindex="-1"> 5. 外观（Facade）</h2>
<h3 id="intent-22" tabindex="-1"> Intent</h3>
<p>提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。</p>
<h3 id="class-diagram-22" tabindex="-1"> Class Diagram</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f9978fa6-9f49-4a0f-8540-02d269ac448f.png"/> </div><br>
<h3 id="implementation-22" tabindex="-1"> Implementation</h3>
<p>观看电影需要操作很多电器，使用外观模式实现一键看电影功能。</p>
<div><pre><code><span>public</span> <span>class</span> <span>SubSystem</span> <span>{</span>
    <span>public</span> <span>void</span> <span>turnOnTV</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"turnOnTV()"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setCD</span><span>(</span><span>String</span> cd<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"setCD( "</span> <span>+</span> cd <span>+</span> <span>" )"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>startWatching</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"startWatching()"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Facade</span> <span>{</span>
    <span>private</span> <span>SubSystem</span> subSystem <span>=</span> <span>new</span> <span>SubSystem</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>void</span> <span>watchMovie</span><span>(</span><span>)</span> <span>{</span>
        subSystem<span>.</span><span>turnOnTV</span><span>(</span><span>)</span><span>;</span>
        subSystem<span>.</span><span>setCD</span><span>(</span><span>"a movie"</span><span>)</span><span>;</span>
        subSystem<span>.</span><span>startWatching</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Facade</span> facade <span>=</span> <span>new</span> <span>Facade</span><span>(</span><span>)</span><span>;</span>
        facade<span>.</span><span>watchMovie</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><h3 id="设计原则-1" tabindex="-1"> 设计原则</h3>
<p>最少知识原则：只和你的密友谈话。也就是说客户对象所需要交互的对象应当尽可能少。</p>
<h2 id="_6-享元-flyweight" tabindex="-1"> 6. 享元（Flyweight）</h2>
<h3 id="intent-23" tabindex="-1"> Intent</h3>
<p>利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。</p>
<h3 id="class-diagram-23" tabindex="-1"> Class Diagram</h3>
<ul>
<li>Flyweight：享元对象</li>
<li>IntrinsicState：内部状态，享元对象共享内部状态</li>
<li>ExtrinsicState：外部状态，每个享元对象的外部状态不同</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5f5c22d5-9c0e-49e1-b5b0-6cc7032724d4.png"/> </div><br>
<h3 id="implementation-23" tabindex="-1"> Implementation</h3>
<div><pre><code><span>public</span> <span>interface</span> <span>Flyweight</span> <span>{</span>
    <span>void</span> <span>doOperation</span><span>(</span><span>String</span> extrinsicState<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteFlyweight</span> <span>implements</span> <span>Flyweight</span> <span>{</span>

    <span>private</span> <span>String</span> intrinsicState<span>;</span>

    <span>public</span> <span>ConcreteFlyweight</span><span>(</span><span>String</span> intrinsicState<span>)</span> <span>{</span>
        <span>this</span><span>.</span>intrinsicState <span>=</span> intrinsicState<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>doOperation</span><span>(</span><span>String</span> extrinsicState<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Object address: "</span> <span>+</span> <span>System</span><span>.</span><span>identityHashCode</span><span>(</span><span>this</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"IntrinsicState: "</span> <span>+</span> intrinsicState<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ExtrinsicState: "</span> <span>+</span> extrinsicState<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>FlyweightFactory</span> <span>{</span>

    <span>private</span> <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Flyweight</span><span>></span></span> flyweights <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

    <span>Flyweight</span> <span>getFlyweight</span><span>(</span><span>String</span> intrinsicState<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span>flyweights<span>.</span><span>containsKey</span><span>(</span>intrinsicState<span>)</span><span>)</span> <span>{</span>
            <span>Flyweight</span> flyweight <span>=</span> <span>new</span> <span>ConcreteFlyweight</span><span>(</span>intrinsicState<span>)</span><span>;</span>
            flyweights<span>.</span><span>put</span><span>(</span>intrinsicState<span>,</span> flyweight<span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> flyweights<span>.</span><span>get</span><span>(</span>intrinsicState<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>FlyweightFactory</span> factory <span>=</span> <span>new</span> <span>FlyweightFactory</span><span>(</span><span>)</span><span>;</span>
        <span>Flyweight</span> flyweight1 <span>=</span> factory<span>.</span><span>getFlyweight</span><span>(</span><span>"aa"</span><span>)</span><span>;</span>
        <span>Flyweight</span> flyweight2 <span>=</span> factory<span>.</span><span>getFlyweight</span><span>(</span><span>"aa"</span><span>)</span><span>;</span>
        flyweight1<span>.</span><span>doOperation</span><span>(</span><span>"x"</span><span>)</span><span>;</span>
        flyweight2<span>.</span><span>doOperation</span><span>(</span><span>"y"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code>Object address: 1163157884
IntrinsicState: aa
ExtrinsicState: x
Object address: 1163157884
IntrinsicState: aa
ExtrinsicState: y
</code></pre></div><h3 id="jdk-19" tabindex="-1"> JDK</h3>
<p>Java 利用缓存来加速大量小对象的访问时间。</p>
<ul>
<li>java.lang.Integer#valueOf(int)</li>
<li>java.lang.Boolean#valueOf(boolean)</li>
<li>java.lang.Byte#valueOf(byte)</li>
<li>java.lang.Character#valueOf(char)</li>
</ul>
<h2 id="_7-代理-proxy" tabindex="-1"> 7. 代理（Proxy）</h2>
<h3 id="intent-24" tabindex="-1"> Intent</h3>
<p>控制对其它对象的访问。</p>
<h3 id="class-diagram-24" tabindex="-1"> Class Diagram</h3>
<p>代理有以下四类：</p>
<ul>
<li>远程代理（Remote Proxy）：控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。</li>
<li>虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。</li>
<li>保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。</li>
<li>智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9b679ff5-94c6-48a7-b9b7-2ea868e828ed.png"/> </div><br>
<h3 id="implementation-24" tabindex="-1"> Implementation</h3>
<p>以下是一个虚拟代理的实现，模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。</p>
<div><pre><code><span>public</span> <span>interface</span> <span>Image</span> <span>{</span>
    <span>void</span> <span>showImage</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>HighResolutionImage</span> <span>implements</span> <span>Image</span> <span>{</span>

    <span>private</span> <span>URL</span> imageURL<span>;</span>
    <span>private</span> <span>long</span> startTime<span>;</span>
    <span>private</span> <span>int</span> height<span>;</span>
    <span>private</span> <span>int</span> width<span>;</span>

    <span>public</span> <span>int</span> <span>getHeight</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> height<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getWidth</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> width<span>;</span>
    <span>}</span>

    <span>public</span> <span>HighResolutionImage</span><span>(</span><span>URL</span> imageURL<span>)</span> <span>{</span>
        <span>this</span><span>.</span>imageURL <span>=</span> imageURL<span>;</span>
        <span>this</span><span>.</span>startTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>width <span>=</span> <span>600</span><span>;</span>
        <span>this</span><span>.</span>height <span>=</span> <span>600</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>boolean</span> <span>isLoad</span><span>(</span><span>)</span> <span>{</span>
        <span>// 模拟图片加载，延迟 3s 加载完成</span>
        <span>long</span> endTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
        <span>return</span> endTime <span>-</span> startTime <span>></span> <span>3000</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>showImage</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Real Image: "</span> <span>+</span> imageURL<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>ImageProxy</span> <span>implements</span> <span>Image</span> <span>{</span>

    <span>private</span> <span>HighResolutionImage</span> highResolutionImage<span>;</span>

    <span>public</span> <span>ImageProxy</span><span>(</span><span>HighResolutionImage</span> highResolutionImage<span>)</span> <span>{</span>
        <span>this</span><span>.</span>highResolutionImage <span>=</span> highResolutionImage<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>showImage</span><span>(</span><span>)</span> <span>{</span>
        <span>while</span> <span>(</span><span>!</span>highResolutionImage<span>.</span><span>isLoad</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>try</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Temp Image: "</span> <span>+</span> highResolutionImage<span>.</span><span>getWidth</span><span>(</span><span>)</span> <span>+</span> <span>" "</span> <span>+</span> highResolutionImage<span>.</span><span>getHeight</span><span>(</span><span>)</span><span>)</span><span>;</span>
                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>100</span><span>)</span><span>;</span>
            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        highResolutionImage<span>.</span><span>showImage</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>ImageViewer</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>String</span> image <span>=</span> <span>"http://image.jpg"</span><span>;</span>
        <span>URL</span> url <span>=</span> <span>new</span> <span>URL</span><span>(</span>image<span>)</span><span>;</span>
        <span>HighResolutionImage</span> highResolutionImage <span>=</span> <span>new</span> <span>HighResolutionImage</span><span>(</span>url<span>)</span><span>;</span>
        <span>ImageProxy</span> imageProxy <span>=</span> <span>new</span> <span>ImageProxy</span><span>(</span>highResolutionImage<span>)</span><span>;</span>
        imageProxy<span>.</span><span>showImage</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="jdk-20" tabindex="-1"> JDK</h3>
<ul>
<li>java.lang.reflect.Proxy</li>
<li>RMI</li>
</ul>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li>弗里曼. Head First 设计模式 [M]. 中国电力出版社, 2007.</li>
<li>Gamma E. 设计模式: 可复用面向对象软件的基础 [M]. 机械工业出版社, 2007.</li>
<li>Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.</li>
<li><a href="http://www.oodesign.com/" target="_blank" rel="noopener noreferrer">Design Patterns</a></li>
<li><a href="http://java-design-patterns.com/" target="_blank" rel="noopener noreferrer">Design patterns implemented in Java</a></li>
<li><a href="http://www.programering.com/a/MTNxAzMwATY.html" target="_blank" rel="noopener noreferrer">The breakdown of design patterns in JDK</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>面向对象思想</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">面向对象思想</source>
      <category>OOP</category>
      <pubDate>Mon, 16 May 2022 04:59:52 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>

<h1 id="一、三大特性" tabindex="-1"> 一、三大特性</h1>
<h2 id="封装" tabindex="-1"> 封装</h2>
<p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p>
<p>优点：</p>
<ul>
<li>减少耦合：可以独立地开发、测试、优化、使用、理解和修改</li>
<li>减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li>
<li>有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能</li>
<li>提高软件的可重用性</li>
<li>降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</li>
</ul>
<p>以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</p>
<p>注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Person</span> <span>{</span>

    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>int</span> gender<span>;</span>
    <span>private</span> <span>int</span> age<span>;</span>

    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getGender</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> gender <span>==</span> <span>0</span> <span>?</span> <span>"man"</span> <span>:</span> <span>"woman"</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>work</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>18</span> <span>&lt;=</span> age <span>&amp;&amp;</span> age <span>&lt;=</span> <span>50</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name <span>+</span> <span>" is working very hard!"</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name <span>+</span> <span>" can't work any more!"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id="继承" tabindex="-1"> 继承</h2>
<p>继承实现了  <strong>IS-A</strong>  关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p>
<p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</p>
<p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为  <strong>向上转型</strong> 。</p>
<div><pre><code><span>Animal</span> animal <span>=</span> <span>new</span> <span>Cat</span><span>(</span><span>)</span><span>;</span>
</code></pre></div><h2 id="多态" tabindex="-1"> 多态</h2>
<p>多态分为编译时多态和运行时多态：</p>
<ul>
<li>编译时多态主要指方法的重载</li>
<li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li>
</ul>
<p>运行时多态有三个条件：</p>
<ul>
<li>继承</li>
<li>覆盖（重写）</li>
<li>向上转型</li>
</ul>
<p>下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Instrument</span> <span>{</span>

    <span>public</span> <span>void</span> <span>play</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Instument is playing..."</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Wind</span> <span>extends</span> <span>Instrument</span> <span>{</span>

    <span>public</span> <span>void</span> <span>play</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Wind is playing..."</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Percussion</span> <span>extends</span> <span>Instrument</span> <span>{</span>

    <span>public</span> <span>void</span> <span>play</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Percussion is playing..."</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Music</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>List</span><span><span>&lt;</span><span>Instrument</span><span>></span></span> instruments <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        instruments<span>.</span><span>add</span><span>(</span><span>new</span> <span>Wind</span><span>(</span><span>)</span><span>)</span><span>;</span>
        instruments<span>.</span><span>add</span><span>(</span><span>new</span> <span>Percussion</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>for</span><span>(</span><span>Instrument</span> instrument <span>:</span> instruments<span>)</span> <span>{</span>
            instrument<span>.</span><span>play</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code>Wind is playing...
Percussion is playing...
</code></pre></div><h1 id="二、类图" tabindex="-1"> 二、类图</h1>
<p>以下类图使用 <a href="https://www.planttext.com/" target="_blank" rel="noopener noreferrer">PlantUML</a> 绘制，更多语法及使用请参考：http://plantuml.com/ 。</p>
<h2 id="泛化关系-generalization" tabindex="-1"> 泛化关系 (Generalization)</h2>
<p>用来描述继承关系，在 Java 中使用 extends 关键字。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c0874e0a-dba3-467e-9c86-dd9313e0843e.jpg" width="180px"> </div><br>
<div><pre><code>@startuml

title Generalization

class Vihical
class Car
class Trunck

Vihical &lt;|-- Car
Vihical &lt;|-- Trunck

@enduml
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="实现关系-realization" tabindex="-1"> 实现关系 (Realization)</h2>
<p>用来实现一个接口，在 Java 中使用 implements 关键字。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/83d466bd-946b-4430-854a-cf7b0696d4c8.jpg" width="170px"> </div><br>
<div><pre><code>@startuml

title Realization

interface MoveBehavior
class Fly
class Run

MoveBehavior &lt;|.. Fly
MoveBehavior &lt;|.. Run

@enduml
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="聚合关系-aggregation" tabindex="-1"> 聚合关系 (Aggregation)</h2>
<p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a0ce43b7-afa8-4397-a96e-5c12a070f2ae.jpg" width="300px"> </div><br>
<div><pre><code>@startuml

title Aggregation

class Computer
class Keyboard
class Mouse
class Screen

Computer o-- Keyboard
Computer o-- Mouse
Computer o-- Screen

@enduml
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="组合关系-composition" tabindex="-1"> 组合关系 (Composition)</h2>
<p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6a88a398-c494-41f5-bb62-9f7fb811df7c.jpg" width="280px"> </div><br>
<div><pre><code>@startuml

title Composition

class Company
class DepartmentA
class DepartmentB

Company *-- DepartmentA
Company *-- DepartmentB

@enduml
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="关联关系-association" tabindex="-1"> 关联关系 (Association)</h2>
<p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a3e4dc62-0da5-4d22-94f2-140078281812.jpg" width="200px"> </div><br>
<div><pre><code>@startuml

title Association

class School
class Student

School "1" - "n" Student

@enduml
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="依赖关系-dependency" tabindex="-1"> 依赖关系 (Dependency)</h2>
<p>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：</p>
<ul>
<li>A 类是 B 类方法的局部变量；</li>
<li>A 类是 B 类方法当中的一个参数；</li>
<li>A 类向 B 类发送消息，从而影响 B 类发生变化。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/379444c9-f1d1-45cd-b7aa-b0c18427d388.jpg" width="330px"> </div><br>
<div><pre><code>@startuml

title Dependency

class Vihicle {
    move(MoveBehavior)
}

interface MoveBehavior {
    move()
}

note "MoveBehavior.move()" as N

Vihicle ..> MoveBehavior

Vihicle .. N

@enduml
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h1 id="三、设计原则" tabindex="-1"> 三、设计原则</h1>
<h2 id="s-o-l-i-d" tabindex="-1"> S.O.L.I.D</h2>
<table>
<thead>
<tr>
<th style="text-align:center">简写</th>
<th style="text-align:center">全拼</th>
<th style="text-align:center">中文翻译</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SRP</td>
<td style="text-align:center">The Single Responsibility Principle</td>
<td style="text-align:center">单一责任原则</td>
</tr>
<tr>
<td style="text-align:center">OCP</td>
<td style="text-align:center">The Open Closed Principle</td>
<td style="text-align:center">开放封闭原则</td>
</tr>
<tr>
<td style="text-align:center">LSP</td>
<td style="text-align:center">The Liskov Substitution Principle</td>
<td style="text-align:center">里氏替换原则</td>
</tr>
<tr>
<td style="text-align:center">ISP</td>
<td style="text-align:center">The Interface Segregation Principle</td>
<td style="text-align:center">接口分离原则</td>
</tr>
<tr>
<td style="text-align:center">DIP</td>
<td style="text-align:center">The Dependency Inversion Principle</td>
<td style="text-align:center">依赖倒置原则</td>
</tr>
</tbody>
</table>
<h3 id="_1-单一责任原则" tabindex="-1"> 1. 单一责任原则</h3>
<blockquote>
<p>修改一个类的原因应该只有一个。</p>
</blockquote>
<p>换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。</p>
<p>如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。</p>
<h3 id="_2-开放封闭原则" tabindex="-1"> 2. 开放封闭原则</h3>
<blockquote>
<p>类应该对扩展开放，对修改关闭。</p>
</blockquote>
<p>扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。</p>
<p>符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。</p>
<h3 id="_3-里氏替换原则" tabindex="-1"> 3. 里氏替换原则</h3>
<blockquote>
<p>子类对象必须能够替换掉所有父类对象。</p>
</blockquote>
<p>继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。</p>
<p>如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。</p>
<h3 id="_4-接口分离原则" tabindex="-1"> 4. 接口分离原则</h3>
<blockquote>
<p>不应该强迫客户依赖于它们不用的方法。</p>
</blockquote>
<p>因此使用多个专门的接口比使用单一的总接口要好。</p>
<h3 id="_5-依赖倒置原则" tabindex="-1"> 5. 依赖倒置原则</h3>
<blockquote>
<p>高层模块不应该依赖于低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。</p>
</blockquote>
<p>高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。</p>
<p>依赖于抽象意味着：</p>
<ul>
<li>任何变量都不应该持有一个指向具体类的指针或者引用；</li>
<li>任何类都不应该从具体类派生；</li>
<li>任何方法都不应该覆写它的任何基类中的已经实现的方法。</li>
</ul>
<h2 id="其他常见原则" tabindex="-1"> 其他常见原则</h2>
<p>除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。</p>
<table>
<thead>
<tr>
<th style="text-align:center">简写</th>
<th style="text-align:center">全拼</th>
<th style="text-align:center">中文翻译</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LOD</td>
<td style="text-align:center">The Law of Demeter</td>
<td style="text-align:center">迪米特法则</td>
</tr>
<tr>
<td style="text-align:center">CRP</td>
<td style="text-align:center">The Composite Reuse Principle</td>
<td style="text-align:center">合成复用原则</td>
</tr>
<tr>
<td style="text-align:center">CCP</td>
<td style="text-align:center">The Common Closure Principle</td>
<td style="text-align:center">共同封闭原则</td>
</tr>
<tr>
<td style="text-align:center">SAP</td>
<td style="text-align:center">The Stable Abstractions Principle</td>
<td style="text-align:center">稳定抽象原则</td>
</tr>
<tr>
<td style="text-align:center">SDP</td>
<td style="text-align:center">The Stable Dependencies Principle</td>
<td style="text-align:center">稳定依赖原则</td>
</tr>
</tbody>
</table>
<h3 id="_1-迪米特法则" tabindex="-1"> 1. 迪米特法则</h3>
<p>迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。</p>
<h3 id="_2-合成复用原则" tabindex="-1"> 2. 合成复用原则</h3>
<p>尽量使用对象组合，而不是通过继承来达到复用的目的。</p>
<h3 id="_3-共同封闭原则" tabindex="-1"> 3. 共同封闭原则</h3>
<p>一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。</p>
<h3 id="_4-稳定抽象原则" tabindex="-1"> 4. 稳定抽象原则</h3>
<p>最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。</p>
<h3 id="_5-稳定依赖原则" tabindex="-1"> 5. 稳定依赖原则</h3>
<p>包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。</p>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li>Java 编程思想</li>
<li>敏捷软件开发：原则、模式与实践</li>
<li><a href="http://www.cnblogs.com/shanyou/archive/2009/09/21/1570716.html" target="_blank" rel="noopener noreferrer">面向对象设计的 SOLID 原则</a></li>
<li><a href="http://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html#generalization" target="_blank" rel="noopener noreferrer">看懂 UML 类图和时序图</a></li>
<li><a href="http://www.cnblogs.com/wolf-sun/p/UML-Sequence-diagram.html" target="_blank" rel="noopener noreferrer">UML 系列——时序图（顺序图）sequence diagram</a></li>
<li><a href="http://blog.csdn.net/jianyuerensheng/article/details/51602015" target="_blank" rel="noopener noreferrer">面向对象编程三大特性 ------ 封装、继承、多态</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>中间件</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">中间件</source>
      <pubDate>Mon, 16 May 2022 04:59:52 GMT</pubDate>
    </item>
    <item>
      <title>分布式中间件</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">分布式中间件</source>
      <category>中间件</category>
      <pubDate>Mon, 16 May 2022 04:59:52 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
</ul>

<h1 id="分布式架构" tabindex="-1"> 分布式架构</h1>
<p>一般来说，相对于单机架构系统，分布式系统可以从以下三个方面获得收益和增强：</p>
<p>1.扩展性
这是一个系统对所要处理的持续增长的任务的适应能力和兼容能力，可用以下三种扩展性来概括：1）集群规模扩展性：整体服务性能可以随集群机器数量线性增长；2）地理扩展性：能够使用不同地区的数据中心以抵消地理因素带来的延迟；3）管理扩展性：集群数量的上升不会导致管理复杂度快速上升。</p>
<p>2.性能
所谓的性能优良的系统应该具备三个特质：短RT、低延迟，高吞吐和较低的计算资源占用率。</p>
<p>这里值得一提的是延迟和吞吐。延迟lantency英语本意是潜伏期，在分布式领域中描述的是 ‘从事件发生到 可被观测到’ 之间的时间间隔。数据从开始被写入，到磁盘持久化成功，花了100ms，但是这期间没有任何第三方能够观察到此次写入的变更结果，再过了100ms，终于有第三方能够观察到此次写入的最新结果。这里的”延迟“ 为  200ms，而非100ms。 吞吐可以简单理解为单位时间内最多能处理请求数量。</p>
<p>3.可用性
可用性=可用时间/(可用时间+不可用时间)，可用性百分比越高，难度越高 。提升系统可用性的关键一点：在设计阶段就需要考虑容错性(Fault  tolerance) ，即“面向失败的设计”。那么如何把一个单系统应用快速改造成分布式应用呢，我们需要考虑如何提供分布式的服务，如何用分布式缓存，分布式数据库等等。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-15-31-00.png" alt="" loading="lazy"></p>
]]></content:encoded>
    </item>
    <item>
      <title>分布式事务</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">分布式事务</source>
      <category>中间件</category>
      <pubDate>Mon, 16 May 2022 04:59:52 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>

<p>分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的 分布式系统 的不同节点之上。</p>
<h1 id="分布式事务解决方案" tabindex="-1"> 分布式事务解决方案</h1>
<h2 id="两阶段提交" tabindex="-1"> 两阶段提交</h2>
<p>两阶段提交，是实现分布式事务的成熟方案。第一阶段是表决阶段，是所有参与者都将本事务能否成功的反馈发给协调者；第二阶段是执行阶段，协调者根据所有参与者的反馈，通知所有参与者，步调一致地在所有分支上提交，或者在所有分支上回滚。</p>
<p>缺点</p>
<ol>
<li>同步阻塞：所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。</li>
<li>单点问题：协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者会一直等待，无法完成其它操作。</li>
<li>数据不一致：在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</li>
<li>太过保守：任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</li>
</ol>
<h2 id="tcc" tabindex="-1"> TCC</h2>
<p>TCC（Try、Confirm、Cancel）是两阶段提交的一个变种。TCC提供了一个框架，需要应用程序按照该框架编程，将业务逻辑的每个分支都分为Try、Confirm、Cancel三个操作集。TCC让应用程序自己定义数据库操作的粒度，使得降低锁冲突、提高吞吐量成为可能。</p>
<h1 id="txc" tabindex="-1"> TXC</h1>
<h2 id="应用场景" tabindex="-1"> 应用场景</h2>
<p>TXC的目标应用场景是：解决在分布式应用中，多条数据库记录被修改而可能带来的一致性问题；该分布式应用可以接受最终一致性；该应用的事务改造对工作量有较严格的限制</p>
<ul>
<li>跨多分库的分布式数据库事务场景</li>
<li>跨多数据库的事务场景</li>
<li>跨数据库系统、消息系统的事务场景</li>
<li>跨服务的事务场景</li>
</ul>
<h2 id="架构" tabindex="-1"> 架构</h2>
<ul>
<li>客户端（TXC-Client），资源管理器（RM），事务协调器（TXC-Server）。
客户端与事务协调器间，资源管理器与事务协调器间都是通过TXC分布式事务协议进行通信。客户端负责界定事务边界，开启/提交/回滚全局事务，</li>
<li>资源管理器负责管理资源，支持的资源包括：TDDL/DRDS，Oracle，MySQL，RDS，PgSQL，H2，MQ，MetaQ，Notify，后续计划根据实际业务需求支持更多类型资源。</li>
<li>事务协调器，也就是TXC服务器，负责协调整个事务过程，是分布式事务处理的大脑。</li>
</ul>
<p>TXC事务可以通过RPC框架和消息中间件进行事务传递，把整个业务调用链路或者消息链路串在一个分布式事务，极大简化应用开发。</p>
<h2 id="txc分阶段提交事务" tabindex="-1"> TXC分阶段提交事务</h2>
<p>TXC通过两阶段提交方式进行分布式事务推进。客户端向事务协调器注册全局事务作为一阶段的开启的标记；分布式事务内的每一次资源（DB或消息）操作，均通过资源管理器进行，资源管理器向事务协调器注册一个事务分支；客户端通知事务协调器进行全局提交／全局回滚作为一阶段完成的标记。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-14-34-21.png" alt="" loading="lazy"></p>
<p>TXC分布式事务的二阶段由事务协调器驱动，驱动所有事务分支执行提交或回滚操作，一旦确定某个分布式事务提交或回滚，则不断重试所有事务分支，直到完成整个分布式事务提交或回滚。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-14-34-29.png" alt="" loading="lazy"></p>
<h2 id="软件结构" tabindex="-1"> 软件结构</h2>
<p>TXC使用diamond实现软负载均衡，支持自动化的扩容和缩容，在业务规模发生变化时不对业务产生影响，并消除了事务协调器的单点故障风险。</p>
<p>业务方可通过TXC客户端API接入TXC事务，当调用已经接入TXC事务的HSF服务时，HSF服务会自动加入当前的全局事务，最大程度降低业务的开发成本。</p>
<p>TXC分布式事务中间件提供多种资源器支持，目前，已经完成TDDL、DRDS、Notify、MetaQ接入。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-14-40-38.png" alt="" loading="lazy"></p>
<h1 id="消息队列实现分布式事务" tabindex="-1"> 消息队列实现分布式事务</h1>
<ul>
<li>通过两阶段提交来实现事务的，事务消息都保存在单独的主题上</li>
<li>消息预发送机制：如果业务执行成功，再去发消息，此时如果还没来得及发消息，业务系统就已经宕机了，系统重启后，根本没有记录之前是否发送过消息，这样就会导致业务执行成功，消息最终没发出去的情况。</li>
</ul>
<h2 id="rocketmq实现" tabindex="-1"> RocketMQ实现</h2>
<p>通过“半消息”来实现的
<img src="@source/assets/cs-note/distribute/mk-2020-07-12-14-12-40.png" alt="" loading="lazy"></p>
<ul>
<li>producer发送half消息</li>
<li>broker确认half消息，并通知producer，表示消息已经成功发送到broker（这个过程其实就是步骤1broker的返回）</li>
<li>producer收到half确认消息之后，执行自己本地事务，并将事务结果（UNKNOW、commit、rollback）告诉broker（这是一个oneway消息，而且失败不重试）</li>
<li>broker收到producer本地事务的结果后决定是否投递消息给consumer</li>
<li>鉴于producer发送本地事务结果可能失败，broker会定时扫描集群中的事务消息，然后回查</li>
</ul>
<h2 id="kafka" tabindex="-1"> kafka</h2>
<p>直接将消息发送给对应的topic，通过客户端来过滤实现的</p>
]]></content:encoded>
    </item>
    <item>
      <title>分布式搜索</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">分布式搜索</source>
      <category>中间件</category>
      <pubDate>Mon, 16 May 2022 04:59:52 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>

<h1 id="opensearch" tabindex="-1"> OpenSearch</h1>
<h2 id="简介" tabindex="-1"> 简介</h2>
<p>开放搜索（OpenSearch）是一款结构化数据搜索托管服务，为移动应用开发者和网站站长提供简单、高效、稳定、低成本和可扩展的搜索解决方案。</p>
<p>OpenSearch基于阿里巴巴自主研发的大规模分布式搜索引擎平台，该平台承载了阿里巴巴全部主要搜索业务，包括淘宝、天猫、一淘、1688、ICBU、神马搜索等业务。OpenSearch以平台服务化的形式，将专业搜索技术简单化、低门槛化和低成本化，让搜索引擎技术不再成为客户的业务瓶颈，以低成本实现产品搜索功能并快速迭代。</p>
<h2 id="产品特性" tabindex="-1"> 产品特性</h2>
<ul>
<li>支持文档索引结构定制，以及自由修改
OpenSearch将搜索引擎复杂的索引结构概念简单化、可视化和自助定制化。开发者可以通过控制台创建搜索实例，定制文档字段的结构和属性，包括字段名称、类型、分词方式、搜索属性等。搜索实例在运行过程中可以自由修改，满足了产品快速变化的需求，极大缩短了需求变更到上线的过程。</li>
<li>支持多种数据接入方式，数据自动同步更新
开发者的数据如果在阿里云的云存储服务（RDS、OSS、ODPS等）上，开发者是需要在OpenSearch控制台中授权，数据皆可以自动同步至OpenSearch中，后续数据的更新也可以自动实时同步（ODPS除外）。而且在同一区域中，从云存储同步数据至OpenSearch免收流量费。书局不在阿里云上的开发者，可以通过RESTfulAPI或者SDK上传数据，小数据量也可以直接在控制台上传。</li>
<li>支持多表，插件式数据处理
类似于数据库，每个搜索实例可以创建一张或多张表，每张表的字段上可以内置数据处理插件，对字段内容做文本处理和转换，例如拼音转换、HTML标签剔除、JSON数据解释等，多个表可以Join在一起实现多表联合查询。数据存放在RDS数据库里的开发者，可以用此功能代替数据库全文检索，实现更高的性能和搜索体验。</li>
<li>支持搜索结果相关性两阶段排序定制，线上实时相关性调试
用户使用搜索功能的目的是从海量数据中找到自己想要得信息，搜索结果相关性排序是影响用户体验的最关键的一环。OpenSearch支持开发者定制两轮相关性排序规则来准确控制搜索结果的排序。
<ul>
<li>第一轮为粗排，从命中的文档集合里选出相关文档。支持配置字段、文本相关性和时效性算分特征的权重。</li>
<li>第二轮为精排，对粗排的结果做更精细筛选，支持任意复杂的表达式和语法。这样做除了方便开发者能准确控制排序效果之外，更重要的是能优化系统性能，提高搜索相应速度。开发者可以通过排序规则直接在控制台中调试效果，并在效果满意后直接切换到线上</li>
</ul>
</li>
</ul>
<h2 id="产品架构" tabindex="-1"> 产品架构</h2>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-13-56-46.png" alt="" loading="lazy"></p>
<ul>
<li>白色线为实时数据处理流</li>
<li>红色线为全量数据处理流</li>
<li>黑色线为搜索流程</li>
</ul>
<p>开发者通过控制台和API与系统交互。典型的使用流程是开发者进入控制台，创建应用实例，配置应用字段结构、搜索属性，配置文本处理插件、定制相关性排序规则等。应用实例创建完成后，开发者再通过SDK/API将数据推送至云端（阿里云存储用户可以配置数据自动同步，只需在控制台中授权），数据实时流式进入Import子系统的数据导入服务模块(iStream Service)，经过格式解析和数据处理后，存储在结构化数据存储系统中。随后，Dump子系统的数据导出服务(iStream Service)将数据经过一定处理后发送给实时消息队列系统(Swift)，搜索系统(HA3)从消息队列中订阅数据，在内存中构建索引并提供搜索服务。这个数据实时流式处理过程（白色箭头）大概十秒左右。</p>
<p>当开发者修改了索引结构，需要对应用中的数据做增量索引重建。为了保证搜索效率，系统也会定期对所有数据做全量重建索引。索引重建流程参见红色箭头，这是一个非实时的流程，依数据大小不同可能需要几分钟到十几分钟，全量索引重建则需要数小时。</p>
<p>数据在云端经过一系列处理和索引构建后，开发者就可以通过API搜索应用实例中的数据。搜索请求首先发送到查询聚合服务Aggregator。</p>
<p>如果开发者配置了查询改写处理逻辑（即将上线），Aggregator会将查询请求发送给查询改写服务QP，QP按照开发者配置的处理规则（例如：拼写纠错、同义词或者查询语义改写）改写查询请求，并将改写后的查询回传给Aggregator，Aggregator最终将查询请求发送给搜索系统HA3，HA3根据开发者定制的相关性排序规则对命中的结果文档排序，并最终通过Aggregator将结果返回给开发者。</p>
<p>为了保证不同开发者各个应用数据推送和搜索相互不受影响，资源合理利用。配额管理服务（Quota Server）会对进入系统的数据和搜索请求频率依据开发者的配额（文档总量、QPS）做限流控制。超出配额部分的数据推送将失败，查询请求将随机丢弃。</p>
<h3 id="引擎ha3" tabindex="-1"> 引擎HA3</h3>
<p>HA3是阿里自主研发的新一代分布式实时搜索系统，中文名叫问天3，具备自动容灾、动态扩容、秒级实时等能力。下图是HA3系统模块组成图。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-14-00-30.png" alt="" loading="lazy"></p>
<p>其中，Admin是整个系统的大脑，负责节点角色分配、调度决策、FailOver处理、状态监测、动态扩容等。Amonitor是系统的性能状态监控模块，收集和展示整个系统所有节点的性能参数。QRS是查询解析和改写服务，是系统对外的搜索接口。Proxy是搜索代理模块，负责接收QRS的查询请求，并转发给下辖的所有Searcher节点。Searcher节点执行实际的查询匹配计算，将搜索结果汇总后回传给QRS。</p>
<h1 id="solr" tabindex="-1"> Solr</h1>
<p>Solr是一个基于Lucene的Java搜索引擎服务器。Solr 提供了层面搜索、命中醒目显示并且支持多种输出格式（包括 XML/XSLT 和 JSON 格式）。它易于安装和配置，而且附带了一个基于 HTTP 的管理界面。Solr已经在众多大型的网站中使用，较为成熟和稳定。Solr 包装并扩展了 Lucene，所以Solr的基本上沿用了Lucene的相关术语。更重要的是，Solr 创建的索引与 Lucene 搜索引擎库完全兼容。通过对 Solr 进行适当的配置，某些情况下可能需要进行编码，Solr 可以阅读和使用构建到其他 Lucene 应用程序中的索引。此外，很多 Lucene 工具（如Nutch、 Luke）也可以使用 Solr 创建的索引。</p>
]]></content:encoded>
    </item>
    <item>
      <title>分布式数据库</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">分布式数据库</source>
      <category>中间件</category>
      <pubDate>Mon, 16 May 2022 04:59:52 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="tddl" tabindex="-1"> TDDL</h1>
<h2 id="产生背景" tabindex="-1"> 产生背景</h2>
<p>一开始的时候，由于数据量比较少，数据库最长见的是单库单表的情况。随着业务的发展，业务库中的数据量不断增长。单库的性能已经不能再支持业务的发展。我们开始使用对数据库进行分库分表和读写分离的方式，来分散数据库的压力，提高整体的性能。</p>
<ul>
<li>单库单表
通常刚开始的时候，应用的数据比较少，也不会很复杂，所以应用只有一个数据库，数据库中的表是一张完整的表，这也是我们刚开始接触数据库时的数据库形态。</li>
<li>读写分离随着业务的发展，数据量与数据访问量不断增长，很多时候应用的主要业务是读多写少的，比如说一些新闻网站，运营在后台上传了一堆新闻之后，所有的用户都会去读取这些新闻资讯，因此数据库面临的读压力远大于写压力，那么这时候在原来数据库 Master 的基础上增加一个备用数据库 Slave，备库和主库存储着相同的数据，但只提供读服务，不提供写服务。以后的写操作以及事务中的读操作就走主库，其它读操作就走备库，这就是所谓的读写分离。读写分离会直接带来两个问题：
<ul>
<li><strong>数据复制问题</strong>：因为最新写入的数据只会存储在主库中，之后想要在备库中读取到新数据就必须要从主库复制过来，这会带来一定的延迟，造成短期的数据不一致性。但这个问题应该也没有什么特别好的办法，主要依赖于数据库提供的数据复制机制，常用的是根据数据库日志 binary-log 实现数据复制。</li>
<li><strong>数据源选择问题</strong>：读写分离之后我们都知道写要找主库，读要找备库，但是程序不知道，所以我们在程序中应该根据 SQL 来判断出是读操作还是写操作，进而正确选择要访问的数据库。</li>
</ul>
</li>
<li>垂直分库数据量与访问量继续上升时，主备库的压力都在变大，这时候可以根据业务特点考虑将数据库垂直拆分，即把数据库中不同的业务单元的数据划分到不同的数据库里面。比如说，还是新闻网站，注册用户的信息与新闻是没有多大关系的，数据库访问压力大时可以尝试把用户信息相关的表放在一个数据库，新闻相关的表放在一个数据库中，这样大大减小了数据库的访问压力。垂直分库会带来以下问题：
<ul>
<li>ACID 被打破：数据分到不同的数据库之后，原来的事务操作将会受很大影响，比如说注册账户的时候需要在用户表和用户信息表中插入一条数据，单机数据库利用事务可以很好地完成这个任务，但是多机将会变得比较麻烦。以下两点也是因为数据库在不同的机子上而导致简单的操作变得复杂，不一一分析了。</li>
<li>Join 操作困难</li>
<li>外键约束受影响</li>
</ul>
</li>
<li>水平分表经过长时间积累，特别对于 ugc 的业务，数据量会达到惊人的地步，每张表存放着大量的数据，任何 CRUD 都变成了一次极其消耗性能的操作，这个时候就会考虑水平分表，把一张表内大量的数据拆分成多张子表，比如说原来一张表中存放 50000 条数据，水平分成 5 张表之后，每张表只要存放 10000 条数据。这种结构可以比较容易的存储和维护海量数据。水平分表会在垂直分库的基础上带来更多的影响：
<ul>
<li>自增主键会有影响：这个影响很明显，分表中如果使用的是自增主键的话，那么就不能产生唯一的 ID 了，因为逻辑上来说多个分表其实都属于一张表，自增主键无法标识每一条数据。</li>
<li>有些单表查询会变成多表：比如说 count 操作，原来是一张表的问题，现在要从多张分表中共同查询才能得到结果。</li>
</ul>
</li>
</ul>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-13-28-49.png" alt="" loading="lazy"></p>
<h2 id="应用场景" tabindex="-1"> 应用场景</h2>
<ul>
<li>读写分离</li>
<li>分库分表</li>
<li>动态数据源</li>
<li>主备切换</li>
</ul>
<p>TDDL 主要解决了以下问题：</p>
<ol>
<li>单机数据库容量瓶颈： 随着数据量和访问量的增长，单机数据库会遇到很大的挑战，依赖硬件升级并不能完全解决问题。</li>
<li>单机数据库扩展困难：传统数据库容量扩展往往意味着服务中断，很难做到业务无感知或者少感知。</li>
<li>传统数据库使用成本高。</li>
<li>跨语言支持：基于 TDDL 的 Corona 产品提供跨语言支持。Corona 是一个 MySQL 的 proxy，提供标准的 MySQL 协议。因此，用户可以像使用 MySQL 一样使用 Corona，从而提供跨语言支持。</li>
</ol>
<h2 id="整体架构" tabindex="-1"> 整体架构</h2>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-13-29-36.png" alt="" loading="lazy"></p>
<p>客户端架构
<img src="@source/assets/cs-note/distribute/mk-2020-07-12-13-30-03.png" alt="" loading="lazy"></p>
<p>服务端架构
<img src="@source/assets/cs-note/distribute/mk-2020-07-12-13-30-14.png" alt="" loading="lazy"></p>
<h3 id="tddl三层数据源关系" tabindex="-1"> TDDL三层数据源关系</h3>
<p>Matrix（TDataSource）实现分库分表逻辑，持有多个Group实例；</p>
<p>Group（TGroupDataSource）实现数据库的主备切换，读写分离逻辑，持有多个Atom实例；</p>
<p>Atom（TAtomDataSource）实现数据库ip，port，password，connectionProperties等信息的动态推送，持有原子的数据源（分离的Jboss数据源）。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-13-30-32.png" alt="" loading="lazy"></p>
<ul>
<li>Matrix层：Matrix层主要负责的是SQL的解析，优化，执行。这一层主要解决了分库分表对应用透明化的问题。应用在这一层看到的表是作为一个单表来看待的。</li>
<li>Group层：读写分离与主备切换带来的问题由 Group 层解决</li>
<li>Atom层：Atom层主要是由物理DB组成，负责管理DB的链接状态，给上层提供服务。DB一般都是有主库和备库组成</li>
</ul>
<h2 id="tddl高级特性" tabindex="-1"> TDDL高级特性</h2>
<h3 id="tddl分库分表" tabindex="-1"> TDDL分库分表</h3>
<h3 id="tddl-sequence" tabindex="-1"> TDDL Sequence</h3>
<ul>
<li>主键唯一性</li>
<li>全局ID</li>
<li>高并发场景下的唯一ID</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>分布式服务</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">分布式服务</source>
      <category>中间件</category>
      <pubDate>Mon, 16 May 2022 04:59:52 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>

<h1 id="介绍" tabindex="-1"> 介绍</h1>
<p>一般意义上，一个公司的业务系统发展脉络基本都是类似，从单体应用到多应用，从本地调用到远程调用，随着发展需要对远程服务进行高效的资源管理，这个过程是系统应对变化和复杂的应对之道。</p>
<h2 id="rpc" tabindex="-1"> RPC</h2>
<p>RPC（Remote Process Call），即远程服务调用，被广泛地应用在很多企业应用中，是早期主要的服务治理方案，其流程较为简单，客户端consumer携带参数发送RPC请求到服务提供方provider，provider根据参数路由到具体函数，方法，并将执行获得的结果返回，至此一次RPC调用完成。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-11-16.png" alt="" loading="lazy"></p>
<p>随着业务的发展，大数据时代的到来，服务提供方的压力也日益增大，单机应用的处理能力无论在软件，硬件上都受到限制，provider也不可能一直无限扩容，即使扩容，也存在着很多问题，即服务的路由，和Consumer的负载均衡问题。因此，分布式服务架构应运而生，RPC发展到一定阶段思考的变革，成为了分布式服务，云计算的计算机基础。</p>
<h2 id="soa" tabindex="-1"> SOA</h2>
<p>由于简单的RPC调用已经不能随着时代发展满足需求，因此复杂的业务逻辑对于分布式应用架构体系的需求愈发强烈，业务希望自己的服务是分布式部署的，请求是分流的，对数据的操作是能读写分离的，同时能屏蔽许多复杂需要自己编写的底层服务，借助已有的公共服务，去快速的构建自己的应用，降低人力开发维护的成本和提高应用交付的效率，基因此，基于分布式服务思想的SOA（Service-Oriented Architecture）成了新的受追捧的架构。常见的SOA服务调用流程图如下：</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-11-54.png" alt="" loading="lazy"></p>
<h1 id="框架" tabindex="-1"> 框架</h1>
<h2 id="hsf" tabindex="-1"> HSF</h2>
<p>HSF (High-speed Service Framework)，高速服务框架，是在阿里巴巴内部广泛使用的分布式 RPC 服务框架。</p>
<h3 id="功能角色" tabindex="-1"> 功能角色</h3>
<p>HSF功能结构上分为6个部分，分别是：服务消费方、服务提供方、地址注册中心、持久化配置中心、元数据存储中心和HSF运维平台（HSF 控制台），它们组合在一起可以提供全功能的分布式服务，其中必须的是服务消费方、服务提供方和地址注册中心，上述功能结构的描述如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:center">是否必须</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">服务消费方</td>
<td style="text-align:center">是</td>
<td style="text-align:left">消费服务提供方提供的服务，服务消费者通过地址注册中心订阅服务，根据订阅到的地址信息发起调用，地址注册中心作为旁路不参与调用</td>
</tr>
<tr>
<td style="text-align:left">服务提供方</td>
<td style="text-align:center">是</td>
<td style="text-align:left">服务提供方会绑定一个端口（一般是12200），接受请求并提供服务，同时将地址信息发布到地址注册中心</td>
</tr>
<tr>
<td style="text-align:left">地址注册中心</td>
<td style="text-align:center">是</td>
<td style="text-align:left">接受服务提供方发布的地址，当服务消费方根据服务进行订阅时，会将地址信息推送给服务消费方，注册中心就是服务信息的中介，提供服务发现的能力</td>
</tr>
<tr>
<td style="text-align:left">持久化配置中心</td>
<td style="text-align:center">否</td>
<td style="text-align:left">持久化的配置中心用于存储 HSF 服务的各种治理规则，HSF 客户端在启动的过程中会向持久化配置中心订阅各种服务治理规则，如路由规则、归组规则、权重规则等，从而根据规则对调用过程的选址逻辑进行干预</td>
</tr>
<tr>
<td style="text-align:left">元数据存储中心</td>
<td style="text-align:center">否</td>
<td style="text-align:left">元数据是指 HSF 服务对应的方法列表以及参数结构等信息，元数据不会对 HSF 的调用过程产生影响，因此元数据存储中心也并不是必须的。但考虑到服务运维的便捷性，HSF客户端在启动时会将元数据上报到元数据存储中心，以便提供给服务运维使用</td>
</tr>
<tr>
<td style="text-align:left">HSF运维平台</td>
<td style="text-align:center">否</td>
<td style="text-align:left">HSF 控制台通过打通地址注册中心 ConfigServer、持久化配置中心 Diamond、元数据存储中心 Redis，为用户提供了一些列服务运维功能，包括服务查询、服务治理规则管理、服务测试、服务 Mock、单机运维等，旨在提高 HSF 服务研发的效率、运维的便捷性</td>
</tr>
</tbody>
</table>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-19-15-25-26.png" alt="" loading="lazy"></p>
<p>从上图可以看到，服务提供方在启动后会向地址注册中心发布地址，服务消费方根据服务名向地址注册中心订阅服务地址，当服务地址推送到服务消费方后，服务消费方就可以从地址列表中选择一个地址发起RPC调用。</p>
<p>服务提供方在发布地址的同时会将服务元信息发布到元数据存储中心，HSF控制台通过访问元数据存储中心向使用者展示服务的详情，同时HSF控制台还可以通过持久化配置中心和地址注册中心客户端查询服务信息和规则信息。</p>
<h3 id="模块" tabindex="-1"> 模块</h3>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-19-15-26-46.png" alt="" loading="lazy"></p>
<ul>
<li>地址注册中心：ConfigServer可以理解为一个IP地址的管理中心，它负责向消费者用户来推送服务端的地址，所以开发人员只需自己配置消费端或者服务端的地址就好。<strong>服务端和客户端都会跟CS建立长连接，并且通过心跳包进行维持</strong>。</li>
<li>配置中心：对于分布式服务，客户端如何调用实现负载均衡。规则配置中心Diamond，就是用于存放HSF的各种规则，是一个持久化的配置中心，这里客户端是主动从Diamond上进行拉取配置，并且注册了Listener，当路由规则变化时，Diamond会将新的规则重新推送给客户端，所以，客户端不需要与Diamond保持长连接。</li>
<li>容器pandora：pandora是HSF的基础容器，用于管理整个HSF的生命周期和二方包的隔离，同时，其他的几个中间件，configServer和Diamond也在pandora容器中。</li>
</ul>
<h3 id="内部框架" tabindex="-1"> 内部框架</h3>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-17-11.png" alt="" loading="lazy"></p>
<p>这4块领域从下到上，分别是：框架、应用、服务和配置。框架提供了基础功能，负责通信、线程、协议、序列化以及编解码相关的工作，它们提供了良好的抽象，框架之上的域只需要基于这些抽象就能完成一次高性能的调用。</p>
<p>应用主要面向服务框架的注册和发现过程，是HSF完成分布式调用的基础，它用来支撑服务。服务的粒度比应用小，它包含了调用链路、地址路由以及负载均衡等功能。在服务之上是配置，用户使用API来对各层进行配置，并生成调用的代理或暴露服务。</p>
<p>沿着客户端配置链路可以看到，用户配置了调用的接口、版本以及分组后，可以指定负载均衡策略、注册中心类型以及支持何种协议，当配置完成后，就可以生成客户端代理，开始远程调用了。服务端配置有所不同，除了配置注册中心以外，还可以配置序列化方式以及线程池，这些都会影响服务端的服务能力。</p>
<p>服务注册发现链路比较简单，它们贯穿在协议流程中，负责注册地址或者订阅服务。</p>
<p>调用链路从客户端发起调用开始，经历了客户端的选址和负载均衡后，将参数对象完成序列化，经过框架协议编码后，通过网络层发送出去。服务端接受到数据后进行解码，解码获得的二进制协议派发到服务端线程完成反序列化，生成出参数对象，最终完成反射调用。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-17-16-49-26.png" alt="" loading="lazy"></p>
<h3 id="调用方式" tabindex="-1"> 调用方式</h3>
<ul>
<li>同步实时调用：HSF的IO操作都是异步的，这里的同步其本质是做future.get(timeout)在这个点等待服务端的返回</li>
<li>Future异步调用</li>
<li>Callback异步调用（客户端需提供回调方法）</li>
<li>Generic调用（不依赖二方包，通过传入方法名，方法签名和参数值的方式调用服务）</li>
<li>服务端async调用（应用将通过AsyncContext写响应）</li>
<li>HTTP调用HSF(从2.1.1.6版本开始)</li>
</ul>
<p>此外Node， C++都是可以使用HSF的</p>
<h4 id="兼容调用" tabindex="-1"> 兼容调用</h4>
<p>一次远程服务调用都要经过代理层，协议层和IO层，其中在协议层，会根据服务提供者支持的协议选择不同的协议进行通信，如果服务提供者是DUBBO，那么就会根据其支持的协议选择DUBBO1或者DUBBO2协议进行传输，上层服务调用者不会感知到任何不同。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-19-15-27-47.png" alt="" loading="lazy"></p>
<h3 id="负载体系" tabindex="-1"> 负载体系</h3>
<p>HSF消费者启动的时候，会向ConfigServer注册自己订阅的服务信息，然后CS会将该服务的所有提供者IP推送给客户端，这时客户端就会根据从配置中心Diamond上拉下的规则对这些IP进行分类组装，然后返回给Consumer去随机调用，实现软负载的功能。规则的发布都可以在hsfops平台统一发布。</p>
<ol>
<li>路由规则：优先级是参数级路由 &gt; 方法级路由 &gt; 接口级路由</li>
<li>归组规则：每个应用唯一的一个归组，只有相同归组的服务（group）才能调用，对于发布了同一HSF服务的所有机器的一个分组。（如果不清楚，一般不要配置）。</li>
<li>同机房优先规则：HSF机房流量控制规则用于对跨机房间的HSF调用流量进行规划控制，能够保证HSF服务消费者在请求HSF服务时，优先选择与服务消费者同机房的服务提供者。同机房规则默认是关闭的。同样在ops上配置。有3个规则属性：</li>
</ol>
<ul>
<li>localPreferredSwitch： on|off</li>
<li>threshold： float值，生效阀值的计算方法：服务可用比例=本机房可用机器数量/服务所有机房的机器总量当服务可用比例&gt;=threshold时，启用本地机房优先策略当服务可用比例小于threshold时，本地机房优先策略关闭，服务仍然采用随机调用的方式</li>
<li>exclusions：如果期望该规则只对一部分机器生效，可以使用这一属性配置需要排除的IP，比如：172.24.*,将表示该规则不会应用于所有172.24打头的IP。</li>
</ul>
<ol start="4">
<li>权重规则：使用场景一般是压测或者机器的配置不均衡。</li>
</ol>
<h2 id="dubbo" tabindex="-1"> Dubbo</h2>
<p><a href="/notes/%E6%A1%86%E6%9E%B6/Dubbo.md" target="_blank" rel="noopener noreferrer">Dubbo详细内容</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>分布式消息</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">分布式消息</source>
      <category>中间件</category>
      <pubDate>Mon, 16 May 2022 04:59:52 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
</ul>

<p>分布式消息的主要目的是：解耦、滑峰填谷，保证最终一致性</p>
<h1 id="metaq" tabindex="-1"> MetaQ</h1>
<p>MetaQ是一款分布式、队列模型的消息中间件。分为Topic与Queue两种模式，Push（后台轮询pull）和Pull两种方式消费，支持严格的消息顺序，亿级别的堆积能力（超过后订阅消息吞吐量会下降），支持消息回溯（基于时间的回溯消费，）和多个维度的消息查询。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-23-25.png" alt="" loading="lazy"></p>
<h2 id="应用场景" tabindex="-1"> 应用场景</h2>
<ul>
<li>填⾕削峰，如聚⽯塔消息推送</li>
<li>和精卫配合做binlog同步、异步分发，TC、IC、UIC、彩票等</li>
<li>订单类应⽤，如⼩微⾦融的基⾦理财、阿⾥云官⽹售卖虚拟机等</li>
<li>流计算类应⽤，⽐如实时直播间</li>
<li>IM等实时消息领域，如钉钉的消息总线</li>
<li>⼴播⽅式cache同步</li>
</ul>
<h2 id="架构" tabindex="-1"> 架构</h2>
<h3 id="消息模型" tabindex="-1"> 消息模型</h3>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-23-59.png" alt="" loading="lazy"></p>
<ul>
<li>Producer：消息生产者，负责产生消息并发送消息到meta服务器</li>
<li>Consumer：消息消费者，负责消费消息，一般是后台系统负责异步消费。</li>
<li>Broker：Metaq的服务器</li>
<li>Topic：消息的主题,由用户定义并在服务端配置</li>
<li>Message：在生产者，消费者，服务器间传递的消息</li>
<li>Group：组名，一类Producer/Consumer的集合名称，通常称为Producer/Consumer集群</li>
<li>Offset：消息在服务器上的每个分区都是组织成一个文件列表,消费者拉取数据需要知道数据在文件中的偏移量,这个偏移量就是所谓的offset。</li>
</ul>
<h3 id="物理模型" tabindex="-1"> 物理模型</h3>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-24-53.png" alt="" loading="lazy"></p>
<p>各组件功能为：</p>
<ul>
<li>Name Server：注册服务器，Name Server 是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。name server保存topic与broker集群的对应关系，决定哪个topic路由到哪个broker集群。在broker 注册topic信息的时候，写入所有节点。</li>
<li>Broker：存储转发服务器，每个broker需要与所有的name server建立长连接，从而获取topic信息；分为master和容灾的slaver，Master 与Slave 的对应关系通过指定相同的BrokerName，不同BrokerId 来定义</li>
<li>Producer：消息发送方，需要与其中一个name server建立连接，获得路由信息，再与主题对应的broker建立长连接且定时向master发送心跳；消息由producer发送到master，再由master同步到所有broker</li>
<li>Consumer：消息接收方，需要与其中一个name server建立连接，获得路由信息，再向提供服务的master、slaver建立长连接，具体接收消息时刻选择broker</li>
</ul>
<h3 id="存储结构" tabindex="-1"> 存储结构</h3>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-26-02.png" alt="" loading="lazy"></p>
<p>物理队列只有一个，采用固定大小的文件顺序存储消息。逻辑队列有多个，每个逻辑队列有多个分区，每个分区有多个索引。</p>
<p>a.消息顺序写入物理文件里面，每个文件达到一定的大小，新建一个文件继续顺序写数据（消息的写入是串行的，避免了磁盘竞争）。</p>
<p>b.消息的索引则顺序的写入逻辑文件中，并不存放真正的消息，只是存放指向消息的索引。 metaq对于客户端展现的是逻辑队列就是消费队列，consumer从消费队列里顺序取消息进行消费。</p>
<p>这种设计是把物理和逻辑分离，消费队列更加轻量化。所以metaq可以支撑更多的消费队列数，提升消息的吞吐量，并且有一定的消息堆积能力。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-17-16-05-40.png" alt="" loading="lazy"></p>
<p>缺点 ： 写虽然是顺序写，但是读却是随机读的 解决办法 ：尽可能让读命中pageCache，减少磁盘IO次数， metaq的所有消息都是持久化的，先写入系统PAGECACHE（页高速缓存），然后刷盘，可以保证内存与磁盘都有一份数据，访问时，直接从内存读取。 刷盘策略分为异步和同步两种。</p>
<h3 id="整体存储结构" tabindex="-1"> 整体存储结构</h3>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-17-15-23-02.png" alt="" loading="lazy"></p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-19-15-59-39.png" alt="" loading="lazy"></p>
<h4 id="index结构" tabindex="-1"> index结构</h4>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-19-16-22-22.png" alt="" loading="lazy"></p>
<p>Header：记录落Broker时间戳、偏移量，槽位数目和索引个数</p>
<p>SlotTable：数组插槽，插槽位置 = key的Hash值 % 插槽数量，每个槽位记录当前索引总数</p>
<p>Index Linked List：插槽后接的链表结构，记录key的Hash值、物理偏移地址、落盘时间和哈希冲突后上一个索引地址</p>
<ul>
<li>通过MessageKey检索消息：通过key定位slot，加锁从最大索引值开始倒序查找，比对hash值和落盘时间，返回一致时的物理偏移地址。</li>
</ul>
<h2 id="组件" tabindex="-1"> 组件</h2>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-17-16-40-20.png" alt="" loading="lazy"></p>
<h3 id="broker" tabindex="-1"> broker</h3>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-17-16-34-37.png" alt="" loading="lazy"></p>
<h4 id="负载均衡" tabindex="-1"> 负载均衡</h4>
<ul>
<li>一个topic分布在多个broker上，一个broker可以配置多个topic，它们是多对多的关系。</li>
<li>如果某个topic消息量很大，应该给它多配置几个队列，并且尽量多分布在不同broker上，减轻某个broker的压力。</li>
<li>topic消息量都比较均匀的情况下，如果某个broker上的队列越多，则该broker压力越大。</li>
</ul>
<h4 id="可用性" tabindex="-1"> 可用性</h4>
<p>由于消息分布在各个broker上，一旦某个broker宕机，则该broker上的消息读写都会受到影响。所以rocketmq提供了master/slave的结构，salve定时从master同步数据，如果master宕机，则slave提供消费服务，但是不能写入消息，此过程对应用透明，由rocketmq内部解决。</p>
<ul>
<li>一旦某个broker master宕机，生产者和消费者多久才能发现？受限于rocketmq的网络连接机制，默认情况下，最多需要30秒，但这个时间可由应用设定参数来缩短时间。这个时间段内，发往该broker的消息都是失败的，而且该broker的消息无法消费，因为此时消费者不知道该broker已经挂掉。</li>
<li>消费者得到master宕机通知后，转向slave消费，但是slave不能保证master的消息100%都同步过来了，因此会有少量的消息丢失。但是消息最终不会丢的，一旦master恢复，未同步过去的消息会被消费掉。</li>
</ul>
<h2 id="特性" tabindex="-1"> 特性</h2>
<h3 id="消息的可靠性保证" tabindex="-1"> 消息的可靠性保证</h3>
<p>一个消息从发送端应用，到消费端应用，中间有三个过程需要保证消息的可靠性。</p>
<p>1.发送端发消息</p>
<p>消息生产者发送消息后返回SendResult，如果isSuccess返回为true,则表示消息已经确认发送到服务器并被服务器接收存储。整个发送过程是一个同步的过程。保证消息送达服务器并返回结果。 只有当消息中间件及时明确的返回成功，才能确认消息可靠到达消息中间件。</p>
<p>2.消息中间件把消息存储起来</p>
<p>metaq服务器收到消息后首先把消息存放在磁盘文件中，确保持久存储，写入成功之后返回应答给发布者。因此，可以确认每条发送结果为成功的消息服务器都是写入磁盘的。 内存中内容属于非持久数据，会在断电之后丢失。</p>
<p>刷盘方式有同步双写和异步复制：</p>
<ul>
<li>同步双写：主备都刷盘完成才返回成功，能够保证数据的完全可靠性，但是目前主备不能自动切换，还需要手动切换，所以，还可能有部分数据丢失（切换中的数据）。</li>
<li>异步复制：异步的同步两个主备磁盘，可以保证数据的99%的不丢，但是当主异常时候，可能会有部分数据没有异步复制完成，导致少量数据丢失。broker slave启动一个线程，不断从master拉取数据，然后异步构建consume queue数据结构。</li>
</ul>
<p>3.消费端消费消息</p>
<p>消费者是一条接着一条地顺序消费消息，只有在成功消费一条消息后才会接着消费下一条。 如果在消费某条消息失败（如异常），则会尝试重试消费这条消息（默认最大5次），超过最大次数后仍然无法消费，则将消息存储在消费者的本地磁盘，由后台线程继续做重试。而主线程继续往后走，消费后续的消息。。由此来保证消息的可靠消费。</p>
<h3 id="消息发布" tabindex="-1"> 消息发布</h3>
<ol>
<li>消息生产者发送消息后返回SendResult，如果isSuccess返回为true,则表示消息已经确认发送到服务器并被服务器接收存储。整个发送过程是一个同步的过程。保证消息送达服务器并返回结果。 只有当消息中间件及时明确的返回成功，才能确认消息可靠到达消息中间件。</li>
<li>发送消息时，如果订阅方有过滤需求，请在消息Tag属性上设置相关值，Tag的名称不需要申请，可自由设置，一条消息只允许设置一个Tag。</li>
</ol>
<h3 id="消息订阅" tabindex="-1"> 消息订阅</h3>
<ol>
<li>非顺序消息消费，耗时时间不做限制，但是应用应该尽可能保证耗时短，这样才能达到高性能，另外消费消息Hang住，会导致消息所在队列的消费动作暂停，直到Hang住的消息消费完。对其他队列不受影响</li>
<li>顺序消息消费，耗时时间有限制，要保证每条消息在30s内消费完，超过30s会有潜在的乱序问题。（原因是分布式锁超时问题，但概率极低）</li>
<li>消费方式：
<ul>
<li>集群消费，一条消息只会被同一个group里一个消费端消费。不同group之间相互不影响。</li>
<li>广播消费，一条消息会被同一个group里每一个消费端消费。</li>
</ul>
</li>
<li>消息堆积：MetaQ每台服务器提供大约亿级的消息堆积能力（多个业务方共用），超过堆积阀值，订阅消息吞吐量会下降。</li>
</ol>
<h3 id="顺序消息" tabindex="-1"> 顺序消息</h3>
<p>普通顺序消息：正常情况下保证完全的消息顺序，一旦异常，broker重启，由于队列总数发生变化，哈希取模后定位的队列会变化，产生短暂的消息顺序不一致。</p>
<p>严格顺序消息：无论正常异常情况都能保证顺序，但是牺牲了分布式Failover （分布式异常回复机制）特性，即Broker 集群中只要有一台机器不可用，则整个集群都不可用，服务可用性大大降低。无论正常异常情况都能保证顺序，但是牺牲了分布式Failover 特性，即Broker 集群中只要有一台机器不可用，则整个集群都不可用，服务可用性大大降低。</p>
<h3 id="消息过滤" tabindex="-1"> 消息过滤</h3>
<p>在Broker 中，按照Consumer 的要求做过滤，优点是减少了对于Consumer 无用消息的网络传输。缺点是增加了Broker 的负担，实现相对复杂。Notify 支持多种过滤方式，包含直接按照消息类型过滤，灵活的语法表达式过滤，几乎可以满足最苛刻的过滤需求。metaq 支持按照简单的Message Tag 过滤，也支持按照Message Header、body 进行过滤。</p>
<h3 id="消息重试" tabindex="-1"> 消息重试</h3>
<ol>
<li>非顺序消息消费失败重试，消费失败的消息发回服务器，应用可以指定这条失败消息下次到达Consumer的时间。消费失败重试次数有限制，通常线上为每个订阅组每条失败消息重试5次（每次消息都会定时重试，定时时间随着重试次数递增，此过程应用可干预）。超过重试次数，消息进入死信队列，并向用户报警。</li>
<li>顺序消息消费失败重试，某个队列正在消费的消息消费失败，会将当前队列挂起（挂起时间应用可通过API设置），其他队列仍然正常消费。</li>
</ol>
<h3 id="消息重复性" tabindex="-1"> 消息重复性</h3>
<p>MetaQ不能保证消息不重复</p>
<ul>
<li>发送消息阶段，会存在分布式环境下典型的超时问题，即发送消息阶段不能保证消息不重复。</li>
<li>订阅消息阶段，由于涉及集群订阅，多个订阅者需要Rebalance方式订阅，在Rebalance短暂不一致情况下，会产生消息重复</li>
<li>订阅者意外宕机，消费进度未及时存储，也会产生消息重复</li>
</ul>
<p>解决</p>
<ul>
<li>应用方收到消息后，可通过Tair、DB等去重</li>
<li>应用方可通过主动拉的方式，可保证拉消息绝对不重复，但是分布式协调分配队列问题需要应用来控制</li>
</ul>
<h2 id="通信" tabindex="-1"> 通信</h2>
<h3 id="通信方式" tabindex="-1"> 通信方式</h3>
<p>同步(sync)
异步(async)
单向(oneway)</p>
<h3 id="reactor多线程" tabindex="-1"> Reactor多线程</h3>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-19-16-03-32.png" alt="" loading="lazy"></p>
<p>一个 Reactor 主线程（eventLoopGroupBoss，即为上面的1）负责监听 TCP网络连接请求，建立好连接后丢给Reactor 线程池（eventLoopGroupSelector，即为上面的“N”，源码中默认设置为3），它负责将建立好连接的socket 注册到 selector上去（RocketMQ的源码中会自动根据OS的类型选择NIO和Epoll，也可以通过参数配置），然后监听真正的网络数据。拿到网络数据后，再丢给Worker线程池（defaultEventExecutorGroup，即为上面的“M1”，源码中默认设置为8）。</p>
<p>为了更为高效的处理RPC的网络请求，这里的Worker线程池是专门用于处理Netty网络通信相关的（包括编码/解码、空闲链接管理、网络连接管理以及网络请求处理）。而处理业务操作放在业务线程池中执行（在NettyServerHandler中，对接收到的请求数据处理），根据 RomotingCommand 的业务请求码code去processorTable这个本地缓存变量中找到对应的 processor，然后封装成task任务后，提交给对应的业务processor处理线程池来执行（sendMessageExecutor，以发送消息为例，即为上面的 “M2”）。</p>
<table>
<thead>
<tr>
<th>线程数</th>
<th>线程名</th>
<th>线程具体说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>NettyBoss_%d</td>
<td>Reactor 主线程</td>
</tr>
<tr>
<td>N</td>
<td>NettyServerEPOLLSelector_%d_%d</td>
<td>Reactor 线程池</td>
</tr>
<tr>
<td>M1</td>
<td>NettyServerCodecThread_%d</td>
<td>Worker线程池</td>
</tr>
<tr>
<td>M2</td>
<td>RemotingExecutorThread_%d</td>
<td>业务processor处理线程池</td>
</tr>
</tbody>
</table>
<h2 id="事务消息" tabindex="-1"> 事务消息</h2>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-19-16-34-31.png" alt="" loading="lazy"></p>
<ol>
<li>事务消息与普通消息的区别就在于消息生产环节，生产者首先预发送一条消息到MQ(这也被称为发送half消息)</li>
<li>MQ接受到消息后，先进行持久化，则存储中会新增一条状态为待发送的消息</li>
<li>然后返回ACK给消息生产者，此时MQ不会触发消息推送事件</li>
<li>生产者预发送消息成功后，执行本地事务</li>
<li>执行本地事务，执行完成后，发送执行结果给MQ</li>
<li>MQ会根据结果删除或者更新消息状态为可发送</li>
<li>如果消息状态更新为可发送，则MQ会push消息给消费者，后面消息的消费和普通消息是一样的</li>
</ol>
<p>局限性：
针对消息消费失败场景，如果是消息处理真的失败了，重试多次仍然失败，如消息消费依赖1-5业务系统，1，2，3，4执行成功，5失败，此时，为了保证一致性，如果直接回滚1-4的操作，复杂度太高。目前这里的处理主要是补偿策略和对账。</p>
<p>Metaq的存储结构是文件记录形式，通过Offset递增进行访问数据，缺乏KV存储具有的update能力，如果要支持事务，必须引入类似于KV存储的模块才可以。所以Metaq目前对分布式事务支持不好。</p>
<h1 id="消息队列对比" tabindex="-1"> 消息队列对比</h1>
]]></content:encoded>
    </item>
    <item>
      <title>分布式缓存</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">分布式缓存</source>
      <category>中间件</category>
      <pubDate>Mon, 16 May 2022 04:59:52 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<p>缓存我们知道分为本地缓存和分布式缓存，本地缓存是本机使用，随着本地计算机系统向分布式系统的扩展，在分布式计算领域中得到了广泛的应用，称为分布式缓存。</p>
<p>分布式缓存能够处理大量的动态数据，因此比较适合应用在Web 2.0时代中的社交网站等需要由用户生成内容的场景。从本地缓存扩展到分布式缓存后，关注重点从CPU、内存、缓存之间的数据传输速度差异也扩展到了业务系统、数据库、分布式缓存之间的数据传输速度差异。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-30-40.png" alt="" loading="lazy"></p>
<h1 id="缓存更新模式" tabindex="-1"> 缓存更新模式</h1>
<h2 id="cache-aside" tabindex="-1"> Cache Aside</h2>
<p>常用的缓存模式了，具体的流程是：</p>
<ul>
<li>失效：应用程序先从 cache 取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li>
<li>命中：应用程序从 cache 中取数据，取到后返回。</li>
<li>更新：先把数据存到数据库中，成功后，再让缓存失效。</li>
</ul>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-15-45-40.png" alt="" loading="lazy"></p>
<h2 id="read-write-through-更新模式" tabindex="-1"> Read/Write Through 更新模式</h2>
<p>在上面的 Cache Aside 更新模式中，应用代码需要维护两个数据存储，一个是缓存（Cache），一个是数据库（Repository）。而在Read/Write Through 更新模式中，应用程序只需要维护缓存，数据库的维护工作由缓存代理了。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-15-46-38.png" alt="" loading="lazy"></p>
<ul>
<li>Read Through：Read Through 模式就是在查询操作中更新缓存，也就是说，当缓存失效的时候，Cache Aside 模式是由调用方负责把数据加载入缓存，而 Read Through 则用缓存服务自己来加载。</li>
<li>Write Through：Write Through 模式和 Read Through 相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后由缓存自己更新数据库（这是一个同步操作）。</li>
</ul>
<h2 id="write-behind-caching-更新模式" tabindex="-1"> Write Behind Caching 更新模式</h2>
<p>Write Behind Caching 更新模式就是在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处就是直接操作内存速度快。因为异步，Write Behind Caching 更新模式还可以合并对同一个数据的多次操作到数据库，所以性能的提高是相当可观的。</p>
<p>但其带来的问题是，数据不是强一致性的，而且可能会丢失。另外，Write Behind Caching 更新模式实现逻辑比较复杂，因为它需要确认有哪些数据是被更新了的，哪些数据需要刷到持久层上。只有在缓存需要失效的时候，才会把它真正持久起来。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-15-47-29.png" alt="" loading="lazy"></p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>三种缓存模式的优缺点：</p>
<p>Cache Aside 更新模式实现起来比较简单，但是需要维护两个数据存储，一个是缓存（Cache），一个是数据库（Repository）。</p>
<p>Read/Write Through 更新模式只需要维护一个数据存储（缓存），但是实现起来要复杂一些。</p>
<p>Write Behind Caching 更新模式和Read/Write Through 更新模式类似，区别是Write Behind Caching 更新模式的数据持久化操作是异步的，但是Read/Write Through 更新模式的数据持久化操作是同步的。优点是直接操作内存速度快，多次操作可以合并持久化到数据库。缺点是数据可能会丢失，例如系统断电等。</p>
<p>缓存是通过牺牲强一致性来提高性能的。所以使用缓存提升性能，就是会有数据更新的延迟。这需要我们在设计时结合业务仔细思考是否适合用缓存。然后缓存一定要设置过期时间，这个时间太短太长都不好，太短的话请求可能会比较多的落到数据库上，这也意味着失去了缓存的优势。太长的话缓存中的脏数据会使系统长时间处于一个延迟的状态，而且系统中长时间没有人访问的数据一直存在内存中不过期，浪费内存。</p>
<h1 id="缓存淘汰算法" tabindex="-1"> 缓存淘汰算法</h1>
<p>缓存淘汰算法是指令的一个明细表，用于决定缓存系统中哪些数据应该被删去。</p>
<h2 id="最不经常使用算法-lfu" tabindex="-1"> 最不经常使用算法（LFU）</h2>
<p>这个缓存算法使用一个计数器来记录条目被访问的频率。通过使用LFU缓存算法，最低访问数的条目首先被移除。这个方法并不经常使用，因为它无法对一个拥有最初高访问率之后长时间没有被访问的条目缓存负责。</p>
<h2 id="最近最少使用算法-lru" tabindex="-1"> 最近最少使用算法（LRU）</h2>
<p>LRU（The Least Recently Used，最近最久未使用算法）是一种常见的缓存算法，在很多分布式缓存系统（如Redis, Memcached）中都有广泛使用。</p>
<p>这个缓存算法将最近使用的条目存放到靠近缓存顶部的位置。当一个新条目被访问时，LRU将它放置到缓存的顶部。当缓存达到极限时，较早之前访问的条目将从缓存底部开始被移除。这里会使用到昂贵的算法，而且它需要记录“年龄位”来精确显示条目是何时被访问的。此外，当一个LRU缓存算法删除某个条目后，“年龄位”将随其他条目发生改变。</p>
<h2 id="先进先出算法-fifo" tabindex="-1"> 先进先出算法（FIFO）</h2>
<p>FIFO是英文First In First Out 的缩写，是一种先进先出的数据缓存器，他与普通存储器的区别是没有外部读写地址线，这样使用起来非常简单，但缺点就是只能顺序写入数据，顺序的读出数据，其数据地址由内部读写指针自动加1完成，不能像普通存储器那样可以由地址线决定读取或写入某个指定的地址。</p>
<h1 id="tair" tabindex="-1"> Tair</h1>
<p>Tair是一个类似于map的key/value结构存储系统（也就是缓存系统），具备标准的特性是：高性能、高扩展、高可靠，也就是传说中的三高产品，支持分布式集群部署。官网说目前支持java和c这两个版本。</p>
<ul>
<li>高性能——基于高速缓存、内存或者ssd</li>
<li>高扩展——轻量中间件+三种数据引擎+负载均衡</li>
<li>高可用——各种容灾部署方式和解决方案</li>
</ul>
<h2 id="主要功能" tabindex="-1"> 主要功能：</h2>
<ul>
<li>数据库缓存——作为数据库与dao层之间的中间缓存，降低对后端数据库的访问压力，高速缓存能使得访问速度达到1ms级别，例如高频率的数据库查询；</li>
<li>临时数据存储——应用程序需要维护大量临时数据，将临时数据存储在mdb中，可以降低内存管理的开销，改进应用程序工作负载。例如：在分布式系统中，同一个用户的不同请求可能会发送到不同的服务器上，这时可以用mdb作为全局存储，用于保存Session数据、用户的Token、权限信息等数据。【通常将缓存和临时数据存储统称为“非持久化存储”】</li>
<li>持久化存储——此时类似于传统的数据库，将数据存入磁盘中做持久化存储，例如广告推荐类需要离线计算大量数据以及榜单的生成（注意：由于此时采用的数据库引擎ldb是NoSQL类型的，所以不支持sql查询）</li>
</ul>
<h2 id="架构" tabindex="-1"> 架构</h2>
<h3 id="物理架构" tabindex="-1"> 物理架构</h3>
<p>Tair是Master/Slave结构。Config Server管理Data Server节点、维护Data Server的状态信息；Data Server负责数据存储，按照Config Server的指示完成数据复制和迁移工作，并定时给Config Server发送心跳信息。Config Server是单点，采用一主一备的方式保证可靠性。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-37-50.png" alt="" loading="lazy"></p>
<h3 id="逻辑架构" tabindex="-1"> 逻辑架构</h3>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-38-17.png" alt="" loading="lazy"></p>
<h2 id="存储模式对比" tabindex="-1"> 存储模式对比</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>基于数据库</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>MDB</td>
<td>Memcached</td>
<td>基于内存；仅支持k-v类型数据；不支持持久化</td>
<td>数据小而简单，读多（QPS 万以上）写少，且偶尔数据丢失不应该对业务产生较大影响；例如访问量显示，session manager等功能</td>
</tr>
<tr>
<td>RDB</td>
<td>Redis</td>
<td>基于内存；除了kv，还支持string, list, hash, set, sortedset等数据类型；</td>
<td>支持一定程度的持久化</td>
</tr>
<tr>
<td>LDB</td>
<td>LevelDB</td>
<td>基于ssd硬盘；仅支持k-v类型数据；支持持久化</td>
<td>数据简单，有持久化需求，且读写QPS较高（万级别）但存储数据较简单的应用场景；例如订单计数，库存记录等功能，更新非常频繁。</td>
</tr>
</tbody>
</table>
<h2 id="数据一致性" tabindex="-1"> 数据一致性</h2>
<p>Tair使用版本号version来保证数据一致性。在Tair的put接口中有version参数，如果不带version参数，则不考虑并发，直接强制更新。</p>
<ul>
<li>version：为解决并发更新同一个数据而设置。当version=0时，表示强制更新，当version非0时，判断客户端和服务端当version是否一致，不一致则返回ResultCode.VERERROR.</li>
<li>version的增加是服务器端的行为，tair并不支持多版本数据。另外，更新也是使用put接口。</li>
<li>version的值是由服务器端决定的，和client指定的version值无关。</li>
</ul>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-42-05.png" alt="" loading="lazy"></p>
<h2 id="负载均衡" tabindex="-1"> 负载均衡</h2>
<p>分布式负载均衡采用的是一致性哈希算法</p>
<ol>
<li>将机器根据hash函数映射到环上；</li>
<li>将数据桶根据hash函数映射到换上；</li>
<li>据数据映射到桶的位置顺时针找到第一台机器将该桶放到该机器上；</li>
<li>当某台机器坏掉时，类似(3)将存储在该机器上的数据顺时针找到下一台机器；</li>
<li>当增加机器时，将该机器与前一台机器(逆时针)之间的桶存储在新增机器上并从原来机器上移除。</li>
</ol>
<ul>
<li>优点：相比简单的对机器数取模算法，当节点变动的时候只有相对较少的key失效，实现也相对简单。不需要进行数据迁移，每个服务器是独立的。</li>
<li>缺点：还是会有部分的key失效，如果访问量非常大的时候，如果访问到失效的key的时候，就会直接访问到数据源上面去了，可能会导致数据源直接压挂。</li>
</ul>
<h2 id="多级缓存" tabindex="-1"> 多级缓存</h2>
<p>问题背景</p>
<p>Tair是一个高性能、分布式、可扩展、高可靠的NoSQL存储系统，在阿里巴巴集团内部有着大量的部署和使用。由于Tair的访问方式是客户端对请求的Key进行类一致性 Hash 计算后，再通过数据路由表查表定位到某台DataServer（数据节点服务器）进行读写的，所以对相同Key的读写请求必然固定映射到相同的DataServer上，如图
<img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-45-22.png" alt="" loading="lazy"></p>
<p>此时DataServer单节点的读写性能便成了单Key的读写性能瓶颈，且无法通过简单的水平扩展来解决。由于电商系的促销活动天然的存在热点数据，所以热点数据缓存的读写能力对整个缓存集群的稳定性和服务能力都起着至关重要的作用。</p>
<h3 id="热点读写" tabindex="-1"> 热点读写</h3>
<h4 id="热点识别" tabindex="-1"> 热点识别</h4>
<p>DataServer收到客户端的请求后，由每个具体处理请求的工作线程（Worker Thread）进行请求的统计。工作线程用来统计热点的数据结构均为ThreadLocal模式的数据结构，完全无锁化设计。热点识别算法使用精心设计的多级加权LRU链和HashMap组合的数据结构，在保证服务端请求处理效率的前提下进行请求的全统计，支持QPS热点和流量热点（即请求的QPS不大但是数据本身过大而造成的大流量所形成的热点）的精准识别。每个采样周期结束时，工作线程会将统计的数据结构转交到后台的统计线程池进行分析处理。统计工作异步在后台进行，不抢占正常的数据请求的处理资源。</p>
<h4 id="读热点" tabindex="-1"> 读热点</h4>
<ol>
<li>服务端设计</li>
</ol>
<p>相同Key的读写请求必然落在固定的DataServer上，且无法通过水平扩展DataServer数量来解决。</p>
<p>通过在DataServer上划分一块HotZone存储区域的方式来解决热点数据的访问。该区域存储当前产生的所有读热点的数据，由客户端配置的缓存访问逻辑来处理各级缓存的访问。多级缓存架构如下：</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-12-00-19.png" alt="" loading="lazy"></p>
<p>所有DataServer的HotZone存储区域之间没有权重关系，每个HotZone都存储相同的读热点数据。客户端对热点数据Key的请求会随机到任意一台DataServer的HotZone区域，这样单点的热点请求就被散列到多个节点乃至整个集群。</p>
<p>DataServer的HotZone使用独立的网络IO线程与工作线程，监听独立的热点数据读写端口，并初始化独立的LocalTair 模式的Mdb实例，进行热点数据的存储。使用独立的Mdb实例的原因是该逻辑要同时兼容Mdb和Ldb引擎，为了一套代码通用，所以从IO线程到Worker线程再到具体的处理线程都是独立的代码逻辑，并使用独立的Mdb实例进行存储。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-57-09.png" alt="" loading="lazy"></p>
<ol start="2">
<li>客户端设计</li>
</ol>
<p>当客户端在第一次请求前初始化时，会获取整个Tair集群的节点信息以及完整的数据路由表，同时也会获取配置的热点散列机器数（即客户端访问的HotZone的节点范围）。随后客户端随机选择一个HotZone区域作为自身固定的读写HotZone区域。在DataServer数量和散列机器数配置未发生变化的情况下，不会改变选择。即每个客户端只访问唯一的HotZone区域。</p>
<h4 id="写热点" tabindex="-1"> 写热点</h4>
<p>对于写热点，因为一致性的问题，难以使用多级缓存的方式来解决。</p>
<p>热点Key的写请求在IO线程被分发到专门的热点合并线程处理，该线程根据Key对写请求进行一定时间内的合并，随后由定时线程按照预设的合并周期将合并后的请求提交到引擎层。合并过程中请求结果暂时不返回给客户端，等请求合并写入引擎成功后统一返回。这样做不会有一致性的问题，不会出现写成功后却读到旧数据，也避免了LDB集群返回成功，数据并未落盘的情况（假写）。具体的合并周期在服务端可配置，并支持动态修改生效。</p>
<h1 id="分布式缓存面临的问题" tabindex="-1"> 分布式缓存面临的问题</h1>
<h2 id="缓存与数据库双写不一致" tabindex="-1"> 缓存与数据库双写不一致</h2>
<p>一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果你的系统不是严格要求 “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：读请求和写请求串行化，串到一个内存队列里去。</p>
<p>串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>
<h2 id="缓存穿透" tabindex="-1"> 缓存穿透</h2>
<p>访问一个不存在的 key，缓存不起作用，请求会穿透到 DB，流量大时 DB 会挂掉。</p>
<p>举个栗子。系统A，每秒 5000 个请求，结果其中 4000 个请求是黑客发出的恶意攻击。数据库 id 是从 1 开始的，而黑客发过来的请求 id 全部都是负数。这样的话，缓存中不会有，请求每次都“视缓存于无物”，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-16-48-39.png" alt="" loading="lazy"></p>
<p>解决方案：</p>
<ol>
<li>对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该 key 对应的数据 insert 之后再清理缓存。</li>
<li>对一定不存在的 key 进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该Bitmap过滤。</li>
</ol>
<h2 id="缓存雪崩" tabindex="-1"> 缓存雪崩</h2>
<p>对于系统 A，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-16-49-58.png" alt="" loading="lazy"></p>
<p>解决方案：</p>
<ol>
<li>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。</li>
<li>不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</li>
<li>做二级缓存，A1 为原始缓存，A2为拷贝缓存，A1 失效时，可以访问 A2，A1 缓存失效时间设置为短期，A2 设置为长期（此点为补充）</li>
</ol>
<p>缓存雪崩的事前事中事后的解决方案如下：</p>
<p>事前：Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃。
事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。
事后：Redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-16-59-15.png" alt="" loading="lazy"></p>
<p>用户发送一个请求，系统 A 收到请求后，先查本地 ehcache 缓存，如果没查到再查 Redis。如果 ehcache 和 Redis 都没有，再查数据库，将数据库中的结果，写入 ehcache 和 Redis 中。</p>
<p>限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？走降级！可以返回一些默认的值，或者友情提示，或者空值。</p>
<p>好处：</p>
<ul>
<li>数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。</li>
<li>只要数据库不死，就是说，对用户来说，2/5 的请求都是可以被处理的。</li>
<li>只要有 2/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来了</li>
</ul>
<h2 id="缓存击穿" tabindex="-1"> 缓存击穿</h2>
<p>某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。</p>
<p>解决方案：</p>
<ol>
<li>使用互斥锁 (mutex key)：感知到缓存失效，去查询 DB 时，使用分布式锁，使得只有一个线程去数据库加载数据，加锁失败的线程，等待即可。</li>
<li>手动过期：redis 上从不设置过期时间，功能上将过期时间存在 key 对应的 value 里，如果发现要过期，通过一个后台的异步线程进行缓存的构建，也就是“手动”过期。</li>
</ol>
<p>不同场景下的解决方式可如下：</p>
<ul>
<li>若缓存的数据是基本不会发生更新的，则可尝试将该热点数据设置为永不过期。</li>
<li>若缓存的数据更新不频繁，且缓存刷新的整个流程耗时较少的情况下，则可以采用基于 Redis、zookeeper 等分布式中间件的分布式互斥锁，或者本地互斥锁以保证仅少量的请求能请求数据库并重新构建缓存，其余线程则在锁释放后能访问到新缓存。</li>
<li>若缓存的数据更新频繁或者在缓存刷新的流程耗时较长的情况下，可以利用定时线程在缓存过期前主动地重新构建缓存或者延后缓存的过期时间，以保证所有的请求能一直访问到对应的缓存。</li>
</ul>
<h2 id="缓存并发竞争" tabindex="-1"> 缓存并发竞争</h2>
<p>某个时刻，多个系统实例都去更新某个 key。可以基于 zookeeper 实现分布式锁。每个系统通过 zookeeper 获取分布式锁，确保同一时间，只能有一个系统实例在操作某个 key，别人都不允许读和写。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-17-11-50.png" alt="" loading="lazy"></p>
<p>要写入缓存的数据都是从 mysql 里查出来的，都得写入 mysql 中，写入 mysql 中的时候必须保存一个时间戳，从 mysql 查出来的时候，时间戳也要查出来。</p>
<p>每次要写之前，先判断一下当前这个 value 的时间戳是否比缓存里的 value 的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。</p>
<h1 id="常见缓存框架" tabindex="-1"> 常见缓存框架</h1>
<h2 id="ehcache" tabindex="-1"> EhCache</h2>
<p>EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认CacheProvider</p>
<h3 id="特性" tabindex="-1"> 特性</h3>
<ul>
<li>快速、简单</li>
<li>多种缓存策略</li>
<li>缓存数据有两级：内存和磁盘</li>
<li>缓存数据会在虚拟机重启的过程中写入磁盘</li>
<li>可以通过RMI、可插入API等方式进行分布式缓存</li>
<li>具有缓存和缓存管理器的侦听接口</li>
<li>支持多缓存管理器实例，以及一个实例的多个缓存区域</li>
<li>内存统计</li>
</ul>
<h3 id="瓶颈" tabindex="-1"> 瓶颈</h3>
<ul>
<li>
<p>缓存漂移（Cache Drift）
每个应用节点只管理自己的缓存，在更新某个节点的时候，不会影响到其他的节点，这样数据之间可能就不同步了。</p>
</li>
<li>
<p>数据库瓶颈（Database Bottlenecks ）
对于单实例的应用来说，缓存可以保护数据库的读风暴；但是，在集群的环境下，每一个应用节点都要定期保持数据最新，节点越多，要维持这样的情况对数据库的开销也越大。</p>
</li>
</ul>
<h2 id="guava-cache" tabindex="-1"> Guava Cache</h2>
<p>Guava Cache是Google开源的Java重用工具集库Guava里的一款缓存工具，它的设计灵感来源于ConcurrentHashMap，使用多个segments方式的细粒度锁，在保证线程安全的同时，支持高并发场景需求，同时支持多种类型的缓存清理策略，包括基于容量的清理、基于时间的清理、基于引用的清理等。
Guava cache是google开发的，目前被常用在单机上，如果是分布式，它就无能为力了</p>
<h3 id="特性-1" tabindex="-1"> 特性</h3>
<p>guava cache类似concurrentMap使用分段锁提高并发写的效率</p>
<ul>
<li>支持缓存三种缓存淘汰策略</li>
<li>支持缓存移除监听(移除、过期、gc回收)</li>
<li>支持key/value的软引用、弱引用缓存</li>
<li>命中率统计</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>分布式计算</title>
      <link>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97.html</link>
      <guid>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97.html</guid>
      <source url="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/rss.xml">分布式计算</source>
      <category>中间件</category>
      <pubDate>Mon, 16 May 2022 04:59:52 GMT</pubDate>
      <content:encoded><![CDATA[
<ul>
<li></li>
</ul>

<h1 id="分布式计算" tabindex="-1"> 分布式计算</h1>
<p>分布式计算系统构建在分布式存储的基础上，充分发挥分布式系统的数据冗余灾备，多副本高效获取数据的特性，进而并行计算，把原本需要长时间计算的任务拆分成多个任务并行处理，从而提高了计算效率。分布式计算系统在场景上分为离线计算，实时计算和流式计算。</p>
<ul>
<li>离线：Hadoop</li>
<li>实时：Spark</li>
<li>流式：Storm，Flink/Blink</li>
</ul>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-15-18-36.png" alt="" loading="lazy"></p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-15-18-43.png" alt="" loading="lazy"></p>
]]></content:encoded>
    </item>
  </channel>
</rss>