---
title: Java虚拟机执行系统
icon:
category: Java
tag:
  - JVM
  - 类加载
---
<!-- GFM-TOC -->
* [五、类文件结构](#五类文件结构)
  * [Class类文件的结构](#class类文件的结构)
    * [1. 魔数](#1-魔数)
    * [2. Class文件版本](#2-class文件版本)
    * [3. 常量池](#3-常量池)
    * [4. 访问标志](#4-访问标志)
    * [5. 当前类索引,父类索引与接口索引集合](#5-当前类索引父类索引与接口索引集合)
    * [6. 字段表集合](#6-字段表集合)
    * [7. 方法表集合](#7-方法表集合)
    * [8. 属性表集合](#8-属性表集合)
  * [字节码指令](#字节码指令)
    * [1. 字节码和数据类型](#1-字节码和数据类型)
    * [2. 加载和存储指令](#2-加载和存储指令)
    * [3. 运算指令](#3-运算指令)
    * [4. 类型转换指令](#4-类型转换指令)
    * [5. 对象创建与访问指令](#5-对象创建与访问指令)
    * [6. 操作数栈管理指令](#6-操作数栈管理指令)
    * [7. 控制转移指令](#7-控制转移指令)
    * [8. 方法调用和返回指令](#8-方法调用和返回指令)
    * [9. 异常处理](#9-异常处理)
    * [10. 同步指令](#10-同步指令)
  * [公有设计和私有实现](#公有设计和私有实现)
* [六、类加载机制](#六类加载机制)
  * [类的生命周期](#类的生命周期)
  * [类加载过程](#类加载过程)
    * [1. 加载](#1-加载)
    * [2. 验证](#2-验证)
    * [3. 准备](#3-准备)
    * [4. 解析](#4-解析)
    * [5. 初始化](#5-初始化)
  * [类初始化时机](#类初始化时机)
    * [1. 主动引用](#1-主动引用)
    * [2. 被动引用](#2-被动引用)
  * [类与类加载器](#类与类加载器)
  * [类加载器分类](#类加载器分类)
  * [双亲委派模型](#双亲委派模型)
    * [1. 工作过程](#1-工作过程)
    * [2. 好处](#2-好处)
    * [3. 实现](#3-实现)
    * [4. “破坏”](#4-破坏)
  * [自定义类加载器实现](#自定义类加载器实现)
* [七、字节码执行引擎](#七字节码执行引擎)
  * [运行时栈帧结构](#运行时栈帧结构)
    * [1. 局部变量表](#1-局部变量表)
    * [2. 操作数栈](#2-操作数栈)
    * [3. 动态连接](#3-动态连接)
    * [4. 方法返回地址](#4-方法返回地址)
  * [方法调用](#方法调用)
    * [1. 解析](#1-解析)
    * [2. 分派](#2-分派)
    * [3. 动态类型语言支持](#3-动态类型语言支持)
  * [基于栈的字节码解释执行引擎](#基于栈的字节码解释执行引擎)
    * [1. 解释执行](#1-解释执行)
    * [2. 指令集](#2-指令集)
* [八、程序编译与代码优化](#八程序编译与代码优化)
  * [早期(编译期)优化](#早期编译期优化)
    * [1. javac编译器](#1-javac编译器)
    * [2. Java语法糖](#2-java语法糖)
  * [晚期(运行期)优化](#晚期运行期优化)
    * [1. 解释器与编译器](#1-解释器与编译器)
    * [2. 编译对象与触发条件](#2-编译对象与触发条件)
    * [3. 编译过程](#3-编译过程)
    * [4. 编译优化技术](#4-编译优化技术)
    * [5. Java与C/C++的编译器对比](#5-java与cc的编译器对比)
* [参考资料](#参考资料)

<!-- GFM-TOC -->


本文大部分内容参考  **周志明《深入理解 Java 虚拟机》** ，想要深入学习的话请看原书。


# 五、类文件结构

在 Java 中，JVM 可以理解的代码就叫做`字节码`(即扩展名为 `.class` 的文件)，它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。

各种不同的虚拟机与所有平台都统一使用字节码(ByteCode)是构成平台无关性的基石，实现语言无关性的基础仍然是虚拟机和字节码的存储格式。Java虚拟机不和包括Java在内的任何语言绑定，至于"Class文件"这种特定二进制文件格式所关联，虚拟机不关心Class的来源是何种语言。

Clojure(Lisp 语言的一种方言)、Groovy、Scala 等语言都是运行在 Java 虚拟机之上。下图展示了不同的语言被不同的编译器编译成`.class`文件最终运行在 Java 虚拟机之上。

<div align="center"> 

![](../../assets/cs-note/jvm/编译字节码.png ':size=600')
</div>


可以说.class文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因。

Java语言中各种变量、关键字和运算符号的寓意最终都是有多条字节码命令组成，因此字节码命令所能提供的语义描述能力比Java语言本身更加强大。

## Class类文件的结构

**注意**  任何一个Class文件都对应着唯一一个类或接口的定义信息，但反之不一定，类或接口并不一定都得定义在文件里(譬如类或接口也可通过类加载器直接加载)。将一个有效的类或接口锁应满足的格式成为“Class文件格式”，不一定以磁盘文件形式存在。(一串二进制字节流，无论以何种形式存在)

Class文件是一组以8位字节为基础单位的二进制流，各个数据项严格按照顺序紧凑排列在Class文件中，中间无任何分隔符，当遇到需要占用8位字节以上数据项，则按照高位在前(大端)的方式分隔成若干8位字节存储。

根据 Java 虚拟机规范，类文件格式采用类似C语言结构体的伪结构存储数据，伪结构只有两种数据类型：无符号数和表。

无符号数属于基本数据类型，u1,u2,u4,u8;无符号数用来描述数字、索引引用、数量值或按照UTF-8编码构成字符串值；

表是由多个无符号数或其他表作为数据项构成的复合数据类型，习惯性以"_info"结尾。
Class文件就是一张表。

类文件由单个 ClassFile 结构组成：

```java
ClassFile {
    u4             magic; //Class 文件的标志
    u2             minor_version;//Class 的小版本号
    u2             major_version;//Class 的大版本号
    u2             constant_pool_count;//常量池的数量
    cp_info        constant_pool[constant_pool_count-1];//常量池
    u2             access_flags;//Class 的访问标记
    u2             this_class;//当前类
    u2             super_class;//父类
    u2             interfaces_count;//接口
    u2             interfaces[interfaces_count];//一个类可以实现多个接口
    u2             fields_count;//Class 文件的字段属性
    field_info     fields[fields_count];//一个类会可以有个字段
    u2             methods_count;//Class 文件的方法数量
    method_info    methods[methods_count];//一个类可以有个多个方法
    u2             attributes_count;//此类的属性表中的属性数
    attribute_info attributes[attributes_count];//属性表集合
}
```

**Class文件字节码结构组织示意图**

<div align="center"> 

![](../../assets/cs-note/jvm/类文件字节码结构组织示意图.png ':size=600')
</div>

### 1. 魔数

```java
    u4             magic; //Class 文件的标志
```

每个 Class 文件的头四个字节称为魔数(Magic Number),它的唯一作用是**确定这个文件是否为一个能被虚拟机接收的 Class 文件**。 

程序设计者很多时候都喜欢用一些特殊的数字表示固定的文件类型或者其它特殊的含义。

### 2. Class文件版本

```java
    u2             minor_version;//Class 的小版本号
    u2             major_version;//Class 的大版本号
```

紧接着魔数的四个字节存储的是 Class 文件的版本号：第五和第六是**次版本号**，第七和第八是**主版本号**。

高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。

### 3. 常量池

```java
    u2             constant_pool_count;//常量池的数量
    cp_info        constant_pool[constant_pool_count-1];//常量池
```

紧接着主次版本号之后的是常量池，常量池的数量是 constant_pool_count-1(**常量池计数器是从1开始计数的，将第0项常量空出来是有特殊考虑的，索引值为0代表“不引用任何一个常量池项”**)。

常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量： 

- 类和接口的全限定名 
- 字段的名称和描述符 
- 方法的名称和描述符

常量池中每一项常量都是一个表，这14种表有一个共同的特点：**开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．**

|               类型               | 标志(tag) |          描述          |
| :------------------------------: | :-------: | :--------------------: |
|        CONSTANT_utf8_info        |     1     |   UTF-8编码的字符串    |
|      CONSTANT_Integer_info       |     3     |       整形字面量       |
|       CONSTANT_Float_info        |     4     |      浮点型字面量      |
|        CONSTANT_Long_info        |     5     |      长整型字面量      |
|       CONSTANT_Double_info       |     6     |   双精度浮点型字面量   |
|       CONSTANT_Class_info        |     7     |   类或接口的符号引用   |
|       CONSTANT_String_info       |     8     |    字符串类型字面量    |
|      CONSTANT_Fieldref_info      |     9     |     字段的符号引用     |
|     CONSTANT_Methodref_info      |    10     |   类中方法的符号引用   |
| CONSTANT_InterfaceMethodref_info |    11     |  接口中方法的符号引用  |
|    CONSTANT_NameAndType_info     |    12     |  字段或方法的符号引用  |
|     CONSTANT_MothodType_info     |    16     |      标志方法类型      |
|    CONSTANT_MethodHandle_info    |    15     |      表示方法句柄      |
|   CONSTANT_InvokeDynamic_info    |    18     | 表示一个动态方法调用点 |

`.class` 文件可以通过`javap -v class类名` 指令来看一下其常量池中的信息(`javap -v  class类名-> temp.txt` ：将结果输出到 temp.txt 文件)。

Class文件中方法、字段等都需要引用CONSTANT_utf8_info型常量来描述名称，该常量最大长度就是Java方法、字段名最大长度，即u2类型最大值65535.

### 4. 访问标志

在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。

具体标志位及标志含义如下：

|    标志名称    | 标志值 |                     含义                     |
| :------------: | :----: | :------------------------------------------: |
|   ACC_PUBLIC   | 0x0001 |                 是否为public                 |
|   ACC_FINAL    | 0x0010 |     是否被声明为final，只有类可以被设置      |
|   ACC_SUPER    | 0x0020 |    是否允许使用invokespecial字节码新语意     |
| ACC_INTERFACE  | 0x0200 |                   标识接口                   |
|  ACC_ABSTRACT  | 0x0400 | 是否为abstract类型，对于接口和抽象类来说是真 |
| ACC_SYNTHETIC  | 0x1000 |          标识该类并非有用户代码产生          |
| ACC_ANNOTATION | 0x2000 |                   标识注解                   |
|    ACC_ENUM    | 0x4000 |                   标识枚举                   |


### 5. 当前类索引,父类索引与接口索引集合

```java
    u2             this_class;//当前类索引
    u2             super_class;//父类索引
    u2             interfaces_count;//接口数目
    u2             interfaces[interfaces_count];//一个类可以实现多个接口
```

类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 `java.lang.Object` 之外，所有的 java 类都有父类，因此除了 `java.lang.Object` 外，所有 Java 类的父类索引都不为 0。

接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按`implents`(如果这个类本身是接口的话则是`extends`) 后的接口顺序从左到右排列在接口索引集合中。

类索引和父类索引采用两个u2类型索引值表示，各自指向一个 CONSTANT_Class_info 的类描述符常量，通过 CONSTANT_Class_info 类型的常量中的索引值可以找到定义在 CONSTANT_utf8_info 类型的常量中的全限定名字符串。

### 6. 字段表集合

```java
    u2             fields_count;//Class 文件的字段的个数
    field_info     fields[fields_count];//一个类会可以有个字段
```

字段表(field info)用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。包括的信息有：字段作用域(public、private、protected)、实例变量或类变量(static)、可变性(final)、并发可见性(volatile)、可否被序列化(transient)、字段数据类型(基本类型、对象、数组)、字段名称。

field info(字段表) 的结构:

```java
field_info{
    u2                  access_flags;//字段作用域
    u2                  name_index;//字段名称索引，对常量池的引用，表示的字段的名称
    u2                  descriptor_index;//描述符索引，对常量池的引用，表示字段的描述符
    u2                  attributes_count;//属性数目，一个字段还会拥有一些额外的属性
    atrribute_info      attributes[attributes_count];//属性表，存放具体属性具体内容

}
```

- **access_flags:**  字段的作用域(`public` ,`private`,`protected`修饰符)，是实例变量还是类变量(`static`修饰符),可否被序列化(`transient` 修饰符),可变性(`final`),可见性(`volatile` 修饰符，是否强制从主内存读写)。

上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。

字段访问标志如下表：

|   标志名称    | 标志值 |            含义            |
| :-----------: | :----: | :------------------------: |
|  ACC_PUBLIC   | 0x0001 |       是否为 public        |
|  ACC_PRIVATE  | 0x0002 |       是否为 private       |
| ACC_PROTECTED | 0x0004 |      是否为 protected      |
|  ACC_STATIC   | 0x0008 | 是否被声明为 static 类变量 |
|   ACC_FINAL   | 0x0010 |     是否被声明为 final     |
| ACC_VOLATILE  | 0x0040 |      是否为 volatile       |
| ACC_TRANIENT  | 0x0080 |      是否为 transient      |
| ACC_SYNTHETIC | 0x1000 |  字段是否由编译器自动产生  |
|   ACC_ENUM    | 0x4000 |        是否为 enum         |

字段表中不会列出从超类或负借口中继承而来的字段，但有可能列出原本Java代码中不存在的字段(譬如在内部类中国为了保持对外部类的访问行，自动添加指向外部类的实例的字段)

另外，Java语言中字段是无法重载的，但对于字节码来讲，如果两个字段描述符不一致，字段重名就是合法的。


### 7. 方法表集合

```java
    u2             methods_count;//Class 文件的方法的数量
    method_info    methods[methods_count];//一个类可以有个多个方法
```

methods_count 表示方法的数量，而 method_info 表示的方法表。

Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。 

method_info(方法表)结构如下：

```java
method_info{
    u2                  access_flags;
    u2                  name_index;
    u2                  descriptor_index;
    u2                  attributes_count;
    atrribute_info      attributes[attributes_count];
}
```

注意：因为`volatile`修饰符和`transient`修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了`synchronized`、`native`、`abstract`等关键字修饰方法，所以也就多了这些关键字对应的标志。

方法访问标志如下表：

|     标志名称     | 标志值 |            含义             |
| :--------------: | :----: | :-------------------------: |
|    ACC_PUBLIC    | 0x0001 |        是否为 public        |
|   ACC_PRIVATE    | 0x0002 |       是否为 private        |
|  ACC_PROTECTED   | 0x0004 |      是否为 protected       |
|    ACC_STATIC    | 0x0008 |        是否为 static        |
|    ACC_FINAL     | 0x0010 |     是否被声明为 final      |
| ACC_SYNCHRONIZED | 0x0020 |     是否为 synchronize      |
|    ACC_BRIDGE    | 0x0040 | 是否为 编译器产生的桥接方法 |
|   ACC_VARARGS    | 0x0080 |      是否接受不定参数       |
|    ACC_NATIVE    | 0x0100 |        是否为 native        |
|   ACC_ABSTRACT   | 0x0400 |       是否为 abstract       |
|   ACC_STRICTFP   | 0x0800 |       是否为 strictfp       |
|  ACC_SYNTHETIC   | 0x1000 |  字段是否由编译器自动产生   |

在Java语言中，重载一个方法，要与原方法具有相同简单名称，还必须有不同的特征签名，特征签名是方法中各个参数在常量池中字段符号引用的集合，返回值不在特征签名中，因此Java是无法仅靠返回值不同来重载方法。但Class文件格式中，特征签名的范围更大，只要描述符不是完全一致的两个方法可以共存。

**描述符**

描述符的作用是描述字段的数据类型、方法的参数列表(包括数量、类型及顺序)和返回值。

描述符标识字符含义如下表：

| 标识字符 |              含义              |
| :------: | :----------------------------: |
|    B     |              byte              |
|    C     |              char              |
|    D     |             double             |
|    F     |             float              |
|    I     |              int               |
|    J     |              long              |
|    S     |             short              |
|    Z     |            boolean             |
|    V     |              void              |
|    L     | 对象类型(如 Ljava/lang/String) |

对于数组类型，每一位度使用一个前置的 "["字符来描述，如"String[][]"被记录为"[[Ljava/lang/String"；"int[]"被记录为"[I"。

### 8. 属性表集合

```java
   u2             attributes_count;//此类的属性表中的属性数
   attribute_info attributes[attributes_count];//属性表集合
```
attribute_info(属性表)结构如下：
```java
attribute_info{
    u2                  attribute_name_index;
    u4                  attribute_length;
    u1                  info[attribute_length];
}
```

在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。

**虚拟机规范预定义的属性**

|               属性名称               |      使用位置      |                                     含义                                      |
| :----------------------------------: | :----------------: | :---------------------------------------------------------------------------: |
|                 Code                 |       方法表       |                              编译成的字节码指令                               |
|            ConstantValue             |       字段表       |                           final 关键字定义的常量值                            |
|              Deprecated              | 类、方法表、字段表 |                       被声明为 Deprecated 的方法和字段                        |
|              Exceptions              |       方法表       |                                方法抛出的异常                                 |
|           EnclosingMethod            |       类文件       |           当一个类为局部类或匿名类时，这个属性标识这个类的外围方法            |
|             InnerClasses             |       类文件       |                                  内部类列表                                   |
|           LineNumberTable            |     Code 属性      |                       Java源码行号与字节码指令对应关系                        |
|          LocalVariableTable          |     Code 属性      |                               方法局部变量描述                                |
|            StackMapTable             |     Code 属性      |                                    JDK1.6                                     |
|              Signature               | 类、方法表、字段表 |                        JDK1.5 用于支持泛型情况下的签名                        |
|              SourceFile              |       类文件       |                                记录源文件名称                                 |
|         SourceDebugExtension         |       类文件       |                                    JDK1.6                                     |
|              Synthetic               | 类、方法表、字段表 |                       标识方法或字段是编译器自动生成的                        |
|        LocalVariableTypeTable        |         类         | JDK1.5 使用特征签名代替描述符，为了引入反省与法之后能描述泛型参数化类型而添加 |
|      RuntimeVisibleAnnotations       | 类、方法表、字段表 |                                    JDK1.5                                     |
|     RuntimeInVisibleAnnotations      | 类、方法表、字段表 |                                    JDK1.5                                     |
|  RuntimeVisibleParameterAnnotations  |       方法表       |                                    JDK1.5                                     |
| RuntimeInVisibleParameterAnnotations |       方法表       |                                    JDK1.5                                     |
|          AnnotationDefault           |       方法表       |                       JDK1.5 用于记录注解类元素的默认值                       |
|           BootstrapMethods           |       类文件       |                                    JDK1.7                                     |

#### Code 属性

code_attribute_info(Code 属性表)结构如下：
```java
attribute_info{
    u2                  attribute_name_index;//属性字段名称索引，对常量池的引用，表示的属性字段的名称
    u4                  attribute_length;//属性长度
    u2                  max_stack;//操作数栈深度最大值
    u2                  max_locals;//局部变量表所需存储空间
    u4                  code_length;//字节码长度
    u1                  code;//存储字节码指令的一系列字节流
    u2                  exception_table_length;//异常表长度
    exception_info      exception_table;//异常表
    u2                  attributes_count;//
    attribute_info      attributes[attributes_count];//
}
```

> 虚拟机规范中明确闲置一个方法不允许超过65535条字节码指令，即只使用u2的长度，如果超过限制，javac编译器拒绝编译。

Code 属性是 Class 文件最重要的一个属性，Java程序中信息分为代码(Code,方法体里面Java代码)和元数据(Metadata,包括类、字段、方法定义及其他信息)两部分，那么整个Class文件中，Code属性用于描述代码，所有的其他数据项目都用于描述元数据。




## 字节码指令

Java虚拟机的指令由一个字节长度、代表着某种特定操作含义的数字(操作码)以及跟随其后的零至多个代表此操作所需要参数(操作数)而构成。

字节码指令集是一种具有鲜明特点、优劣势都很突出的指令集架构，由于限制了 Java 虚拟机操作码的长度为一个字节(即 0 ~ 255)，这意味着指令集的操作码总数不可能超过 256 条；又由于 Class 文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机处理那些超过一个字节数据的时候，不得不在运行时从字节中重建出具体数据的结构，如果要将一个 16 位长度的无符号整数使用两个无符号字节存储起来(将它们命名为 byte1 和 byte2)，那它们的值应该是这样的：

```
(byte1<<8 | byte2)
```

用一个字节来代表操作码，也是为了尽可能获得短小精干的编译代码。这种追求尽可能小数据量、高传输效率的设计是由 Java 语言设计之初面向网络、智能家电的技术背景所决定的，并一直沿用至今。

### 1. 字节码和数据类型

在Java虚拟机的指令集中，大多数指令都包含了其操作所对应的数据类型信息，Java虚拟机的操作码长度只有一个字节，如果每一种数据类型相关的指令都支持Java虚拟机所有运行时数据类型的话，那指令的数据恐怕就会超过一个字节所能表示的数量范围了。因此，Java虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它。

### 2. 加载和存储指令

加载和存储指令用于将数据在栈帧中的局部变量表和操作数据栈之间来回传输

- 将一个局部变量加载到操作栈: iload, iload~n~, lload, fload .....
- 将一个数值从操作数栈存储到局部变量表: istore, istore~n~....
- 将一个常量加载到操作数栈: bipush, sipush, ldc.....
- 扩充局部变量表的访问索引的指令: wide

### 3. 运算指令

运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。

由于没有直接支持byte，short, chart和boolean类型的算术指令，对于这类数据的运算，应使用操作int类型的指令代替。


- 加法： idadd, ladd, fadd, dadd
- 减法：isub, lsub, fsub, dsub
- 乘法：imul, lmul, fmul, dmul
- 除法：idiv, ldiv, fdiv, ddiv
- 求余： irem, lrem, frem, drem
- 取反： ineg, lneg, fneg, dneg
- 位移： ishl, ishr, iushr, lshl, lshr, lushr
- 按位或指令： ior, lor
- 按位与指令： iand, land
- 按位异或指令: ixor, lxor
- 局部变量自增指令: iinc
- 比较指令： dcmpg, dcmpl, fcmpg, fcmpl, lcmp

### 4. 类型转换指令

类型转换指令：可以将两种不同的数据类型进行相互转换，一般用户实现代码中显示类型转换操作。

Java虚拟机直接支持(即转换无需显式的转换指令)以下数据类型的宽化类型转换(Widening Numeric Conversions，即小范围类型向大范围类型的安全转换。 
- int类型到long, float 或者 double类型， 
- long类型到float, double类型， 
- float类型到double类型

相对的，处理窄化类型转换( Narrowing Numeric Conversions)时，必须显式地使用转换指令来完成，这些转换指令包括：i2b, i2c, i2s........

### 5. 对象创建与访问指令

- 创建类实例的指令： new
- 创建数组的指令： newarray, anewarray, multianewarray
- 访问类字段(static字段)和实例字段(非static字段，或者称为实例变量)的指令: getfield, putfield, getstatic, putstatic
- 把一个数组元素加载到操作数栈的指令： baload, caload, saload, iaload, laload......
- 将一个操作数栈的值存储到数组元素中的指令： bastore, castore,sastore....
- 取数组长度的指令： arraylength
- 检查类实例类型的指令： instanceof, checkcast

### 6. 操作数栈管理指令

Java虚拟机提供了直接操作操作数栈的指令。

- 将操作数栈的栈顶一个或两个元素出栈： pop, pop2
- 复制栈顶一个或两个数值并将复制值或双份的复制值 重新压入栈顶：dup, dup2, dpu_x1....
- 将栈最顶端的两个数值互换： swap

### 7. 控制转移指令

可以让Java虚拟机有条件或无条件地从指定的位置指令继续执行

- 条件分支：ifeq, iflt, ifle....
- 复合条件分支： tableswitch, lookpuswitch
- 无条件分支： goto, toto_w....

对于boolean、byte、char、short类型的条件分支比较操作，都是使用int类型比较指令完成，而对于long、float、double类型的条件分支操作，则会先执行相应的比较运算指令，返回整数值到操作数栈，随后执行int类型条件分支比较操作来完成分支跳转。

由于各种类型的比较最终都会转化为int类型的比较操作，所以Java虚拟机提供的int类型条件分支指令是最为丰富和强大的。

### 8. 方法调用和返回指令

- invokevirtual 用于调用对象的实例方法。
- invokeinterface 用于调用接口方法
- invokespecial 用于调用需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法
- invokestatic 用于调用类方法(static方法)
- invokedynamic 用于在运行时动态解析出调用点限定符所引用的方法

前4条调用指令的分派逻辑固化在Java虚拟机内部，而invokedynamic 指令的分派逻辑是由用户所设定的引导方法决定的。

方法调用指令与数据类型无关，而方法返回指令是根据返回值类型区分，包括
- ireturn (boolean、byte、char、short和int类型)
- lreturn
- freturn
- dreturn
- areturn
- return (void方法、实例初始化方法、类和接口的类初始化方法)

### 9. 异常处理

在Java程序中显式异常的操作(throw语句)都由athrow指令实现

Java虚拟机中，处理异常(catch语句)不是由字节码指令实现(很久前曾使用jsr和ret指令实现)，而是采用异常表实现。

### 10. 同步指令

Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步。这两种同步结构都是使用管程(Monitor)实现的。

方法级的同步是隐式的，无需通过字节码指令控制，实现在方法调用和返回中，虚拟机可以从方法常量池的方法表结构中ACC_SYNCHRONIZED访问标志得知是否为同步方法。如果设置：执行线程要求先持有monitor，然后执行方法，最后方法完成(正常完成或非正常完成)时释放monitor。如果一个同步方法执行期间抛出异常并且在方法内部无法处理此异常，那么该同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。

同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要javac编译器和Java虚拟机两者共同协作支持。编译器必须确保无论方法通过何种方式完成，方法调用过的monitorenter指令都必须执行其对应的monitorexit指令，而无论方法正常结束还是异常结束。

## 公有设计和私有实现

java虚拟机规范描述了java虚拟机应有的共同程序存储格式：class文件格式以及字节码指令集。这些内容与硬件、操作系统以及具体的java虚拟机实现之间是完全独立的，具体实现方式是实现着自己的事，只要外部接口与规范描述一致即可。

虚拟机实现的方式主要有一下两种：
1. 将输入的java虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集。
2. 将输入的java虚拟机代码在加载或者执行时翻译成宿主机cpu的本地指令集。


# 六、类加载机制

与那些在编译时需要进行连接工作的语言不同，在JAVA中，类型的加载和连接过程都是在程序运行期间完成的，这样会在类加载时稍微增加一些性能开销，但是却能为JAVA应用程序提高高度的灵活性，JAVA中天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。

类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。

## 类的生命周期

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/335fe19c-4a76-45ab-9320-88c90d6a0d7e.png" width="600px"> </div><br>

包括以下 7 个阶段：

-  **加载(Loading)** 
-  **验证(Verification)** 
-  **准备(Preparation)** 
-  **解析(Resolution)** 
-  **初始化(Initialization)** 
- 使用(Using)
- 卸载(Unloading)

## 类加载过程

类加载过程：**加载->连接->初始化**。连接过程又可分为三步:**验证->准备->解析**。

<div align="center"> 

![](../../assets/cs-note/jvm/类加载过程.png ':size=600')
</div>

包含了加载、验证、准备、解析和初始化这 5 个阶段。

加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类加载过程必须按照这种顺序按部就班**开始**(互相交叉地混合式进行),二解析阶段则不一定

### 1. 加载

加载是类加载的一个阶段，注意不要混淆。

加载过程完成以下三件事：

- 通过类的完全限定名称获取定义该类的二进制字节流。
- 将该字节流表示的静态存储结构转换为方法区的运行时数据存储结构。
- 在内存中生成一个代表该类的 java.lang.Class 对象，作为方法区中该类各种数据的访问入口。


其中二进制字节流可以从以下方式中获取：

- 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。
- 从网络中获取，最典型的应用是 Applet。
- 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。
- 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。
- ......


非数组类的加载阶段是开发人员控性最强的，加载阶段既可以使用系统提供的引导类加载器完成，也可用户自定义类加载器完成；

对于数组类来说，它不通过类加载器创建，由Java虚拟机直接创建，但数组中的元素类型(Element Type , 去掉所有维度的类型)还是需要类加载器去创建。

数组类创建遵循以下规则：
- 如果数组的组件类型(Component Type , 去掉一个维度的类型)是引用类型，就递归地去加载这个组件类型
- 如果数组的组件类型不是引用类型(例如 int[] 一些基本数据的数组)，数组会被标记与引导类加载器关联
- 如果数组类的可见性与它的组件类型一致，如果组件类型不是引用类型，那数组类的可见性将默认为public

加载完成后，二进制字节流按照虚拟机所需的格式存储在方法区之中。然后在内存中实例一个java.lang.Class对象，虽然它为对象，但是它在方法区中。此对象作为程序访问方法区中的这些类型数据的外部接口。

加载阶段与连接阶段的部分内容(如部分字节码文件格式验证动作)是交叉运行的。


### 2. 验证

确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

4个阶段的检验动作

1. 文件格式验证：验证字节流是否符事Class文件格式的规范，并且能被当前版本的虚拟机处理
    - 是否以魔数0xCAFEBABE开头
    - 主、次版本号是否在当前虚拟机处理范围之内
    - 常量池的常量中是否有不被支持的常量类型
    - 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量
    - CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据
    - Class文件中各个部分以及文件本身是否有被删除的或附加的其他信息
    - ......
2. 元数据验证：对字节码描述的信息进行语义分析,保证其描述信息符合Java语言规范
    - 类是否有父亲(除了java.lang.Obejct之外，所有的类都应当有父类)
    - 类的父亲是否继承了不允许被继承的类(被final修饰的类)
    - 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法
    - 类中的字段、方法是否与父类产生了矛盾
    - ......
3. 字节码验证：主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。
   - 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况，在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中
   - 保证跳转指令不会跳转到方法体以外的字节码指令上
   - 保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，反之则是危险的。
   - ......
4. 符号引用验证 最后一阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段--解析阶段中发生。符号引用验证可以看做是对类自身以外的信息进行匹配性校验。 
   - 符号引用中通过字符串描述的全限定名是否能找到对应的类；
   - 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段
   - 符号引用中的类、字段和方法的访问行(private,protected,public,default)是否可被当前类访问
   - ......

### 3. 准备

正式为类变量(static 修饰)分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配

实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。

**通常情况下**，初始值一般为零值，例如下面的类变量 value 被初始化为 0 而不是 123；value被赋值为123，会在类的初始化`<clinit>()`阶段才会执行。

```java
public static int value = 123;
```

**特殊情况**：如果类变量是常量，即类字段字段属性表中存在ConstantValue属性，那么准备阶段就会被初始化ConstantValue属性所指定的值。例如下面的常量 value 被初始化为 123 而不是 0。

```java
public static final int value = 123;
```

**基本数据类型的零值：**

<div align="center"> 

![](../../assets/cs-note/jvm/基本数据类型的零值.png ':size=600')
</div>

### 4. 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。

> 符号引用：以一组符号来描述所引用的目标，可以是任意形式的字面量，只要使用时能无歧义的定位到目标。符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。
> 直接引用：可以是直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。它与虚拟机内存布局相关。同一符号引用被不同虚拟机实例翻译出来的直接引用一般不会相同，如果有了直接引用，那引用目标必定已经在内存中存在。

符号引用就是一组符号来描述目标，可以是任何字面量。**直接引用**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。

综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。

其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。

<div data="补充为什么可以支持动态绑定 --> <--"></div>

### 5. 初始化

<div data="modify -->"></div>

初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 `<clinit>()` 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。

`<clinit>()` 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：

```java
public class Test {
    static {
        i = 0;                // 给变量赋值可以正常编译通过
        System.out.print(i);  // 这句编译器会提示“非法向前引用”
    }
    static int i = 1;
}
```

由于父类的 `<clinit>()` 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：

```java
static class Parent {
    public static int A = 1;
    static {
        A = 2;
    }
}

static class Sub extends Parent {
    public static int B = A;
}

public static void main(String[] args) {
     System.out.println(Sub.B);  // 2
}
```

`<clinit>()`方法对类和接口并不是必须的，当类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成`<clinit>()`方法。

接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 `<clinit>()` 方法。但接口与类不同的是，执行接口的 `<clinit>()` 方法不需要先执行父接口的 `<clinit>()` 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 `<clinit>()` 方法。

虚拟机会保证一个类的 `<clinit>()` 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 `<clinit>()` 方法，其它线程都会阻塞等待，直到活动线程执行 `<clinit>()` 方法完毕。如果在一个类的 `<clinit>()` 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。

**注意** 同一个类加载器下，一个类型只会初始化一次

## 类初始化时机

### 1. 主动引用

虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化(加载、验证、准备都会随之发生)：

- 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段的时候(被 final 修饰、已在编译期把结果放入常量池的静态字段除外)；以及调用一个类的静态方法的时候。
- 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。
- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
- 当虚拟机启动时，用户需要指定一个要执行的主类(包含 main() 方法的那个类)，虚拟机会先初始化这个主类；
- 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；

### 2. 被动引用

以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：

- 通过子类引用父类的静态字段，不会导致子类初始化。

```java
System.out.println(SubClass.value);  // value 字段在 SuperClass 中定义
```

- 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法，创建动作由字节码指令newarray触发。

```java
SuperClass[] sca = new SuperClass[10];
```

- 常量在编译阶段会存入调用类的常量池中(常量传播优化)，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

```java
System.out.println(ConstClass.HELLOWORLD);
```

## 类与类加载器

两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。

这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。

## 类加载器分类

从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：

- 启动类加载器(Bootstrap ClassLoader)，使用 C++ 实现，是虚拟机自身的一部分；

- 所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。

从 Java 开发人员的角度看，类加载器可以划分得更细致一些：

- 启动类加载器(Bootstrap ClassLoader)此类加载器负责将存放在 <JRE_HOME>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的(仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载)类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。

- 扩展类加载器(Extension ClassLoader)这个类加载器是由 ExtClassLoader(sun.misc.Launcher$ExtClassLoader)实现的。它负责将 <JAVA_HOME>/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。

- 应用程序类加载器(Application ClassLoader)这个类加载器是由 AppClassLoader(sun.misc.Launcher$AppClassLoader)实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径(ClassPath)上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。


## 双亲委派模型

应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。

下图展示了类加载器之间的层次关系，称为双亲委派模型(Parents Delegation Model)。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系(Composition)来实现，而不是继承关系(Inheritance)。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0dd2d40a-5b2b-4d45-b176-e75a4cd4bdbf.png" width="500px"> </div><br>

### 1. 工作过程

一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。

<div align="center"> 

![](../../assets/cs-note/jvm/classloader.png ':size=600')
</div>

### 2. 好处

使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。

双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载(JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类)。

例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。

**如果我们不想用双亲委派模型怎么办？**

为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重载 `loadClass()` 即可。

### 3. 实现

以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。

```java
public abstract class ClassLoader {
    // The parent class loader for delegation
    private final ClassLoader parent;

    public Class<?> loadClass(String name) throws ClassNotFoundException {
        return loadClass(name, false);
    }

    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
        synchronized (getClassLoadingLock(name)) {
            // 首先，检查请求的类是否已经被加载过
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // 父类加载器抛出ClassNotFoundException
                    // 说明父类加载器无法完成加载要求
                }

                if (c == null) {
                    // 父类加载器无法加载时
                    // 调用本身的findClass方法进行类加载
                    c = findClass(name);
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }

    protected Class<?> findClass(String name) throws ClassNotFoundException {
        throw new ClassNotFoundException(name);
    }
}
```
### 4. “破坏”
- 自定义类加载器
- 线程上下文加载器
- OSGI

## 自定义类加载器实现

以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件(.class 文件)，然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。

java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。

```java
public class FileSystemClassLoader extends ClassLoader {

    private String rootDir;

    public FileSystemClassLoader(String rootDir) {
        this.rootDir = rootDir;
    }

    protected Class<?> findClass(String name) throws ClassNotFoundException {
        byte[] classData = getClassData(name);
        if (classData == null) {
            throw new ClassNotFoundException();
        } else {
            return defineClass(name, classData, 0, classData.length);
        }
    }

    private byte[] getClassData(String className) {
        String path = classNameToPath(className);
        try {
            InputStream ins = new FileInputStream(path);
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            int bufferSize = 4096;
            byte[] buffer = new byte[bufferSize];
            int bytesNumRead;
            while ((bytesNumRead = ins.read(buffer)) != -1) {
                baos.write(buffer, 0, bytesNumRead);
            }
            return baos.toByteArray();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    private String classNameToPath(String className) {
        return rootDir + File.separatorChar
                + className.replace('.', File.separatorChar) + ".class";
    }
}
```



# 七、字节码执行引擎

执行引擎是jvm最核心的部分，jvm是java虚拟机，有自己实现的指令集和执行引擎结构体系，能够支持那些不被硬件直接支持的指令集。

执行引擎在不同的jvm实现中是不同的，jvm可以选择解释执行或编译执行，也可能两者兼具，甚至包括几个不同级别的编译器执行引擎。

## 运行时栈帧结构

栈帧是虚拟机栈中的元素，是用于支持方法调用和执行的数据结构，栈帧储存了方法的局部变量表，操作数栈，动态链接和方法返回地址等信息。

每个方法从调用到完成的过程，就对应着一个栈帧在栈里从入栈到出栈的过程。在程序编译为字节码时，栈帧中有多大的局部变量表，多深的操作数栈已经完全确定了，写入到了方法表的Code属性之中了。在活动线程中，只有位于栈顶的栈帧才是有效的，被称为当前栈帧。这个栈帧关联的方法叫当前方法。

### 1. 局部变量表

是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在方法的Code属性中max_locals确定了该方法所需要分配的局部变量表的最大容量。

局部变量表的容量以变量槽(slot)为最小单位。一个Slot可以存放一个32位以内的数据类型(boolean、byte、char、short、int、float、reference、returnAddress)(Java虚拟机规范中没有明确reference类型长度，长度与32位或64位虚拟机有关，若是64位还和是否开启某些对象指针压缩优化有关)(与明确指出“每个Slot占用32位长度内存空间”有一些差别)

对于64位数据类型，虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。不过，由于局部变量表建立在线程的堆栈上，是线程私有的数据，无论读写两个连续的Slot是否为原子操作，都不会引起数据安全问题。

- 虚拟机通过索引定位的方式使用局部变量表，索引值范围从0开始至最大的Slot数量
- 在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程。如果执行的是实例方法(非static的方法)，那局部变量表中第0位索引的Slot默认用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数，其余参数则按照参数顺序排列，占用从1开始的局部变量slot。
- 为尽可能节省栈空间，局部变量表中Slot是可以重用的

**注意**：类变量会经历两次赋值(有默认值)(一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的初始值)。而局部变量不会，所以局部变量如果定义但是不赋值是不能使用的。

### 2. 操作数栈

Operand Stack也常称为操作栈，它是一个后入先出(Last In First Out, LIFO)栈。

当方法刚开始执行时，操作数栈是空的，然后执行时，字节码指令往操作数栈中写入和提取内容，也就是入栈、出栈操作(例如，算数运算通过操作数栈进行，又或者用在调用其他方法时通过操作数栈来进行参数传递)。

操作数栈的元素的数据类型必须和字节码指令的序列严格匹配。javac编译器和类加载时的验证阶段都要严格保证这一点。

在概念模型中，两个栈帧是完全独立的，但在虚拟机实现中会做一些优化处理，让两个栈出现一部分重叠。

jvm的解释执行引擎称为"基于栈的执行引擎",其中所指的栈就是操作数栈。

### 3. 动态连接

每个栈帧都包含一个执行运行时常量池(在方法区)中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接的。

Class文件中的常量池中有大量的符号引用，这些常量池在类加载完成后会方法运行时常量池中，字节码中的方法调用指令就是以运行时常量池中的方法符号引用作为参数。

这些符号引用中，一部分在类加载阶段或第一次使用的时候转化为直接引用，这种成为静态解析。另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。

### 4. 方法返回地址

当一个方法开始执行后，只有两种方式可以退出该方法：
1. 正常完成出口：执行引擎遇到任意一个方法返回的字节码指令，正常退出
2. 异常完成出口：在方法执行过程中出现异常，并且这个那异常没有在方法体内得到处理。(不会给上层调用者产生任何返回值)

方法退出后，会返回到方法被调用的位置。方法返回是需要保存一些信息，用来帮助他的上层方法恢复执行状态。
1. 正常退出时：栈帧需要保存调用者的PC计数器的值作为返回地址
2. 异常退出时：返回地址要通过异常处理表来确定，栈帧中一般不会保存这部分信息

## 方法调用

方法调用阶段唯一的任务就是确定被调用方法的版本(即调用哪一个方法)

Class文件中只是储存的符号引用，而不是直接引用。这样就有了灵活性，但也使得方法调用变得复杂，需要在类加载期间，甚至运行期间才能确定目标方法的直接引用。

### 1. 解析

在类加载的解析阶段有一部分符号引用就能转化为直接引用，前提是：方法在程序运行之前就有一个可确定的调用版本，并且这个方法的调用版本是运行起不可改变的。(调用目标在程序代码写好，编译器进行编译时就必须确定下来)

Java中符合"编译器可知，运行期不变"这个要求的方法，主要是静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可知。

Java虚拟机中提供了5条方法调用字节码指令：
- invokestatic 用于调用类方法(static方法)
- invokespecial 用于调用需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法
- invokevirtual 调用所有虚方法
- invokeinterface 用于调用接口方法，会在运行时再确定一个实现此接口的对象
- invokedynamic 先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条指令，分配逻辑是固话在Java虚拟机内的，而这个指令的分配逻辑是用户所设定的引导方法决定的。

只有被invokestatic和invokespecial调用的方法，才能在解析阶段中确定唯一的调用版本，符合条件的静态方法、私有方法、实例构造器、父类方法四种方法被称为非虚方法，其他方法称为虚方法(除去final方法，虽然final方法是使用invokevirtual调用的，但final方法无法被重写，没有其他版本，所以无法进行多态，所以final方法为非虚方法)。

静态方法的继承：
- 在Java中静态方法可以被继承，但是不能被覆盖，即不能重写。
- 如果子类中也含有一个返回类型、方法名、参数列表均与之相同的静态方法，那么该子类实际上只是将父类中的该同名方法进行了隐藏，而非重写。
- 父类引用指向子类对象时，只会调用父类的静态方法。所以，它们的行为也并不具有多态性。

### 2. 分派

解析调用一定是一个静态过程，在编译期间就能确定。而分派调用则可能是静态分派，也可能是动态分派。根据分派的宗量数可以分为单分派和多分派。

Java包括三个基本特征：继承、封装和多态。
分派调用将会揭示多态的原理。
重载和重写属于多态的特性。

#### 静态分派

静态类型和实际类型都可以在程序运行时都可以发生一下变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是编译器可知的。而实际类型是在运行起才能确定。编译器在编译程序时并不知道一个对象的实际类型是什么。

编译器在重载时使用参数的静态类型而不是动态类型做为判定依据。因为静态类型是编译期可知的，所以在编译阶段，javac会根据参数的静态类型决定使用那个重载版本。选择了重载版本之后，会使用invokevirtual指令在方法的字节码中把选择的重载版本作为参数。

所以利用静态类型的定位方法执行版本的分派动作成为静态分派。

**静态分派的典型应用是方法重载。**
静态分派发生在编译阶段，因此确定静态分派的动作不是由Java虚拟机执行的。

这里还需要注意的是，方法重载时，为了匹配参数可能会发生自动类型转换。
char >> int >> long >> Character >> Serializable >> Object >> char ...

静态方法也能够被重载，所以静态方法的重载版本的选择也是通过静态分派完成的。

#### 动态分派

**动态分派与重写相关**

在invokevirtual指令在运行时解析过程大致分为以下几个步骤：
- 找到操作数栈顶的第一个元素所指向的对象的实际类型，记做C
- 如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，若通过校验则返回这个方法的直接引用，查找过程结束，若不通过，则抛出错误
- 否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程
- 若最后没有找到合适的方法，则抛出错误

Java编译器在编译时期并不总是知道哪一些代码会被执行，因为编译器仅仅知道对象的静态类型， 而不知道对象的真实类型，而方法的调用则是根据真实类型，而不是静态类型。

由于invokevirtual指令执行的第一步是在运行期确定接受者的实际类型，所以调用中的invokevirtual指令把常量池中类方法符号引用解析到了不同的直接引用上。

这个过程是Java语言重写的本质。在运行期间根据实际类型确定执行版本的分派过程称为动态分派。

重载是静态的，重写是动态的，因此有人认为只有重写算是多态性的体现，重载不算多态。(概念仅仅是说明问题的一种工具)

#### 单分派与多分派

方法的接收者与方法的参数统称为方法的宗量。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多余一个宗量对目标方法进行选择

目前的Java是一个静态多分派，动态单分派的语言

#### 虚拟机动态分派的实现

由于动态分派是非常频繁的动作，虚拟机实现中基于性能考虑，大部分实现都不会那么频繁的搜索。

常用的稳定优化手段是为类在方法区中建立一个虚方法表(vtable)，(与此对应,invokeinterface执行会用到接口方法表(itable))使用虚方法表索引来代替元数据查找以提高性能。

- 虚方法表存放着各个方法的实际入口地址，如果子类没有重写父类的方法，那子类的虚方法表和父类是一致的，都指向父类的实现入口。如果子类重写了父类的方法，则子类方法表中的地址会替换为指向子类实现版本的入口地址。
- 具有相同签名的方法，在子类父类的虚方法表中都应当具有一样的索引号，这样当类型转换时，仅需变更查找的方法表，而不需要变索引。

方法表在类加载的连接阶段进行初始化，当类变量初始化后，会初始化虚方法表。

### 3. 动态类型语言支持

#### 动态类型语言

动态类型语言的关键特征是他的类型语言检查的主体过程是在运行期而不是编译期，变量无类型而变量的值有类型也是动态类型语言的重要特征。

静态类型语言在编译期确定类型,最显著的好处是编译器可以提供严谨的类型检查,这样与类型相关的问题能在编码的时候就及时发现,利于稳定性及代码达到更大规模。而动态类型语言在运行期确定类型,这可以为开发人员提供更大的灵活性 ,某些在静态类型语言中需用大量“臃肿”代码来实现的功能,由动态类型语言来实现可能 会更加清晰和简洁,清晰和简洁通常也就意味着开发效率的提升。

#### jdk7与动态类型

现在，一些动态语言已经可以运行在jvm之上了，比如scala。动态类型的支持需要在jvm层面上解决才最合适，因此，jdk7引入了invokedynamic指令和java.lang.invoke包。


#### java.lang.invoke包

这个包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法这种方式以外,提供一种新的动态确定目标方法的机制,**称为MethodHandle**

举个例子, 如果我们要实现一个带谓词的排序函数,在C/C++中常用的做法是把谓词定义为函数,用函数指针把谓词传递到排序方法
```c++
void sort(int list[],const int size,int(*compare)(int,int))
```

Java没办法把一个函数作为参数进行传递，普遍的做法是设计一个接口，然后以实现了这个接口的对象作为参数。
```java
void sort (List list,Comparator c)
```

**Reflection和MethodHandle**
- 两种机制都是在模拟方法调用，但Reflection是在模拟Java代码层次的方法调用，而MethodHandle是在模拟字节码层次的方法调用。在 MethodHandles.lookup中的3个方法——findStatic()、fmdVirtual()、fmdSpecial()正是为了对应于invokestatic、invokevirtual、invokeinterface和invokespecial这几条字节码指令的执行权限校验行为,而这些底层细节在使用Reflection API时是不需要关心的
- Reflection中的java.lang.reflect.Method对象远比MethodHandle机制中的 java.lang.invoke.MethodHandle对象所包含的信息多。前者是方法在Java一端的全面映像,包含了方法的签名、描述符以及方法属性表中各种属性的Java端表示方式,还包含执行权限等的运行期信息。而后者仅仅包含与执行该方法相关的信息。通俗的话来讲,Reflection是重量级 ,而MethodHandle是轻量级。
- 由于MethodHandle是对字节码的方法指令调用的模拟,所以理论上虚拟机在这方面做的各种优化(如方法内联),在MethodHandle上也应当可以采用类似思路去支持(但目前实现还不完善)。而通过反射去调用方法则不行。

MethodHandle与Reflection除了上面列举的区别外,最关键的一点还在于去掉前面讨论施加的前提“仅站在Java语言的角度来看” : Reflection API的设计目标是只为Java语言服务的, 而MethodHandle则设计成可服务于所有Java虚拟机之上的语言,其中也包括Java语言。

#### invokedynamic指令

在某种程度上,invokedynamic指令与MethodHandle机制的作用是一样的,都是为了解决原有4条“invoke*”指令方法分派规则固化在虚拟机之中的问题,把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中,让用户(包含其他语言的设计者)有更高的自由度。 而且 ,它们两者的思路也是可类比的,可以把它们想象成为了达成同一个目的,一个采用上层Java代码和API来实现,另一个用字节码和Class中其他属性、常量来完成。

每一处含有invokedynamic指令的位置都称做“动态调用点” ( Dynamic Call Site ) , 这条指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量 ,而变为JDK 1.7新加入的CONSTANT_InvokeDynamic_info常量,从这个新常量中可以得到3项信息:引导方法(Bootstrap Method,此方法存放在新增的BootstrapMethods属性中)、方法类型 ( MethodType ) 和名称。引导方法是有固定的参数,并且返回A是java.langinvoke.CallSite对象 ,这个代表真正要执行的目标方法调用。根据CONSTANT_InvokeDynamic_info常量中提供的信息,虚拟机可以找到并且执行引导方法,从而获得一个CallSite对象,最终调用要执行的目标方法。

## 基于栈的字节码解释执行引擎

### 1. 解释执行

如今,基于物理机、Java虚拟机,或者非Java的其他高级语言虚拟机(HLLVM )的语 言 ,大多都会遵循这种基于现代经典编译原理的思路,在执行前先对程序源码进行词法分析和语法分析处理,把源码转化为抽象语法树( Abstract Syntax Tree,AST)。对于一门具体语言的实现来说,词法分析、语法分析以至后面的优化器和目标代码生成器都可以选择独立于执行引擎,形成一个完整意义的编译器去实现,这类代表是C/C++语言。也可以选择把其中一部分步骤(如生成抽象语法树之前的步骤)实现为一个半独立的编译器,这类代表是Java 语言。又或者把这些步骤和执行引擎全部集中封装在一个封闭的黑匣子之中,如大多数的JavaScript执行器。

Java语言中 ,Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树,再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的, 而解释器在虚拟机的内部,所以Java程序的编译就是半独立的实现。

### 2. 指令集

Java编译器输出的指令流，基本上是一种基于栈的指令集架构( Instruction Set Architecture,ISA ) , 指令流中的指令大部分都是零地址指令,它们包赖操作数栈进行工作。

与之相对的另外一套常用的指令集架构是基于寄存器的指令集,最典型的就是x86的二地址指令集。

虽然栈架构指令集的代码非常紧凑,但是完成相同功能所需的指令数量一般会比寄存器架构多,因为出栈、入栈操作本身就产生了相当多的指令数量。更重要的是 ,栈实现在内存之中 ,频繁的栈访问也就意味着频繁的内存访问,**相对于处理器来说,内存始终是执行速度的瓶颈**。尽管虚拟机可以采取栈顶缓存的手段,把最常用的操作映射到寄存器中避免直接内存访问 ,但这也只能是优化措施而不是解决本质问题的方法。 **由于指令数量和内存访问的原因 ,所以导致了栈架构指令集的执行速度会相对较慢。**

栈结构指令集的运算过程的中间变量都以操作数栈的出栈、入栈为信息交换途径。

# 八、程序编译与代码优化

## 早期(编译期)优化

Java编译器可能是指一个前端编译器(其实叫“编译器的前端”更准备一些)，把*.java文件转变成*.class文件的过程；也可能是指虚拟机的后端运行期编译器(JIT编译器，Just In Time Compiler)把字节码转变成机器码的过程；还可能是指使用静态提前编译器(AOT编译器，Ahead Of Time Compiler)直接把*.java文件编译成本地机器代码的过程。例如：

- 前端编译器：Sun的javac，Eclipse JDT中的增量式编译器(ECJ)；
- JIT编译器：HotSpot VM的C1、C2编译器；
- AOT编译器：GUN Complier for the Java(GCJ)，Excelsior JET；


javac做了许多针对java语言编码过程的优化措施来改善程序员的编码风格和提高编码效率。相当多新生的Java语法特性，都是靠编译器的“语法糖”来实现，而不是依赖虚拟机的底层改进来支持，可以说，Java中即时编译器在运行期的优化过程对于程序运行来说更重要，而前端编译器在编译期的优化过程对于程序编码来说关系更加密切。

### 1. javac编译器

#### 解析与填充符号表

1. 词法、语法分析
    - 词法分析是将源代码的字符流转变为标记(Token)集合。
    - 语法分析是根据Token序列构造抽象语法树的过程，抽象语法树(Abstract Syntax Tree，AST)是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构，例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以使一个语法结构。
2. 填充符号表：符号表(Symbol Table)是由一组符号地址和符号信息构成的表格。

#### 插入式注解处理器的注解处理过程

注解与普通的java代码一样，是在运行期间发挥作用的。JDK 1.6提供了插入式注解处理器的标准API在编译期间对注解进行处理，这些API类似插件，它们可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，那么编译器将回到解析及符号填充表的过程重新处理，直到所有的插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round。

#### 分析与字节码生成过程

1. 标注检查：
    - 变量使用前是否被声明
    - 变量与赋值之间的数据类型是否能够匹配
2. 数据及控制流分析：是对程序上下文逻辑更进一步的验证
    - 局部变量在使用前是否赋值
    - 方法的每条路径是否有返回值
    - 是否所有的受检异常都正确处理
3. 解语法糖：Java中最常用的语法糖主要是泛型、变长参数、自动装箱/拆箱等，虚拟机运行时不支持这些语法，它们在编译阶段还原回简单的基础语法结构，这个过程称为解语法糖
4. 字节码生成是javac编译过程的最后一个阶段，字节码生成阶段不仅仅是把前面各个步骤锁生成的信息(语法树、符号表)转换成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作
    - 代码添加：实例构造器和类构造器在这个阶段添加到语法树
    - 代码转换：字符串的"+"替换为StringBuffer或StringBuilder的append操作

### 2. Java语法糖

语法糖(Syntactic Sugar)，也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说，使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。

语法糖可以看做是编译期实现的一些“小把戏”，这些“小把戏”可能会使得效率“大提升”

#### 泛型与类型擦除

泛型的本质是参数化类型(Parametersized Type)的应用，也就是说所操作的数据类型被指定为一个参数

**泛型分类**
- 真实泛型：在C#语言里面，泛型无论在程序源码中、编译后的IL中(中间语言，这时候泛型是一个占位符)，或是运行期的CLR中，都是切实存在的，`List<int>`与`List<String>`就是两种不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨胀，基于这种方法实现的泛型称为真实泛型。
- 伪泛型：在Java语言里面，泛型只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型了，并且在相应的地方插入了强制转型代码。因此对于运行期的Java语言来说，`ArrayList<int>`与`ArrayList<String>`就是同一个类。所以泛型技术实际上是Java语言的一个语法糖。Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。

Java语言中的泛型只在源码中存在，在编译后的字节码中，就已经替换为原来的原生类型(Raw Type，也称为裸类型)，所以泛型是java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型

**本质**：参数化类型的应用，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以应用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。

**原本的方法**：在没有泛型以前，只能通过Object是所有类型的父类和类型强制转换两个特点的配合来实现类型泛化。——问题：在编译期间，编译器无法检查这个Object的强制转型是否成功，如果仅仅依赖程序员去保障这项操作的正确性，许多ClassCastException的风险就会嫁接到程序运行期之中去。


引入Signature、LocalVariableTable等属性用于解决伴随泛型而来的参数化类型的识别；
Signature：作用是存储一个方法在字节码层面的特征签名，保存的类型不是原生类型，而是包含了参数化类型的信息

**存在的问题**
- 泛型方法的重载：泛型擦除成相同的原生类型无法重载(无法通过编译，JDK1.6中通过不同返回值可以编译通过)

擦除法所谓的擦除，仅仅是对方法的code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能够通过反射手段获取到参数化类型的根本依据

#### 自动装箱、拆箱与遍历循环

- 自动装箱、拆箱在编译之后被转化为了对应的包装和还原方法，如Integer.valueOf()与Integer.intValue()方法
- 遍历循环则把代码还原成了迭代器的实现，这也是为何遍历循环需要被遍历的类实现Iterable接口的原因
- 变长参数在调用的时候变成了一个数组类型的参数

包装类的"=="运算在不遇到算术运算的情况下不会自动拆箱；包装类equals()方法不处理数据转型的关系

#### 条件编译

Java语言中条件编译的实现也是Java语言的一颗语法糖，根据布尔常量值的真假编译器将会把分支中不成立的代码块消除掉，这一工作将在编译器解除语法糖阶段完成。

## 晚期(运行期)优化

Java 程序最初是通过解释器解释执行的，当虚拟机发现有个方法或代码块运行特别频繁时，就会把这些代码认定为“热点代码”。为了提高热点代码的执行效率，虚拟机会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器被称为即时编译器(Just In Time Compiler，简称 JIT 编译器)。

介绍 **Hotspot 虚拟机内的即时编译器**

### 1. 解释器与编译器

解释器与编译器有各自的优势：当程序需要快速启动时，解释器可以发挥作用，省去编译时间立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码后，可以获取更高的执行效率。

当程序运行环境的内存资源限制较大时，使用**解释器执行节省内存**，反之可以使用**编译执行提升效率**。同时，解释器还可以作为编译器激进优化时的一个“**逃生门**”，让编译器根据概率选择一个大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立时，比如加载了新类后类型继承结构出现变化，出现“罕见陷阱”时可以通过逆优化退回到解释状态继续执行。因此，在虚拟机中解释器和编译器经常配合工作，

<div align="center"> 

![](../../assets/cs-note/jvm/解释器与编译器交互.png ':size=550')
</div>

HotSpot 虚拟机内置了两个即时编译器：Client Compiler 和 Server Compiler，简称 C1 编译器和 C2 编译器。默认采用解释器和其中一个编译器直接配合的方式工作

由于即时编译器编译本地代码需要占用程序运行时间，要编译出优化程度更高的代码，所需时间会更长。同时，解释器还要替编译器收集性能监控信息，这对解释执行速度也有影响。为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot 虚拟机又引入了分层编译的策略。分层编译根据编译器编译、优化的规模与耗时，划分为不同的编译层次，包括：

1. 第 0 层，程序解释执行，不开启性能监控功能，可触发第 1 层编译。
2. 第 1 层，称为 C1 编译，将字节码编译为本地代码，并进行简单可靠的优化，如有必要将加入性能监控逻辑。
3. 第 2 层，称为 C2 编译，也是将字节码编译为本地代码，但是会进行耗时较长的优化，甚至会根据性能监控信息进行一些不完全可靠的激进优化。

实施分层编译后，Client Compiler 和 Server Compiler 会同时工作，许多代码可能会被编译多次，用 Client Compiler 获得更快的编译速度，用 Server Compiler 获取更好的编译质量，在解释执行的时候也无需再承担收集性能监控信息的任务。

### 2. 编译对象与触发条件

在运行过程中，会被即时编译器编译的**热点代码**有两类：
- 被多次调用的方法。
- 被多次执行的循环体。

这两种情况，编译器都会编译整个方法。因为编译发生在方法执行过程中，因此形象地称之为栈上替换(On Stack Replacement，简称 OSR，即方法栈帧还在栈上，方法就被替换了)

判断一段代码是不是热点代码，是否需要触发即时编译，这样的行为称为**热点探测**(Hot Spot Detection)，热点探测方式主要有两种：
- 基于采样的热点探测：采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果某个方法经常出现在栈顶，那它就是热点方法。其优点是简单、高效，还可以获取方法调用关系；缺点是不够精确，容易受到线程阻塞或其他外接因素的影响。
- 基于计数的热点探测：采用这种方法的虚拟机会为每个方法(甚至是代码块)建立计数器，统计方法执行次数，次数超过一定阈值就认为是热点方法。这种方法实现起来麻烦，但是其统计结果相对来说更加精确和严谨。

在 HotSpot 虚拟机里使用的是第二种方法，因此它为每个方法准备了两类计数器：方法调用计数器(Invocation Counter)和回边计数器(Back edge Counter)。

**方法调用计数器**

<div align="center"> 

![](../../assets/cs-note/jvm/方法调用计数器.png ':size=550')
</div>

方法调用计数器统计的不是方法被调用的绝对次数，而是一段时间内的方法被调用的次数。当超过一段的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半。这个过程称为热度衰减(Counter Decay)，这段时间称为方法统计的半衰周期(Counter Half Life Time)。进行热度衰减的动作是虚拟机在垃圾收集时顺便进行的

**回边计数器**

回边计数器的作用是统计方法体中循环体代码执行次数，在字节码中遇到遇到控制流向后调整的指令称为回边。显然，建立回边计数器统计的目的就是为了触发 OSR 编译。
<div align="center"> 

![](../../assets/cs-note/jvm/回边计数器.png ':size=550')
</div>

回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出状态，这样下次再进入该方法的时候就会执行标准编译过程。

### 3. 编译过程

默认情况下，即时编译是在后台进行的，编译完成之前还是按照解释方式执行，用户可以通过参数 -XX:-BackgroundCompilation 来禁止后台编译。

Client Compiler 和 Server Compiler 两个编译器的编译过程是不一样的。

**Client Compiler** 是一个简单快速的三段式编译器，主要关注点在于局部优化，放弃了许多耗时的全局优化手段。
1. 在第一个阶段，一个平台独立的前端将字节码构造成一种高级中间代码(High Level Intermediate Representation，HIR)表示。HIR 使用静态单分配的形式来代表代码值，这使得一些在 HIR 之后和之中进行的优化动作更容易实现。在此之前编译器会在字节码上完成一部分基础优化，如方法内敛、常量传播等。
2. 在第二个阶段，一个平台相关的后端从 HIR 中产生低级中间代码表示(Low Level Intermediate Representation，LIR)表示。在此之前，会在 HIR 上完成另一些优化，比如空值检查消除、范围检查消除，以便让 HIR 达到更高效的代码表示形式。
3. 最后阶段，是在平台相关的后端，使用线性扫描算法在 LIR 上分配寄存器，并在 LIR 上做窥孔优化，然后产生机器代码。

<div align="center"> 

![](../../assets/cs-note/jvm/Client Compiler过程.png.png ':size=550')
</div>

**Server Compiler** 是面向服务端的，并且为服务端性能配置进行了特别调整，是一个充分优化过的高级编译器，几乎能达到 GNU 编译器使用 -O2 参数时的优化强度。它会执行所有经典的优化动作，比如无用代码消除、循环展开、循环表达式外提、消除公共子表达式、常量传播、基本块重排序等，还会实施一些与 Java 语言特征密切相关的技术，比如范围检查消除、空值检查消除。另外，还可能根据解释器或 Client Compiler 提供的性能监控信息，进行一些不稳定的激进优化，如守护内联、分支频率预测等。

Server Compiler 的寄存器分配器是一个全局图着色分配器，它可以充分利用某些处理器架构上的大寄存器集合。以即时编译的标准来看，Server Compiler 无疑是比较缓慢的，但它的编译速度依然超过传统的静态优化编译器，而且相对于 Client Compiler 来说代码质量有所提高，可以减少本地代码执行时间，从而抵消了额外的编译时间开销。


### 4. 编译优化技术

- 语言无关的经典优化技术之一：公共子表达式消除
- 语言相关的经典优化技术之一：数组范围检查消除
- 最重要的优化技术之一：方法内联
- 最前沿的优化技术之一：逃逸分析

#### 公共子表达式消除

公共子表达式消除是一个普遍应用于各种编译器的经典优化技术，它的原理是：如果一个表达式 E 已经计算过了，并且从先前计算到现在 E 中所有变量的值都没有发生变化，那么 E 的这次计算就称为公共子表达。对于这种表达式，就没有必要再对其进行计算了，使用之前计算过的值即可。

#### 数组边界检查消除

数组边界检查消除是即时编译器中语言相关的经典优化技术。编译器会对代码进行分析，如果确定某次数组访问一定不会越界，就可以去掉数组的上下界检查。

与数组边界检查消除类似的优化，还有隐式异常处理，Java 中空指针检查和除数为零检查都采用了这种思路。

#### 方法内联

方法内联是编译器最重要的优化手段之一，除了消除方法调用成本之外，它更重要的意义是为其他优化手段建立良好的基础。

方法内联看起来简单，但实际中很多方法都无法直接进行内联。除了使用 invokespecial 指令调用的私有方法、实例构造器、父类方法以及使用 invokestatic 指令调用的静态方法，还有部分 final 方法能够在编译时唯一确定执行的方法版本，这一类称为非虚方法。

为了解决虚方法的内联问题，Java 虚拟机引入了一种称为“类型继承关系分析”(Class Hierarchy Analysis，CHA)的技术，这是一种基于整个查询的类型分析技术，它用于确定在目前已加载的类中，某个接口是否有多于一种实现，某个类是否存在子类、子类是否为抽象类等信息。

如果通过 CHA 分析得知某个方法只有一个版本，就可以进行内联，不过这种内联属于“**激进优化**”，需要预留一个“逃生门”，称为守护内联。如果程序在执行过程中，虚拟机一直没有加载到令这个类继承关系发生变化的类，那这个内联优化的代码就可以一直使用下去。但如果加载了导致继承关系发生变化的新类，那就需要抛弃已经编译的代码，返回到解释状态执行，或者重新进行编译。

**内联缓存**: 在未发生方法调用之前，内联缓存状态为空，当第一次调用发生后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较接收者版本，如果以后进来的每次调用的方法接收者版本都是一样的，那这个内联还可以一直用下去。如果发生了方法接收者不一致的情况，就说明程序真正使用了虚方法的多态特性，这时才会取消内联，查找虚方法表进行方法分派。

#### 逃逸分析

逃逸分析是目前 Java 虚拟机中比较前言的优化技术，它与类型继承关系分析一样，并不是直接优化代码的技术，而是为其他优化手段提供依据的分析技术。逃逸分析的基本行为是分析对象动态作用域：当一个对象在方法里定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为**方法逃逸**。甚至还有可能被外部方法访问到，譬如赋值给类变量或其他线程中访问的实例变量，称为**线程逃逸**。

如果能证明一个对象不会逃逸到方法或线程之外，就可以为这个变量进行一些高效优化：
- 栈上分配(Stack Allocation)
- 同步消除(Synchronization Elimination)
- 标量替换(Scalar Replacement)：
    - 标量是指一个数据已经无法再分解成更小的数据来表示了
    - 如果把一个Java对象拆散，根据程序访问的情况，将其使用到的成员变量恢复原始类型来访问就叫做标量替换
    - 程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替

### 5. Java与C/C++的编译器对比

Java虚拟机的即时编译器与C/C++的静态优化编译器相比，可能会由于下列这些原因而导致输出的本地代码有一些**劣势**：
1. 因为即时编译器运行占用的是用户程序的运行时间，具有很大的时间压力，它能提供的优化手段也严重受制于编译成本。
2. Java语言是动态的类型安全语言，这就意味着需要由虚拟机来确保程序不会违反语言语义或访问非结构化内存，要消耗不少的运行时间
3. Java语言中虽然没有virtual关键字，但是使用虚方法的频率却远远大于C/C++语言，这意味着运行时对方法接收者进行多态选择的频率要远远大于C/C++语言，也意味着即时编译器在进行一些优化(如前面提到的方法内联)时的难度要远大于C/C++的静态优化编译器。
4. Java语言是可以动态扩展的语言，运行时加载新的类可能改变程序类型的继承关系，这使得很多全局的优化都难以进行
5. Java语言中对象的内存分配都是堆上进行的，只有方法中的局部变量才能在栈上分配。而C/C++的对象则有多种内存分配方式，既可能在堆上分配，又可能在栈上分配，如果可以在栈上分配线程私有的对象，将减轻内存回收的压力。另外，C/C++中主要由用户程序代码来回收分配的内存，这就不存在无用对象筛选的过程，因此效率上(仅指运行效率，排除了开发效率)也比垃圾收集机制要高。

**好处**：
1. 在C/C++中，别名分析(Alias Analysis)的难度就要远高于Java。
2. 由于C/C++编译器所有优化都在编译期完成，以运行期性能监控为基础的优化措施它都无法进行，如调用频率预测(Call Frequency Prediction)、分支频率预测(Branch Frequency Prediction)、裁剪未被选择的分支(Untaken Branch Pruning)等，这些都会成为Java语言独有的性能优势。

# 参考资料

- 周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.
- [Chapter 2. The Structure of the Java Virtual Machine](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4)
- [Jvm memory](https://www.slideshare.net/benewu/jvm-memory)
[Getting Started with the G1 Garbage Collector](http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html)
- [JNI Part1: Java Native Interface Introduction and “Hello World” application](http://electrofriends.com/articles/jni/jni-part1-java-native-interface/)
- [Memory Architecture Of JVM(Runtime Data Areas)](https://hackthejava.wordpress.com/2015/01/09/memory-architecture-by-jvmruntime-data-areas/)
- [JVM Run-Time Data Areas](https://www.programcreek.com/2013/04/jvm-run-time-data-areas/)
- [Android on x86: Java Native Interface and the Android Native Development Kit](http://www.drdobbs.com/architecture-and-design/android-on-x86-java-native-interface-and/240166271)
- [深入理解 JVM(2)——GC 算法与内存分配策略](https://crowhawk.github.io/2017/08/10/jvm_2/)
- [深入理解 JVM(3)——7 种垃圾收集器](https://crowhawk.github.io/2017/08/15/jvm_3/)
- [JVM Internals](http://blog.jamesdbloom.com/JVMInternals.html)
- [深入探讨 Java 类加载器](https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html#code6)
- [Guide to WeakHashMap in Java](http://www.baeldung.com/java-weakhashmap)
- [Tomcat example source code file (ConcurrentCache.java)](https://alvinalexander.com/java/jwarehouse/apache-tomcat-6.0.16/java/org/apache/el/util/ConcurrentCache.java.shtml)
